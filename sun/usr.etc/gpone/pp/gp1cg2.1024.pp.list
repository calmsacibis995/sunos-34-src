Warning: file ./polyline.pp.u, line 205: shared memory write followed by shared memory read at location   28510

Sun Microsystems GP-1 Painting Processor Microassembler -- Version 1.2 (26 October 1984) -- Company Confidential

   addr  fl mv s b d  alu  gen  source line

                                | "@(#)pp.u 1.3 86/09/13 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   Command processor from vp to pp.
                                | @(#)pp.h 1.2 86/09/12 SMI
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                | "@(#)s1024.pp.h 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                | The starting org address had been changed for 3.2 to make more room for vp microcode.
                                org 0x1123
                                debug off
   1123  05 06 e 0 0 f900 0000  reset:	movw 0, y;		am->fl2reg;	;				| 
   1124  05 45 e 0 0 7140 018e  	;			0x18e->scrmemp; ;				| 
   1125  05 4a e 0 0 7140 0000  	;			0->scrmem;	;				| 
   1126  05 45 e 0 0 7140 018f  	;			 0x18f->scrmemp; ;				| 
   1127  15 0a 1 0 0 f900 122a  	movw 0, y;		am->scrmem;	cjs, go resetrr;		| 
   1128  05 61 3 d 0 f8c1 1128  start:	movw d, acc;		fifo1->am;	cjp, f1e .;			| Get new command.
   1129  15 00 1 0 0 7140 1156  	;			;		cjs, go badcmd;			| 
                                |   Reset ropreg memory (resetrr) if last cmd was ack && current command is not ack.
                                |   Doing resetrr here means that the next command was in the fifo (retrieved at start:).
   112a  05 45 e 0 0 d880 018f  	movw acc, r[0];		 0x18f->scrmemp; ;				| copy acc to r[0] so sub2nw later preserves acc
   112b  01 59 e 0 0 e195 0000  	sub2nw,s 0, d, y;	scrmem->am;	;				| Is last command ack?
   112c  05 0a 3 8 0 f880 112f  	movw acc, y;		am->scrmem;	cjp, ~zer norr;			| 
   112d  01 00 e 0 0 c1e0 0000  	sub2nw,s 0, r[0];	;		;				| Is current command not ack?
   112e  05 00 1 8 0 7140 122a  	;			;		cjs, ~zer resetrr;		| 
   112f  05 49 e 0 0 d8c0 1132  norr:	movw d, r[0];		=cmd->am;	;				| 
   1130  05 04 e 0 0 9080 0000  	addw r[0], acc, y;	am->brreg;	;				| 
   1131  1d 00 3 0 0 dd80 0000  	mov2nw 14, r[0];	;		cjp, go;			| 0x4000 to add to bad commands.
   1132  15 00 3 0 0 7140 1ff9  cmd:	;			;		cjp, go stopit;			| 0 Null cmd
   1133  15 00 3 0 0 7140 120c  	;			;		cjp, go ppack;			| 1 Painting processor acknowledge
   1134  15 00 3 0 0 7140 1d86  	;			;		cjp, go roptex1;		| 2 textured 1 bit deep rops.
   1135  15 00 3 0 0 7140 1215  	;			;		cjp, go ppinit;			| 3 Software reset.  1 means get gpaddr off fifo
   1136  15 00 3 0 0 7140 1241  	;			;		cjp, go rnull;			| 4 Rop null to fb
   1137  15 00 3 0 0 7140 128d  	;			;		cjp, go ropfb;			| 5 Rop fb to fb
   1138  15 00 3 0 0 7140 1222  	;			;		cjp, go fbaddr;			| 6 Frame buffer board high address
   1139  15 00 3 0 0 7140 1165  	;			;		cjp, go flashy;			| 7 Flash screen (for debugging)
   113a  15 00 3 0 0 7140 1226  	;			;		cjp, go ppmask;			| 8 Planes mask
   113b  15 00 3 0 0 7140 1167  	;			;		cjp, go vecvec;			| 9  Draw vectors  Must have called stclip first
   113c  15 00 3 0 0 7140 14f2  	;			;		cjp, go stclip;			| 10 Store multiple clip rectangles
   113d  15 00 3 0 0 7140 123f  	;			;		cjp, go stcolor;		| 11 Store r[27]
   113e  15 00 3 0 0 d918 1128  	movw 0, r[24];		;		cjp, go start;			| 12 Initialization for solid, width 1 xf vectors.
   113f  15 00 3 0 0 7140 1169  	;			;		cjp, go vecvecxf;		| 13 Xformed, solid width 1 vectors.
   1140  15 00 3 0 0 8080 1156  	addw r[0], acc, acc;	;		cjp, go badcmd;			| 14
   1141  15 00 3 0 0 7140 1548  	;			;		cjp, go scrbuf;			| 15 screen rectangle to buffer rectangle
   1142  15 00 3 0 0 7140 1570  	;			;		cjp, go setbuf;			| 16 set a rectangle of buffer to r[27]
   1143  15 00 3 0 0 7140 15bb  	;			;		cjp, go bufscr;			| 17 buffer rectangle bytes to screen rectangle
   1144  15 00 3 0 0 7140 169c  	;			;		cjp, go plginit;		| 18 Polygon  (2D) initialization
   1145  15 00 3 0 0 7140 17b4  	;			;		cjp, go plhinit;		| 19 Polyhedra (3D) initialization
   1146  15 00 3 0 0 7140 17b3  	;			;		cjp, go fillinit;		| 20 filling initialization
   1147  15 00 3 0 0 7140 17b2  	;			;		cjp, go shinit;			| 21 gouraud shading initialization
   1148  15 00 3 0 0 7140 15dd  	;			;		cjp, go plgfill;		| 22 Polygon (2D) fill (one segment)
   1149  15 00 3 0 0 7140 169e  	;			;		cjp, go plhfill;		| 23 Polyhedra (3D) fill (one segment)
   114a  15 00 3 0 0 7140 16a0  	;			;		cjp, go plgsh;			| 24 Polygon (2D) Gouraud shading (one segment)
   114b  15 00 3 0 0 7140 1707  	;			;		cjp, go plhsh;			| 25 Polyhedra (3D)Gouraud shading (one segment)
   114c  15 00 3 0 0 7140 116b  	;			;		cjp, go textex;			| 26 Textured vectors.
   114d  15 00 3 0 0 7140 1d71  	;			;		cjp, go ldtex;			| 27 Load polygon texture into scratch.
   114e  15 00 3 0 0 7140 1dff  	;			;		cjp, go plgtex1;		| 28 1 line textured 1-to-8 rop.
   114f  15 00 3 0 0 7140 1f19  	;			;		cjp, go plgtex8;		| 29 1 line textured 8-to-8 rop.
   1150  15 00 3 0 0 7140 116d  	;			;		cjp, go polypoly;		| 30 Polylines, textured and solid.
   1151  15 00 3 0 0 7140 1d03  	;			;		cjp, go xflineinit;		| 31 Initialization for xfline.
   1152  15 00 3 0 0 7140 1cd9  	;			;		cjp, go xfline;			| 32 For drawing transformed textured & fat vecs.
   1153  15 00 3 0 0 7140 1d13  	;			;		cjp, go setlinetex;		| 33 Set line texture.
   1154  15 00 3 0 0 7140 1d23  	;			;		cjp, go setlinewidth;		| 34 Set line width.
   1155  15 00 3 0 0 7140 1f26  	;			;		cjp, go roptex8;		| 35 8 bit textured multi-line rops.
                                |	;			;		cjp, go rdback;			|  Write fifo.
   1156  01 49 e 0 0 e200 0024  badcmd:	subw,s d, acc, y;	36->am;		;				| #->am is highest command + 1.
   1157  09 49 a a 0 d8c6 0002  	movw,s d, r[6];		2->am;		crtn, ~cry;			| Number of times to flash - 1.
   1158  05 52 e 0 0 7140 0021  	;			0x21->vhiareg;	;				| 
   1159  05 49 e 0 0 7140 f800  	;			0xf800->am;	;				| 
   115a  05 53 e 0 0 d8c5 f800  	movw d, r[5];		0xf800->vloareg; ;				| 
   115b  05 44 e 0 0 7140 03fc  	;			1020->brreg;	;				| Maximum number of shorts to write.
   115c  05 00 3 f 0 7140 115c  	;			;		cjp, ~vir .;			| 
   115d  1d 54 4 0 0 d880 0073  	movw acc, r[0];		0x73->vctlreg; push, go;			| Write command in shmem.
   115e  05 0d 3 f 7 d840 115e  	movw r[0], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   115f  05 49 e 0 0 f8c1 00a0  	movw d, acc;		160->am;	;				| Length of flash in milliseconds.
   1160  05 00 1 9 0 7140 17c3  	;			;		cjs, ~neg flash;		| Flash if r[6] not negative.
   1161  05 61 3 d 0 d8c0 1161  	movw d, r[0];		fifo1->am;	cjp, f1e .;			| Get data out of fifo.  Maybe hang here.
   1162  05 13 e 0 0 c3c5 0000  	add2nw 1, r[5], r[5];	am->vloareg;	;				| increment shmem address by two bytes.
   1163  09 52 8 0 0 c1e6 0021  	sub2nw,s 0, r[6];	0x21->vhiareg;	rfct;				| 
   1164  15 00 3 0 0 7140 1164  	;			;		cjp, go .;			| Hang here.
   1165  15 00 1 0 0 eb86 17c3  flashy:	mov2nw 5, acc;		;		cjs, go flash;			| 
   1166  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   1167  15 00 1 0 0 d918 1338  vecvec:	movw 0,r[24];		;		cjs, go vector;			| Initialization for pixrect routines.
   1168  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   1169  15 00 1 0 0 7140 1338  vecvecxf: ;			;		cjs, go vector;			| Xformed vectors, single width, solid.
   116a  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   116b  15 00 1 0 0 7140 17dd  textex: ;			;		cjs, go texvec;			| 
   116c  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   116d  15 00 1 0 0 7140 1c26  polypoly: ;			;		cjs, go polyln;			| 
   116e  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
                                | "@(#)mul.pp.u 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   Multiplier routine.
                                |   Multiplier arrives in r[2].  It should have fewer one bits than
                                |   multiplicand which arrives in acc.  The result is computed and
                                |   in r[0,1] with the low order bits in r[0].  The algorithm is a
                                |   simple shift-add.  It was chosen because the majority of
                                |   multipliers will not have many bits.
   116f  01 00 e 0 0 9102 0000  multiply:xorw,s r[2], acc, y;;	;				| 
   1170  05 00 3 9 0 d904 1172     	movw 0, r[4];		;		cjp, ~neg mul;			| 
   1171  05 00 e 0 0 dd04 0000     	incw 0, r[4];		;		;				| 
   1172  05 00 e 0 0 d900 0000  mul:	movw 0, r[0];		;		;				| Clear.
   1173  01 44 e 0 0 d842 1179  	 movw,s r[2], y;	=mul2->brreg;	;				| 
   1174  05 00 3 9 0 d901 1176  	movw 0, r[1];		;		cjp, ~neg mul1;			| 
   1175  05 00 e 0 0 df62 0000  	negw r[2], r[2];;		;				| 
   1176  09 00 a 0 0 f880 0000  mul1:	 movw,s acc, y;	;		crtn, zer;			| 
   1177  0c 49 3 9 3 d462 0010  	priw r[2], 0, r[3];16->am;	cjp, ~neg;			| Find highest bit and test r[2].
   1178  05 00 e 0 0 fe81 0000  	negw acc, acc;	;		;				| 
   1179  0d 04 a 0 0 9e43 0000  mul2:	rsubw d, r[3], r[3];	am->brreg;	crtn, zer;			| Generate number of times for loop.
   117a  19 00 4 0 0 9fe2 0000  	rolw,s 15, r[2], r[2];;	push, go;			| Shift r[2]. Set carry 0.
                                | Ld cntr.  Push mulloop on stack.
   117b  05 00 3 9 0 7140 117d  	;			;		cjp, ~neg mulshift;		| If bit 15 zero skip addition.
   117c  01 00 e 0 0 9881 0000  	addw,s r[1], acc, r[1];;	;				| Add Multiplicand to result.
   117d  05 00 e 0 0 cce1 0000  mulshift:srcw r[1], r[1];	;		;				| Shift result.
   117e  05 00 e 0 0 ccc0 0000  	srqw r[0], r[0];	;		;				| 
   117f  09 00 8 0 0 9fe2 0000  	rolw,s 15, r[2], r[2];;	rfct;				| Shift r[2]. Set carry 0.
   1180  05 03 e 0 0 dc43 0000  	incw r[3], y;		am->nreg;	;				| 
   1181  05 00 e 0 0 d903 0000  	movw 0, r[3];		;		;				| 
   1182  07 00 e 0 0 e1a3 0000  	bsetw n, r[3];		;		;				| 
   1183  05 09 e 0 0 c1e3 0000  	sub2nw 0, r[3], r[3];	am->am;		;				| 
   1184  07 00 e 0 0 81e1 0000  	rolw n, r[1], r[1];;		;				| Rotate right 1 bit.
   1185  05 00 e 0 0 d801 0000  	movw r[1], acc;	;		;				| 
   1186  05 00 e 0 0 9ec1 0000  	andw d, r[1], r[1];	;		;				| r[3] is in d.
   1187  05 09 e 0 0 d840 0000  	movw r[0], y;		am->am;		;				| Save r[0] in d.
   1188  07 00 e 0 0 a103 0000  	romw n, d, acc, r[3];	;		;				| 
   1189  01 00 e 0 0 d844 0000  	 movw,s r[4], y;		;		;				| 
   118a  0d 00 a 0 0 d880 0000  	movw acc, r[0];	;		crtn, zer;			| 
   118b  01 00 e 0 0 df60 0000  	negw,s r[0], r[0];	;		;				| 
   118c  0d 00 a a 0 db61 0000  	compw r[1], r[1];	;		crtn, ~cry;			| 
   118d  1d 00 a 0 0 dd61 0000  	incw r[1], r[1];	;		crtn, go;			| 
   118e  01 00 e 0 0 9105 0000  muldbl:	xorw,s r[5], acc, y; ;		;				| 
   118f  05 00 3 9 0 d904 1191  	movw 0, r[4];		;		cjp, ~neg muld;			| 
   1190  05 00 e 0 0 dd04 0000  	incw 0, r[4];		;		;				| 
   1191  05 00 e 0 0 d900 0000  muld:	movw 0, r[0];		;		;				| Clear
   1192  01 00 e 0 0 d845 0000  	 movw,s r[5], y;	;		;				| 
   1193  05 00 3 8 0 d901 1198  	movw 0, r[1];		;		cjp, ~zer muldnot0;		| 
   1194  01 00 e 0 0 d842 0000  	 movw,s r[2], y;	;		;				| 
   1195  09 49 a 0 0 f880 0010  	 movw,s acc, y;	16->am;		crtn, zer;			| 
   1196  04 00 3 1 3 d462 11a0  	priw r[2], 0, r[3]; ;		cjp, neg muldneg;		| 
   1197  15 00 3 0 0 7140 11a1  	;			;		cjp, go muld2;			| 
   1198  05 00 3 9 0 7140 119c  muldnot0: ;			;		cjp, ~neg muld1;		| 
   1199  01 00 e 0 0 df62 0000  	negw,s r[2], r[2]; ;	;				| Double precision negate.
   119a  05 00 3 a 0 db65 119c  	compw r[5], r[5];	;		cjp, ~cry muld1;		| 
   119b  05 00 e 0 0 dd65 0000  	incw r[5], r[5];	;		;				| 
   119c  00 49 e 0 3 d465 0020  muld1:	priw,s r[5], 0, r[3]; 32->am;	;				| Find highest bit
   119d  01 00 3 8 0 f880 119f  	 movw,s acc, y;	;		cjp, ~zer muldznhi;		| 
   119e  04 49 e 0 3 d462 0010  	priw r[2], 0, r[3]; 16->am;	;				| 
   119f  05 00 3 9 0 7140 11a1  muldznhi: ;			;		cjp, ~neg muld2;		| 
   11a0  05 00 e 0 0 fe81 0000  muldneg: negw acc, acc;	;		;				| 
   11a1  0d 04 a 0 0 9e43 0000  muld2:	rsubw d, r[3], r[3];	am->brreg;	crtn, zer;			| Calculate number of loop cycles
   11a2  05 00 e 0 0 cc85 0000  	sr0w r[5], r[5]; ;		;				| Shift multiplier, set carry 0.
   11a3  05 00 e 0 0 ccc2 0000  	srqw r[2], r[2]; ;		;				| 
   11a4  05 00 e 0 0 83e5 0000  	rolw 1, r[5], r[5]; ;		;				| Fudge so that next instr. can shift in link bit.
   11a5  19 00 4 0 0 ccc5 0000  	srqw,s r[5], r[5]; ;		push, go;			| 
   11a6  05 00 3 9 0 7140 11a8  	;			;		cjp, ~neg muldshift;		| If bit 15 zero skip addition.
   11a7  01 00 e 0 0 9881 0000  	addw,s r[1], acc, r[1]; ;	;				| Add Multiplicand to result.
   11a8  05 00 e 0 0 cce1 0000  muldshift: srcw r[1], r[1];	;		;				| Shift result.
   11a9  05 00 e 0 0 ccc0 0000  	srqw r[0], r[0];	;		;				| 
   11aa  05 00 e 0 0 cc85 0000  	sr0w r[5], r[5]; ;		;				| Shift multiplier, set carry 0.
   11ab  05 00 e 0 0 ccc2 0000  	srqw r[2], r[2]; ;		;				| 
   11ac  05 00 e 0 0 83e5 0000  	rolw 1, r[5], r[5]; ;		;				| 
   11ad  09 00 8 0 0 ccc5 0000  	srqw,s r[5], r[5]; ;		rfct;				| 
   11ae  01 49 e 0 0 9e03 0010  	subw,s d, r[3], r[3];	16->am;		;				| 
   11af  05 00 3 9 0 7140 11b4  	;			;		cjp, ~neg muldrol;		| 
   11b0  05 00 e 0 0 9e83 0000  	addw d, r[3], r[3];	;		;				| 
   11b1  00 00 e 0 0 d961 0000  muldhi:	movw,s r[1], r[0];	;		;				| r[3] < 16.
   11b2  05 00 3 9 0 d901 11b4  	movw 0, r[1];		;		cjp, ~neg muldrol;		| 
   11b3  05 00 e 0 0 c1e1 0000  	sub2nw 0, r[1], r[1];	;		;				| 
   11b4  05 03 e 0 0 dc43 0000  muldrol: incw r[3], y;		am->nreg;	;				| 
   11b5  05 00 e 0 0 d903 0000  	movw 0, r[3];		;		;				| 
   11b6  07 00 e 0 0 e1a3 0000  	bsetw n, r[3];		;		;				| 
   11b7  01 09 e 0 0 c1e3 0000  	sub2nw,s 0, r[3], r[3];	am->am;		;				| 
   11b8  07 00 3 8 0 81e1 11ba  	rolw n, r[1], r[1];	;		cjp, ~zer muldlt16;		| Rotate right 1 bit.
   11b9  05 09 e 0 0 db03 0000  	compw 0, r[3];		am->am;		;				| 
   11ba  05 00 e 0 0 d801 0000  muldlt16: movw r[1], acc;	;		;				| 
   11bb  05 00 e 0 0 9ec1 0000  	andw d, r[1], r[1];	;		;				| r[3] is in d.
   11bc  05 09 e 0 0 d840 0000  	movw r[0], y;		am->am;		;				| Save r[0] in d.
   11bd  07 00 e 0 0 a103 0000  	romw n, d, acc, r[3];	;		;				| 
   11be  01 00 e 0 0 d844 0000  	 movw,s r[4], y;		;		;				| 
   11bf  0d 00 a 0 0 d880 0000  	movw acc, r[0];	;		crtn, zer;			| 
   11c0  01 00 e 0 0 df60 0000  	negw,s r[0], r[0];	;		;				| 
   11c1  0d 00 a a 0 db61 0000  	compw r[1], r[1];	;		crtn, ~cry;			| 
   11c2  1d 00 a 0 0 dd61 0000  	incw r[1], r[1];	;		crtn, go;			| 
                                | "@(#)m1024.pp.u 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   Multiply by 1024.  Number comes in r[2] (r[2] as in mul.pp.u)
                                |   and goes out in r[0] (low) and r[1] (high).
                                |   y * 1024 = y << 10
   11c3  04 00 e 0 1 95e2 0000  MulSWid:rolw 10, r[2], r[1];;		;				| (y << 3 + y) << 7.
   11c4  04 49 e 0 0 9ec1 fc00  	andw d, r[1], r[0];	0xfc00->am;	;				| 
   11c5  1d 49 a 0 0 9ec1 03ff  	andw d, r[1], r[1];	0x3ff->am;	crtn, go;			| 
                                |   y * 128 = y << 7
   11c6  04 00 e 0 1 8fe2 0000  MulSWWid:rolw 7, r[2], r[1];;		;				| (y << 3 + y) << 7.
   11c7  04 49 e 0 0 9ec1 ff80  	andw d, r[1], r[0];	0xff80->am;	;				| 
   11c8  1d 49 a 0 0 9ec1 007f  	andw d, r[1], r[1];	0x7f->am;	crtn, go;			| 
                                | @(#)div.pp.u 1.2 86/09/12 SMI
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |      Div.pp.u, modified by stuart levy to also calculate the mod, and leave this quantity in the accumulator.
                                |      The only other register that was added was the Mask register, which uses r[1] when the NDvsr is done
                                |      with it.  There is some test code for the routine commented out at its head.
                                |   Division.  Unsigned numbers only.
                                |   Normalized.
                                |   16 Bit Dividend, 16 Bit Divisor, 16 Bit Quotient.
                                |   Number of bits needed to normalize divisor.
                                |   Number of bits needed to normalize dividend.  Not r[3] because divlong may call divide.
                                |   test:	movw d,r[0];		450->am;	;				| Dividend is 16 (top).
                                |	movw d,acc;		25->am;	;				| Divisor is 3 (bottom).
                                |	movw 0,r[1];		;		;				| Does this need to be done ???
                                |	;			;		cjs, go divide;			| 
                                |	;			;		crtn, go;			| 
   11c9  01 00 e 0 0 9040 0000  divide:	rsubw,s r[0], acc, y;	;		;				| Compare dividend and divisor.
   11ca  01 00 3 a 0 d481 11de  	priw,s acc, 0, r[1];	;		cjp, ~cry divquit0;		| Find highest 1 bit.
   11cb  00 09 3 0 4 d460 11de  	priw,s r[0], 0, r[4]; am->am;	cjp, zer divquit0;		| Find highest 1 bit.
   11cc  01 04 3 0 0 9601 11de  	subw,s d, r[1], y;	am->brreg;	cjp, zer divquit0;		| 
   11cd  05 03 3 1 0 c1e4 11de  	sub2nw 0, r[4];	am->nreg;	cjp, neg divquit0;		| 
   11ce  07 00 e 0 0 81e0 0000  	rolw n, r[0], r[0];	;		;				| Normalize Dividend.
   11cf  05 03 e 0 0 c1e1 0000  	sub2nw 0, r[1];	am->nreg;	;				| 
   11d0  07 00 e 0 0 e19d 0000  	rolw n, acc, acc;	;		;				| Normalize Divisor.
   11d1  05 09 e 0 0 d844 0000  	movw r[4], y;		am->am;		;				| 
   11d2  1d 00 4 0 0 d902 0000  	movw 0, r[2];		;		push, go;			| Push addr. of divloop on stack and load counter
   11d3  01 00 e 0 0 9840 0000  divloop:rsubw,s r[0], acc, r[0];;		;				| Compare dividend and divisor.
   11d4  05 00 3 a 0 cc02 11d6  	sl0w r[2], r[2];	;		cjp, ~cry divneg;		| 
   11d5  15 00 3 0 0 dd62 11d7  	incw r[2], r[2];	;		cjp, go divshift;		| 
   11d6  05 00 e 0 0 9880 0000  divneg:	addw r[0], acc, r[0];;		;				| Restore.
   11d7  0d 49 8 0 0 ec81 0010  divshift: sr0w acc, acc;	0x10->am;	rfct;				| 
   11d8  05 03 e 0 0 8644 0000  	rsubw d, r[4], acc;	am->nreg;	;				| Shift dividend back down to get remainder.
   11d9  07 00 e 0 0 8180 0000  	rolw n, r[0], acc;	;		;				| Rotated, now mask by complement of orig. Ndvdnd.
   11da  05 00 e 0 0 d901 0000  	movw 0,r[1];		;		;				| 
   11db  07 09 e 0 0 e1a1 0000  	bsetw n,r[1];		am->am;		;				| Generate mask {[2**(16 - Ndvdnd)] - 1}.
   11dc  05 09 e 0 0 c1e1 0000  	sub2nw 0,r[1];		am->am;		;				| 
   11dd  1d 00 a 0 0 e2c1 0000  	andw d, acc, acc;	;		crtn, go;			| r[1] remainder and return.
   11de  05 00 e 0 0 d902 0000  divquit0: movw 0, r[2];		;		;				| 
   11df  1d 00 a 0 0 d800 0000  	movw r[0],acc;		;		crtn, go;			| 
                                |   32 Bit Dividend, 16 Bit Divisor, 16 Bit Quotient.  Mod is in r[1].
                                |   divlong: xorw,s r[1], acc, y;	;		;				| REMOVE THIS PRIOR TO RELEASE !!
                                |	movw acc,  r[4];	;		cjs, ~neg divl0;		| REMOVE THIS PRIOR TO RELEASE !!
                                |	;			;		cjs, go vidoff;			| REMOVE THIS PRIOR TO RELEASE !!
                                |	mov2nw 9, acc;		;		cjs, go delay;			| REMOVE THIS PRIOR TO RELEASE !!
                                |	movw  r[4], acc;	;		cjs, go vidon;			| REMOVE THIS PRIOR TO RELEASE !!
                                |   divl0:	priw,s r[1], 0,  r[4]; ;		;				| Normalize dividend. Find highest 1 bit.
   11e0  00 00 e 0 4 d461 0000  divlong: priw,s r[1], 0,  r[4]; ;		;				| Normalize dividend. Find highest 1 bit.
   11e1  05 03 3 0 0 c1e4 120b  	sub2nw 0,  r[4];		am->nreg;	cjp, zer divl16;		| 
   11e2  05 00 e 0 0 d882 0000  	movw acc, r[2];	;		;				| Save Divisor.
   11e3  07 00 e 0 0 e186 0000  	mov2nw n,  acc;		;		;				| 
   11e4  05 00 e 0 0 e185 0000  	sub2nw 0,  acc;		;		;				| 
   11e5  07 09 e 0 0 81e0 0000  	rolw n, r[0], r[0];	am->am;		;				| 
   11e6  07 00 e 0 0 81e1 0000  	rolw n, r[1], r[1];	;		;				| 
                                |   	romw 0, d, r[1],  acc;	;		;				| Finish normalize dividend.
   11e7  05 00 e 0 0 c2c3 0000  	andw d,  acc, r[3];	;		;				| ASSEMBLER BUG WORKAROUND
   11e8  05 00 e 0 0 fa81 0000  	compw  acc,  acc;	;		;				| ASSEMBLER BUG WORKAROUND
   11e9  05 00 e 0 0 80c1 0000  	andw r[1],  acc,  acc;	;		;				| ASSEMBLER BUG WORKAROUND
   11ea  04 00 e 0 1 9883 0000  	addw r[3],  acc, r[1];;		;				| ASSEMBLER BUG WORKAROUND
   11eb  05 00 e 0 0 d802 0000  	movw r[2], acc;	;		;				| Restore Divisor.
   11ec  01 00 e 0 0 d483 0000  	priw,s acc, 0,  r[3];	;		;				| Find highest 1 bit.
   11ed  05 03 3 0 0 c1e3 1209  	sub2nw 0,  r[3];		am->nreg;	cjp, zer divlquit0;		| 
   11ee  07 00 e 0 0 e19d 0000  	rolw n, acc, acc;	;		;				| Normalize Divisor.
   11ef  05 09 e 0 0 d844 0000  	movw  r[4], y;		am->am;		;				| 
   11f0  00 44 e 0 4 9e03 11f3  	subw,s d,  r[3],  r[4];=divl1pass->brreg;;				| 
   11f1  0c 49 3 1 3 9e84 0010  	addw d,  r[4],  r[3];	16->am;		cjp, neg;			| 
   11f2  15 04 3 0 0 d844 11f5  	movw  r[4], y;		am->brreg;	cjp, go divlldct;		| 
   11f3  05 04 e 0 0 d843 0000  divl1pass:movw  r[3], y;	am->brreg;	;				| 
   11f4  05 00 e 0 0 d903 0000  	movw 0, r[3];		;		;				| 
   11f5  09 00 c 0 0 d902 0000  divlldct:movw,s 0, r[2];	;		ldct;				| 33rd bit of Dvdnd is 0. Set cc to match.
   11f6  01 00 3 1 0 9841 11f9  divlloop:rsubw,s r[1], acc, r[1];;		cjp, neg divl33;		| Compare dividend and divisor.
   11f7  05 00 3 a 0 cc02 11fa  	sl0w r[2], r[2];	;		cjp, ~cry divlneg;		| 
   11f8  15 00 3 0 0 dd62 11fb  	incw r[2], r[2];	;		cjp, go divlshift;		| 
   11f9  15 00 3 0 0 cc22 11fb  divl33:	sl1w r[2], r[2];	;		cjp, go divlshift;		| 33rd bit was set.
   11fa  01 09 e 0 0 9881 0000  divlneg:addw,s r[1], acc, r[1];am->am;	;				| Restore and save in d for postloop check.
   11fb  05 00 e 0 0 cc00 0000  divlshift:sl0w r[0], r[0];	;		;				| 
   11fc  05 00 9 0 0 cc41 11f6  	slqw r[1], r[1];	;		rpct divlloop;			| 
   11fd  01 44 e 0 0 d844 000f  	movw,s  r[4],y;	15->brreg;	;				| 
   11fe  05 00 3 1 0 7140 1202  	;			;		cjp, neg divlmod;		| STUART (no more return, jump to mod calc.
   11ff  05 00 e 0 0 ffa4 0000  	bsetw 15,  r[4];	;		;				| STUART (down one line).
   1200  0c 00 c 0 3 d962 0000  	movw r[2], r[3];	;		ldct;				| 
   1201  11 00 3 0 0 f8c0 11f6  	movw,s d,y;		;		cjp, go divlloop;		| Set cc on state of 33rd bit in Dvdnd.
   1202  04 03 e 0 1 c9e4 0000  divlmod: sub2nw 4,  r[4],  r[1];	am->nreg;	;				| Shift dividend back down to get remainder.
   1203  06 00 e 0 1 81e0 0000  	rolw n, r[0],  r[1];	;		;				| Rotated, now mask by complement of orig. Ndvdnd.
   1204  05 00 e 0 0 f901 0000  	movw 0, acc;		;		;				| 
   1205  07 09 e 0 0 e182 0000  	bsetw n, acc;		am->am;		;				| Generate mask {[2**(16 - Ndvdnd)] - 1}.
   1206  05 09 e 0 0 e185 0000  	sub2nw 0, acc;		am->am;		;				| 
   1207  1d 00 a 0 0 9ec1 0000  	andw d,  r[1],  r[1];	;		crtn, go;			|  acc remainder and return.
   1208  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   1209  05 00 e 0 0 d903 0000  divlquit0:movw 0, r[3];	;		;				| 
   120a  1d 00 a 0 0 d902 0000  	movw 0, r[2];		;		crtn, go;			| 
   120b  15 00 3 0 0 d903 11c9  divl16:	movw 0, r[3];		;		cjp, go divide;			| Really only 16 bits.  r[0] already in r[0].
                                | "@(#)ack.pp.u 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   ppack:  Acknowledgement from painting processor to outside world.
   120c  05 61 3 d 0 d8c0 120c  ppack:	movw d, r[0];		fifo1->am;	cjp, f1e ppack;			| 
   120d  05 45 e 0 0 7140 018d  	;			0x18d->scrmemp; ;				| 
   120e  01 59 e 0 0 f8c0 0000  	 movw,s d, y;		scrmem->am;	;				| 
   120f  05 72 3 0 0 7140 120f  	;			scrmem->vhiareg; cjp, zer .;			| If 0x18d was never initialized then loop.
   1210  05 53 e 0 0 7140 8002  	;			0x8002->vloareg; ;				| 
   1211  05 00 3 f 0 7140 1211  ppack0:	;			;		cjp, ~vir ppack0;		| 
   1212  05 54 e 0 0 7140 0073  	;			0x73->vctlreg;;				| 
   1213  05 0d 3 f 7 d840 1213  	movw r[0], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1214  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
                                | "@(#)init.pp.u 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   ldmasktbl:  Load mask table.
                                |   From /usr/src/1/usr.lib/libpixrect/cg2_rop.c
                                |   short mrc_lmasktable[]= {0x0000, 0x8000, 0xc000, 0xe000,
                                |			     0xf000, 0xf800, 0xfc00, 0xfe00,
                                |			     0xff00, 0xff80, 0xffc0, 0xffe0,
                                |			     0xfff0, 0xfff8, 0xfffc, 0xfffe}; 
                                |   short mrc_rmasktable[]= {0x7fff, 0x3fff, 0x1fff, 0x0fff,
                                |			     0x07ff, 0x03ff, 0x01ff, 0x00ff,
                                |			     0x007f, 0x003f, 0x001f, 0x000f,
                                |			     0x0007, 0x0003, 0x0001, 0x0000}
   1215  05 45 e 0 0 7140 018d  ppinit:	;			0x18d->scrmemp; ;				| 
                                |	;			am->scrmem;	;				| 
   1216  05 61 3 d 0 f8c1 1216  	movw d, acc;		fifo1->am;	cjp, f1e .;			| High address bits of gp.
   1217  05 0a e 0 0 f880 0000  	movw acc, y;		am->scrmem;	;				| 
   1218  05 56 e 0 0 7140 6000  	;			0x6000->zbhiptr; ;				| Reset gbuffer state.
   1219  05 49 e 0 0 d8dd 00ff  	movw d, r[29];		0xff->am;	;				| 
   121a  05 45 e 0 0 f901 01a0  	movw 0, acc;		0x1a0->scrmemp; ;				| 
   121b  05 44 e 0 0 7140 000e  	;			14->brreg;	;				| Rdy to load counter.
   121c  1d 0a 4 0 4 f880 0000  	movw acc, y;		am->scrmem;	push, go;		scrmp +	| 
   121d  0d 0a 8 0 4 eca1 0000  	sr1w acc, acc;		am->scrmem;	rfct;			scrmp +	| mrc_lmasktable.
   121e  05 44 e 0 0 7140 000f  	;			15->brreg;	;				| 
   121f  1d 45 4 0 0 7140 01b0  	;			0x1b0->scrmemp;push, go;			| 
   1220  0d 0a 8 0 4 ec81 0000  	sr0w acc, acc;		am->scrmem;	rfct;			scrmp +	| mrc_rmasktable.
   1221  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   1222  05 61 3 d 0 d8df 1222  fbaddr:	movw d, r[31];		fifo1->am;	cjp, f1e .;			| High address bits of frame buffer (fb).
   1223  04 49 e 0 e 9e9f 0030  	addw d, r[31], r[30];	0x30->am;	;				| Control area of fb
   1224  15 00 1 0 0 7140 122a  	;			;		cjs, go resetrr;		| 
   1225  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   1226  01 61 3 d 0 961d 1226  ppmask:	subw,s d, r[29], y;	fifo1->am;	cjp, f1e .;			| 
   1227  05 53 e 0 0 d8dd a000  	movw d, r[29];		0xa000->vloareg; ;				| 
   1228  05 00 1 8 0 7140 122a  	;			;		cjs, ~zer resetrr;		| 
   1229  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   122a  05 12 e 0 0 d85e 0000  resetrr: movw r[30], y;	am->vhiareg;	;				| Must actually load patt since ffff is valid.
   122b  05 00 3 f 0 7140 122b  	;			;		cjp, ~vir .;			| Wait till vctlreg ready.
   122c  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   122d  05 53 e 0 0 7140 a000  	;			0xa000->vloareg; ;				| 
   122e  05 0d 3 f 7 d85d 122e  	movw r[29], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   122f  05 45 e 0 0 7140 01c0  	;			0x1c0->scrmemp; ;				| Set defaults so all will change first time thru.
   1230  05 4a e 0 4 7140 ffff  	;			0xffff->scrmem;	;			scrmp +	| Op.
   1231  05 53 e 0 0 7140 8006  	;			 0x8006->vloareg; ;			| 
   1232  05 0d 3 f 7 f900 1232  	movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
                                |	movw acc, r[3];		;		;				| 
                                |	movw d, acc;		0x200->am;	;				| 
                                |	incw 0, r[0];		;		cjs, go cndflash;		| 
                                |	movw r[3], acc;		;		;				| 
                                |	;			0x1c0->scrmemp; ;				| 
                                |	;			;		;			scrmp +	| 
   1233  05 4a e 0 4 7140 0000  	;			0->scrmem;	;			scrmp +	| Pattern.
   1234  05 00 e 0 0 7140 0000  	;			;		;				| 
   1235  05 4a e 0 4 7140 ffff  	;			0xffff->scrmem;	;			scrmp +	| Mask2
   1236  05 00 e 0 0 7140 0000  	;			;		;				| 
   1237  05 4a e 0 4 7140 ffff  	;			0xffff->scrmem;	;			scrmp +	| Mask1
   1238  05 00 e 0 0 7140 0000  	;			;		;				| 
   1239  05 4a e 0 4 7140 ffff  	;			0xffff->scrmem;	;			scrmp +	| Width
   123a  05 00 e 0 0 7140 0000  	;			;		;				| 
   123b  05 4a e 0 4 7140 ffff  	;			0xffff->scrmem;	;			scrmp +	| OpCnt
   123c  05 00 e 0 0 7140 0000  	;			;		;				| 
   123d  05 4a e 0 4 7140 ffff  	;			0xffff->scrmem;	;			scrmp +	| Shift
                                |   ELIMINATE Next 2 instructions?
                                |	;			;		;				| 
                                |	;			0x00ff->scrmem;	;			scrmp +	| Prime.  This never equals col | col<<8.
   123e  1d 00 a 0 1 7140 0000  	;			;		crtn, go;		varegs +| 
   123f  05 61 3 d 0 f8c1 123f  stcolor: movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   1240  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
                                | "@(#)ropnull.pp.u 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   Implements null to frame buffer rasterops.
                                |   rsetup is called by ropnull and ropfb.
   1241  15 00 1 0 0 7140 1309  rnull:	;			;		cjs, go ropreg;			| 
   1242  05 61 3 d 0 d8c0 1242  	movw d, r[0];		fifo1->am;	cjp, f1e .;			| 
   1243  05 13 e 0 0 d840 0000  	movw r[0], y;		am->vloareg;	;				| 
   1244  05 61 3 d 0 d8c1 1244  	movw d, r[1];		fifo1->am;	cjp, f1e .;			| 
   1245  05 61 3 d 0 d8c8 1245  	movw d, r[8];		fifo1->am;	cjp, f1e .;			| 
   1246  05 61 3 d 0 d8db 1246  	movw d, r[27];		fifo1->am;	cjp, f1e .;			| 
   1247  05 61 3 d 0 d8c7 1247  	movw d, r[7];		fifo1->am;	cjp, f1e .;			| 
   1248  05 61 3 d 0 d8da 1248  	movw d, r[26];		fifo1->am;	cjp, f1e .;			| 
   1249  05 61 3 d 0 d8c5 1249  	movw d, r[5];	fifo1->am;	cjp, f1e .;			| 
   124a  05 49 e 0 0 d8c9 0080  	movw d, r[9];	 128->am;	;				| 
   124b  05 12 e 0 0 d841 0000  	movw r[1], y;		am->vhiareg;	;				| 
   124c  01 00 e 0 0 d847 0000  	 movw,s r[7], y;		;		;				| switch (r[7])
   124d  05 04 3 8 0 c1e8 1253  	sub2nw 0, r[8];		am->brreg;	cjp, ~zer rnull1;		| case 0:  r[7]= sizey.
   124e  1d 49 4 0 0 d809 0000  	movw r[9], acc;	0->am;		push, go;			| while (r[7]--) { 
   124f  05 0d 3 f 7 d85b 124f  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| *((short*)by)= r[27].
   1250  05 13 e 0 0 9880 0000  	addw r[0], acc, r[0];am->vloareg;	;				| 
   1251  0d 12 8 0 0 9ea1 0000  	addcw d, r[1], r[1];am->vhiareg;	rfct;				| 
   1252  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   1253  01 49 e 0 0 9707 0001  rnull1:	xorw,s d, r[7], y;		1->am;		;				| 
   1254  05 04 3 8 0 d848 125d  	movw r[8], y;		am->brreg;	cjp, ~zer rnull2;		| case 1:  while (sizey--) {
   1255  1d 49 4 0 0 d809 0000  	movw r[9], acc;	0->am;		push, go;			| 
   1256  05 0d 3 f 7 d85b 1256  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| *((short*)by)= r[27].
   1257  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   1258  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   1259  05 0d 3 f 7 d85b 1259  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| *((short*)by)= r[27].
   125a  05 13 e 0 0 9880 0000  	addw r[0], acc, r[0];am->vloareg;	;				| 
   125b  0d 12 8 0 0 9ea1 0000  	addcw d, r[1], r[1];am->vhiareg;	rfct;				| by += r[9].
   125c  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   125d  01 53 e 0 0 d85a 8010  rnull2:	 movw,s r[26], y;		0x8010->vloareg; ;			| if (r[26]) cg2_setwidth (, , 2, 2)
   125e  05 12 3 0 0 d85e 1282  	movw r[30], y;		am->vhiareg;	cjp, zer rnull2d;		| 
   125f  05 49 e 0 0 d8c4 0002  	movw d, r[4];		2->am;		;				| 
   1260  05 0d 3 f 7 d804 1260  	movw r[4], acc;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1261  05 53 e 0 0 7140 8012  	;			0x8012->vloareg; ;			| 
   1262  05 0d 3 f 7 f880 1262  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1263  04 09 e 0 2 cc07 0000  	sl0w r[7], r[2];		am->am;		;				| 
   1264  05 00 e 0 0 9e09 0000  	subw d, r[9], r[9]; ;		;				| 
   1265  05 00 e 0 0 9847 0000  	rsubw r[7], acc, r[7];	;		;				| r[7] -= 2
   1266  05 49 e 0 0 7140 0000  	;			0->am;		;				| 0 for d register for high word addition.
                                | while (sizey--) {
   1267  05 13 e 0 0 d840 0000  rn2loop: movw r[0], y;	am->vloareg;	;				| bx= y
   1268  05 12 e 0 0 d841 0000  	movw r[1], y;		am->vhiareg;	;				| 
   1269  05 0d 3 f 7 d85b 1269  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| *((short*)by)= r[27].
   126a  05 13 e 0 0 9880 0000  	addw r[0], acc, r[0]; am->vloareg;	;				| 
   126b  05 12 e 0 0 9ea1 0000  	addcw d, r[1], r[1]; am->vhiareg;	;				| 
   126c  05 0d 3 f 7 d85b 126c  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| *((short*)by)= r[27].
   126d  00 00 e 0 2 c1e7 0000  	sub2nw,s 0, r[7], r[2];		;		;				| 
   126e  05 00 e 0 0 9880 0000  	addw r[0], acc, r[0]; ;		;				| 
   126f  05 00 3 1 0 9ea1 1277  	addcw d, r[1], r[1]; ;		cjp, neg rnvme2c;		| if (r[7] <= 0) skip fastloop.
   1270  15 00 1 0 0 d805 14e7  	movw r[5], acc;	;		cjs, go vropmode;		| 
   1271  04 04 e 0 2 c1e7 0000  	sub2nw 0, r[7], r[2];		am->brreg;	;				| 
   1272  05 13 e 0 0 d840 0000  	movw r[0], y;		am->vloareg;	;				| reload address registers.
   1273  1d 12 4 0 0 d841 0000  	movw r[1], y;		am->vhiareg;	push, go;			| 
   1274  05 0d 3 f 7 d85b 1274  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| *((short*)by)= r[27].
   1275  05 49 e 0 1 9e80 0002  	addw d, r[0], r[0];	2->am;		;			varegs +| 
   1276  0d 49 8 0 1 9ea1 0000  	addcw d, r[1], r[1]; 0->am;		rfct;			varegs +| 
   1277  05 49 e 0 0 f8c1 0006  rnvme2c: movw d, acc;		6->am;	;				| 
   1278  15 00 1 0 0 7140 14e7  	;			;		cjs, go vropmode;		| 
   1279  05 13 e 0 0 d840 0000  	movw r[0], y;		am->vloareg;	;				| 
   127a  05 12 e 0 0 d841 0000  	movw r[1], y;		am->vhiareg;	;				| 
   127b  05 0d 3 f 7 d85b 127b  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| *((short*)by)= r[27].
   127c  05 49 e 0 0 d809 0000  	movw r[9], acc;	0->am;		;				| 0 for d register for high word addition.
   127d  05 13 e 0 0 9880 0000  	addw r[0], acc, r[0]; am->vloareg;	;				| 
   127e  05 12 e 0 0 9ea1 0000  	addcw d, r[1], r[1]; am->vhiareg;	;				| 
   127f  01 00 e 0 0 c1e8 0000  	sub2nw,s 0, r[8], r[8];	;		;				| sizey--
   1280  05 00 3 9 0 d804 1267  	movw r[4], acc;		;		cjp, ~neg rn2loop;		| 
   1281  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   1282  05 04 e 0 0 d848 0000  rnull2d: movw r[8], y;		am->brreg;	;				| 
   1283  05 13 e 0 0 d840 0000  	movw r[0], y;		am->vloareg;	;				| 
   1284  1d 12 4 0 0 d841 0000  	movw r[1], y;		am->vhiareg;	push, go;			| 
   1285  05 00 e 0 0 d807 0000  	movw r[7], acc;		;		;				| 
   1286  05 0d 3 f 7 d85b 1286  rnvme2d: movw r[27], y;		am->vwdreg;	cjp, ~vir rnvme2d;	vmewr	| 
   1287  01 00 e 0 1 e185 0000  	sub2nw,s 0, acc;		;		;			varegs +| 
   1288  05 00 3 9 1 7140 1286  	;			;		cjp, ~neg rnvme2d;	varegs +| 
   1289  05 49 e 0 0 d809 0000  	movw r[9], acc;	0->am;		;				| 
   128a  05 13 e 0 0 9880 0000  	addw r[0], acc, r[0]; am->vloareg;	;				| 
   128b  0d 12 8 0 0 9ea1 0000  	addcw d, r[1], r[1]; am->vhiareg;	rfct;				| 
   128c  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
                                | "@(#)ropfb.pp.u 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   Frame buffer to frame buffer rops.
   128d  15 00 1 0 0 7140 1309  ropfb:	;			;		cjs, go ropreg;			| 
   128e  05 61 3 d 0 d8c0 128e  rfalo1:	movw d, r[0];		fifo1->am;	cjp, f1e rfalo1;		| Interleave instructions with fifo fetches.
   128f  05 13 e 0 0 f8c0 0000  	movw d, y;		am->vloareg;	;				| Get first data from source raster. (*sx)
   1290  05 61 3 d 0 d8c1 1290  rfahi1:	movw d, r[1];		fifo1->am;	cjp, f1e rfahi1;		| 
   1291  05 12 3 f 0 f8c0 1291  rfvctl:	movw d, y;		am->vhiareg;	cjp, ~vir rfvctl;		| 
   1292  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   1293  05 61 3 d 0 d8c3 1293  rfalo:	movw d, r[3];		fifo1->am;	cjp, f1e rfalo;			| 
   1294  05 61 3 d 0 d8c4 1294  rfahi:	movw d, r[4];		fifo1->am;	cjp, f1e rfahi;			| 
   1295  05 61 3 d 0 d8c9 1295  rfw:	movw d, r[9];		fifo1->am;	cjp, f1e rfw;			| 
   1296  05 61 3 d 0 d8ca 1296  rfropm:	movw d, r[10];	fifo1->am;	cjp, f1e rfropm;		| 
   1297  05 61 3 d 0 d8cb 1297  rfrecht:movw d, r[11];		fifo1->am;	cjp, f1e rfrecht;		| 
   1298  05 61 3 d 0 d8cd 1298  rfdir:	movw d, r[13];		fifo1->am;	cjp, f1e rfdir;			| 
   1299  05 61 3 d 0 d8ce 1299  rfprime:movw d, r[14];		fifo1->am;	cjp, f1e rfprime;		| 
   129a  05 49 e 0 0 d8cc 0080  	movw d, r[12];	 128->am;	;				| 
   129b  05 00 3 f 6 7140 129b  	;			;		cjp, ~vir .;		vmerd	| 
   129c  01 00 e 0 0 d849 0000  	 movw,s r[9], y;		;		;				| if (r[9]) {
   129d  05 00 3 0 0 c3e9 12e7  	sub2nw 1, r[9], r[9];		;		cjp, zer rfwzero;		| r[9]-- (twice because fastloop done at least once).
   129e  01 00 e 0 0 c1eb 0000  rfloop:	sub2nw,s 0, r[11], r[11];	;		;				| while (--SizeY >= 0)
   129f  04 00 3 1 5 d960 1128  	movw r[0], r[5];	;		cjp, neg start;			| sx= sy
   12a0  04 00 e 0 6 d961 0000  	movw r[1], r[6];	;		;				| 
   12a1  04 00 e 0 7 d963 0000  	movw r[3], r[7];	;		;				| bx= by
   12a2  04 00 e 0 8 d964 0000  	movw r[4], r[8];	;		;				| 
   12a3  01 00 e 0 0 e3ed 0000  	btstw,s 1, r[13];		;		;				| if (rop_isright (r[13])) {
   12a4  01 00 3 8 0 d84e 12c7  	 movw,s r[14], y;		;		cjp, ~zer rfleft;		| if (r[14])
   12a5  05 00 3 0 0 7140 12ad  	;			;		cjp, zer rfrxfer;		| 
   12a6  05 53 e 0 0 7140 8002  	;			 0x8002->vloareg;;			| 
   12a7  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| Get ready for cg2_set{r,l}source ()
   12a8  05 3d 3 f 7 7140 12a8  rfrvwr:	;			vrdreg->vwdreg;	cjp, ~vir rfrvwr;	vmewr	| cg2_setrsource (,, *(sx)--)
   12a9  05 13 e 0 0 c3e5 0000  	sub2nw 1, r[5], r[5];	am->vloareg;	;				| 
   12aa  05 49 e 0 0 9e26 0000  	subcw d, r[6], r[6];	0->am;		;				| 
   12ab  05 12 e 0 0 d846 0000  	movw r[6], y;		am->vhiareg;	;				| 
   12ac  05 00 3 f 6 7140 12ac  rfrvrd:	;			;		cjp, ~vir rfrvrd;	vmerd	| *bx--= *sx--
   12ad  05 13 e 0 0 d847 0000  rfrxfer:movw r[7], y;		am->vloareg;	;				| 
   12ae  05 12 e 0 0 d848 0000  	movw r[8], y;		am->vhiareg;	;				| 
   12af  01 3d 3 f 7 d849 12af  rfrvwr1: movw,s r[9], y;		vrdreg->vwdreg;	cjp, ~vir rfrvwr1;	vmewr	| 
   12b0  05 04 3 1 0 d849 12bd  	movw r[9], y;		am->brreg;	cjp, neg rfrend;		| ready to load counter for fastloop (if needed)
   12b1  15 00 1 0 0 d80a 14e7  	movw r[10], acc;	;		cjs, go vropmode;		| statusreg.r[10]= r[10]
   12b2  1d 00 4 0 0 f901 0000  	movw 0, acc;		;		push, go;			| fastloop (r[9], *bx-- = *sx--)
   12b3  05 13 e 0 0 c3e5 0000  	sub2nw 1, r[5], r[5];	am->vloareg;	;				| 
   12b4  05 12 e 0 0 9866 0000  	rsubcw r[6], acc, r[6];	am->vhiareg;	;				| 
   12b5  05 00 3 f 6 7140 12b5  rfrvrdf:;			;		cjp, ~vir rfrvrdf;	vmerd	| 
   12b6  05 13 e 0 0 c3e7 0000  	sub2nw 1, r[7], r[7];	am->vloareg;	;				| 
   12b7  05 12 e 0 0 9868 0000  	rsubcw r[8], acc, r[8];	am->vhiareg;	;				| 
   12b8  05 00 3 f 0 7140 12b8  rfrvwrf:;			;		cjp, ~vir rfrvwrf;		| 
   12b9  05 3d e 0 0 7140 0000  	;			vrdreg->vwdreg;	;				| 
   12ba  05 00 3 f 7 7140 12ba  rfrvwrf1:;			;		cjp, ~vir rfrvwrf1;	vmewr	| 
   12bb  0d 49 8 0 0 7140 0006  	;			6->am;	rfct;				| end of fastloop. 6 for after loop done.
   12bc  15 00 1 0 0 f8c1 14e7  	movw d, acc;		;		cjs, go vropmode;		| statusreg.r[10]= 6
   12bd  05 13 e 0 0 c3e5 0000  rfrend:	sub2nw 1, r[5], r[5];	am->vloareg;	;				| *bx= *sx
   12be  05 49 e 0 0 9e26 0000  	subcw d, r[6], r[6];	0->am;		;				| 
   12bf  05 12 e 0 0 d846 0000  	movw r[6], y;		am->vhiareg;	;				| 
   12c0  05 00 3 f 6 7140 12c0  rfrvrde:;			;		cjp, ~vir rfrvrde;	vmerd	| 
   12c1  05 13 e 0 0 c3e7 0000  	sub2nw 1, r[7], r[7];	am->vloareg;	;				| 
   12c2  05 49 e 0 0 9e28 0000  	subcw d, r[8], r[8];	0->am;		;				| 
   12c3  05 12 e 0 0 d848 0000  	movw r[8], y;		am->vhiareg;	;				| 
   12c4  05 3d 3 f 7 7140 12c4  rfrvwre:;			vrdreg->vwdreg;	cjp, ~vir rfrvwre;	vmewr	| 
   12c5  11 00 1 0 0 e1ed 12fd  	btstw,s 0, r[13];		;		cjs, go rfdown;			| 
   12c6  15 00 3 0 0 7140 129e  	;			;		cjp, go rfloop;			| 
   12c7  05 00 3 0 0 7140 12cf  rfleft:	;			;		cjp, zer rflxfer;		| if (r[14])
   12c8  05 53 e 0 0 7140 8004  	;			 0x8004->vloareg;;			| cg2_setlsource (,, *(sx)--)
   12c9  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| Get ready for cg2_set{r,l}source ()
   12ca  05 3d 3 f 7 7140 12ca  rflvwr:	;			vrdreg->vwdreg;	cjp, ~vir rflvwr;	vmewr	| 
   12cb  05 13 e 0 0 c3c5 0000  	add2nw 1, r[5], r[5];	am->vloareg;	;				| 
   12cc  05 49 e 0 0 9ea6 0000  	addcw d, r[6], r[6];	0->am;		;				| 
   12cd  05 12 e 0 0 d846 0000  	movw r[6], y;		am->vhiareg;	;				| 
   12ce  05 00 3 f 6 7140 12ce  rflvrd:	;			;		cjp, ~vir rflvrd;	vmerd	| *bx--= *sx--
   12cf  05 13 e 0 0 d847 0000  rflxfer:movw r[7], y;		am->vloareg;	;				| 
   12d0  05 12 e 0 0 d848 0000  	movw r[8], y;		am->vhiareg;	;				| 
   12d1  01 3d 3 f 7 d849 12d1  rflvwr1: movw,s r[9], y;		vrdreg->vwdreg;	cjp, ~vir rflvwr1;	vmewr	| 
   12d2  05 04 3 1 0 d849 12dd  	movw r[9], y;		am->brreg;	cjp, neg rflend;		| ready to load counter for fastloop (if needed)
   12d3  15 00 1 0 0 d80a 14e7  	movw r[10], acc;	;		cjs, go vropmode;		| statusreg.r[10]= r[10]
   12d4  1d 00 4 0 0 f901 0000  	movw 0, acc;		;		push, go;			| fastloop (r[9], *bx-- = *sx--)
   12d5  05 13 e 0 0 c3c5 0000  	add2nw 1, r[5], r[5];	am->vloareg;	;				| 
   12d6  05 12 e 0 0 98a6 0000  	addcw r[6], acc, r[6];	am->vhiareg;	;				| 
   12d7  05 00 3 f 6 7140 12d7  rflvrdf:;			;		cjp, ~vir rflvrdf;	vmerd	| 
   12d8  05 13 e 0 0 c3c7 0000  	add2nw 1, r[7], r[7];	am->vloareg;	;				| 
   12d9  05 12 e 0 0 98a8 0000  	addcw r[8], acc, r[8];	am->vhiareg;	;				| 
   12da  05 3d 3 f 7 7140 12da  rflvwrf:;			vrdreg->vwdreg;	cjp, ~vir rflvwrf;	vmewr	| 
   12db  0d 49 8 0 0 7140 0006  	;			6->am;	rfct;				| end of fastloop. 6 for after loop done.
   12dc  15 00 1 0 0 f8c1 14e7  	movw d, acc;		;		cjs, go vropmode;		| statusreg.r[10]= 6
   12dd  05 13 e 0 0 c3c5 0000  rflend:	add2nw 1, r[5], r[5];	am->vloareg;	;				| *bx= *sx
   12de  05 49 e 0 0 9ea6 0000  	addcw d, r[6], r[6];	0->am;		;				| 
   12df  05 12 e 0 0 d846 0000  	movw r[6], y;		am->vhiareg;	;				| 
   12e0  05 00 3 f 6 7140 12e0  rflvrde:;			;		cjp, ~vir rflvrde;	vmerd	| 
   12e1  05 13 e 0 0 c3c7 0000  	add2nw 1, r[7], r[7];	am->vloareg;	;				| 
   12e2  05 49 e 0 0 9ea8 0000  	addcw d, r[8], r[8];	0->am;		;				| 
   12e3  05 12 e 0 0 d848 0000  	movw r[8], y;		am->vhiareg;	;				| 
   12e4  05 3d 3 f 7 7140 12e4  rflvwre:;			vrdreg->vwdreg;	cjp, ~vir rflvwre;	vmewr	| 
   12e5  11 00 1 0 0 e1ed 12fd  	btstw,s 0, r[13];		;		cjs, go rfdown;			| 
   12e6  15 00 3 0 0 7140 129e  	;			;		cjp, go rfloop;			| 
   12e7  05 49 e 0 0 f8c1 0006  rfwzero:movw d, acc;		6->am;	;				| 
   12e8  15 00 1 0 0 7140 14e7  	;			;		cjs, go vropmode;		| 
   12e9  01 00 e 0 0 c1eb 0000  rfwloop:sub2nw,s 0, r[11], r[11];	;		;				| while (--SizeY >= 0)
   12ea  04 13 3 1 5 d960 1128  	movw r[0], r[5];	am->vloareg;	cjp, neg start;			| sx= sy
   12eb  04 12 e 0 6 d961 0000  	movw r[1], r[6];	am->vhiareg;	;				| 
   12ec  04 00 e 0 7 d963 0000  	movw r[3], r[7];	;		;				| bx= by
   12ed  04 00 e 0 8 d964 0000  	movw r[4], r[8];	;		;				| 
   12ee  01 00 e 0 0 d84e 0000  	 movw,s r[14], y;		;		;				| 
   12ef  05 00 3 0 0 7140 12f7  	;			;		cjp, zer rfwvrd;		| 
   12f0  05 00 3 f 6 7140 12f0  rfwvrd0: ;			;		cjp, ~vir rfwvrd0;	vmerd	| *sx--
   12f1  05 53 e 0 0 7140 8004  	;			 0x8004->vloareg;;			| cg2_setlsource (,, *(sx)--)
   12f2  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| Get ready for cg2_set{r,l}source ()
   12f3  05 3d 3 f 7 7140 12f3  rfwvwr:	;			vrdreg->vwdreg;	cjp, ~vir rfwvwr;	vmewr	| 
   12f4  05 13 e 0 0 c3c5 0000  	add2nw 1, r[5], r[5];	am->vloareg;	;				| 
   12f5  05 49 e 0 0 9ea6 0000  	addcw d, r[6], r[6];	0->am;		;				| 
   12f6  05 12 e 0 0 d846 0000  	movw r[6], y;		am->vhiareg;	;				| 
   12f7  05 00 3 f 6 7140 12f7  rfwvrd:	;			;		cjp, ~vir rfwvrd;	vmerd	| *bx--= *sx--
   12f8  05 13 e 0 0 d847 0000  rfwxfer: movw r[7], y;		am->vloareg;	;				| 
   12f9  05 12 e 0 0 d848 0000  	movw r[8], y;		am->vhiareg;	;				| 
   12fa  05 3d 3 f 7 7140 12fa  rfwvwr1:;			vrdreg->vwdreg;	cjp, ~vir rfwvwr1;	vmewr	| 
   12fb  11 00 1 0 0 e1ed 12fd  	btstw,s 0, r[13];		;		cjs, go rfdown;			| rfdown will use result of this test.
   12fc  15 00 3 0 0 7140 12e9  	;			;		cjp, go rfwloop;		| 
   12fd  05 49 e 0 0 f8c1 0080  rfdown:	movw d, acc;		 128->am;	;				| 
   12fe  05 00 3 8 0 7140 1304  	;			;		cjp, ~zer rfup;			| 
   12ff  05 13 e 0 0 9840 0000  	rsubw r[0], acc, r[0];	am->vloareg;	;				| sy -= r[12] 
   1300  05 49 e 0 0 9e21 0000  	subcw d, r[1], r[1];	0->am;		;				| 
   1301  05 12 3 f 0 d841 1301  rfdown1:movw r[1], y;		am->vhiareg;	cjp, ~vir rfdown1;		| get read ready for next line.
   1302  05 00 e 0 6 9843 0000  	rsubw r[3], acc, r[3];	;		;			vmerd	| by -= r[12]
   1303  1d 49 a 0 0 9e24 0000  	subcw d, r[4], r[4];	0->am;		crtn, go;			| 
   1304  05 13 e 0 0 9880 0000  rfup:	addw r[0], acc, r[0];	am->vloareg;	;				| sy += r[12] 
   1305  05 49 e 0 0 9ea1 0000  	addcw d, r[1], r[1];	0->am;		;				| 
   1306  05 12 3 f 0 d841 1306  rfup1:	movw r[1], y;		am->vhiareg;	cjp, ~vir rfup1;		| get read ready for next line.
   1307  05 00 e 0 6 9883 0000  	addw r[3], acc, r[3];	;		;			vmerd	| by += r[12]
   1308  1d 49 a 0 0 9ea4 0000  	addcw d, r[4], r[4];	0->am;		crtn, go;			| 
                                |   Set r[27] r[31] 2 rop registers from fifo.
   1309  05 61 3 d 0 f8c1 1309  ropreg:	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   130a  05 00 3 f 0 7140 130a  	;			;		cjp, ~vir .;			| 
   130b  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   130c  15 00 1 0 0 7140 14e7  	;			;		cjs, go vropmode;		| 
   130d  05 45 e 0 0 7140 01c0  	;			0x1c0->scrmemp; ;				| 
   130e  05 61 3 d 0 f8c1 130e  	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   130f  01 59 e 0 0 e200 0000  	subw,s d, acc, y;	scrmem->am;	;				| 
   1310  05 0a 3 0 4 f880 1313  	movw acc, y;		am->scrmem;	cjp, zer rrpatt;	scrmp +	| 
   1311  05 53 e 0 0 7140 800e  	;			 0x800e->vloareg; ;			| 
   1312  05 0d 3 f 7 f880 1312  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1313  05 61 3 d 0 f8c1 1313  rrpatt:	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   1314  01 59 e 0 0 e200 0000  	subw,s d, acc, y;	scrmem->am;	;				| 
   1315  05 0a 3 0 4 f880 1318  	movw acc, y;		am->scrmem;	cjp, zer rrm2;		scrmp +	| 
   1316  05 53 e 0 0 7140 8006  	;			 0x8006->vloareg; ;			| 
   1317  05 0d 3 f 7 f880 1317  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1318  05 61 3 d 0 f8c1 1318  rrm2:	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   1319  01 59 e 0 0 e200 0000  	subw,s d, acc, y;	scrmem->am;	;				| 
   131a  05 0a 3 0 4 f880 131d  	movw acc, y;		am->scrmem;	cjp, zer rrm1;		scrmp +	| 
   131b  05 53 e 0 0 7140 800a  	;			0x800a->vloareg; ;			| 
   131c  05 0d 3 f 7 f880 131c  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   131d  05 61 3 d 0 f8c1 131d  rrm1:	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   131e  01 59 e 0 0 e200 0000  	subw,s d, acc, y;	scrmem->am;	;				| 
   131f  05 0a 3 0 4 f880 1322  	movw acc, y;		am->scrmem;	cjp, zer rrwid;		scrmp +	| 
   1320  05 53 e 0 0 7140 8008  	;			0x8008->vloareg; ;			| 
   1321  05 0d 3 f 7 f880 1321  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1322  05 61 3 d 0 f8c1 1322  rrwid:	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   1323  01 59 e 0 0 e200 0000  	subw,s d, acc, y;	scrmem->am;	;				| 
   1324  05 0a 3 0 4 f880 1327  	movw acc, y;		am->scrmem;	cjp, zer rrcnt;		scrmp +	| 
   1325  05 53 e 0 0 7140 8010  	;			0x8010->vloareg; ;			| 
   1326  05 0d 3 f 7 f880 1326  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1327  05 61 3 d 0 f8c1 1327  rrcnt:	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   1328  01 59 e 0 0 e200 0000  	subw,s d, acc, y;	scrmem->am;	;				| 
   1329  05 0a 3 0 4 f880 132c  	movw acc, y;		am->scrmem;	cjp, zer rrsh;		scrmp +	| 
   132a  05 53 e 0 0 7140 8012  	;			0x8012->vloareg; ;			| 
   132b  05 0d 3 f 7 f880 132b  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   132c  05 61 3 d 0 f8c1 132c  rrsh:	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   132d  01 59 e 0 0 e200 0000  	subw,s d, acc, y;	scrmem->am;	;				| 
   132e  05 0a 3 0 4 f880 1331  	movw acc, y;		am->scrmem;	cjp, zer rrsrc2;	scrmp +	| 
   132f  05 53 e 0 0 7140 800c  	;			0x800c->vloareg; ;			| 
   1330  05 0d 3 f 7 f880 1330  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1331  05 61 3 d 0 f8c1 1331  rrsrc2:	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   1332  05 53 e 0 0 7140 8804  	;			0x8804->vloareg; ;			| 
   1333  05 0d 3 f 7 f880 1333  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1334  1d 00 a 0 0 7140 0000  rrrtn:	;			;		crtn, go;			| 
   1335  05 61 3 d 0 7140 1335  fifovme: ;			fifo1->am;	cjp, f1e .;			| 
   1336  05 0d 3 f 7 f8c0 1336  	movw d, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1337  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
                                | "@(#)vector.pp.u 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   vector:  Mimics the action of cg2_vec.c
                                |   Please refer to cg2_vec.c and follow along.
                                |   Vector can be called from the pixrect level (0 has been stuffed into r[24] field), or it can
                                |   be called from the xfline level, where we have solid, width 1 vectors.  In this case, a 0 has
                                |   been loaded into r[24] for the first vector, but this register is not touched after that.
   1338  05 45 e 0 0 7140 0190  vector:	;			 0x190->scrmemp; ;				| 
   1339  05 61 3 d 0 d8cf 1338  	movw d, r[15];		fifo1->am;	cjp, f1e vector;		| 
   133a  05 0a e 0 4 f8c0 0000  	movw d, y;		am->scrmem;	;			scrmp +	| 
   133b  05 61 3 d 0 d8ce 133b  vec1:	movw d, r[14];		fifo1->am;	cjp, f1e vec1;			| 
   133c  05 0a e 0 4 f8c0 0000  	movw d, y;		am->scrmem;	;			scrmp +	| 
   133d  05 61 3 d 0 d8cd 133d  vec2:	movw d, r[13];		fifo1->am;	cjp, f1e vec2;			| 
   133e  05 0a e 0 4 f8c0 0000  	movw d, y;		am->scrmem;	;			scrmp +	| 
   133f  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];	;		;				| r[11]
   1340  05 61 3 d 0 d8cc 1340  vec3:	movw d, r[12];		fifo1->am;	cjp, f1e vec3;			| 
   1341  05 0a e 0 0 f8c0 0000  	movw d, y;		am->scrmem;	;				| 
   1342  04 00 e 0 a 9e4e 0000  	rsubw d, r[14], r[10];	;		;				| r[10].
   1343  05 61 3 d 0 d8dc 1343  vec4:	movw d, r[28];		fifo1->am;	cjp, f1e vec4;			| 
   1344  00 49 e 0 7 9f3c fffe  	norw,s d, r[28], r[23];	0xfffe->am;	;				| (PIX_DONTCLIP == 1) => (r[23] == 0).
   1345  05 61 3 d 0 d8db 1345  vec5:	movw d, r[27];		fifo1->am;	cjp, f1e vec5;			| 
   1346  05 00 e 0 0 979c 0000  	rolw 11, r[28], acc;	;		;				| r[27] in r[28]?
   1347  01 49 e 0 0 e2c1 07ff  	andw,s d, acc, acc;	0x7ff->am;	;				| 
   1348  05 00 3 0 0 cc9c 134a  	sr0w r[28], r[28];		;		cjp, zer vop0;			| r[28] >>= 1.
   1349  05 00 e 0 0 d89b 0000  	movw acc, r[27];	;		;				| 
   134a  05 49 e 0 0 9edc 000f  vop0:	andw d, r[28], r[28];		0xf->am;	;				| 
                                |   PIXOP_NEEDS_DST (r[28]<<1)= (r[28]^(r[28]<<1)) & 0xa
   134b  05 00 e 0 0 d81c 0000  	movw r[28], acc;		;		;				| 
   134c  05 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;				| 
   134d  05 45 e 0 0 811c 0500  	xorw r[28], acc, acc;	0x500->scrmemp; ;				| Get ready to get clipping rectangle.
   134e  05 49 e 0 0 d8d0 0500  	movw d, r[16];	0x500->am;	;				| 
   134f  01 49 e 0 0 e2c1 000a  	andw,s d, acc, acc;	0xa->am;	;				| 
   1350  05 00 3 8 0 d91a 1352  	movw 0, r[26];		;		cjp, ~zer vtr;			| 
   1351  05 00 e 0 0 dd1a 0000  	incw 0, r[26];		;		;				| 
                                |   code will return to vtr (through vreset) after each r[23] rectangle.
   1352  01 00 e 0 0 d857 0000  vtr:	 movw,s r[23], y;		;		;				| If no clipping, return from end of module (vreset)
   1353  01 59 3 0 4 d8d3 135c  	movw,s d, r[19];	scrmem->am;	cjp, zer vtrnclip;	scrmp +	| Transform screen coords to pixrect relative.
   1354  0d 00 a 1 0 9e0f 0000  	subw d, r[15], r[15];		;		crtn, neg;			| Neg == end of r[23] list.
   1355  05 00 e 0 0 9e0d 0000  	subw d, r[13], r[13];		;		;				| 
   1356  05 59 e 0 4 d8d4 0000  	movw d, r[20];	scrmem->am;	;			scrmp +	| 
   1357  05 00 e 0 0 9e0e 0000  	subw d, r[14], r[14];		;		;				| 
   1358  05 00 e 0 0 9e0c 0000  	subw d, r[12], r[12];		;		;				| 
   1359  05 59 e 0 4 d8d1 0000  	movw d, r[17];		scrmem->am;	;			scrmp +	| 
   135a  05 59 e 0 4 d8d2 0000  	movw d, r[18];		scrmem->am;	;			scrmp +	| 
   135b  15 00 3 0 0 c5d0 1360  	add2nw 2, r[16], r[16]; ;		cjp, go vtrstat;		| 
   135c  05 00 e 0 0 d913 0000  vtrnclip: movw 0, r[19];	;		;				| 
   135d  05 00 e 0 0 d914 0000  	movw 0, r[20];	;		;				| 
   135e  05 49 e 0 0 d8d1 0400  	movw d, r[17];		 1024->am;	;				| 
   135f  05 49 e 0 0 d8d2 0400  	movw d, r[18];		 1024->am;	;				| 
   1360  05 41 e 0 0 f8c1 0000  vtrstat: movw d, acc;		vstreg->am;	;				| Clear vme status register.
                                |   Handle vectors of length 1 or 2 by drawing endpoints.  Check first for short vector.
   1361  01 44 e 0 0 dc0b 1382  	incw,s r[11], acc;		=vnshrt->brreg;	;				| Compare absolute value r[11] with 1.
                                |   Incw takes care of r[11] == -1.  Thus we compare with 2.
   1362  09 49 3 1 0 e240 0002  	rsubw,s d, acc, y;	2->am;		cjp, neg;			| vector is not short.
   1363  09 00 3 1 0 dc0a 0000  	incw,s r[10], acc;		;		cjp, neg;			| 
   1364  09 49 3 1 0 e240 0002  	rsubw,s d, acc, y;	2->am;		cjp, neg;			| 
   1365  09 44 3 1 0 e7f8 14c2  	btstw,s 3,r[24]; =vropset1->brreg; cjp, neg;			| 
   1366  01 00 3 8 0 d85a 136c  	 movw,s r[26], y;		;		cjp, ~zer vsdraw;		| Jump if no rasterop setup nec.
   1367  05 00 3 f 0 f8e0 1367  	movw 0x73,y;		;		cjp, ~vir .;			| 
   1368  15 14 1 0 0 0073 14c0  	;			am->vctlreg;	cjs, go vropseta;		| Set up rasterop chips.
   1369  05 00 e 0 0 b1db 0000  vsropdone: romw 8, r[27], acc, 0xff00; ;	;				| instruction completes on next cycle.
   136a  05 53 e 0 0 ff00 8802  	;			0x8802->vloareg; ;			| vhiareg unchanged.
   136b  05 0d 3 f 7 f880 136b  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   136c  05 00 3 f 0 7140 136c  vsdraw:	;			;		cjp, ~vir .;			| must set rop chips after short.
   136d  01 54 e 0 0 d80f 0060  	movw,s r[15], acc;		0x60->vctlreg;	;				| 
   136e  01 00 3 1 0 9011 1376  	subw,s r[17], acc, y;	;		cjp, neg vschk2;		| if (pos0.x >= size.x) check 2nd endpoint.
   136f  01 00 3 9 0 d80e 1376  	movw,s r[14], acc;		;		cjp, ~neg vschk2;		| 
   1370  01 00 3 1 0 9012 1376  	subw,s r[18], acc, y;	;		cjp, neg vschk2;		| if (pos0.y >= size.y) 
   1371  05 00 3 9 0 d814 1376  	movw r[20], acc;	;		cjp, ~neg vschk2;		| first endpt clipped out.
   1372  14 00 1 0 2 988e 11c3  	addw r[14], acc, r[2]; ;		cjs, go MulSWid;		| cg2_roppixel (dmd, pos0.x, pos0.y)
   1373  05 00 e 0 0 d813 0000  	movw r[19], acc;	;		;				| 
   1374  15 00 1 0 0 808f 14ee  	addw r[15], acc, acc;	;		cjs, go vcompvme;		| 
   1375  05 0d 3 f 7 d85b 1375  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1376  05 00 e 0 0 d80b 0000  vschk2:	movw r[11], acc;		;		;				| 
   1377  01 00 e 0 0 914a 0000  	orw,s r[10],acc,y;		;		;				| 
   1378  01 00 3 0 0 d80d 14b7  vschk2a: movw,s r[13], acc;	;		cjp, zer vreset;		| 
   1379  01 00 3 1 0 9011 14b7  	subw,s r[17], acc, y;	;		cjp, neg vreset;		| if (pos1.x >= size.x)2nd endpt clipped.
   137a  01 00 3 9 0 d80c 14b7  	movw,s r[12], acc;		;		cjp, ~neg vreset;		| 
   137b  01 00 3 1 0 9012 14b7  	subw,s r[18], acc, y;	;		cjp, neg vreset;		| if (pos1.y >= size.y)2nd endpt clipped.
   137c  05 00 3 9 0 d814 14b7  	movw r[20], acc;	;		cjp, ~neg vreset;		| 
   137d  14 00 1 0 2 988c 11c3  	addw r[12], acc, r[2]; ;		cjs, go MulSWid;		| cg2_roppixel (dmd, pos1.x, pos1.y)
   137e  05 00 e 0 0 d813 0000  	movw r[19], acc;	;		;				| 
   137f  15 00 1 0 0 808d 14ee  	addw r[13], acc, acc;	;		cjs, go vcompvme;		| 
   1380  05 0d 3 f 7 d85b 1380  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1381  15 00 3 0 0 7140 14b7  	;			;		cjp, go vreset;			| 
                                |   Not a short vector.  Force vector to have increasing x.
                                |   Limits number of octants to 4.
   1382  01 00 e 0 0 d84b 0000  vnshrt:	 movw,s r[11], y;		;		;				| Test r[11].
   1383  05 00 3 9 0 d916 138c  	movw 0, r[22];	;		cjp, ~neg vnoswap;		| r[22]= 0.
   1384  05 00 e 0 0 d80f 0000  	movw r[15], acc;		;		;				| 
   1385  04 00 e 0 f d96d 0000  	movw r[13], r[15];		;		;				| Swap x.
   1386  05 00 e 0 0 d88d 0000  	movw acc, r[13];		;		;				| 
   1387  05 00 e 0 0 d80e 0000  	movw r[14], acc;		;		;				| Swap y.
   1388  04 00 e 0 e d96c 0000  	movw r[12], r[14];		;		;				| 
   1389  05 00 e 0 0 d88c 0000  	movw acc, r[12];		;		;				| 
   138a  05 00 e 0 0 df6b 0000  	negw r[11], r[11];		;		;				| r[11]= -r[11].
   138b  05 00 e 0 0 df6a 0000  	negw r[10], r[10];		;		;				| r[10]= -r[10].
                                |   Clipper works with y positive going. If needed, r[22]
                                |   vector around the centerline.  Remember this in the r[22]
                                |   variable so it can be undone later.
   138c  01 00 e 0 0 d84a 0000  vnoswap: movw,s r[10], y;		;		;				| 
   138d  01 00 3 9 0 d84c 1393  	 movw,s r[12], y;		;		cjp, ~neg vbound;		| Set r[12] cc for vbound
   138e  05 00 e 0 0 df6a 0000  	negw r[10], r[10];		;		;				| 
   138f  05 49 e 0 0 8612 0001  	subw d, r[18], acc;	1->am;		;				| size.y-1
   1390  05 00 e 0 0 980e 0000  	subw r[14], acc, r[14];	;		;				| pos0.y= (size.y-1) - pos0.y.
   1391  01 00 e 0 0 980c 0000  	subw,s r[12], acc, r[12];	;		;				| pos1.y= (size.y-1) - pos1.y.
   1392  05 49 e 0 0 9e96 0002  	addw d, r[22], r[22];2->am;		;				| r[22] += 2
                                |   Bounds check for vector ending before rectangle or starting after.
   1393  01 00 3 1 0 d84d 14b7  vbound:	 movw,s r[13], y;		;		cjp, neg vreset;		| if (pos1.y < 0 || pos1.x < 0)
   1394  05 00 3 1 0 d80f 14b7  	movw r[15], acc;		;		cjp, neg vreset;		| 
   1395  01 00 e 0 0 9011 0000  	subw,s r[17], acc, y;	;		;				| || pos0.x >= size.x
   1396  05 00 3 9 0 d80e 14b7  	movw r[14], acc;		;		cjp, ~neg vreset;		| 
   1397  01 00 e 0 0 9012 0000  	subw,s r[18], acc, y;	;		;				| || pos0.y >= size.y
                                |   If vector horizontal use fast algorithm.
   1398  01 00 3 9 0 d84a 14b7  vhor:	 movw,s r[10], y;		;		cjp, ~neg vreset;		| 
   1399  01 00 3 8 0 d80b 1414  	movw,s r[11], acc;		;		cjp, ~zer vvert;		| Set cc for vert test.
   139a  05 12 3 f 0 d85e 139a  	movw r[30],y;		am->vhiareg;	cjp, ~vir .;			| Wait till vctlreg ready.
   139b  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   139c  05 45 e 0 0 7140 01c0  	;			0x1c0->scrmemp; ;				| 
   139d  01 59 e 0 0 961c 0000  	subw,s d, r[28], y;	scrmem->am;	;				| 
   139e  05 0a 3 0 4 d85c 13a1  	movw r[28], y;		am->scrmem;	cjp, zer vhpatt0;	scrmp +	| 
   139f  05 53 e 0 0 7140 800e  	;			 0x800e->vloareg;;			| vhiareg unchanged.
   13a0  05 0d 3 f 7 d85c 13a0  	movw r[28], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setfunction (..., r[28]).
   13a1  05 53 e 0 0 7140 8006  vhpatt0: ;			 0x8006->vloareg; ;			| vhiareg unch.
   13a2  01 59 e 0 0 f8c0 0000  	movw,s d, y;		scrmem->am;	;				| 
   13a3  05 0a 3 0 4 f900 13a5  	movw 0, y;		am->scrmem;	cjp, zer vhpatt1;	scrmp +	| 
   13a4  05 0d 3 f 7 f900 13a4  	movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   13a5  01 09 e 0 0 d84f 0000  vhpatt1:  movw,s r[15], y;		am->am;		;				| if (pos0.x >= 0)
   13a6  05 00 3 9 0 d811 13a8  	movw r[17], acc;	;		cjp, ~neg vhx1;			| 
   13a7  05 09 e 0 0 d90f 0000  	movw 0, r[15];		am->am;		;				| pos0.x= 0
   13a8  01 00 e 0 0 904d 0000  vhx1:	rsubw,s r[13], acc, y;	;		;				| if (pos1.x >= size.x)
   13a9  05 00 3 1 0 e185 13ab  	sub2nw 0, acc;		;		cjp, neg vhdx;			| pos1.x= size.x - 1
   13aa  15 00 3 0 0 d88d 13ac  	movw acc, r[13];		;		cjp, go vhdx1;			| 
   13ab  05 00 e 0 0 d80d 0000  vhdx:	movw r[13], acc;		;		;				| 
   13ac  04 00 e 0 b 9e0d 0000  vhdx1:	subw d, r[13], r[11];		;		;				| r[11]= pos1.x - pos0.x
   13ad  05 59 e 0 0 d8c0 0000  	movw d, r[0];		scrmem->am;	;				| 
   13ae  05 53 e 0 0 8093 800a  	addw r[19], acc, acc;	0x800a->vloareg;;			| cg2_prd_skew (dmd, pos1.x). vhiareg unchanged.
   13af  05 49 e 0 0 c2c5 000f  	andw d, acc, r[5];	0xf->am;	;				| r[5]= cg2_prd_skew
   13b0  05 49 e 0 0 8685 01b0  	addw d, r[5], acc;	0x1b0->am;	;				| rmasktable [r[5]]
   13b1  05 05 e 0 0 f880 0000  	movw acc, y;		am->scrmemp;	;				| 
   13b2  01 59 e 0 0 9600 0000  	subw,s d, r[0], y ;	scrmem->am;	;				| 
   13b3  05 00 3 0 0 d80f 13b8  	movw r[15], acc;		;		cjp, zer vhm1;			| 
   13b4  05 59 e 0 0 d8c0 0000  	movw d, r[0];		scrmem->am;	;				| 
   13b5  05 45 e 0 0 7140 01c2  	;			 0x1c2->scrmemp; ;				| 
   13b6  05 0a e 0 0 d840 0000  	movw r[0], y;		am->scrmem;	;				| 
   13b7  05 0d 3 f 7 d840 13b7  	movw r[0], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   13b8  05 53 e 0 0 8093 8008  vhm1:	addw r[19], acc, acc;	0x8008->vloareg; ;			| cg2_prd_skew (dmd, pos0.x) vhiareg unchanged.
   13b9  05 49 e 0 0 c2c5 000f  	andw d, acc, r[5];	0xf->am;	;				| r[5]= cg2_prd_skew
   13ba  05 49 e 0 0 8685 01a0  	addw d, r[5], acc;	0x1a0->am;	;				| 
   13bb  05 05 e 0 0 f880 0000  	movw acc, y;		am->scrmemp;	;				| 
   13bc  05 59 e 0 0 d8c0 0000  	movw d, r[0];		scrmem->am;	;				| 
   13bd  05 45 e 0 0 7140 01c3  	;			 0x1c3->scrmemp; ;				| 
   13be  01 59 e 0 0 9600 0000  	subw,s d, r[0], y;	scrmem->am;	;				| 
   13bf  05 0a 3 0 4 d840 13c1  	movw r[0], y;		am->scrmem;	cjp, zer vhrm;		scrmp +	| 
   13c0  05 0d 3 f 7 d840 13c0  	movw r[0], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   13c1  01 49 e 0 0 d85a 0004  vhrm:	 movw,s r[26], y;		4->am;	;				| 
   13c2  05 00 3 8 0 d8d5 13c4  	movw d, r[21];	;		cjp, ~zer vhropmode;		| if (r[26]) r[21]= 4
   13c3  05 49 e 0 0 d8d5 0006  	movw d, r[21];	6->am;	;				| else r[21]= 6
   13c4  05 49 e 0 0 f8c1 0006  vhropmode:movw d, acc;		6->am;	;				| 
   13c5  15 00 1 0 0 7140 14e7  	;			;		cjs, go vropmode;		| 
   13c6  05 00 e 0 0 d80b 0000  	movw r[11], acc;		;		;				| r[5]= (r[11]+r[5])>>4.  (>>4 == <<12).
   13c7  05 49 e 0 0 9885 0fff  	addw r[5], acc, r[5];	0xfff->am;	;				| 
   13c8  05 53 e 0 0 99e5 8010  	rolw 12, r[5], r[5];	0x8010->vloareg;;			| vhiareg unchanged.  mask off high bits of rotate.
   13c9  05 00 e 0 0 9ec5 0000  	andw d, r[5], r[5];	;		;				| 
   13ca  01 59 e 0 0 9605 0000  	subw,s d, r[5], y;	scrmem->am;	;				| 
   13cb  05 0a 3 0 4 d845 13cd  	movw r[5], y;		am->scrmem;	cjp, zer vhcnt;		scrmp +	| 
   13cc  05 0d 3 f 7 d845 13cc  	movw r[5], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 1st 1/2 cg2_setwidth (..., r[5], r[5]).
   13cd  05 53 e 0 0 7140 8012  vhcnt:	;			0x8012->vloareg; ;			| vhiareg unchanged.
   13ce  01 59 e 0 0 9605 0000  	subw,s d, r[5], y;	scrmem->am;	;				| 
   13cf  05 0a 3 0 4 d845 13d1  	movw r[5], y;		am->scrmem;	cjp, zer vhsh;		scrmp +	| 
   13d0  05 0d 3 f 7 d845 13d0  	movw r[5], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 2nd 1/2 cg2_setwidth (..., r[5], r[5]).
   13d1  05 53 e 0 0 7140 800c  vhsh:	;			0x800c->vloareg; ;			| vhiareg unchanged.
   13d2  01 59 e 0 0 f195 0000  	sub2nw,s 8, d, y;	scrmem->am;	;				| 
   13d3  05 0a 3 0 4 f196 13d5  	mov2nw 8, y;		am->scrmem;	cjp, zer vhsrc2a;	scrmp +	| 
   13d4  05 0d 3 f 7 f196 13d4  	mov2nw 8, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setshift (..., 0, 1).
   13d5  05 00 e 0 0 d81b 0000  vhsrc2a: movw r[27], acc;	;		;				| 
   13d6  05 00 e 0 0 b1db 0000  	romw 8, r[27], acc, 0xff00;;		;				| instruction completes on next cycle.
   13d7  05 53 e 0 0 ff00 8804  	;			0x8804->vloareg;;			| vhiareg unchanged.
   13d8  05 0d 3 f 7 f880 13d8  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   13d9  05 00 e 0 0 d814 0000  	movw r[20], acc;	;		;				| 
   13da  14 00 1 0 2 988e 11c6  	addw r[14], acc, r[2];;		cjs, go MulSWWid;		| cg2_ropword (dmd, 0, pos0.x, pos0.x)
   13db  05 00 e 0 0 d813 0000  	movw r[19], acc;	;		;				| 
   13dc  05 00 e 0 0 988f 0000  	addw r[15], acc, r[15];	;		;				| 
   13dd  05 00 e 0 0 9b8f 0000  	rolw 13, r[15], acc;	;		;				| cg2_ropword: (x>>4)*(sizeof(short))
   13de  05 49 e 0 0 e2c1 1fff  	andw d, acc, acc;	0x1fff->am;	;				| a5_adr= cg2_ropword	
   13df  05 13 e 0 0 9880 0000  	addw r[0], acc, r[0];am->vloareg;	;				| 
   13e0  05 49 e 0 0 86bf 0020  	addcw d, r[31], acc;	0x20->am;	;				| 
   13e1  05 12 e 0 0 9881 0000  	addw r[1], acc, r[1];am->vhiareg;	;				| 
                                |   switch (d5_count) unwrapped.  r[26] part separated out.
   13e2  01 00 e 0 0 d85a 0000  vhcolor: movw,s r[26], y;		;		;				| 
   13e3  05 04 3 8 0 d845 13e9  	movw r[5], y;		am->brreg;	cjp, ~zer vhnodst;		| 
   13e4  1d 00 4 0 0 7140 0000  	;			;		push, go;			| 
   13e5  05 0d 3 f 7 d85b 13e5  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| value written is immaterial.
   13e6  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   13e7  0d 00 8 0 1 7140 0000  	;			;		rfct;			varegs +| 
   13e8  15 00 3 0 0 e7d8 14b7  	bclrw 3,r[24];	;		cjp, go vreset;			| Must setup rop chips after hor.
   13e9  01 49 e 0 0 9605 0002  vhnodst:subw,s d, r[5], y;	2->am;		;				| 
   13ea  01 00 3 9 0 d845 13f0  	 movw,s r[5], y;		;		cjp, ~neg vh2;			| 
   13eb  05 0d 3 f 7 d85b 13eb  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   13ec  05 00 3 0 1 e7d8 14b7  	bclrw 3,r[24];	;		cjp, zer vreset;	varegs +| Must setup rop chips after hor.
   13ed  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   13ee  05 00 3 f 7 7140 13ee  	;			;		cjp, ~vir .;		vmewr	| 
   13ef  15 00 3 0 0 7140 14b7  	;			;		cjp, go vreset;			| 
   13f0  05 12 e 0 0 d85e 0000  vh2:	movw r[30], y;		am->vhiareg;	;				| 
   13f1  05 53 e 0 0 e386 8010  	mov2nw 1, acc;		0x8010->vloareg; ;			| 
   13f2  05 45 e 0 0 7140 01c4  	;			0x1c4->scrmemp; ;				| 
   13f3  01 59 e 0 0 e395 0000  	sub2nw,s 1, d, y;	scrmem->am;	;				| 
   13f4  05 0a 3 0 4 e396 13f6  	mov2nw 1, y;		am->scrmem;	cjp, zer vhcnt1;	scrmp +	| 
   13f5  05 0d 3 f 7 f880 13f5  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 1st 1/2 cg2_setwidth (..., 2, 2).
   13f6  05 53 e 0 0 7140 8012  vhcnt1:	;			0x8012->vloareg; ;			| vhiareg unchanged.
   13f7  01 59 e 0 0 e395 0000  	sub2nw,s 1, d, y;	scrmem->am;	;				| 
   13f8  05 0a 3 0 4 e396 13fa  	mov2nw 1, y;		am->scrmem;	cjp, zer vhcol0;	scrmp +	| 
   13f9  05 0d 3 f 7 f880 13f9  vhcount1:movw acc, y;		am->vwdreg;	cjp, ~vir vhcount1;	vmewr	| 2nd 1/2 cg2_setwidth (..., 2, 2).
   13fa  05 13 e 0 0 d840 0000  vhcol0:	movw r[0], y;		am->vloareg;	;				| 
   13fb  05 12 e 0 0 d841 0000  	movw r[1], y;		am->vhiareg;	;				| 
   13fc  05 0d 3 f 7 d85b 13fc  vhcol1:	movw r[27], y;		am->vwdreg;	cjp, ~vir vhcol1;	vmewr	| *(a5_adr)++= d3_color (value is immaterial)
   13fd  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   13fe  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   13ff  05 00 3 f 7 7140 13ff  vhcol2:;			;		cjp, ~vir vhcol2;	vmewr	| *(a5_adr)++= d3_color (value is immaterial)
   1400  01 49 e 0 1 9e05 0003  	subw,s d, r[5], r[5];	3->am;		;			varegs +| r[5] less 3 so "fastloop" right num
   1401  05 00 3 1 1 7140 1412  	;			;		cjp, neg vhvmewr3;	varegs +| 
   1402  15 00 1 0 0 d815 14e7  	movw r[21], acc;	;		cjs, go vropmode;		| 
   1403  01 49 e 0 0 9e80 0004  	addw,s d, r[0], r[0];4->am;		;				| Sync r[0] with vme addr counter.
   1404  05 13 3 a 0 d840 1406  	movw r[0], y;		am->vloareg;	cjp, ~cry vhncry1;		| 
   1405  05 00 e 0 0 dd61 0000  	incw r[1], r[1];	;		;				| Sync r[1] with vme addr counter.
   1406  05 04 e 0 0 d845 0000  vhncry1:movw r[5], y;		am->brreg;	;				| Get ready to load counter.
   1407  1d 12 4 0 0 d841 0000  	movw r[1], y;		am->vhiareg;	push, go;			| 
   1408  05 0d 3 f 7 d85b 1408  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| (value is immaterial)
   1409  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   140a  0d 49 8 0 1 7140 0006  	;			6->am;	rfct;			varegs +| 
   140b  15 00 1 0 0 f8c1 14e7  	movw d, acc;		;		cjs, go vropmode;		| 
   140c  04 00 e 0 4 cc05 0000  	sl0w r[5], r[4];	;		;				| 
   140d  01 49 e 0 0 8684 0002  	addw,s d, r[4], acc;	2->am;		;				| 
   140e  01 13 3 a 0 9880 1410  	addw,s r[0], acc, r[0];am->vloareg;	cjp, ~cry vhvmewr2;		| 
   140f  05 00 e 0 0 dc41 0000  	incw r[1], y;		;		;				| 
   1410  05 12 3 a 0 d841 1412  vhvmewr2:movw r[1], y;	am->vhiareg;	cjp, ~cry vhvmewr3;		| 
   1411  05 12 e 0 0 dc41 0000  	incw r[1], y;		am->vhiareg;	;				| 
   1412  05 0d 3 f 7 f900 1412  vhvmewr3: movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| (value is immaterial)
   1413  15 00 3 0 0 e7d8 14b7  	bclrw 3,r[24];	;		cjp, go vreset;			| 
                                |   If vector is vertical use fast algorithm.
   1414  01 00 3 8 0 e7f8 1430  vvert:	btstw,s 3,r[24]; ;		cjp, ~zer vdxdy;		| Jump if r[11] != 0 (cc set earlier).
   1415  05 00 3 8 0 7140 141a  	;			;		cjp, ~zer vvclip;		| Jump if no rasterop chip setup nec.
   1416  15 00 1 0 0 7140 14bf  	;			;		cjs, go vropset;		| Set up rasterop chips.
   1417  05 00 e 0 0 b1db 0000  vvropdone: romw 8, r[27], acc, 0xff00; ;	;				| instruction completes on next cycle.
   1418  05 53 e 0 0 ff00 8802  	;			0x8802->vloareg;;			| vhiareg unchanged.
   1419  05 0d 3 f 7 f880 1419  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   141a  01 00 e 0 0 d84e 0000  vvclip:	 movw,s r[14], y;		;		;				| Test (pos0.y < 0)
   141b  05 00 3 9 0 d80c 141d  	movw r[12], acc;		;		cjp, ~neg vvclip1;		| 
   141c  05 00 e 0 0 d90e 0000  	movw 0, r[14];		;		;				| if (pos0.y < 0) pos0.y= 0.
   141d  01 49 e 0 0 9012 0001  vvclip1: subw,s r[18], acc, y;	1->am;		;				| if (pos1.y >= size.y)
   141e  05 00 3 1 0 8612 1420  	subw d, r[18], acc;	;		cjp, neg vvclip2;		| pos1.y= size.y - 1.
   141f  15 00 3 0 0 d88c 1421  	movw acc, r[12];		;		cjp, go vvclip3;		| 
   1420  05 00 e 0 0 d80c 0000  vvclip2:movw r[12], acc;		;		;				| 
   1421  04 44 e 0 a 980e 1425  vvclip3: subw r[14], acc, r[10];	=vvnorefl->brreg; ;				| r[10]= pos1.y - pos0.y
   1422  01 49 e 0 0 96d6 0002  	andw,s d, r[22], y;	2->am;		;				| if (r[22] & 2)
   1423  0d 49 3 0 0 8612 0001  	subw d, r[18], acc;	1->am;		cjp, zer;			| size.y - 1
   1424  04 00 e 0 e 980c 0000  	subw r[12], acc, r[14];	;		;				| pos0.y= size.y - 1 - pos1.y.
   1425  05 00 3 f 0 d814 1425  vvnorefl:movw r[20], acc;	;		cjp, ~vir vvnorefl;		| 
   1426  14 00 1 0 2 988e 11c3  	addw r[14], acc, r[2];;		cjs, go MulSWid;		| cg2_roppixel (dmd, pos0.x, pos0.y)
   1427  05 54 e 0 0 d813 0060  	movw r[19], acc;	0x60->vctlreg;	;				| 
   1428  15 00 1 0 0 808f 14ee  	addw r[15], acc, acc;	;		cjs, go vcompvme;		| cg2_roppixel
   1429  05 04 e 0 0 d84a 0000  	movw r[10], y;		am->brreg;	;				| Prepare to load counter.
   142a  05 49 e 0 0 f8c1 0400  	movw d, acc;		 1024->am;	;				|   1024= cg2_linebytes.
   142b  1d 09 4 0 0 f900 0000  	movw 0, y;		am->am;		push, go;			| Push loop, ld cntr.
   142c  05 0d 3 f 7 d85b 142c  vvvmewr:movw r[27], y;		am->vwdreg;	cjp, ~vir vvvmewr;	vmewr	| cg2_vertln ().
   142d  05 13 e 0 0 9880 0000  	addw r[0], acc, r[0];am->vloareg;	;				| 
   142e  0d 12 8 0 0 9ea1 0000  	addcw d, r[1], r[1];am->vhiareg;	rfct;				| 
   142f  15 00 3 0 0 7140 14b7  	;			;		cjp, go vreset;			| 
                                |   One more reflection. Note that r[11] in acc from horizontal test.
   1430  01 00 e 0 0 900a 0000  vdxdy:	subw,s r[10], acc, y;	;		;				| 
   1431  05 00 3 9 0 d80f 143d  	movw r[15], acc;		;		cjp, ~neg viniterr;		| if (r[11] < r[10]) swap (r[15], r[14])
   1432  04 00 e 0 f d96e 0000  	movw r[14], r[15];		;		;				| 
   1433  05 00 e 0 0 d88e 0000  	movw acc, r[14];		;		;				| 
   1434  05 00 e 0 0 d80d 0000  	movw r[13], acc;		;		;				| Swap (r[13], r[12])
   1435  04 00 e 0 d d96c 0000  	movw r[12], r[13];		;		;				| 
   1436  05 00 e 0 0 d88c 0000  	movw acc, r[12];		;		;				| 
   1437  04 00 e 0 b d96a 0000  	movw r[10], r[11];		;		;				| r[10] = r[11]
   1438  04 00 e 0 a 980e 0000  	subw r[14], acc, r[10];	;		;				| Recompute r[10] (saves a cycle).
   1439  05 00 e 0 0 d811 0000  	movw r[17], acc;	;		;				| Swap (size.x, size.y).
   143a  04 00 e 0 1 d972 0000  	movw r[18], r[17];	;		;				| 
   143b  05 00 e 0 0 d892 0000  	movw acc, r[18];	;		;				| Swap complete.
   143c  05 00 e 0 0 dd76 0000  	incw r[22], r[22];	;		;				| r[22] += 1.
   143d  04 00 e 0 8 cc8b 0000  viniterr:sr0w r[11], r[8];		;		;				| initerror= -(r[11] >> 1).
   143e  01 00 e 0 0 df68 0000  	negw,s r[8], r[8];	;		;				| 
   143f  05 00 3 a 0 db09 1441  	compw 0, r[9];		;		cjp, ~cry vierr1;		| 
   1440  05 00 e 0 0 dd69 0000  	incw r[9], r[9];	;		;				| 
   1441  00 00 e 0 7 d96f 0000  vierr1:	movw,s r[15], r[7];	;		;				| start= pos0. 
   1442  04 00 e 0 6 d96e 0000  	movw r[14], r[6];	;		;				| 
   1443  05 00 3 9 0 de07 1457  	negw r[7], acc;	;		cjp, ~neg vadvy;		| initerr += -start.x * r[10].
   1444  14 00 1 0 2 d96a 116f  	movw r[10], r[2];	;		cjs, go multiply;		| pr_product
   1445  05 00 e 0 0 d801 0000  	movw r[1], acc;	;		;				| double precision add.
   1446  05 09 e 0 0 d840 0000  	movw r[0], y;		am->am;		;				| 
   1447  05 00 e 0 0 9e88 0000  	addw d, r[8], r[8];	;		;				| 
   1448  05 00 e 0 0 98a9 0000  	addcw r[9], acc, r[9];;		;				| 
   1449  05 00 e 0 0 d907 0000  	movw 0, r[7];		;		;				| start.x= 0.
   144a  04 09 e 0 4 c1eb 0000  	sub2nw 0, r[11], r[4];		am->am;		;				| r[5]= (initerr + (r[11]-1)) / r[11].
   144b  04 00 e 0 0 9e88 0000  	addw d, r[8], r[0];	;		;				| double precision add.
   144c  04 49 e 0 1 9ea9 0000  	addcw d, r[9], r[1];	0->am;		;				| 
   144d  15 00 1 0 0 d80b 11e0  	movw r[11], acc;		;		cjs, go divlong;		| 
   144e  04 00 e 0 5 d962 0000  	movw r[2], r[5];	;		;				| 
   144f  05 00 e 0 0 d806 0000  	movw r[6], acc;	;		;				| 
   1450  04 00 e 0 6 9885 0000  	addw r[5], acc, r[6];;		;				| start.y += r[5].
   1451  05 00 e 0 0 d805 0000  	movw r[5], acc;	;		;				| initerr -= r[5] * r[11].
   1452  14 00 1 0 2 d96b 116f  	movw r[11], r[2];	;		cjs, go multiply;		| pr_product
   1453  05 09 e 0 0 d841 0000  	movw r[1], y;		am->am;		;				| 
   1454  05 00 e 0 0 d800 0000  	movw r[0], acc;	;		;				| 
   1455  05 00 e 0 0 9848 0000  	rsubw r[8], acc, r[8];	;		;				| 
   1456  05 00 e 0 0 9e29 0000  	subcw d, r[9], r[9];	;		;				| 
   1457  05 00 e 0 0 d806 0000  vadvy:	movw r[6], acc;	;		;				| 
   1458  01 00 e 0 0 9012 0000  	subw,s r[18], acc, y;	;		;				| if (start.y >= size.y)
   1459  00 00 3 9 2 d966 14b7  	movw,s r[6], r[2]; ;		cjp, ~neg vreset;		| if (start.y < 0)...
   145a  05 00 3 9 0 d80d 1473  	movw r[13], acc;		;		cjp, ~neg vcliprt;		| initerr += start.y * r[11].
   145b  15 00 1 0 0 d80b 116f  	movw r[11], acc;	;		cjs, go multiply;		| pr_product
   145c  05 00 e 0 0 d800 0000  	movw r[0], acc;	;		;				| double precision add.
   145d  05 09 e 0 0 d841 0000  	movw r[1], y;		am->am;		;				| 
   145e  05 00 e 0 0 9888 0000  	addw r[8], acc, r[8];	;		;				| 
   145f  05 00 e 0 0 9ea9 0000  	addcw d, r[9], r[9];	;		;				| 
   1460  05 00 e 0 0 d906 0000  vadvy1:	movw 0, r[6];		;		;				| start.y= 0.
   1461  05 00 e 0 0 d80a 0000  	movw r[10], acc;		;		;				| 
   1462  01 00 e 0 0 800b 0000  	subw,s r[11], acc, acc;	;		;				| r[5]= ((r[10]-r[11])-initerr) / r[10].
   1463  05 09 3 9 0 f900 1465  	movw 0, y;		am->am;		cjp, ~neg vadvy1a;		| d and acc (low) form (r[10]-r[11]).
   1464  05 09 e 0 0 fb00 0000  	compw 0, y;		am->am;		;				| 
   1465  04 00 e 0 0 9808 0000  vadvy1a:subw r[8], acc, r[0];	;		;				| double precision subtract.
   1466  04 00 e 0 1 9e69 0000  	rsubcw d, r[9], r[1];	;		;				| 
   1467  15 00 1 0 0 d80a 11e0  	movw r[10], acc;		;		cjs, go divlong;		| 
   1468  04 09 e 0 5 d962 0000  	movw r[2], r[5];	am->am;		;				| 
   1469  05 00 e 0 0 9e87 0000  	addw d, r[7], r[7];	;		;				| start.x += r[5].
   146a  05 00 e 0 0 d80a 0000  	movw r[10], acc;	;		;				| initerr += r[5] * r[10].
   146b  14 00 1 0 2 d965 116f  	movw r[5], r[2];	;		cjs, go multiply;		| pr_product
   146c  05 00 e 0 0 d800 0000  	movw r[0], acc;	;		;				| double precision add.
   146d  05 09 e 0 0 d841 0000  	movw r[1], y;		am->am;		;				| 
   146e  05 00 e 0 0 9888 0000  	addw r[8], acc, r[8];	;		;				| 
   146f  05 00 e 0 0 9ea9 0000  	addcw d, r[9], r[9];	;		;				| 
   1470  05 00 e 0 0 d807 0000  vadvy3:	movw r[7], acc;	;		;				| 
   1471  01 00 e 0 0 9011 0000  	subw,s r[17], acc, y;	;		;				| if (r[7] >= size.x)...
   1472  05 00 3 9 0 d80d 14b7  	movw r[13], acc;		;		cjp, ~neg vreset;		| 
   1473  01 49 e 0 0 9011 0001  vcliprt: subw,s r[17], acc, y;	1->am;		;				| if (pos1.x >= size.x)...
   1474  05 00 3 1 0 8611 1480  	subw d, r[17], acc;	;		cjp, neg vlasty;		| pos1.x= size.x - 1.
   1475  05 00 e 0 0 d88d 0000  	movw acc, r[13];		;		;				| 
   1476  05 00 e 0 0 800f 0000  	subw r[15], acc, acc;	;		;				| (size.x-1) - pos0.x
   1477  14 00 1 0 2 d96a 116f  	movw r[10], r[2];	;		cjs, go multiply;		| pr_product (..., r[10]).
   1478  04 09 e 0 4 cc8b 0000  	sr0w r[11], r[4];		am->am;		;				| acc= (r[11] - r[11]>>1 - 1).  r[4] is junk.
   1479  05 00 e 0 0 860b 0000  	subw d, r[11], acc;	;		;				| 
   147a  05 00 e 0 0 e185 0000  	sub2nw 0, acc;		;		;				| r[11] > 0 so that acc >= 0, and high acc = 0.
   147b  05 00 e 0 0 9880 0000  	addw r[0], acc, r[0];	;		;				| double precision add:  prod + (r[11] - r[11]>>1 - 1).
   147c  05 49 e 0 0 9ea1 0000  	addcw d, r[1], r[1];	0->am;		;				| 
   147d  15 00 1 0 0 d80b 11e0  vcliprt2:movw r[11], acc;		;		cjs, go divlong;		| / r[11]
   147e  05 00 e 0 0 d80e 0000  	movw r[14], acc;		;		;				| 
   147f  04 00 e 0 c 9882 0000  	addw r[2], acc, r[12];	;		;				| pos1.y= pos0.y + (...) / r[11].
   1480  05 00 e 0 0 d80c 0000  vlasty:	movw r[12], acc;		;		;				| 
   1481  01 00 e 0 0 9012 0000  	subw,s r[18], acc, y;	;		;				| if (pos1.y >= size.y)...
   1482  04 09 3 1 5 c1f2 148c  	sub2nw 0, r[18], r[21];	am->am;		cjp, neg vclipdone;		| pos1.y= size.y - 1.  r[21] junk reg for am->am.
   1483  05 00 e 0 0 d8cc 0000  	movw d, r[12];		;		;				| 
   1484  05 00 e 0 0 864e 0000  	rsubw d, r[14], acc;	;		;				| (size.y-1) - pos0.y
   1485  14 00 1 0 2 d96b 116f  	movw r[11], r[2];	;		cjs, go multiply;		| pr_product (..., r[11]).
   1486  04 09 e 0 4 cc8b 0000  	sr0w r[11], r[4];		am->am;		;				| r[11]>>1.  r[4] junk (can't use acc).
   1487  05 00 e 0 0 9e80 0000  	addw d, r[0], r[0];	;		;				| + (r[11]>>1).  double precision add.
   1488  05 49 e 0 0 9ea1 0000  	addcw d, r[1], r[1];	0->am;		;				| 
   1489  15 00 1 0 0 d80a 11e0  vlasty0:movw r[10], acc;		;		cjs, go divlong;		| / r[10].
   148a  05 00 e 0 0 d80f 0000  	movw r[15], acc;		;		;				| 
   148b  04 00 e 0 d 9882 0000  	addw r[2], acc, r[13];	;		;				| pos1.x= pos0.x + (...) / r[10].
   148c  01 00 e 0 0 e7f8 0000  vclipdone: btstw,s 3,r[24]; ;		;				| 
   148d  05 44 e 0 0 d80d 14c2  	movw r[13], acc;		=vropset1->brreg; ;				| Test if rop chips need setup.
   148e  04 00 3 8 5 9807 1493  	subw r[7], acc, r[5]; ;		cjp, ~zer vcolor;		| r[5]= pos1.x-start.x. Jump if chips rop chips ok.
   148f  11 00 1 0 0 d85a 14c0  	 movw,s r[26], y;		;		cjs, go vropseta;		| Set up rasterop chips.
   1490  05 00 e 0 0 b1db 0000  vropdone: romw 8, r[27], acc, 0xff00; ;		;				| instruction completes on next cycle.
   1491  05 53 e 0 0 ff00 8802  	;			0x8802->vloareg;;			| vhiareg unchanged.
   1492  05 0d 3 f 7 f880 1492  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1493  05 0d 3 f 0 d85b 1493  vcolor:	movw r[27], y;		am->vwdreg;	cjp, ~vir .;			| load vwdreg for bresenham loop but don't write.
   1494  01 54 e 0 0 e1f6 0060  	btstw,s 0, r[22];	0x60->vctlreg;	;				| if (r[22] & 1)
   1495  01 00 3 0 0 e3f6 14a7  	btstw,s 1, r[22];	;		cjp, zer vmajx;			| if (r[22] & 2)
   1496  05 00 3 0 0 d811 1499  	movw r[17], acc;	;		cjp, zer vmajy;			| 
   1497  05 00 e 0 0 e185 0000  	sub2nw 0, acc;		;		;				| 
   1498  05 00 e 0 0 9807 0000  	subw r[7], acc, r[7];;		;				| start.x= ((size.x-1) - start.x).
   1499  05 00 e 0 0 d814 0000  vmajy:	movw r[20], acc;	;		;				| 
   149a  14 00 1 0 2 9887 11c3  	addw r[7], acc, r[2];;		cjs, go MulSWid;		| cg2_roppixel (..., start.x).
   149b  05 00 e 0 0 d813 0000  	movw r[19], acc;	;		;				| 
   149c  15 00 1 0 0 8086 14ee  	addw r[6], acc, acc;	;		cjs, go vcompvme;		| cg2_roppixel (..., start.y, ...).
                                |   Bump error so that test in octant is as if it were done after adding r[10].
   149d  05 49 e 0 0 8608 0001  	subw d, r[8], acc;	1->am;		;				| 
   149e  05 00 e 0 0 808a 0000  	addw r[10], acc, acc;	;		;				| We can only directly test r[8] >= 0 not r[8] > 0.
   149f  05 00 e 0 0 d960 0000  	movw r[0], r[0];	;		;				| 
   14a0  05 00 e 0 0 d961 0000  	movw r[1], r[1];	;		;				| 
   14a1  04 09 e 0 3 d96a 0000  	movw r[10], r[3];		am->am;		;				| 
   14a2  04 00 e 0 4 9e4b 0000  	rsubw d, r[11], r[4];	;		;				| 
   14a3  04 00 e 0 2 d965 0000  	movw r[5], r[2];	;		;				| 
   14a4  05 09 e 0 0 d856 0000  	movw r[22], y;	am->am;		;				| 
   14a5  15 00 1 0 0 d8c5 1511  	movw d, r[5];		;		cjs, go octant;			| 
   14a6  15 00 3 0 0 7140 14b7  	;			;		cjp, go vreset;			| 
   14a7  05 00 3 0 0 d812 14aa  vmajx:	movw r[18], acc;	;		cjp, zer vmajx1;		| 
   14a8  05 00 e 0 0 e185 0000  	sub2nw 0, acc;		;		;				| 
   14a9  05 00 e 0 0 9806 0000  	subw r[6], acc, r[6];;		;				| start.x= ((size.x-1) - start.x).
   14aa  05 00 e 0 0 d814 0000  vmajx1:	movw r[20], acc;	;		;				| 
   14ab  14 00 1 0 2 9886 11c3  	addw r[6], acc, r[2];;		cjs, go MulSWid;		| cg2_roppixel (..., start.x).
   14ac  05 00 e 0 0 d813 0000  	movw r[19], acc;	;		;				| 
   14ad  15 00 1 0 0 8087 14ee  	addw r[7], acc, acc;	;		cjs, go vcompvme;		| cg2_roppixel (..., start.y, ...).
                                |   Bump error so that test in octant is as if it were done after adding r[10].
   14ae  05 49 e 0 0 8608 0001  	subw d, r[8], acc;	1->am;		;				| Subtract 2 from error.
   14af  05 00 e 0 0 808a 0000  	addw r[10], acc, acc;	;		;				| We can only directly test r[8] >= 0 not r[8] > 0.
   14b0  05 00 e 0 0 d960 0000  	movw r[0], r[0];	;		;				| 
   14b1  05 00 e 0 0 d961 0000  	movw r[1], r[1];	;		;				| 
   14b2  04 09 e 0 3 d96a 0000  	movw r[10], r[3];		am->am;		;				| 
   14b3  04 00 e 0 4 9e4b 0000  	rsubw d, r[11], r[4];	;		;				| 
   14b4  04 00 e 0 2 d965 0000  	movw r[5], r[2];	;		;				| 
   14b5  05 09 e 0 0 d856 0000  	movw r[22], y;	am->am;		;				| 
   14b6  15 00 1 0 0 d8c5 1511  	movw d, r[5];		;		cjs, go octant;			| 
   14b7  01 45 e 0 0 d857 0190  vreset:	 movw,s r[23], y;		 0x190->scrmemp; ;				| 
   14b8  0d 59 a 0 4 d8cf 0000  	movw d, r[15];		scrmem->am;	crtn, zer;		scrmp +	| if no clipping we are done.
   14b9  05 59 e 0 4 d8ce 0000  	movw d, r[14];		scrmem->am;	;			scrmp +	| 
   14ba  05 59 e 0 4 d8cd 0000  	movw d, r[13];		scrmem->am;	;			scrmp +	| 
   14bb  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];	;		;				| 
   14bc  05 59 e 0 4 d8cc 0000  	movw d, r[12];		scrmem->am;	;			scrmp +	| 
   14bd  04 00 e 0 a 9e4e 0000  	rsubw d, r[14], r[10];	;		;				| 
   14be  15 05 3 0 0 d850 1352  	movw r[16], y;	am->scrmemp;	cjp, go vtr;			| 
                                |   Vropset does the rasterop chip initialization for single pixel fb accesses.  It is called by all but
                                |   the horizontal case for the vector code, and is called in all cases by the textured vector code.
                                |   We return from here with the r[27] in the accumulator.  Note also that the code for vropmode has
                                |   been folded in here to save 2 cycles.
   14bf  01 44 e 0 0 d85a 14c2  vropset:  movw,s r[26], y;		=vropset1->brreg; ;				| 
   14c0  0d 49 3 0 0 f8c1 0003  vropseta: movw d, acc;		3->am;	cjp, zer;			| if PIXOP_NEEDS_DST (r[28]<<1)
   14c1  05 49 e 0 0 f8c1 0001  	movw d, acc;		1->am;	;				| 
   14c2  05 53 e 0 0 e79d 9000  vropset1: rolw 3, acc, acc;	0x9000->vloareg; ;				| Rotate is 3 bits.
   14c3  05 12 3 f 0 d85e 14c3  	movw r[30], y;		am->vhiareg;	cjp, ~vir .;			| wait until vme interface idle
   14c4  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   14c5  05 00 3 f 6 7140 14c5  vropset2: ;			;		cjp, ~vir .;		vmerd	| read status word.
   14c6  05 39 3 f 0 d8c2 14c6  	movw d, r[2];		vrdreg->am;	cjp, ~vir .;			| 
   14c7  05 49 e 0 0 9ec2 ffc7  	andw d, r[2], r[2];	0xffc7->am;	;				| 0x38 is mask to cover 3 bits.
   14c8  05 0d 3 f 7 9942 14c8  	orw r[2], acc, r[2];	am->vwdreg;	cjp, ~vir .;		vmewr	| write status word.
   14c9  05 45 e 0 0 e7b8 01c0  	bsetw 3,r[24];	0x1c0->scrmemp; ;				| 
   14ca  01 59 e 0 0 961c 0000  	subw,s d, r[28], y;	scrmem->am;	;				| 
   14cb  05 0a 3 0 4 d85c 14ce  	movw r[28], y;		am->scrmem;	cjp, zer vrpatt;	scrmp +	| 
   14cc  05 53 e 0 0 7140 800e  	;			 0x800e->vloareg;;			| 
   14cd  05 0d 3 f 7 d85c 14cd  	movw r[28], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setfunction (..., r[28]).
   14ce  05 53 e 0 0 7140 8006  vrpatt:	;			 0x8006->vloareg; ;			| vhiareg unch.  Acc used 2 cycles later
   14cf  01 59 e 0 0 f8c0 0000  	 movw,s d, y;		scrmem->am;	;				| 
   14d0  05 0a 3 0 4 f900 14d2  	movw 0, y;		am->scrmem;	cjp, zer vrmask2;	scrmp +	| 
   14d1  05 0d 3 f 7 f900 14d1  	movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   14d2  05 53 e 0 0 7140 800a  vrmask2: ;			0x800a->vloareg; ;			| vhiareg unchanged.
   14d3  01 59 e 0 0 f8c0 0000  	 movw,s d, y;		scrmem->am;	;				| 
   14d4  05 0a 3 0 4 f900 14d6  	movw 0, y;		am->scrmem;	cjp, zer vrmask1;	scrmp +	| 
   14d5  05 0d 3 f 7 f900 14d5  	movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   14d6  05 53 e 0 0 7140 8008  vrmask1: ;			0x8008->vloareg; ;			| vhiareg unchanged.
   14d7  01 59 e 0 0 f8c0 0000  	 movw,s d, y;		scrmem->am;	;				| 
   14d8  05 0a 3 0 4 f900 14da  	movw 0, y;		am->scrmem;	cjp, zer vrwidth;	scrmp +	| 
   14d9  05 0d 3 f 7 f900 14d9  	movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   14da  05 53 e 0 0 7140 8010  vrwidth: ;			0x8010->vloareg; ;			| vhiareg unchanged.
   14db  01 59 e 0 0 f8c0 0000  	 movw,s d, y;		scrmem->am;	;				| 
   14dc  05 0a 3 0 4 f900 14de  	movw 0, y;		am->scrmem;	cjp, zer vropcnt;	scrmp +	| 
   14dd  05 0d 3 f 7 f900 14dd  	movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| half of cg2_setwidth (..., 0, 0).
   14de  05 53 e 0 0 7140 8012  vropcnt: ;			0x8012->vloareg; ;			| vhiareg unchanged.
   14df  01 59 e 0 0 f8c0 0000  	 movw,s d, y;		scrmem->am;	;				| 
   14e0  05 0a 3 0 4 f900 14e2  	movw 0, y;		am->scrmem;	cjp, zer vrshft;	scrmp +	| 
   14e1  05 0d 3 f 7 f900 14e1  	movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| other half of cg2_setwidth (..., 0, 0).
   14e2  05 53 e 0 0 7140 800c  vrshft:	;			0x800c->vloareg; ;			| vhiareg unchanged.
   14e3  01 59 e 0 0 f195 0000  	sub2nw,s 8, d, y;	scrmem->am;	;				| 
   14e4  05 0a 3 0 4 f196 14e6  	mov2nw 8, y;		am->scrmem;	cjp, zer vrret;		scrmp +	| 
   14e5  05 0d 3 f 7 f196 14e5  	mov2nw 8, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setshift (..., 0, 1).
   14e6  1d 00 a 0 0 d81b 0000  vrret:	movw r[27],acc;		;		crtn, go;			| 
                                |   vropmode subroutine:  fb->status.reg.r[21]= acc.  Uses r[2].  Assumes that high 13 bits of acc are zero.
                                |   Assumes that the vme control word has been set to Word Mode (0x73->vctlreg).
   14e7  05 53 e 0 0 e79d 9000  vropmode: rolw 3, acc, acc;	0x9000->vloareg; ;				| Rotate is 3 bits.
   14e8  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   14e9  05 00 3 f 6 7140 14e9  	;			;		cjp, ~vir .;		vmerd	| read status word.
   14ea  05 39 3 f 0 d8c2 14ea  	movw d, r[2];		vrdreg->am;	cjp, ~vir .;			| 
   14eb  05 49 e 0 0 9ec2 ffc7  	andw d, r[2], r[2];	0xffc7->am;	;				| 0x38 is mask to cover 3 bits.
   14ec  05 0d 3 f 7 9942 14ec  	orw r[2], acc, r[2];	am->vwdreg;	cjp, ~vir .;		vmewr	| write status word.
   14ed  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
                                |   vcompvme:  completes vme address calculation:  addr + acc + r[31] + 0x20.
                                |   Input:	r[0]	low address.
                                |   		r[1]	high address.
                                |   		acc	value such as x to be added in.
                                |   Uses no other registers.
                                |   Output:	r[0]	low address.
                                |   		r[1]	high address.
                                |   		vloareg
                                |   		vhiareg
   14ee  01 13 e 0 0 9880 0000  vcompvme:addw,s r[0], acc, r[0];am->vloareg;;				| 
   14ef  05 49 e 0 0 869f 0020  vcompv:	addw d, r[31], acc;	0x20->am;	;				| 
   14f0  0d 12 a a 0 9881 0000  	addw r[1], acc, r[1];am->vhiareg;	crtn, ~cry;			| 
   14f1  1d 12 a 0 0 dd61 0000  	incw r[1], r[1];	am->vhiareg;	crtn, go;			| 
                                | "@(#)stclip.pp.u 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   stclip:
                                |   Resource Usage:  acc, r[0], r[1], scratch memory.
                                |   stclip stores the clipping list from the fifo into
                                |   the scratch memory at the location 0x500.  It consists
                                |   of groups of four values: offsetx, offsety, sizex, and sizey.
                                |   These are sanity checked against the edges of the screen.
   14f2  05 45 e 0 0 7140 0500  stclip:	;			0x500->scrmemp; ;				| Initialize scratch memory.
   14f3  05 61 3 d 0 f8c1 14f3  strect:	movw d, acc;		fifo1->am;	cjp, f1e strect;		| Get number of rectangles.
   14f4  05 04 e 0 0 e185 0000  	sub2nw 0, acc;		am->brreg;	;				| 
   14f5  1d 00 4 0 0 7140 0000  	;			;		push, go;			| Load counter, do loop.
   14f6  01 61 3 d 0 f8c1 14f6  stx:	movw,s d, acc;		fifo1->am;	cjp, f1e stx;			| Get offsetx.
   14f7  05 00 3 1 0 d900 14fb  	movw 0, r[0];		;		cjp, neg sty;			| Compare with 0.
   14f8  01 49 e 0 0 e240 03ff  	rsubw,s d, acc, y;	 1023->am;	;				| Compare with  1023.
   14f9  05 00 3 9 0 d880 14fb  	movw acc, r[0];		;		cjp, ~neg sty;			| 
   14fa  05 49 e 0 0 d8c0 03ff  	movw d, r[0];		 1023->am;	;				| 
   14fb  01 61 3 d 0 f8c1 14fb  sty:	movw,s d, acc;		fifo1->am;	cjp, f1e sty;			| Get offsety.
   14fc  05 00 3 1 0 d901 1500  	movw 0, r[1];		;		cjp, neg stw;			| Compare with 0.
   14fd  01 49 e 0 0 e240 03ff  	rsubw,s d, acc, y;	 1023->am;	;				| Compare with  1023.
   14fe  05 00 3 9 0 d881 1500  	movw acc, r[1];		;		cjp, ~neg stw;			| r[2] ok.
   14ff  05 49 e 0 0 d8c1 03ff  	movw d, r[1];		 1023->am;	;				| 
   1500  01 61 3 d 0 f8c1 1500  stw:	movw,s d, acc;		fifo1->am;	cjp, f1e stw;			| Get r[2].
   1501  04 44 3 1 4 9880 150e  	addw r[0], acc, r[4];	=stwskip->brreg; cjp, neg stwskip;		| if (r[2] <= 0) skip this rectangle.
   1502  09 49 3 0 0 9e44 0400  	rsubw,s d, r[4], r[4];	 1024->am;	cjp, zer;			| if ((offsetx+r[2]) >  1023) trim r[2]
   1503  05 00 3 9 0 d882 1505  	movw acc, r[2];	;		cjp, ~neg sth;			| Sizex ok.
   1504  04 00 e 0 2 9884 0000  	addw r[4], acc, r[2];	;		;				| Adjust r[2].
   1505  01 61 3 d 0 f8c1 1505  sth:	movw,s d, acc;		fifo1->am;	cjp, f1e sth;			| Get r[3].
   1506  04 44 3 1 4 9881 150f  	addw r[1], acc, r[4];	=strfct->brreg;	cjp, neg strfct;		| if (r[3] <= 0) skip this rectangle.
   1507  09 49 3 0 0 9e44 0400  	rsubw,s d, r[4], r[4];	 1024->am;	cjp, zer;			| if ((offsety+r[3]) >  1023) trim r[3]
   1508  05 00 3 9 0 d883 150a  	movw acc, r[3];	;		cjp, ~neg stvals;		| Sizey ok.
   1509  04 00 e 0 3 9884 0000  	addw r[4], acc, r[3];	;		;				| Adjust r[3].
   150a  05 0a e 0 4 d840 0000  stvals:	movw r[0], y;		am->scrmem;	;			scrmp +	| Store values.
   150b  05 0a e 0 4 d841 0000  	movw r[1], y;		am->scrmem;	;			scrmp +	| 
   150c  05 0a e 0 4 d842 0000  	movw r[2], y;		am->scrmem;	;			scrmp +	| 
   150d  15 0a 3 0 4 d843 150f  	movw r[3], y;		am->scrmem;	cjp, go strfct;		scrmp +	| 
   150e  05 61 3 d 0 7140 150e  stwskip: ;			fifo1->am;	cjp, f1e stwskip;		| Discard r[3].  Skip this rectangle.
   150f  0d 00 8 0 0 7140 0000  strfct:	;			;		rfct;				| 
   1510  15 0a 3 0 4 fb00 1128  	compw 0, y;		am->scrmem;	cjp, go start;		scrmp +	| 
                                | "@(#)octant.pp.u 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   Octant subroutine:  chooses octant (one of four) to draw in
                                |   and generates the points.
                                |   Expects the following registers to be loaded:
                                |   vwrdreg:		r[27].
                                |   vctlreg:		byte mode.
                                |   acc:		initial error.
                                |   r[0], vloareg:	low address.
                                |   r[1], vhiareg:	high address.
                                |   r[2]:		number of pixels to draw.
                                |   r[3]:		incr0 (added to error if error is negative).
                                |   r[4]:		incr1 (added to error if error is positive).
                                |   r[5]:		reflect (determines which octant:  0 => 0, 1 => 1, 2 => 7, 3 => 6).
   1511  05 49 e 0 0 7140 1514  octant:	;			=oct0176->am;	;				| Choose octant based on reflect.
   1512  05 04 e 0 0 9685 0000  	addw d, r[5], y;	am->brreg;	;				| 
   1513  1d 00 3 0 0 7140 0000  	;			;		cjp, go;			| 
   1514  15 04 3 0 0 d842 1518  oct0176:movw r[2], y;		am->brreg;	cjp, go oct0;			| Get ready to ld cntr.
   1515  15 04 3 0 0 d842 1524  	movw r[2], y;		am->brreg;	cjp, go oct1;			| Get ready to ld cntr. (dx swapped w/ dy).
   1516  15 04 3 0 0 d842 1530  	movw r[2], y;		am->brreg;	cjp, go oct7;			| Get ready to ld cntr.
   1517  15 04 3 0 0 d842 153c  	movw r[2], y;		am->brreg;	cjp, go oct6;			| Get ready to ld cntr. (dx swapped w/ dy).
   1518  19 44 4 0 0 f880 151f  oct0:	 movw,s acc, y;		=negerr0->brreg;push, go;			| Set cond. code, ld cntr, push loop.
                                |   testing (-acc) < 0 is equivalent to testing (acc) > 0.
                                |   Main vector drawing loop.  Octant 0.
   1519  0d 00 3 9 f 7140 1519  vloop0:	;			;		cjp, ~neg.3 vloop0;	vmewr	| if acc < 0 goto negerr0.
   151a  01 00 e 0 0 dd60 0000  	incw,s r[0], r[0];	;		;				| Increment x.
   151b  05 13 3 a 0 d840 151d  	movw r[0], y;		am->vloareg;	cjp, ~cry ncry0a;		| 
   151c  05 12 e 0 0 dd61 0000  	incw r[1], r[1];	am->vhiareg;	;				| 
   151d  09 00 8 0 0 8083 0000  ncry0a:	addw,s r[3], acc, acc;	;		rfct;				| 
   151e  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   151f  01 49 e 0 0 9e80 0401  negerr0:addw,s d, r[0], r[0]; 1025->am;	;				| Increment x and y. ( 1024 + 1).
   1520  05 13 3 a 0 d840 1522  	movw r[0], y;		am->vloareg;	cjp, ~cry ncry0;		| No need to rewrite vhiareg if no change.
   1521  05 12 e 0 0 dd61 0000  	incw r[1], r[1];	am->vhiareg;	;				| r[1] += carry.
   1522  09 00 8 0 0 8084 0000  ncry0:	addw,s r[4], acc, acc;	;		rfct;				| 
   1523  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   1524  19 44 4 0 0 f880 152b  oct1:	 movw,s acc, y;		=negerr1->brreg;push, go;			| Set cond. code, ld cntr, push loop.
                                |   Main vector drawing loop.  Octant 1.
   1525  0d 00 3 9 f 7140 1525  vloop1:	;			;		cjp, ~neg.3 vloop1;	vmewr	| if acc < 0 goto negerr1.
   1526  01 49 e 0 0 9e80 0400  	addw,s d, r[0], r[0]; 1024->am;	;				| Increment y.
   1527  05 13 3 a 0 d840 1529  	movw r[0], y;		am->vloareg;	cjp, ~cry ncry1a;		| 
   1528  05 12 e 0 0 dd61 0000  	incw r[1], r[1];	am->vhiareg;	;				| 
   1529  09 00 8 0 0 8083 0000  ncry1a:	addw,s r[3], acc, acc;	;		rfct;				| 
   152a  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   152b  01 49 e 0 0 9e80 0401  negerr1:addw,s d, r[0], r[0]; 1025->am;	;				| Increment x and y. ( 1024 + 1).
   152c  05 13 3 a 0 d840 152e  	movw r[0], y;		am->vloareg;	cjp, ~cry ncry1;		| No need to rewrite vhiareg if no change.
   152d  05 12 e 0 0 dd61 0000  	incw r[1], r[1];	am->vhiareg;	;				| r[1] += carry.
   152e  09 00 8 0 0 8084 0000  ncry1:	addw,s r[4], acc, acc;	;		rfct;				| 
   152f  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   1530  19 44 4 0 0 f880 1537  oct7:	 movw,s acc, y;		=negerr7->brreg;push, go;			| Set cond. code, ld cntr, push loop.
                                |   Main vector drawing loop.  Octant 7.
   1531  0d 00 3 9 f 7140 1531  vloop7:	;			;		cjp, ~neg.3 vloop7;	vmewr	| if acc < 0 goto negerr7.
   1532  01 00 e 0 0 dd60 0000  	incw,s r[0],r[0];	;		;				| increment x.
   1533  05 13 3 a 0 d840 1535  	movw r[0], y;		am->vloareg;	cjp, ~cry ncry7a;		| 
   1534  05 12 e 0 0 dd61 0000  	incw r[1], r[1];	am->vhiareg;	;				| 
   1535  09 00 8 0 0 8083 0000  ncry7a:	addw,s r[3], acc, acc;	;		rfct;				| 
   1536  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   1537  01 49 e 0 0 9e80 fc01  negerr7:addw,s d, r[0], r[0];-1023->am;	;				| Increment x, decrement y. (- 1024 + 1).
   1538  05 13 3 2 0 d840 153a  	movw r[0], y;		am->vloareg;	cjp, cry ncry7;			| No need to rewrite vhiareg if no change.
   1539  05 12 e 0 0 c1e1 0000  	sub2nw 0, r[1], r[1];	am->vhiareg;	;				| r[1] -= borrow
   153a  09 00 8 0 0 8084 0000  ncry7:	addw,s r[4], acc, acc;	;		rfct;				| 
   153b  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   153c  19 44 4 0 0 f880 1543  oct6:	 movw,s acc, y;		=negerr6->brreg;push, go;			| Set cond. code, ld cntr, push loop.
                                |   Main vector drawing loop.  Octant 6.
   153d  0d 00 3 9 f 7140 153d  vloop6:	;			;		cjp, ~neg.3 vloop6;	vmewr	| if acc < 0 goto negerr6.
   153e  01 49 e 0 0 9e00 0400  	subw,s d, r[0], r[0]; 1024->am;	;				| Decrement y.
   153f  05 13 3 2 0 d840 1541  	movw r[0], y;		am->vloareg;	cjp, cry ncry6a;		| Not rewrite vhiareg if no change. cry==no borrow
   1540  05 12 e 0 0 c1e1 0000  	sub2nw 0, r[1], r[1];	am->vhiareg;	;				| r[1] -= borrow.
   1541  09 00 8 0 0 8083 0000  ncry6a:	addw,s r[3], acc, acc;	;		rfct;				| 
   1542  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   1543  01 49 e 0 0 9e80 fc01  negerr6:addw,s d, r[0], r[0];-1023->am;	;				| Increment x, decrement y. (- 1024 + 1).
   1544  05 13 3 2 0 d840 1546  	movw r[0], y;		am->vloareg;	cjp, cry ncry6;			| No need to rewrite vhiareg if no change.
   1545  05 12 e 0 0 c1e1 0000  	sub2nw 0, r[1], r[1];	am->vhiareg;	;				| r[1] -= borrow
   1546  09 00 8 0 0 8084 0000  ncry6:	addw,s r[4], acc, acc;	;		rfct;				| 
   1547  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
                                | "@(#)gbuffer.pp.u 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   G-Buffer routines.
                                |   Copy portion of screen to g-buffer.
   1548  05 61 3 d 0 d8c3 1548  scrbuf:	movw d, r[3];		fifo1->am;	cjp, f1e scrbuf;		| 
   1549  05 61 3 d 0 d8c4 1549  sbsy:	movw d, r[4];		fifo1->am;	cjp, f1e sbsy;			| 
   154a  05 61 3 d 0 d8c5 154a  sbsw:	movw d, r[5];		fifo1->am;	cjp, f1e sbsw;			| 
   154b  05 61 3 d 0 d8c6 154b  sbsh:	movw d, r[6];		fifo1->am;	cjp, f1e sbsh;			| 
   154c  05 61 3 d 0 d8c7 154c  sbbx:	movw d, r[7];		fifo1->am;	cjp, f1e sbbx;			| 
   154d  05 61 3 d 0 d8c8 154d  sbby:	movw d, r[8];		fifo1->am;	cjp, f1e sbby;			| 
   154e  05 00 3 e 0 7140 154e  sbinit:	;			;		cjp, ~zbr sbinit;		| 
   154f  05 56 e 0 0 7140 6000  	;			0x6000->zbhiptr; ;				| do a rd or wr 8 or more cycles after, < 10 usec.
   1550  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   1551  05 53 e 0 0 7140 a000  	;			0xa000->vloareg; ;				| 
   1552  05 00 3 f 0 7140 1552  sbvctl: ;			;		cjp, ~vir sbvctl;		| 
   1553  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   1554  05 4d e 0 0 7140 00ff  sbpp:	;			255->vwdreg;	;				| 
   1555  05 00 3 f 7 7140 1554  	;			;		cjp, ~vir sbpp;		vmewr	| 
   1556  05 49 e 0 0 f8c1 0001  	movw d, acc;		1->am;	;				| 
   1557  15 00 1 0 0 7140 14e7  	;			;		cjs, go vropmode;		| 
   1558  14 00 1 0 2 d964 11c3  	movw r[4], r[2];		;		cjs, go MulSWid;		| screen address (r[3], r[4])
   1559  05 00 3 f 0 d803 1559  sbvctl1: movw r[3], acc;		;		cjp, ~vir sbvctl1;		| 
   155a  04 54 e 0 d 9880 0060  	addw r[0], acc, r[13]; 0x60->vctlreg; ;				| 
   155b  04 49 e 0 e 9ea1 0050  	addcw d, r[1], r[14];	0x50->am;	;				| 
   155c  14 00 1 0 2 d968 11c3  	movw r[8], r[2];		;		cjs, go MulSWid;		| 
   155d  05 00 e 0 0 d807 0000  	movw r[7], acc;		;		;				| 
   155e  04 00 e 0 9 9880 0000  	addw r[0], acc, r[9]; ;		;				| 
   155f  04 49 e 0 a 9ea1 0000  	addcw d, r[1], r[10];	0->am;		;				| 
   1560  01 00 e 0 0 de46 0000  sbwhile: negw,s r[6], y;		;		;				| while (r[6]-- > 0) {
   1561  05 13 3 9 0 d84d 1128  	movw r[13], y;	am->vloareg;	cjp, ~neg start;		| 
   1562  05 12 e 0 0 d84e 0000  	movw r[14], y;	am->vhiareg;	;				| 
   1563  05 16 3 e 0 d84a 1563  sbbhi:	movw r[10], y;	am->zbhiptr;	cjp, ~zbr sbbhi;		| 
   1564  05 17 3 e 0 d849 1564  sbblo:	movw r[9], y;	am->zbloptr;	cjp, ~zbr sbblo;		| 
   1565  05 04 e 0 0 c1e5 0000  	sub2nw 0, r[5];		am->brreg;	;				| 
   1566  1d 00 4 0 0 dd65 0000  	incw r[5], r[5];		;		push, go;			| fastloop (r[5], *ba++, *sa++)
   1567  05 00 3 f 6 7140 1567  sbfast:	;			;		cjp, ~vir sbfast;	vmerd	| 
   1568  05 39 3 f 0 f8c1 1568  sbread:	movw d, acc;		vrdreg->am;	cjp, ~vir sbread;		| 
   1569  05 00 3 e 0 7140 1569  sbgbr:	;			;		cjp, ~zbr sbgbr;		| 
   156a  0d 0b 8 0 1 f880 0000  	movw acc, y;		am->zbwdreg;	rfct;			varegs+	| 
   156b  05 49 e 0 0 9e8d 0400  	addw d, r[13], r[13];  1024->am;	;				| 
   156c  05 49 e 0 0 9eae 0000  	addcw d, r[14], r[14]; 0->am;	;				| 
   156d  05 49 e 0 0 9e89 0400  	addw d, r[9], r[9];  1024->am;	;				| 
   156e  05 49 e 0 0 9eaa 0000  	addcw d, r[10], r[10]; 0->am;	;				| 
   156f  15 00 3 0 0 c1e6 1560  	sub2nw 0, r[6], r[6];		;		cjp, go sbwhile;		| end while
                                |   set buf:  set a rectangle in the g-buffer to a r[27].
   1570  05 61 3 d 0 d8db 1570  setbuf:	movw d, r[27];		fifo1->am;	cjp, f1e .;			| 
   1571  05 45 e 0 0 7140 0190  	;			 0x190->scrmemp; ;				| 
   1572  05 61 3 d 0 d8c3 1572  	movw d, r[3];		fifo1->am;	cjp, f1e .;			| 
   1573  05 0a e 0 4 d843 0000  	movw r[3], y;		am->scrmem;	;			scrmp +	| 
   1574  05 61 3 d 0 d8c4 1574  	movw d, r[4];		fifo1->am;	cjp, f1e .;			| 
   1575  05 0a e 0 4 d844 0000  	movw r[4], y;		am->scrmem;	;			scrmp +	| 
   1576  05 61 3 d 0 d8c5 1576  	movw d, r[5];		fifo1->am;	cjp, f1e .;			| 
   1577  05 0a e 0 4 d845 0000  	movw r[5], y;		am->scrmem;	;			scrmp +	| 
   1578  05 61 3 d 0 d8c6 1578  	movw d, r[6];		fifo1->am;	cjp, f1e .;			| 
   1579  05 0a e 0 4 d846 0000  	movw r[6], y;		am->scrmem;	;			scrmp +	| 
   157a  05 00 3 e 0 7140 157a  	;			;		cjp, ~zbr .;			| 
   157b  05 56 e 0 0 7140 6000  	;			0x6000->zbhiptr; ;				| 
   157c  05 49 e 0 0 d8c9 0500  	movw d, r[9];	0x500->am;	;				| 
   157d  05 45 e 0 0 7140 0190  sb0clip: ;			 0x190->scrmemp; ;				| 
   157e  05 59 e 0 4 d8c3 0000  	movw d, r[3];		scrmem->am;	;			scrmp +	| 
   157f  05 59 e 0 4 d8c4 0000  	movw d, r[4];		scrmem->am;	;			scrmp +	| 
   1580  05 59 e 0 4 d8c5 0000  	movw d, r[5];		scrmem->am;	;			scrmp +	| 
   1581  05 59 e 0 4 d8c6 0000  	movw d, r[6];		scrmem->am;	;			scrmp +	| 
   1582  05 05 e 0 0 d849 0000  	movw r[9], y;	am->scrmemp;	;				| 
   1583  05 49 e 0 0 9e89 0004  	addw d, r[9], r[9]; 4->am;	;				| 
   1584  01 59 e 0 4 d8ca 0000  	movw,s d, r[10];	scrmem->am;	;			scrmp +	| 
   1585  05 00 3 1 0 d805 1128  	movw r[5], acc;		;		cjp, neg start;			| neg == end of clip list
   1586  05 00 e 0 0 8083 0000  	addw r[3], acc, acc;	;		;				| 
   1587  01 00 e 0 0 900a 0000  	subw,s r[10], acc, y;	;		;				| 
   1588  05 00 3 1 0 d806 157d  	movw r[6], acc;		;		cjp, neg sb0clip;		| 
   1589  05 00 e 0 0 8084 0000  	addw r[4], acc, acc;	;		;				| 
   158a  05 59 e 0 4 d8cb 0000  	movw d, r[11];	scrmem->am;	;			scrmp +	| 
   158b  01 00 e 0 0 900b 0000  	subw,s r[11], acc, y;	;		;				| 
   158c  05 59 3 1 4 d8cc 157d  	movw d, r[12];		scrmem->am;	cjp, neg sb0clip;	scrmp +	| 
   158d  05 00 e 0 0 d80a 0000  	movw r[10], acc;	;		;				| 
   158e  05 00 e 0 0 808c 0000  	addw r[12], acc, acc;	;		;				| 
   158f  01 00 e 0 0 9003 0000  	subw,s r[3], acc, y;	;		;				| 
   1590  05 59 3 1 4 d8cd 157d  	movw d, r[13];		scrmem->am;	cjp, neg sb0clip;	scrmp +	| 
   1591  05 00 e 0 0 d80b 0000  	movw r[11], acc;	;		;				| 
   1592  05 00 e 0 0 808d 0000  	addw r[13], acc, acc;	;		;				| 
   1593  01 00 e 0 0 9004 0000  	subw,s r[4], acc, y;	;		;				| 
   1594  05 00 3 1 0 d803 157d  	movw r[3], acc;		;		cjp, neg sb0clip;		| 
   1595  01 09 e 0 0 900a 0000  	subw,s r[10], acc, y;	am->am;		;				| 
   1596  05 00 3 9 0 7140 1599  	;			;		cjp, ~neg sb0offy;		| 
   1597  05 00 e 0 0 9e03 0000  	subw d, r[3], r[3];		;		;				| 
   1598  05 00 e 0 0 9e85 0000  	addw d, r[5], r[5];		;		;				| 
   1599  05 00 e 0 0 d804 0000  sb0offy: movw r[4], acc;		;		;				| 
   159a  01 09 e 0 0 900b 0000  	subw,s r[11], acc, y;	am->am;		;				| 
   159b  05 00 3 9 0 7140 159e  	;			;		cjp, ~neg sb0sizex;		| 
   159c  05 00 e 0 0 9e04 0000  	subw d, r[4], r[4];		;		;				| 
   159d  05 00 e 0 0 9e86 0000  	addw d, r[6], r[6];		;		;				| 
   159e  05 00 e 0 0 d803 0000  sb0sizex: movw r[3], acc;		;		;				| 
   159f  05 00 e 0 0 8085 0000  	addw r[5], acc, acc;	;		;				| 
   15a0  05 09 e 0 0 d84c 0000  	movw r[12], y;		am->am;		;				| 
   15a1  05 00 e 0 0 9e8a 0000  	addw d, r[10], r[10]; ;		;				| 
   15a2  01 00 e 0 0 804a 0000  	rsubw,s r[10], acc, acc; ;		;				| 
   15a3  05 00 3 9 0 7140 15a5  	;			;		cjp, ~neg sb0sizey;		| 
   15a4  05 00 e 0 0 9885 0000  	addw r[5], acc, r[5];	;		;				| 
   15a5  05 00 e 0 0 d804 0000  sb0sizey: movw r[4], acc;		;		;				| 
   15a6  05 00 e 0 0 8086 0000  	addw r[6], acc, acc;	;		;				| 
   15a7  05 09 e 0 0 d84d 0000  	movw r[13], y;		am->am;		;				| 
   15a8  05 00 e 0 0 9e8b 0000  	addw d, r[11], r[11]; ;		;				| 
   15a9  01 00 e 0 0 804b 0000  	rsubw,s r[11], acc, acc; ;		;				| 
   15aa  05 00 3 9 0 7140 15ac  	;			;		cjp, ~neg sb0ok;		| 
   15ab  05 00 e 0 0 9886 0000  	addw r[6], acc, r[6];	;		;				| 
   15ac  14 00 1 0 2 d964 11c3  sb0ok:	movw r[4], r[2];		;		cjs, go MulSWid;		| 
   15ad  05 00 e 0 0 d803 0000  	movw r[3], acc;		;		;				| 
   15ae  04 00 e 0 7 9880 0000  	addw r[0], acc, r[7]; ;		;				| 
   15af  04 49 e 0 8 9ea1 0000  	addcw d, r[1], r[8];	0->am;		;				| 
   15b0  01 00 e 0 0 de46 0000  sb0while: negw,s r[6], y;		;		;				| while (sh-- > 0) {
   15b1  05 00 3 9 0 7140 157d  	;			;		cjp, ~neg sb0clip;		| 
   15b2  05 16 3 e 0 d848 15b2  	movw r[8], y;	am->zbhiptr;	cjp, ~zbr .;			| 
   15b3  05 17 3 e 0 d847 15b3  	movw r[7], y;	am->zbloptr;	cjp, ~zbr .;			| 
   15b4  05 04 e 0 0 c1e5 0000  	sub2nw 0, r[5];		am->brreg;	;				| 
   15b5  1d 00 4 0 0 dd65 0000  	incw r[5], r[5];		;		push, go;			| fastloop (r[5], *ba++= r[27])
   15b6  05 00 3 e 0 7140 15b6  	;			;		cjp, ~zbr .;			| 
   15b7  0d 0b 8 0 0 d85b 0000  	movw r[27], y;		am->zbwdreg;	rfct;				| 
   15b8  05 49 e 0 0 9e87 0400  	addw d, r[7], r[7];  1024->am;	;				| 
   15b9  05 49 e 0 0 9ea8 0000  	addcw d, r[8], r[8]; 0->am;	;				| 
   15ba  15 00 3 0 0 c1e6 15b0  	sub2nw 0, r[6], r[6];		;		cjp, go sb0while;		| end while
                                |   bufscr:  copy a rectangle in the g-buffer to a rectangle on the screen.
   15bb  05 61 3 d 0 d8c9 15bb  bufscr:	movw d, r[9];	fifo1->am;	cjp, f1e bufscr;		| flag.  Neg == copy high bytes.
   15bc  05 61 3 d 0 d8c3 15bc  bsbw:	movw d, r[3];		fifo1->am;	cjp, f1e bsbw;			| 
   15bd  05 61 3 d 0 d8c4 15bd  bsbh:	movw d, r[4];		fifo1->am;	cjp, f1e bsbh;			| 
   15be  05 61 3 d 0 d8c5 15be  bsblo:	movw d, r[5];	fifo1->am;	cjp, f1e bsblo;			| 
   15bf  05 61 3 d 0 d8c6 15bf  bsbhi:	movw d, r[6];	fifo1->am;	cjp, f1e bsbhi;			| 
   15c0  05 61 3 d 0 d8c7 15c0  bsslo:	movw d, r[7];	fifo1->am;	cjp, f1e bsslo;			| 
   15c1  05 61 3 d 0 d8c8 15c1  bsshi:	movw d, r[8];	fifo1->am;	cjp, f1e bsshi;			| 
   15c2  15 00 1 0 0 7140 1309  	;			;		cjs, go ropreg;			| 
   15c3  05 00 3 e 0 7140 15c3  bsinit:	;			;		cjp, ~zbr bsinit;		| 
   15c4  05 56 e 0 0 7140 6000  	;			0x6000->zbhiptr; ;				| 
   15c5  01 00 e 0 0 de44 0000  bswhile: negw,s r[4], y;		;		;				| while (sh-- > 0) {
   15c6  05 00 3 9 0 7140 1128  	;			;		cjp, ~neg start;		| 
   15c7  05 16 3 e 0 d846 15c7  bsbhi1:	movw r[6], y;	am->zbhiptr;	cjp, ~zbr bsbhi1;		| 
   15c8  05 17 3 e 5 d845 15c8  bsblo1:	movw r[5], y;	am->zbloptr;	cjp, ~zbr bsblo1;	zbrd	| ma= ma_top
                                |   bsvctl:	;			;		cjp, ~vir bsvctl;		| prime fifo
                                |	;			0x73->vctlreg; ;				| 
                                |	;			0x8804->vloareg; ;			| 
                                |	movw r[30], y;		am->vhiareg;	;				| 
                                |   bsprime: movw d, acc;		zbrdreg->am;	cjp, ~zbr bsprime;	zbrd	| 
                                |	romw 8, d, acc, 0xff00;	;		;				| 
                                |	;			;		;				| 
                                |   bsvw0:	movw acc, y;		am->vwdreg;	cjp, ~vir bsvw0;	vmewr	| 
   15c9  05 13 e 0 0 d847 0000  	movw r[7], y;	am->vloareg;	;				| bx= by
   15ca  05 12 e 0 0 d848 0000  	movw r[8], y;	am->vhiareg;	;				| 
   15cb  05 00 3 f 0 7140 15cb  bsvctl1: ;			;		cjp, ~vir bsvctl1;		| 
   15cc  01 54 e 0 0 d849 0060  	 movw,s r[9], y;	0x60->vctlreg;	;				| 
   15cd  05 04 3 1 0 c1e3 15d3  	sub2nw 0, r[3];		am->brreg;	cjp, neg bshigh;		| 
   15ce  1d 00 4 0 0 dd63 0000  	incw r[3], r[3];		;		push, go;			| fastloop (sw, *sa++= *ba++) low bytes.
   15cf  05 21 3 e 5 f8c1 15cf  bsfast:	movw d, acc;		zbrdreg->am;	cjp, ~zbr bsfast;	zbrd	| 
   15d0  05 0d 3 f 7 f880 15d0  bsvw:	movw acc, y;		am->vwdreg;	cjp, ~vir bsvw;		vmewr	| 
   15d1  0d 00 8 0 1 7140 0000  	;			;		rfct;			varegs+	| 
   15d2  15 00 3 0 0 7140 15d7  	;			;		cjp, go bsvw1;			| 
   15d3  1d 00 4 0 0 dd63 0000  bshigh:	incw r[3], r[3];		;		push, go;			| fastloop (sw, *sa++= *ba++)
   15d4  05 21 3 e 5 f8c1 15d4  bsfasth: movw d, acc;		zbrdreg->am;	cjp, ~zbr bsfasth;	zbrd	| 
   15d5  05 0d 3 f 7 f19c 15d5  bsvwh:	rolw 8, acc, y;		am->vwdreg;	cjp, ~vir bsvwh;	vmewr	| 
   15d6  0d 00 8 0 1 7140 0000  	;			;		rfct;			varegs+	| 
   15d7  05 0d 3 f 7 f900 15d7  bsvw1:	movw 0, y;		am->vwdreg;	cjp, ~vir bsvw1;	vmewr	| flush fifo
   15d8  05 49 e 0 0 9e85 0400  	addw d, r[5], r[5];  1024->am;	;				| ma += ma_vert
   15d9  05 49 e 0 0 9ea6 0000  	addcw d, r[6], r[6]; 0->am;	;				| 
   15da  05 49 e 0 0 9e87 0400  	addw d, r[7], r[7];  1024->am;	;				| sa += linebytes
   15db  05 49 e 0 0 9ea8 0000  	addcw d, r[8], r[8]; 0->am;	;				| 
   15dc  15 00 3 0 0 c1e4 15c5  	sub2nw 0, r[4], r[4];		;		cjp, go bswhile;		| end while
                                | "@(#)shade.pp.u 1.2 86/09/12 SMI"
                                | Copyright 1985 by Sun Microsystems, Inc.
                                |   GShade Module:	Solid fill with no hidden surface elimination (HSE),
                                |   Gouraud with and without HSE.
                                |   
                                |   			No HSE (2D)			HSE (3D)
                                |   
                                |   Solid fill		Polygon fill		Polyhedra fill
                                |   			FB Limited		GP Limited
                                |   			3 cycles		6 cycles
                                |   			40 nsec/pixel		720 nsec/pixel
                                |   			25 M pixels/sec		1.4 M pixels/sec
                                |   			25 frames/sec		1.4 Frames/sec
                                |   			video off: 33% faster
                                |   
                                |   Gouraud shading	Shaded Polygons		Shaded Polyhedra
                                |   			FB Limited		GP Limited
                                |   			4 cycles		8 cycles
                                |   			640 nsec/pixel		960 nsec/pixel
                                |   			1.5 M pixels/sec	1 M pixels/sec
                                |   			1.5 Frame/sec		1 Frame/sec
                                |   
                                |   Note:  Frames are 1152 x 900.  Rates are maximum rates.
                                |   	Rates are for drawing with video on.
                                |   #22:  2D Solid:   22, y0, x0, x1, r[27], r[28].
                                |   #24:  2D Shaded:  24, y0, x0, x1, r[28], chi, dchi, dclo.
                                |   #25:  3D Shaded:  25, y0, x0, x1, r[28], zhi, dzhi, dzlo, chi, dchi, dclo.
                                |   #25:  3D Solid:   25, y0, x0, x1, r[28], zhi, dzhi, dzlo, chi, 0, 0.
                                |   Polygon fill
   15dd  05 61 3 d 0 d8d0 15dd  plgfill: movw d, r[16];		fifo1->am;	cjp, f1e .;			| Solid fill, No HSE (2D).  (#22)
   15de  05 61 3 d 0 d8d1 15de  	movw d, r[17];		fifo1->am;	cjp, f1e .;			| 
   15df  05 61 3 d 0 d8d2 15df  	movw d, r[18];		fifo1->am;	cjp, f1e .;			| 
   15e0  00 00 e 0 9 9e51 0000  	rsubw,s d, r[17], r[25];	;		;				| 
   15e1  05 00 3 9 0 d811 15e5  	movw r[17], acc;		;		cjp, ~neg plgxok;		| 
   15e2  04 00 e 0 1 d972 0000  	movw r[18], r[17];		;		;				| Swap endpoints.
   15e3  05 00 e 0 0 d892 0000  	movw acc, r[18];		;		;				| 
   15e4  05 00 e 0 0 df79 0000  	negw r[25], r[25];		;		;				| 
   15e5  05 61 3 d 0 d8db 15e5  plgxok:	movw d, r[27];		fifo1->am;	cjp, f1e .;			| 
   15e6  05 61 3 d 0 d8dc 15e6  	movw d, r[28];		fifo1->am;	cjp, f1e .;			| 
   15e7  05 00 3 0 0 c1f9 1128  	sub2nw 0, r[25];		;		cjp, zer start;			| r[25] zero
   15e8  05 00 e 0 0 c1f2 0000  	sub2nw 0, r[18];		;		;				| Dont draw pixel of last point (for fitting).
   15e9  04 49 e 0 7 9f3c fffe  	norw d, r[28], r[23];	0xfffe->am;	;				| (PIX_DONTCLIP == 1) => (r[23] == 0)
   15ea  05 00 e 0 0 cc9c 0000  	sr0w r[28], r[28];		;		;				| r[28] >> 1
   15eb  05 49 e 0 0 9edc 000f  	andw d, r[28], r[28];		0xf->am;	;				| 
                                | PIXOP_NEEDS_DST (r[28] << 1)= (r[28]^(r[28] << 1)) & 0xa
   15ec  05 00 e 0 0 d81c 0000  	movw r[28], acc;		;		;				| 
   15ed  05 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;				| 
   15ee  05 00 e 0 0 811c 0000  	xorw r[28], acc, acc;	;		;				| 
   15ef  01 49 e 0 0 e281 000a  	addw,s d, acc, acc;	0xa->am;	;				| 
   15f0  05 00 3 8 0 d91a 15f2  	movw 0, r[26];		;		cjp, ~zer plgrej;		| 
   15f1  05 00 e 0 0 dd1a 0000  	incw 0, r[26];		;		;				| 
   15f2  01 44 e 0 0 d850 1128  plgrej:	movw,s r[16], y;		=start->brreg;	;				| 
   15f3  09 49 3 1 0 9610 0400  	subw,s d, r[16], y;	 1024->am;	cjp, neg;			| if (r[16] < 0) trivial rejection.
   15f4  09 00 3 9 0 d852 0000  	movw,s r[18], y;		;		cjp, ~neg;			| if (r[16] >  1024) trivial rejection.
   15f5  09 49 3 1 0 9611 0400  	subw,s d, r[17], y;	 1024->am;	cjp, neg;			| if (r[18] < 0) trivial rejection.
   15f6  09 44 3 9 0 d851 15f9  	movw,s r[17], y;		=plgx0ok->brreg; cjp, ~neg;			| if (r[17] >  1024) trivial rejection.
   15f7  09 49 3 9 0 9612 0400  	subw,s d, r[18], y;	 1024->am;	cjp, ~neg;			| 
   15f8  05 00 e 0 0 d911 0000  	movw 0, r[17];		;		;				| 
   15f9  05 00 3 1 0 7140 15fb  plgx0ok: ;			;		cjp, neg plgx1ok;		| 
   15fa  05 49 e 0 0 d8d2 03ff  	movw d, r[18];		 1023->am;	;				| 
   15fb  05 45 e 0 0 7140 0190  plgx1ok: ;			 0x190->scrmemp; ;				| 
   15fc  05 0a e 0 4 d850 0000  	movw r[16], y;		am->scrmem;	;			scrmp +	| 
   15fd  05 0a e 0 4 d851 0000  	movw r[17], y;		am->scrmem;	;			scrmp +	| 
   15fe  05 0a e 0 4 d852 0000  	movw r[18], y;		am->scrmem;	;			scrmp +	| 
   15ff  05 49 e 0 0 d8d8 0500  	movw d, r[24];	0x500->am;	;				| 
   1600  05 45 e 0 0 7140 0500  	;			0x500->scrmemp; ;				| 
   1601  01 59 e 0 4 d8d5 0000  plgoff:	movw,s d, r[21];	scrmem->am;	;			scrmp +	| Return here for next r[23].  Offset x.
   1602  05 00 3 1 0 9e11 1128  	subw d, r[17], r[17];		;		cjp, neg start;			| neg == end of r[23] list.
   1603  05 00 e 0 0 9e12 0000  	subw d, r[18], r[18];		;		;				| 
   1604  05 59 e 0 4 d8d6 0000  	movw d, r[22];	scrmem->am;	;			scrmp +	| 
   1605  05 00 e 0 0 9e10 0000  	subw d, r[16], r[16];		;		;				| 
   1606  05 59 e 0 4 d8d3 0000  	movw d, r[19];		scrmem->am;	;			scrmp +	| 
   1607  05 59 e 0 4 d8d4 0000  	movw d, r[20];		scrmem->am;	;			scrmp +	| 
   1608  05 49 e 0 0 9e98 0004  	addw d, r[24], r[24]; 4->am;	;				| 
   1609  05 00 e 0 0 d812 0000  	movw r[18], acc;		;		;				| 
   160a  00 00 e 0 9 9811 0000  	subw,s r[17], acc, r[25];	;		;				| 
   160b  01 00 e 0 0 d857 0000  	 movw,s r[23], y;		;		;				| 
   160c  05 41 3 0 0 f8c0 1614  	movw d, y;		vstreg->am;	cjp, zer plgseg;		| 
   160d  01 00 e 0 0 d850 0000  	 movw,s r[16], y;		;		;				| if (r[16] < 0) skip
   160e  01 00 3 1 0 d852 1615  	 movw,s r[18], y;		;		cjp, neg plgreset;		| if (r[18] < 0) skip
   160f  05 00 3 1 0 d811 1615  	movw r[17], acc;		;		cjp, neg plgreset;		| if (r[17] >= r[19]) skip
   1610  01 00 e 0 0 9013 0000  	subw,s r[19], acc, y;	;		;				| 
   1611  05 00 3 9 0 d810 1615  	movw r[16], acc;		;		cjp, ~neg plgreset;		| if (r[16] >= r[20]) skip
   1612  01 00 e 0 0 9014 0000  	subw,s r[20], acc, y;	;		;				| 
   1613  05 00 3 9 0 7140 1615  	;			;		cjp, ~neg plgreset;		| 
   1614  15 00 1 0 0 7140 161a  plgseg:	;			;		cjs, go flatseg;		| 
   1615  01 45 e 0 0 d857 0190  plgreset:  movw,s r[23], y;		 0x190->scrmemp; ;				| 
   1616  05 59 3 0 4 d8d0 1128  	movw d, r[16];		scrmem->am;	cjp, zer start;		scrmp +	| 
   1617  05 59 e 0 4 d8d1 0000  	movw d, r[17];		scrmem->am;	;			scrmp +	| 
   1618  05 59 e 0 4 d8d2 0000  	movw d, r[18];		scrmem->am;	;			scrmp +	| 
   1619  15 05 3 0 0 d858 1601  	movw r[24], y;	am->scrmemp;	cjp, go plgoff;			| 
                                |   PPFill2DSeg
   161a  05 53 e 0 0 7140 a000  flatseg: ;			0xa000->vloareg; ;				| 
   161b  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   161c  05 00 3 f 0 7140 161c  	;			;		cjp, ~vir .;			| Wait till vctlreg ready.
   161d  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   161e  05 0d 3 f 7 d85d 161e  	movw r[29], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| write ppmask.reg.
   161f  05 45 e 0 0 7140 01c0  	;			0x1c0->scrmemp; ;				| 
   1620  01 59 e 0 0 961c 0000  	subw,s d, r[28], y;	scrmem->am;	;				| 
   1621  05 0a 3 0 4 d85c 1624  	movw r[28], y;		am->scrmem;	cjp, zer fsfpatt0;	scrmp +	| 
   1622  05 53 e 0 0 7140 800e  	;			 0x800e->vloareg; ;			| vhiareg unchanged.
   1623  05 0d 3 f 7 d85c 1623  	movw r[28], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setfunction (..., r[28]).
   1624  05 53 e 0 0 7140 8006  fsfpatt0: ;			 0x8006->vloareg; ;			| vhiareg unch.
   1625  01 59 e 0 0 f8c0 0000  	 movw,s d, y;		scrmem->am;	;				| 
   1626  05 0a 3 0 4 f900 1628  	movw 0, y;		am->scrmem;	cjp, zer fsfpatt1;	scrmp +	| 
   1627  05 0d 3 f 7 f900 1627  	movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1628  01 00 e 0 0 d857 0000  fsfpatt1:  movw,s r[23], y;		;		;				| if (r[23]) ...
   1629  01 00 3 0 0 d851 1631  	 movw,s r[17], y;		;		cjp, zer fsfnclip;		| if (pos0.x > 0)
   162a  05 00 3 9 0 d812 162c  	movw r[18], acc;		;		cjp, ~neg fsfx1;		| 
   162b  05 00 e 0 0 d911 0000  	movw 0, r[17];		;		;				| pos0.x= 0
   162c  01 00 e 0 0 8013 0000  fsfx1:	subw,s r[19], acc, acc;	;		;				| if (pos1.x >= size.x)
   162d  05 09 3 1 0 c1f3 162f  	sub2nw 0, r[19];		am->am;		cjp, neg fsfdx;			| pos1.x= size.x - 1
   162e  05 00 e 0 0 d8d2 0000  	movw d, r[18];		;		;				| 
   162f  05 00 e 0 0 d812 0000  fsfdx:	movw r[18], acc;		;		;				| 
   1630  04 00 e 0 9 9811 0000  	subw r[17], acc, r[25];	;		;				| r[25]= pos1.x - pos0.x
   1631  05 00 e 0 0 d811 0000  fsfnclip: movw r[17], acc;		;		;				| 
   1632  05 00 e 0 0 8099 0000  	addw r[25], acc, acc;	;		;				| 
   1633  05 59 e 0 0 d8c0 0000  	movw d, r[0];		scrmem->am;	;				| 
   1634  05 53 e 0 0 8095 800a  	addw r[21], acc, acc;	0x800a->vloareg; ;			| cg2_prd_skew (dmd, pos1.x). vhiareg unchanged.
   1635  05 49 e 0 0 c2ce 000f  	andw d, acc, r[14];	0xf->am;	;				| r[14]= cg2_prd_skew
   1636  05 49 e 0 0 868e 01b0  	addw d, r[14], acc;	0x1b0->am;	;				| rmasktable [r[14]]
   1637  05 05 e 0 0 f880 0000  	movw acc, y;		am->scrmemp;	;				| 
   1638  01 59 e 0 0 9600 0000  	subw,s d, r[0], y ;	scrmem->am;	;				| 
   1639  05 00 3 0 0 d811 163e  	movw r[17], acc;		;		cjp, zer fsfm1;			| 
   163a  05 59 e 0 0 d8c0 0000  	movw d, r[0];		scrmem->am;	;				| 
   163b  05 45 e 0 0 7140 01c2  	;			 0x1c2->scrmemp; ;				| 
   163c  05 0a e 0 0 d840 0000  	movw r[0], y;		am->scrmem;	;				| 
   163d  05 0d 3 f 7 d840 163d  	movw r[0], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   163e  05 53 e 0 0 8095 8008  fsfm1:	addw r[21], acc, acc;	0x8008->vloareg; ;			| cg2_prd_skew (dmd, pos0.x) vhiareg unchanged.
   163f  05 49 e 0 0 c2ce 000f  	andw d, acc, r[14];	0xf->am;	;				| r[14]= cg2_prd_skew
   1640  05 49 e 0 0 868e 01a0  	addw d, r[14], acc;	0x1a0->am;	;				| 
   1641  05 05 e 0 0 f880 0000  	movw acc, y;		am->scrmemp;	;				| 
   1642  05 59 e 0 0 d8c0 0000  	movw d, r[0];		scrmem->am;	;				| 
   1643  05 45 e 0 0 7140 01c3  	;			 0x1c3->scrmemp; ;				| 
   1644  01 59 e 0 0 9600 0000  	subw,s d, r[0], y;	scrmem->am;	;				| 
   1645  05 0a 3 0 4 d840 1647  	movw r[0], y;		am->scrmem;	cjp, zer fsfrm;		scrmp +	| 
   1646  05 0d 3 f 7 d840 1646  	movw r[0], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1647  01 49 e 0 0 d85a 0004  fsfrm:	 movw,s r[26], y;		4->am;	;				| 
   1648  05 00 3 8 0 d8cf 164a  	movw d, r[15];	;		cjp, ~zer fsfropmode;		| if (r[26]) r[15]= 4
   1649  05 49 e 0 0 d8cf 0006  	movw d, r[15];	6->am;	;				| else r[15]= 6
   164a  05 49 e 0 0 f8c1 0006  fsfropmode: movw d, acc;	6->am;	;				| 
   164b  15 00 1 0 0 7140 14e7  	;			;		cjs, go vropmode;		| 
   164c  05 00 e 0 0 d819 0000  	movw r[25], acc;		;		;				| r[14]= (r[25]+r[14])>>4.  (>>4 == <<12).
   164d  05 49 e 0 0 988e 0fff  	addw r[14], acc, r[14];	0xfff->am;	;				| 
   164e  05 53 e 0 0 99ee 8010  	rolw 12, r[14], r[14];	0x8010->vloareg; ;			| vhiareg unchanged.  mask off high bits of rotate.
   164f  05 00 e 0 0 9ece 0000  	andw d, r[14], r[14];	;		;				| 
   1650  01 59 e 0 0 960e 0000  	subw,s d, r[14], y;	scrmem->am;	;				| 
   1651  05 0a 3 0 4 d84e 1653  	movw r[14], y;		am->scrmem;	cjp, zer fsfcnt;	scrmp +	| 
   1652  05 0d 3 f 7 d84e 1652  	movw r[14], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 1st 1/2 cg2_setwidth (..., r[14], r[14]).
   1653  05 53 e 0 0 7140 8012  fsfcnt:	;			0x8012->vloareg; ;			| vhiareg unchanged.
   1654  01 59 e 0 0 960e 0000  	subw,s d, r[14], y;	scrmem->am;	;				| 
   1655  05 0a 3 0 4 d84e 1657  	movw r[14], y;		am->scrmem;	cjp, zer fsfsh;		scrmp +	| 
   1656  05 0d 3 f 7 d84e 1656  	movw r[14], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 2nd 1/2 cg2_setwidth (..., r[14], r[14]).
   1657  05 53 e 0 0 7140 800c  fsfsh:	;			0x800c->vloareg; ;			| vhiareg unchanged.
   1658  01 59 e 0 0 f195 0000  	sub2nw,s 8, d, y;	scrmem->am;	;				| 
   1659  05 0a 3 0 4 f196 165b  	mov2nw 8, y;		am->scrmem;	cjp, zer fsfsrc2a;	scrmp +	| 
   165a  05 0d 3 f 7 f196 165a  	mov2nw 8, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setshift (..., 0, 1).
   165b  05 00 e 0 0 d81b 0000  fsfsrc2a: movw r[27], acc;	;		;				| 
   165c  05 00 e 0 0 b1db 0000  	romw 8, r[27], acc, 0xff00; ;		;				| instruction completes on next cycle.
   165d  05 53 e 0 0 ff00 8804  	;			0x8804->vloareg; ;			| vhiareg unchanged.
   165e  01 59 e 0 0 e200 0000  	subw,s d, acc, y;	scrmem->am;	;				| 
                                |	movw acc, y;		am->scrmem;	cjp, zer fsfrwrd;	scrmp +	| ELIMINATE ??
   165f  05 0d 3 f 7 f880 165f  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1660  05 00 e 0 0 d816 0000  fsfrwrd: movw r[22], acc;	;		;				| 
   1661  05 00 e 0 0 8090 0000  	addw r[16], acc, acc;	;		;				| 
   1662  15 00 1 0 0 d882 11c6  	movw acc, r[2];	;		cjs, go MulSWWid;		| cg2_ropword (dmd, 0, pos0.x, pos0.x)
   1663  05 00 e 0 0 d815 0000  	movw r[21], acc;	;		;				| 
   1664  05 00 e 0 0 9891 0000  	addw r[17], acc, r[17];	;		;				| 
   1665  05 00 e 0 0 9b91 0000  	rolw 13, r[17], acc;	;		;				| cg2_ropword: (x>>4)*(sizeof(short))
   1666  05 49 e 0 0 e2c1 1fff  	andw d, acc, acc;	0x1fff->am;	;				| a5_adr= cg2_ropword	
   1667  05 13 e 0 0 9880 0000  	addw r[0], acc, r[0]; am->vloareg;	;				| 
   1668  05 49 e 0 0 86bf 0020  	addcw d, r[31], acc;	0x20->am;	;				| 
   1669  05 12 e 0 0 9881 0000  	addw r[1], acc, r[1]; am->vhiareg;	;				| 
                                | switch (d5_count) unwrapped.  r[26] part separated out.
   166a  01 00 e 0 0 d85a 0000  fsfcolor:  movw,s r[26], y;	;		;				| 
   166b  05 04 3 8 0 d84e 1671  	movw r[14], y;		am->brreg;	cjp, ~zer fsfnodst;		| 
   166c  1d 00 4 0 0 7140 0000  	;			;		push, go;			| 
   166d  05 0d 3 f 7 d85b 166d  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| value written is immaterial.
   166e  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   166f  0d 00 8 0 1 7140 0000  	;			;		rfct;			varegs +| 
   1670  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   1671  01 49 e 0 0 960e 0002  fsfnodst: subw,s d, r[14], y;	2->am;		;				| 
   1672  01 00 3 9 0 d84e 1678  	 movw,s r[14], y;		;		cjp, ~neg fsf2;			| 
   1673  05 0d 3 f 7 d85b 1673  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1674  0d 00 a 0 1 7140 0000  	;			;		crtn, zer;		varegs +| 
   1675  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   1676  05 00 3 f 7 7140 1676  	;			;		cjp, ~vir .;		vmewr	| 
   1677  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   1678  05 12 e 0 0 d85e 0000  fsf2:	movw r[30], y;		am->vhiareg;	;				| 
   1679  05 53 e 0 0 e386 8010  	mov2nw 1, acc;		0x8010->vloareg; ;			| 
   167a  05 45 e 0 0 7140 01c4  	;			0x1c4->scrmemp; ;				| 
   167b  01 59 e 0 0 e395 0000  	sub2nw,s 1, d, y;	scrmem->am;	;				| 
   167c  05 0a 3 0 4 e396 167e  	mov2nw 1, y;		am->scrmem;	cjp, zer fsfcnt1;	scrmp +	| 
   167d  05 0d 3 f 7 f880 167d  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 1st 1/2 cg2_setwidth (..., 2, 2).
   167e  05 53 e 0 0 7140 8012  fsfcnt1: ;			0x8012->vloareg; ;			| vhiareg unchanged.
   167f  01 59 e 0 0 e395 0000  	sub2nw,s 1, d, y;	scrmem->am;	;				| 
   1680  05 0a 3 0 4 e396 1682  	mov2nw 1, y;		am->scrmem;	cjp, zer fsfcol0;	scrmp +	| 
   1681  05 0d 3 f 7 f880 1681  fsfcount1: movw acc, y;		am->vwdreg;	cjp, ~vir fsfcount1;	vmewr	| 2nd 1/2 cg2_setwidth (..., 2, 2).
   1682  05 13 e 0 0 d840 0000  fsfcol0: movw r[0], y;	am->vloareg;	;				| 
   1683  05 12 e 0 0 d841 0000  	movw r[1], y;		am->vhiareg;	;				| 
   1684  05 0d 3 f 7 d85b 1684  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| *(a5_adr)++= d3_color (value is immaterial)
   1685  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   1686  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   1687  05 00 3 f 7 7140 1687  	;			;		cjp, ~vir .;		vmewr	| *(a5_adr)++= d3_color (value is immaterial)
   1688  01 49 e 0 1 9e0e 0003  	subw,s d, r[14], r[14];	3->am;		;			varegs +| r[14] less 3 so "fastloop" right num
   1689  05 00 3 1 1 7140 169a  	;			;		cjp, neg fsfvmewr3;	varegs +| 
   168a  15 00 1 0 0 d80f 14e7  	movw r[15], acc;	;		cjs, go vropmode;		| 
   168b  01 49 e 0 0 9e80 0004  	addw,s d, r[0], r[0];4->am;		;				| Sync r[0] with vme addr counter.
   168c  05 13 3 a 0 d840 168e  	movw r[0], y;		am->vloareg;	cjp, ~cry fsfncry1;		| 
   168d  05 00 e 0 0 dd61 0000  	incw r[1], r[1];	;		;				| Sync r[1] with vme addr counter.
   168e  05 04 e 0 0 d84e 0000  fsfncry1: movw r[14], y;	am->brreg;	;				| Get ready to load counter.
   168f  1d 12 4 0 0 d841 0000  	movw r[1], y;		am->vhiareg;	push, go;			| 
   1690  05 0d 3 f 7 d85b 1690  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| (value is immaterial)
   1691  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   1692  0d 49 8 0 1 7140 0006  	;			6->am;	rfct;			varegs +| 
   1693  15 00 1 0 0 f8c1 14e7  	movw d, acc;		;		cjs, go vropmode;		| 
   1694  04 00 e 0 0 cc0e 0000  	sl0w r[14], r[0];	;		;				| 
   1695  01 49 e 0 0 8680 0002  	addw,s d, r[0], acc;	2->am;		;				| 
   1696  01 13 3 a 0 9880 1698  	addw,s r[0], acc, r[0];am->vloareg;	cjp, ~cry fsfvmewr2;		| 
   1697  05 00 e 0 0 dc41 0000  	incw r[1], y;		;		;				| 
   1698  05 12 3 a 0 d841 169a  fsfvmewr2: movw r[1], y;	am->vhiareg;	cjp, ~cry fsfvmewr3;		| 
   1699  05 12 e 0 0 dc41 0000  	incw r[1], y;		am->vhiareg;	;				| 
   169a  05 0d 3 f 7 f900 169a  fsfvmewr3: movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| (value is immaterial)
   169b  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   169c  05 00 e 0 0 7140 0000  plginit: ;			;		;				| initialize plyfill.
   169d  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   169e  05 00 e 0 0 7140 0000  plhfill: ;			;		;				| 
   169f  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
                                |   Gouraud shading.
                                |   Shading routine (#24).  Shaded 2D.  Assume r[27] r[31] has been initialized by shinit.
   16a0  05 61 3 d 0 d8d0 16a0  plgsh:	movw d, r[16];		fifo1->am;	cjp, f1e .;			| 
   16a1  05 61 3 d 0 d8d1 16a1  	movw d, r[17];		fifo1->am;	cjp, f1e .;			| 
   16a2  05 61 3 d 0 d8d2 16a2  	movw d, r[18];		fifo1->am;	cjp, f1e .;			| 
   16a3  00 00 e 0 2 9e51 0000  	rsubw,s d, r[17], r[18];	;		;				| 
   16a4  05 00 e 0 0 c1f2 0000  	sub2nw 0, r[18];		;		;				| Dont draw pixel of last point (for fitting).
   16a5  05 61 3 d 0 d8dc 16a5  	movw d, r[28];		fifo1->am;	cjp, f1e .;			| 
   16a6  05 61 3 d 0 d8cb 16a6  	movw d, r[11];		fifo1->am;	cjp, f1e .;			| 
   16a7  05 61 3 d 0 d8ca 16a7  	movw d, r[10];		fifo1->am;	cjp, f1e .;			| 
   16a8  05 61 3 d 0 d8cd 16a8  	movw d, r[13];		fifo1->am;	cjp, f1e .;			| 
   16a9  05 61 3 d 3 d8cc 16a9  	movw d, r[12];		fifo1->am;	cjp, f1e .;		scrmp 0	| 
   16aa  05 0a 3 0 4 d84c 1128  	movw r[12], y;		am->scrmem;	cjp, zer start;		scrmp +	| store r[12] in scratch memory location 0.
   16ab  05 0a e 0 0 d84d 0000  	movw r[13], y;		am->scrmem;	;				| store r[13] in scratch memory location 1.
   16ac  04 49 e 0 7 9f3c fffe  	norw d, r[28], r[23];	0xfffe->am;	;				| 
   16ad  05 00 e 0 0 cc9c 0000  	sr0w r[28], r[28];		;		;				| r[28] >> 1
   16ae  05 49 e 0 0 9edc 000f  	andw d, r[28], r[28];		0xf->am;	;				| 
   16af  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   16b0  05 00 3 f 0 7140 16b0  	;			;		cjp, ~vir .;			| Wait till vctlreg ready.
   16b1  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   16b2  05 45 e 0 0 7140 01c0  	;			0x1c0->scrmemp; ;				| 
   16b3  01 59 e 0 0 961c 0000  	subw,s d, r[28], y;	scrmem->am;	;				| 
   16b4  05 0a 3 0 4 d85c 16b7  	movw r[28], y;		am->scrmem;	cjp, zer plgdst;	scrmp +	| 
   16b5  05 53 e 0 0 7140 800e  	;			 0x800e->vloareg; ;			| vhiareg unchanged.
   16b6  05 0d 3 f 7 d85c 16b6  	movw r[28], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setfunction (..., r[28]).
                                | PIXOP_NEEDS_DST (r[28] << 1)= (r[28]^(r[28] << 1)) & 0xa
   16b7  05 00 e 0 0 d81c 0000  plgdst:	movw r[28], acc;		;		;				| 
   16b8  05 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;				| 
   16b9  05 00 e 0 0 811c 0000  	xorw r[28], acc, acc;	;		;				| 
   16ba  01 49 e 0 0 e281 000a  	addw,s d, acc, acc;	0xa->am;	;				| 
   16bb  05 00 3 8 0 d91a 16bd  	movw 0, r[26];		;		cjp, ~zer plg2rej;		| 
   16bc  05 00 e 0 0 dd1a 0000  	incw 0, r[26];		;		;				| 
   16bd  01 44 e 0 0 d850 1128  plg2rej: movw,s r[16], y;		=start->brreg;	;				| 
   16be  09 49 3 1 0 9610 0400  	subw,s d, r[16], y;	 1024->am;	cjp, neg;			| if (r[16] < 0) trivial rejection.
   16bf  09 00 3 9 0 d852 0000  	movw,s r[18], y;		;		cjp, ~neg;			| if (r[16] >  1024) trivial rejection.
   16c0  09 49 3 1 0 9611 0400  	subw,s d, r[17], y;	 1024->am;	cjp, neg;			| if (r[18] < 0) trivial rejection.
   16c1  09 44 3 9 0 d851 16c4  	movw,s r[17], y;		=plg2x0ok->brreg; cjp, ~neg;			| if (r[17] >  1024) trivial rejection.
   16c2  09 49 3 9 0 9612 0400  	subw,s d, r[18], y;	 1024->am;	cjp, ~neg;			| 
   16c3  05 00 e 0 0 d911 0000  	movw 0, r[17];		;		;				| 
   16c4  05 00 3 1 0 7140 16c6  plg2x0ok: ;			;		cjp, neg plg2x1ok;		| 
   16c5  05 49 e 0 0 d8d2 03ff  	movw d, r[18];		 1023->am;	;				| 
   16c6  01 45 e 0 0 d857 0190  plg2x1ok:  movw,s r[23], y;		 0x190->scrmemp; ;				| 
   16c7  05 0a 3 0 4 d850 16e9  	movw r[16], y;		am->scrmem;	cjp, zer plg2draw;	scrmp +	| 
   16c8  05 0a e 0 4 d851 0000  	movw r[17], y;		am->scrmem;	;			scrmp +	| 
   16c9  05 0a e 0 4 d852 0000  	movw r[18], y;		am->scrmem;	;			scrmp +	| 
   16ca  05 0a e 0 4 d84b 0000  	movw r[11], y;		am->scrmem;	;			scrmp +	| 
   16cb  05 0a e 0 4 d84a 0000  	movw r[10], y;		am->scrmem;	;			scrmp +	| 
   16cc  05 49 e 0 0 d8d8 0500  	movw d, r[24];	0x500->am;	;				| 
   16cd  05 45 e 0 0 7140 0500  	;			0x500->scrmemp; ;				| 
   16ce  01 59 e 0 4 d8d5 0000  plg2clip: movw,s d, r[21];	scrmem->am;	;			scrmp +	| 4 tests for rejection follow.
   16cf  05 00 3 1 0 dc11 1128  	incw r[17], acc;		;		cjp, neg start;			| Recreate r[18]
   16d0  05 00 e 0 0 9892 0000  	addw r[18], acc, r[18];	;		;				| 
   16d1  01 00 e 0 0 9612 0000  	subw,s d, r[18], y;	;		;				| 
   16d2  05 59 3 1 4 d8d6 16ea  	movw d, r[22];	scrmem->am;	cjp, neg plg2reset;	scrmp +	| 
   16d3  01 00 e 0 0 9610 0000  	subw,s d, r[16], y;	;		;				| 
   16d4  05 59 3 1 4 8695 16ea  	addw d, r[21], acc;	scrmem->am;	cjp, neg plg2reset;	scrmp +	| r[19] + r[21]
   16d5  05 00 e 0 0 d893 0000  	movw acc, r[19];	;		;				| save in r[19]
   16d6  01 00 e 0 0 9051 0000  	rsubw,s r[17], acc, y;	;		;				| 
   16d7  05 59 3 9 0 8696 16ea  	addw d, r[22], acc;	scrmem->am;	cjp, ~neg plg2reset;		| r[20] + r[22]
   16d8  01 00 e 0 0 9050 0000  	rsubw,s r[16], acc, y;	;		;				| 
   16d9  05 00 3 9 0 7140 16ea  	;			;		cjp, ~neg plg2reset;		| Last rejection test.
   16da  05 00 e 0 0 d815 0000  	movw r[21], acc;	;		;				| 
   16db  01 00 e 0 0 8011 0000  	subw,s r[17], acc, acc;	;		;				| 
   16dc  05 00 3 1 0 7140 16e3  	;			;		cjp, neg plg2right;		| 
   16dd  04 00 e 0 5 d96d 0000  	movw r[13], r[5];	;		;				| Change initial r[27]
   16de  14 00 1 0 2 d96c 118e  	movw r[12], r[2];	;		cjs, go muldbl;			| 
   16df  05 00 e 0 0 d80b 0000  	movw r[11], acc;		;		;				| 
                                |	movw r[10], y;		am->am;		;				| NEW
                                |	addw d, r[1], r[10];	;		;				| 
                                |	addcw r[0], acc, r[11];	;		;				| 
   16e0  04 00 e 0 b 9880 0000  	addw r[0], acc, r[11];	;		;				| 
   16e1  05 00 e 0 0 d815 0000  	movw r[21], acc;	;		;				| 
   16e2  05 00 e 0 0 d891 0000  	movw acc, r[17];		;		;				| 
   16e3  05 00 e 0 0 d813 0000  plg2right: movw r[19], acc;	;		;				| 
   16e4  01 00 e 0 0 8012 0000  	subw,s r[18], acc, acc;	;		;				| 
   16e5  05 00 3 9 0 7140 16e7  	;			;		cjp, ~neg plg2drawdx;		| 
   16e6  05 00 e 0 0 9892 0000  	addw r[18], acc, r[18];	;		;				| 
   16e7  05 09 e 0 0 dc51 0000  plg2drawdx: incw r[17], y;		am->am;		;				| Restore r[18].
   16e8  05 00 e 0 0 9e12 0000  	subw d, r[18], r[18];		;		;				| 
   16e9  15 00 1 0 0 7140 16f3  plg2draw: ;			;		cjs, go gs0draw;		| 
   16ea  01 45 e 0 0 d857 0190  plg2reset:  movw,s r[23], y;	 0x190->scrmemp; ;				| 
   16eb  01 45 e 0 0 d857 0190  	 movw,s r[23], y;		 0x190->scrmemp; ;				| 
   16ec  05 59 3 0 4 d8d0 1128  	movw d, r[16];		scrmem->am;	cjp, zer start;		scrmp +	| 
   16ed  05 59 e 0 4 d8d1 0000  	movw d, r[17];		scrmem->am;	;			scrmp +	| 
   16ee  05 59 e 0 4 d8d2 0000  	movw d, r[18];		scrmem->am;	;			scrmp +	| 
   16ef  05 59 e 0 4 d8cb 0000  	movw d, r[11];		scrmem->am;	;			scrmp +	| 
   16f0  05 59 e 0 4 d8ca 0000  	movw d, r[10];		scrmem->am;	;			scrmp +	| 
   16f1  05 49 e 0 0 7140 0004  	;			4->am;		;				| 
   16f2  15 05 3 0 0 9e98 16ce  	addw d, r[24], r[24]; am->scrmemp;	cjp, go plg2clip;		| 
                                |   gsdraw:  shaded 2d segments.
   16f3  15 00 1 0 0 7140 17ab  gs0draw: ;			;		cjs, go gsprime;		| 
   16f4  05 44 e 0 0 7140 16f5  	;			=gs0rmw->brreg;	;				| Return here for next r[23].
                                |   ELIMINATE GRAPHICS BUFFER STUFF? !!
   16f5  0d 56 3 e 0 d810 a000  gs0rmw:	movw r[16], acc;		0xa000->zbhiptr; cjp, ~zbr;			| Set read-modify-write mode.
   16f6  15 00 1 0 0 d882 11c3  	movw acc, r[2];		;		cjs, go MulSWid;		| Calculate address.
   16f7  05 00 e 0 0 d811 0000  	movw r[17], acc;		;		;				| 
   16f8  04 13 e 0 e 9880 0000  	addw r[0], acc, r[14];	am->vloareg;	;				| 
   16f9  05 49 e 0 0 86a1 0020  	addcw d, r[1], acc;	0x20->am;	;				| Pixel mode memory.
   16fa  05 12 e 0 0 909f 0000  	addw r[31], acc, y;	am->vhiareg;	;				| 
   16fb  05 49 e 0 0 c20f 0020  	subw d, acc, r[15];	0x20->am;	;				| 
   16fc  05 16 3 e 0 d84f 16fc  	movw r[15], y;		am->zbhiptr;	cjp, ~zbr .;			| Not altering read-modify-write mode.
   16fd  05 17 3 e 5 d84e 16fd  	movw r[14], y;		am->zbloptr;	cjp, ~zbr .;		zbrd	| At least 8 cycles after setting rmw.
   16fe  05 44 e 0 0 7140 1702  	;			=gs0loop->brreg; ;				| 
   16ff  05 00 3 f 0 d812 16ff  	movw r[18], acc;		;		cjp, ~vir .;			| 
   1700  05 54 e 0 3 7140 0060  	;			0x60->vctlreg;	;			scrmp 0	| 
   1701  15 00 3 0 0 7140 1704  	;			;		cjp, go gs0dec;			| Shaded segment.
   1702  05 00 e 0 1 9e8a 0000  gs0loop: addw d, r[10], r[10];	;		;			varegs+	| increment c.
                                |	addcw d, r[11], r[11];	scrmem->am;	cjp, neg gs0quit;	scrmp 0	| OLD
                                |	addcw d, r[11], r[11];	scrmem->am;	crtn, neg;		scrmp 0	| NEW
   1703  05 59 e 0 3 9eab 0000  	addcw d, r[11], r[11];	scrmem->am;	;			scrmp 0	| NEWEST
   1704  01 59 e 0 4 e185 0000  gs0dec:	sub2nw,s 0, acc;		scrmem->am;	;			scrmp +	| dec loop counter.
   1705  0d 0d 3 9 f d84b 1705  	movw r[11], y;		am->vwdreg;	cjp, ~neg.3 .;		vmewr	| write r[27]
   1706  1d 00 a 0 0 7140 0000  gs0quit: ;			;		crtn, go;			| OLD
                                |   3D Segments, shaded and solid.  (#25).
   1707  05 61 3 d 0 d8d0 1707  plhsh:	movw d, r[16];		fifo1->am;	cjp, f1e .;			| 
   1708  05 61 3 d 0 d8d1 1708  	movw d, r[17];		fifo1->am;	cjp, f1e .;			| 
   1709  05 61 3 d 0 d8d2 1709  	movw d, r[18];		fifo1->am;	cjp, f1e .;			| 
   170a  00 00 e 0 2 9e51 0000  	rsubw,s d, r[17], r[18];	;		;				| 
   170b  05 00 e 0 0 c1f2 0000  	sub2nw 0, r[18];		;		;				| Dont draw pixel of last point (for fitting).
   170c  05 61 3 d 0 d8dc 170c  	movw d, r[28];		fifo1->am;	cjp, f1e .;			| 
   170d  05 61 3 d 0 d8c7 170d  	movw d, r[7];		fifo1->am;	cjp, f1e .;			| 
                                |	movw d, r[6];		fifo1->am;	cjp, f1e .;			| NEW
   170e  05 49 e 0 0 d8c6 7fff  	movw d, r[6];		0x7fff->am;	;				| OLD
   170f  05 61 3 d 0 d8c9 170f  	movw d, r[9];		fifo1->am;	cjp, f1e .;			| 
   1710  05 61 3 d 0 d8c8 1710  	movw d, r[8];		fifo1->am;	cjp, f1e .;			| 
   1711  05 61 3 d 0 d8cb 1711  	movw d, r[11];		fifo1->am;	cjp, f1e .;			| 
   1712  05 61 3 d 0 d8ca 1712  	movw d, r[10];		fifo1->am;	cjp, f1e .;			| 
   1713  05 61 3 d 0 d8cd 1713  	movw d, r[13];		fifo1->am;	cjp, f1e .;			| 
   1714  05 61 3 d 3 d8cc 1714  	movw d, r[12];		fifo1->am;	cjp, f1e .;		scrmp 0	| 
   1715  05 0a 3 0 4 d848 1128  	movw r[8], y;		am->scrmem;	cjp, zer start;		scrmp +	| store r[8] in scratch memory location 0.
   1716  05 0a e 0 4 d849 0000  	movw r[9], y;		am->scrmem;	;			scrmp +	| store r[9] in scratch memory location 1.
   1717  05 0a e 0 4 d84c 0000  	movw r[12], y;		am->scrmem;	;			scrmp +	| store r[12] in scratch memory location 2.
   1718  05 0a e 0 0 d84d 0000  	movw r[13], y;		am->scrmem;	;				| store r[13] in scratch memory location 3.
   1719  04 49 e 0 7 9f3c fffe  	norw d, r[28], r[23];	0xfffe->am;	;				| 
   171a  05 00 e 0 0 cc9c 0000  	sr0w r[28], r[28];		;		;				| r[28] >> 1
   171b  05 49 e 0 0 9edc 000f  	andw d, r[28], r[28];		0xf->am;	;				| 
                                | PIXOP_NEEDS_DST (r[28] << 1)= (r[28]^(r[28] << 1)) & 0xa
                                |	movw r[28], acc;		;		;				| ELIMINATE?
                                |	sl0w acc, acc;		;		;				| 
                                |	xorw r[28], acc, acc;	;		;				| 
                                |	addw,s d, acc, acc;	0xa->am;	;				| 
                                |	movw 0, r[26];		;		cjp, ~zer plhrej;		| 
                                |	incw 0, r[26];		;		;				| 
   171c  01 44 e 0 0 d850 1128  plhrej:	movw,s r[16], y;		=start->brreg;	;				| 
   171d  09 49 3 1 0 9610 0400  	subw,s d, r[16], y;	 1024->am;	cjp, neg;			| if (r[16] < 0) trivial rejection.
   171e  09 00 3 9 0 d852 0000  	movw,s r[18], y;		;		cjp, ~neg;			| if (r[16] >  1024) trivial rejection.
   171f  09 49 3 1 0 9611 0400  	subw,s d, r[17], y;	 1024->am;	cjp, neg;			| if (r[18] < 0) trivial rejection.
   1720  09 44 3 9 0 d851 1723  	movw,s r[17], y;		=plhx0ok->brreg; cjp, ~neg;			| if (r[17] >  1024) trivial rejection.
   1721  09 49 3 9 0 9612 0400  	subw,s d, r[18], y;	 1024->am;	cjp, ~neg;			| 
   1722  05 00 e 0 0 d911 0000  	movw 0, r[17];		;		;				| 
   1723  05 00 3 1 0 7140 1725  plhx0ok: ;			;		cjp, neg plhx1ok;		| 
   1724  05 49 e 0 0 d8d2 03ff  	movw d, r[18];		 1023->am;	;				| 
   1725  01 45 e 0 0 d857 0190  plhx1ok:  movw,s r[23], y;		 0x190->scrmemp; ;				| 
   1726  05 0a 3 0 4 d850 1750  	movw r[16], y;		am->scrmem;	cjp, zer plhdraw;	scrmp +	| 
   1727  05 0a e 0 4 d851 0000  	movw r[17], y;		am->scrmem;	;			scrmp +	| 
   1728  05 0a e 0 4 d852 0000  	movw r[18], y;		am->scrmem;	;			scrmp +	| 
   1729  05 0a e 0 4 d84b 0000  	movw r[11], y;		am->scrmem;	;			scrmp +	| 
   172a  05 0a e 0 4 d84a 0000  	movw r[10], y;		am->scrmem;	;			scrmp +	| 
   172b  05 0a e 0 4 d847 0000  	movw r[7], y;		am->scrmem;	;			scrmp +	| 
   172c  05 0a e 0 4 d846 0000  	movw r[6], y;		am->scrmem;	;			scrmp +	| 
   172d  05 49 e 0 0 d8d8 0500  	movw d, r[24];	0x500->am;	;				| 
   172e  05 45 e 0 0 7140 0500  	;			0x500->scrmemp; ;				| 
   172f  01 59 e 0 4 d8d5 0000  plhclip: movw,s d, r[21];	scrmem->am;	;			scrmp +	| Rtrn here for next r[23].  4 tests for rejection.
   1730  05 00 3 1 0 dc11 1128  	incw r[17], acc;		;		cjp, neg start;			| Recreate r[18]
   1731  05 00 e 0 0 9892 0000  	addw r[18], acc, r[18];	;		;				| 
   1732  01 00 e 0 0 9612 0000  	subw,s d, r[18], y;	;		;				| 
   1733  05 59 3 1 4 d8d6 1751  	movw d, r[22];	scrmem->am;	cjp, neg plhreset;	scrmp +	| 
   1734  01 00 e 0 0 9610 0000  	subw,s d, r[16], y;	;		;				| 
   1735  05 59 3 1 4 8695 1751  	addw d, r[21], acc;	scrmem->am;	cjp, neg plhreset;	scrmp +	| r[19] + r[21]
   1736  05 00 e 0 0 d893 0000  	movw acc, r[19];	;		;				| save in r[19]
   1737  01 00 e 0 0 9051 0000  	rsubw,s r[17], acc, y;	;		;				| 
   1738  05 59 3 9 0 8696 1751  	addw d, r[22], acc;	scrmem->am;	cjp, ~neg plhreset;		| r[20] + r[22]
   1739  01 00 e 0 0 9050 0000  	rsubw,s r[16], acc, y;	;		;				| 
   173a  05 00 3 9 0 7140 1751  	;			;		cjp, ~neg plhreset;		| Last rejection test.
   173b  05 00 e 0 0 d815 0000  	movw r[21], acc;	;		;				| 
   173c  01 00 e 0 0 8011 0000  	subw,s r[17], acc, acc;	;		;				| 
   173d  05 00 3 1 0 7140 174a  	;			;		cjp, neg plhright;		| 
   173e  04 00 e 0 5 d96d 0000  	movw r[13], r[5];	;		;				| Change initial r[27]
   173f  14 00 1 0 2 d96c 118e  	movw r[12], r[2];	;		cjs, go muldbl;			| 
   1740  05 00 e 0 0 d80b 0000  	movw r[11], acc;		;		;				| 
                                |	movw r[10], y;		am->am;		;				| NEW
                                |	addw d, r[1], r[10];	;		;				| 
                                |	addcw r[0], acc, r[11];	;		;				| 
   1741  04 00 e 0 b 9880 0000  	addw r[0], acc, r[11];	;		;				| 
   1742  05 00 e 0 0 d815 0000  	movw r[21], acc;	;		;				| 
   1743  05 00 e 0 0 8011 0000  	subw r[17], acc, acc;	;		;				| 
   1744  04 00 e 0 5 d969 0000  	movw r[9], r[5];	;		;				| Change initial z
   1745  14 00 1 0 2 d968 118e  	movw r[8], r[2];	;		cjs, go muldbl;			| 
   1746  05 00 e 0 0 d807 0000  	movw r[7], acc;		;		;				| 
                                |	movw r[6], y;		am->am;		;				| NEW
                                |	addw d, r[1], r[6];	;		;				| 
                                |	addcw r[0], acc, r[7];	;		;				| 
   1747  04 00 e 0 7 9880 0000  	addw r[0], acc, r[7];	;		;				| 
   1748  05 00 e 0 0 d815 0000  	movw r[21], acc;	;		;				| 
   1749  05 00 e 0 0 d891 0000  	movw acc, r[17];		;		;				| 
   174a  05 00 e 0 0 d813 0000  plhright: movw r[19], acc;	;		;				| 
   174b  01 00 e 0 0 8012 0000  	subw,s r[18], acc, acc;	;		;				| 
   174c  05 00 3 9 0 7140 174e  	;			;		cjp, ~neg plhdrawdx;		| 
   174d  05 00 e 0 0 9892 0000  	addw r[18], acc, r[18];	;		;				| 
   174e  05 09 e 0 0 dc51 0000  plhdrawdx: incw r[17], y;		am->am;		;				| Restore r[18].
   174f  05 00 e 0 0 9e12 0000  	subw d, r[18], r[18];		;		;				| 
   1750  15 00 1 0 0 7140 175b  plhdraw: ;			;		cjs, go gsdraw;			| 
   1751  01 45 e 0 0 d857 0190  plhreset:  movw,s r[23], y;		 0x190->scrmemp; ;				| 
   1752  05 59 3 0 4 d8d0 1128  	movw d, r[16];		scrmem->am;	cjp, zer start;		scrmp +	| 
   1753  05 59 e 0 4 d8d1 0000  	movw d, r[17];		scrmem->am;	;			scrmp +	| 
   1754  05 59 e 0 4 d8d2 0000  	movw d, r[18];		scrmem->am;	;			scrmp +	| 
   1755  05 59 e 0 4 d8cb 0000  	movw d, r[11];		scrmem->am;	;			scrmp +	| 
   1756  05 59 e 0 4 d8ca 0000  	movw d, r[10];		scrmem->am;	;			scrmp +	| 
   1757  05 59 e 0 4 d8c7 0000  	movw d, r[7];		scrmem->am;	;			scrmp +	| 
   1758  05 59 e 0 4 d8c6 0000  	movw d, r[6];		scrmem->am;	;			scrmp +	| 
   1759  05 49 e 0 0 7140 0004  	;			4->am;		;				| 
   175a  15 05 3 0 0 9e98 172f  	addw d, r[24], r[24]; am->scrmemp;	cjp, go plhclip;		| 
                                |   gsdraw:  shaded and solid 3d segments with HSE.
   175b  01 00 e 0 0 d84d 0000  gsdraw:	 movw,s r[13], y;		;		;				| 
   175c  01 00 3 8 0 d84c 175e  	 movw,s r[12], y;		;		cjp, ~zer gsvctl;		| Shaded segment.
   175d  05 00 3 0 0 7140 1794  	;			;		cjp, zer constsh;		| 
   175e  05 00 3 f 0 7140 175e  gsvctl:	;			;		cjp, ~vir .;			| 
   175f  05 54 e 0 0 7140 0060  	;			0x60->vctlreg;	;				| 
   1760  05 44 e 0 0 7140 1761  	;			=gsrmw->brreg;	;				| 
   1761  0d 56 3 e 0 d810 a000  gsrmw:	movw r[16], acc;		0xa000->zbhiptr; cjp, ~zbr;			| Set read-modify-write mode.
   1762  15 00 1 0 0 d882 11c3  	movw acc, r[2];		;		cjs, go MulSWid;		| Calculate address.
   1763  05 00 e 0 0 d811 0000  	movw r[17], acc;		;		;				| 
   1764  04 13 e 0 e 9880 0000  	addw r[0], acc, r[14];	am->vloareg;	;				| 
   1765  04 49 e 0 f 9ea1 0000  	addcw d, r[1], r[15];	0->am;		;				| 
   1766  01 49 e 0 0 961c 000c  	subw,s d, r[28], y;	0xc->am;	;				| if (r[28] == SRC)
   1767  05 49 e 0 0 868f 0010  	addw d, r[15], acc;	0x10->am;	;				| Pixel mode memory
   1768  05 00 3 8 0 7140 177b  	;			;		cjp, ~zer gsnsrc;		| 
   1769  05 12 e 0 0 909f 0000  	addw r[31], acc, y;	am->vhiareg;	;				| 
   176a  05 16 3 e 0 d84f 176a  	movw r[15], y;		am->zbhiptr;	cjp, ~zbr .;			| Not altering read-modify-write mode.
   176b  05 17 3 e 5 d84e 176b  	movw r[14], y;		am->zbloptr;	cjp, ~zbr .;		zbrd	| At least 8 cycles after setting rmw.
   176c  05 44 e 0 0 d812 176e  	movw r[18], acc;		=gsloop->brreg;	;				| 
   176d  15 00 3 0 0 7140 1772  	;			;		cjp, go gsztst;			| 
   176e  05 00 e 0 0 9e86 0000  gsloop:	addw d, r[6], r[6];	;		;				| increment z.
   176f  05 59 3 1 4 9ea7 1778  gsloop1: addcw d, r[7], r[7];	scrmem->am;	cjp, neg gsquit;	scrmp +	| 
   1770  05 59 e 0 4 9e8a 0000  	addw d, r[10], r[10];	scrmem->am;	;			scrmp +	| increment r[27].
   1771  05 59 e 0 1 9eab 0000  	addcw d, r[11], r[11];	scrmem->am;	;			varegs+	| 
   1772  01 21 3 e 3 9607 1772  gsztst:	subw,s d, r[7], y;	zbrdreg->am;	cjp, ~zbr .;		scrmp 0	| compare z with z-buffer value.
   1773  01 59 3 2 4 e185 1777  	sub2nw,s 0, acc;		scrmem->am;	cjp, cry gsabrmw;	scrmp +	| dec loop counter.
   1774  05 0b 3 e 0 d847 1774  	movw r[7], y;		am->zbwdreg;	cjp, ~zbr .;			| write new z.
   1775  0d 0d 3 9 f d84b 1775  	movw r[11], y;		am->vwdreg;	cjp, ~neg.3 .;		vmewr	| write r[27]
   1776  15 00 3 0 0 7140 1778  	;			;		cjp, go gsquit;			| 
   1777  15 00 3 0 5 9e86 176f  gsabrmw: addw d, r[6], r[6];	;		cjp, go gsloop1;	zbrd	| abort read-mod-write wr phase.  do 1st loop instr.
   1778  05 44 e 0 0 7140 1779  gsquit:	;			=gsquit1->brreg; ;				| End read-mod-write so g-buffer released.
   1779  0d 56 3 e 0 7140 6000  gsquit1: ;			0x6000->zbhiptr; cjp, ~zbr;			| 
   177a  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   177b  05 49 e 0 0 868f 0020  gsnsrc:	addw d, r[15], acc;	0x20->am;	;				| 
   177c  05 00 e 0 0 809f 0000  	addw r[31], acc, acc;	;		;				| 
   177d  04 49 e 0 1 c1ee 0000  	sub2nw 0, r[14], r[1];	0->am;		;				| Pre-decrement because loop pre-increments.
   177e  15 00 1 0 0 c222 17ab  	subcw d, acc, r[2];	;		cjs, go gsprime;		| 
   177f  05 16 3 e 0 d84f 177f  	movw r[15], y;		am->zbhiptr;	cjp, ~zbr .;			| Not altering read-modify-write mode.
   1780  05 17 3 e 5 d84e 1780  	movw r[14], y;		am->zbloptr;	cjp, ~zbr .;		zbrd	| At least 8 cycles after setting rmw.
   1781  05 44 e 0 0 d812 1785  	movw r[18], acc;		=gs1loop->brreg; ;				| 
   1782  05 00 3 f 0 7140 1782  	;			;		cjp, ~vir .;			| 
   1783  05 54 e 0 0 7140 0060  	;			0x60->vctlreg;	;				| 
   1784  15 00 3 0 0 7140 178b  	;			;		cjp, go gs1ztst;		| 
   1785  05 00 e 0 0 9e86 0000  gs1loop: addw d, r[6], r[6];	;		;				| increment z.
   1786  05 59 3 1 4 9ea7 1778  gs1loop1: addcw d, r[7], r[7];	scrmem->am;	cjp, neg gsquit;	scrmp +	| 
   1787  05 59 e 0 4 9e8a 0000  	addw d, r[10], r[10];	scrmem->am;	;			scrmp +	| increment r[27].
   1788  15 59 1 0 0 9eab 17ab  	addcw d, r[11], r[11];	scrmem->am;	cjs, go gsprime;		| 
   1789  05 00 3 f 0 7140 1789  	;			;		cjp, ~vir .;			| 
   178a  05 54 e 0 0 7140 0060  	;			0x60->vctlreg;	;				| 
   178b  01 21 3 e 3 9607 178b  gs1ztst: subw,s d, r[7], y;	zbrdreg->am;	cjp, ~zbr .;		scrmp 0	| compare z with z-buffer value.
   178c  05 13 e 0 0 dd61 0000  	incw r[1], r[1];	am->vloareg;	;				| 
   178d  05 49 e 0 0 9ea2 0000  	addcw d, r[2], r[2];	0->am;		;				| 
   178e  05 12 e 0 0 d842 0000  	movw r[2], y;		am->vhiareg;	;				| 
   178f  01 59 3 2 4 e185 1793  	sub2nw,s 0, acc;		scrmem->am;	cjp, cry gs1abrmw;	scrmp +	| dec loop counter.
   1790  05 0b 3 e 0 d847 1790  	movw r[7], y;		am->zbwdreg;	cjp, ~zbr .;			| write new z.
   1791  0d 0d 3 9 f d84b 1791  	movw r[11], y;		am->vwdreg;	cjp, ~neg.3 .;		vmewr	| write r[27]
   1792  15 00 3 0 0 7140 1778  	;			;		cjp, go gsquit;			| 
   1793  15 00 3 0 5 9e86 1786  gs1abrmw: addw d, r[6], r[6];	;		cjp, go gs1loop1;	zbrd	| abort read-mod-write wr phase.  do 1st loop instr.
   1794  15 00 1 0 0 7140 17ab  constsh: ;			;		cjs, go gsprime;		| 
   1795  05 00 3 f 0 7140 1795  	;			;		cjp, ~vir .;			| 
   1796  05 54 e 0 0 7140 0060  	;			0x60->vctlreg;	;				| 
   1797  05 00 3 e 0 7140 1797  	;			;		cjp, ~zbr .;			| 
   1798  05 56 e 0 0 d810 a000  	movw r[16], acc;		0xa000->zbhiptr; ;				| Set read-modify-write mode.
   1799  15 00 1 0 0 d882 11c3  	movw acc, r[2];		;		cjs, go MulSWid;		| 
   179a  05 00 e 0 0 d811 0000  	movw r[17], acc;		;		;				| 
   179b  04 13 e 0 e 9880 0000  	addw r[0], acc, r[14];	am->vloareg;	;				| 
   179c  04 49 e 0 f 9ea1 0000  	addcw d, r[1], r[15];	0->am;		;				| 
   179d  05 49 e 0 0 868f 0020  	addw d, r[15], acc;	0x20->am;	;				| 
   179e  05 12 e 0 0 909f 0000  	addw r[31], acc, y;	am->vhiareg;	;				| 
   179f  05 16 3 e 0 d84f 179f  	movw r[15], y;		am->zbhiptr;	cjp, ~zbr .;			| 
   17a0  05 17 3 e 5 d84e 17a0  	movw r[14], y;		am->zbloptr;	cjp, ~zbr .;		zbrd	| at least 8 cycles after setting rmw.
   17a1  05 44 e 0 0 d812 17a3  	movw r[18], acc;		=segloop->brreg; ;				| 
   17a2  15 00 3 0 0 7140 17a5  	;			;		cjp, go segztst;		| 
   17a3  05 00 e 0 0 9e86 0000  segloop: addw d, r[6], r[6];	;		;				| increment z.
   17a4  05 59 3 1 1 9ea7 1778  segloop1: addcw d, r[7], r[7];	scrmem->am;	cjp, neg gsquit;	varegs+	| 
   17a5  01 21 3 e 3 9607 17a5  segztst: subw,s d, r[7], y;	zbrdreg->am;	cjp, ~zbr segztst;	scrmp 0	| compare z with z-buffer value.
   17a6  01 59 3 2 4 e185 17aa  	sub2nw,s 0, acc;		scrmem->am;	cjp, cry segabrmw;	scrmp +	| dec loop counter.
   17a7  05 0b 3 e 0 d847 17a7  	movw r[7], y;		am->zbwdreg;	cjp, ~zbr .;			| write new z.
   17a8  0d 0d 3 9 f d84b 17a8  	movw r[11], y;		am->vwdreg;	cjp, ~neg.3 .;		vmewr	| write r[27]
   17a9  15 00 3 0 0 7140 1778  	;			;		cjp, go gsquit;			| 
   17aa  15 00 3 0 5 9e86 17a4  segabrmw: addw d, r[6], r[6];	;		cjp, go segloop1;	zbrd	| abort read-mod-write wr phase. do 1st loop instr.
   17ab  05 00 e 0 0 d880 0000  gsprime: movw acc, r[0];	;		;				| 
   17ac  05 00 3 f 0 d80b 17ac  	movw r[11], acc;		;		cjp, ~vir .;			| 
   17ad  05 54 e 0 0 b1cb 0061  	romw 8, r[11], acc, 0xff00; 0x61->vctlreg; ;				| 
   17ae  05 53 e 0 0 ff00 8804  	;			0x8804->vloareg; ;			| 
   17af  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   17b0  05 0d 3 f 7 f880 17b0  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   17b1  1d 00 a 0 0 d800 0000  	movw r[0], acc;		;		crtn, go;			| 
                                |   Init r[27] frame buffer for gouraud shading.
   17b2  05 00 e 0 0 7140 0000  shinit: ;			;		;				| #19
   17b3  05 00 e 0 0 7140 0000  fillinit: ;			;		;				| 
   17b4  15 00 1 0 0 7140 1309  plhinit: ;			;		cjs, go ropreg;			| 
   17b5  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
                                | @(#)delay.pp.u 1.2 86/09/12 SMI
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |   delay code.  Expects delay (in milliseconds) in accumulator.  Assumes 120 ns. cycle time.
   17b6  05 00 e 0 0 d880 0000  delay:	movw acc, r[0];		;		;				| 
   17b7  01 49 e 0 0 f8c1 208a  delay0:	movw,s d, acc;		8330->am;	;				| 
   17b8  01 00 3 8 0 e185 17b8  	sub2nw,s 0, acc;		;		cjp, ~zer .;			| 
   17b9  01 00 e 0 0 c1e0 0000  	sub2nw,s 0, r[0];		;		;				| 
   17ba  05 00 3 9 0 7140 17b7  	;			;		cjp, ~neg delay0;		| 
   17bb  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   17bc  05 45 e 0 0 7140 018e  dbglvl:	;			0x18e->scrmemp; ;				| 
   17bd  05 61 3 d 0 f8c1 17bd  	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   17be  15 0a 3 0 0 f880 1128  	movw acc, y;		am->scrmem;	cjp, go start;			| 
   17bf  05 45 e 0 0 7140 018e  cndflash: ;			0x18e->scrmemp; ;				| Expects debuglevel in r[0], flash time in acc.
   17c0  01 59 e 0 0 9600 0000  	subw,s d, r[0], y;	scrmem->am;	;				| 
   17c1  05 00 1 0 0 7140 17c3  	;			;		cjs, zer flash;			| 
   17c2  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   17c3  05 00 e 0 3 7140 0000  flash:	;			;		;			scrmp 0	| Expects delay to be in accumulator.
   17c4  05 0a e 0 4 f880 0000  	movw acc, y;		am->scrmem;	;			scrmp +	| 
   17c5  05 0a e 0 4 d840 0000  	movw r[0], y;		am->scrmem;	;			scrmp +	| 
   17c6  05 0a e 0 4 d842 0000  	movw r[2], y;		am->scrmem;	;			scrmp +	| 
   17c7  15 00 1 0 0 7140 17b6  	;			;		cjs, go delay;			| 
   17c8  15 00 1 0 3 7140 17cf  	;			;		cjs, go vidoff;		scrmp 0	| 
   17c9  05 59 e 0 0 f8c1 0000  	movw d, acc;		scrmem->am;	;				| 
   17ca  15 00 1 0 0 7140 17b6  	;			;		cjs, go delay;			| 
   17cb  15 00 1 0 3 7140 17d6  	;			;		cjs, go vidon;		scrmp 0	| 
   17cc  05 00 e 0 4 7140 0000  	;			;		;			scrmp +	| 
   17cd  05 59 e 0 4 d8c0 0000  	movw d, r[0];		scrmem->am;	;			scrmp +	| 
   17ce  1d 59 a 0 4 d8c2 0000  	movw d, r[2];		scrmem->am;	crtn, go;		scrmp +	| 
   17cf  05 12 3 f 0 d85e 17cf  vidoff:	movw r[30], y;		am->vhiareg;	cjp, ~vir vidoff;		| 
   17d0  05 53 e 0 0 7140 9000  	;			0x9000->vloareg; ;				| 
   17d1  05 54 e 0 0 7140 0073  	;			0x73->vctlreg;	;				| 
   17d2  05 00 3 f 6 7140 17d2  vidoff0: ;			;		cjp, ~vir vidoff0;	vmerd	| 
   17d3  05 39 3 f 0 d8c2 17d3  vidoff1: movw d, r[2];		vrdreg->am;	cjp, ~vir vidoff1;		| 
   17d4  05 49 e 0 0 9ec2 fffe  	andw d, r[2], r[2];	0xfffe->am;	;				| 
   17d5  1d 0d a 0 7 d842 0000  	movw r[2], y;		am->vwdreg;	crtn, go;		vmewr	| 
   17d6  05 12 3 f 0 d85e 17d6  vidon:	movw r[30], y;		am->vhiareg;	cjp, ~vir vidon;		| 
   17d7  05 53 e 0 0 7140 9000  	;			0x9000->vloareg; ;				| 
   17d8  05 54 e 0 0 7140 0073  	;			0x73->vctlreg;	;				| 
   17d9  05 00 3 f 6 7140 17d9  vidon0: ;			;		cjp, ~vir vidon0;	vmerd	| 
   17da  05 39 3 f 0 d8c2 17da  vidon1: movw d, r[2];		vrdreg->am;	cjp, ~vir vidon1;		| 
   17db  05 49 e 0 0 9f42 0001  	orw d, r[2], r[2];	0x1->am;	;				| 
   17dc  1d 0d a 0 7 d842 0000  	movw r[2], y;		am->vwdreg;	crtn, go;		vmewr	| 
                                | "@(#)texvector.pp.u 1.2 86/09/12"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | Written by Stuart Levy
                                |   texvec:  Mimics the action of pr_texvec.c
                                |   Please refer to pr_texvec.c and follow along.
                                |   The r[24] field is broken down as follows:
                                |  	 bit 15 - startpt	bit 14 - endpt		bit 13 - balancing	bit 12 - givenpattern
                                |  	 bit 11 - fat		bit 10 - poly		bit 9 - mvlist		bit 8 - righthalf
                                |   	 bit 7 - close		bit 6 - 6		bit 5 - solid		bit 4 - 4
                                |   	 bit 3 - 3	bit 2 - 2		bit 1 - firstvec
   17dd  05 45 e 0 0 d902 0190  texvec:	movw 0,r[2];		 0x190->scrmemp; ;				| (Tvecs) Clear numsegs.
   17de  05 61 3 d 0 d8cf 17dd  	movw d, r[15];		fifo1->am;	cjp, f1e texvec;		| 
   17df  05 0a e 0 4 f8c0 0000  	movw d, y;		am->scrmem;	;			scrmp +	| 
   17e0  05 61 3 d 0 d8ce 17e0  tec1:	movw d, r[14];		fifo1->am;	cjp, f1e tec1;			| 
   17e1  05 0a e 0 4 f8c0 0000  	movw d, y;		am->scrmem;	;			scrmp +	| 
   17e2  05 00 e 0 0 d904 0000  	movw 0,r[4];		;		;				| (Tvecs) Clear patln.
   17e3  05 61 3 d 0 d8cd 17e3  tec2:	movw d, r[13];		fifo1->am;	cjp, f1e tec2;			| 
   17e4  05 0a e 0 4 f8c0 0000  	movw d, y;		am->scrmem;	;			scrmp +	| 
   17e5  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];	;		;				| r[11]
   17e6  05 61 3 d 0 d8cc 17e6  tec3:	movw d, r[12];		fifo1->am;	cjp, f1e tec3;			| 
   17e7  05 0a e 0 0 f8c0 0000  	movw d, y;		am->scrmem;	;				| 
   17e8  04 45 e 0 a 9e4e 0150  	rsubw d, r[14], r[10];	0x150->scrmemp;	;				| r[10]. (Tvecs) (150)
   17e9  05 61 3 d 0 d8d5 17e9  	movw d,r[21];		fifo1->am;	cjp, f1e .;			| (Tvecs) Width.
   17ea  01 61 3 d 0 d8c3 17ea  	movw,s d,r[3];		fifo1->am;	cjp, f1e .;			| (Tvecs) Pattern segments.
   17eb  05 0a 3 0 0 f8c0 17f8  	movw d,y;		am->scrmem;	cjp, zer tec3sol;		| (Tvecs) Jump if solid vector.
   17ec  05 00 e 0 0 9e84 0000  	addw d,r[4],r[4];	;		;				| (Tvecs) Patln computation.
   17ed  05 00 e 0 4 dd62 0000  tec3a:	incw r[2],r[2];		;		;			scrmp+	| (Tvecs) Numseg computation.
   17ee  01 61 3 d 0 d8c3 17ee  	movw,s d,r[3];		fifo1->am;	cjp, f1e .;			| (Tvecs) Pattern segments.
   17ef  05 0a 3 0 0 f8c0 17f1  	movw d,y;		am->scrmem;	cjp, zer tec3b;			| (Tvecs) Null terminated.
   17f0  15 00 3 0 0 9e84 17ed  	addw d,r[4],r[4];	;		cjp, go tec3a;			| (Tvecs) Loop until done.
   17f1  05 61 3 d 0 d8c3 17f1  tec3b:	movw d,r[3];		fifo1->am;	cjp, f1e .;			| (Tvecs) Stoff.
   17f2  05 45 e 0 0 7140 0120  	;			0x120->scrmemp; ;				| (Tvecs) Address to save for toctant.
   17f3  05 0a e 0 4 f8c0 0000  	movw d,y;		am->scrmem;	;			scrmp+	| (Tvecs) Store stoff.
   17f4  05 61 3 d 0 d8d8 17f4  tec3c:	movw d,r[24];		fifo1->am;	cjp, f1e .;			| (Tvecs) Pull r[24].
   17f5  05 00 e 0 0 e9b8 0000  	bsetw 4,r[24];	;		;				| (Tvecs) tex->r[24].4=1.
   17f6  05 0a e 0 4 d844 0000  	movw r[4],y;		am->scrmem;	;			scrmp+	| (Tvecs) Store patln.
   17f7  15 0a 3 0 4 d842 17fa  	movw r[2],y;		am->scrmem;	cjp, go tec4;		scrmp+	| (Tvecs) Store numsegs.
   17f8  05 61 3 d 0 d8d8 17f8  tec3sol: movw d,r[24];	fifo1->am;	cjp, f1e .;			| If solid, r[24] still passed.
   17f9  05 00 e 0 0 e9b8 0000  	bsetw 4,r[24];	;		;				| (Tvecs) tex->r[24].4=1.
   17fa  05 61 3 d 0 d8dc 17fa  tec4:	movw d, r[28];		fifo1->am;	cjp, f1e tec4;			| 
   17fb  00 49 e 0 7 9f3c fffe  	norw,s d, r[28], r[23];	0xfffe->am;	;				| (PIX_DONTCLIP == 1) => (r[23] == 0).
   17fc  05 00 3 0 0 e5d8 17fe  	bclrw 2,r[24];	;		cjp, zer tec5;			| (Tvecs) Clear r[23] field of r[24].
   17fd  05 00 e 0 0 e5b8 0000  	bsetw 2,r[24];	;		;				| (Tvecs) Set r[23] field of r[24].
   17fe  05 61 3 d 0 d8db 17fe  tec5:	movw d, r[27];		fifo1->am;	cjp, f1e tec5;			| 
   17ff  05 00 e 0 0 979c 0000  	rolw 11, r[28], acc;	;		;				| r[27] in r[28]?
   1800  01 49 e 0 0 e2c1 07ff  	andw,s d, acc, acc;	0x7ff->am;	;				| 
   1801  05 00 3 0 0 cc9c 1b0a  	sr0w r[28], r[28];		;		cjp, zer fatcheck;		| r[28] >>= 1. 
   1802  15 00 3 0 0 d89b 1b0a  	movw acc, r[27];	;		cjp, go fatcheck;		| Jump to fat vector check.
   1803  05 49 e 0 0 9edc 000f  top0:	andw d, r[28], r[28];		0xf->am;	;				| 
                                |   PIXOP_NEEDS_DST (r[28]<<1)= (r[28]^(r[28]<<1)) & 0xa
   1804  05 00 e 0 0 d81c 0000  	movw r[28], acc;		;		;				| 
   1805  05 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;				| 
   1806  05 45 e 0 0 811c 0500  	xorw r[28], acc, acc;	0x500->scrmemp; ;				| Get ready to get clipping rectangle.
   1807  05 49 e 0 0 d8d0 0500  	movw d, r[16];	0x500->am;	;				| 
   1808  01 49 e 0 0 e2c1 000a  	andw,s d, acc, acc;	0xa->am;	;				| 
   1809  05 00 3 8 0 d91a 180b  	movw 0, r[26];		;		cjp, ~zer ttr;			| 
   180a  05 00 e 0 0 dd1a 0000  	incw 0, r[26];		;		;				| 
                                |   code will return to ttr (through treset) after each r[23] rectangle.
   180b  05 00 e 0 0 d917 0000  ttr:	movw 0, r[23];		;		;				| Textured line drawing begins here.
   180c  05 00 e 0 0 f1b8 0000  	bsetw 8,r[24];	;		;				| tex->r[24].8 = 1.
   180d  05 00 e 0 0 edd8 0000  	bclrw 6,r[24];	;		;				| tex->r[24].6 = 0.
   180e  01 00 e 0 0 e5f8 0000  	btstw,s 2,r[24]; ;		;				| 
   180f  01 59 3 0 4 d8d3 1818  	movw,s d, r[19];	scrmem->am;	cjp, zer ttrnclip;	scrmp +	| Transform screen coords to 4 relative.
   1810  0d 00 a 1 0 9e0f 0000  	subw d, r[15], r[15];		;		crtn, neg;			| End of r[23] list.
   1811  05 00 e 0 0 9e0d 0000  	subw d, r[13], r[13];		;		;				| 
   1812  05 59 e 0 4 d8d4 0000  	movw d, r[20];	scrmem->am;	;			scrmp +	| 
   1813  05 00 e 0 0 9e0e 0000  	subw d, r[14], r[14];		;		;				| 
   1814  05 00 e 0 0 9e0c 0000  	subw d, r[12], r[12];		;		;				| 
   1815  05 59 e 0 4 d8d1 0000  	movw d, r[17];		scrmem->am;	;			scrmp +	| 
   1816  05 59 e 0 4 d8d2 0000  	movw d, r[18];		scrmem->am;	;			scrmp +	| 
   1817  15 00 3 0 0 c5d0 181c  	add2nw 2, r[16], r[16]; ;		cjp, go ttrstat;		| 
   1818  05 00 e 0 0 d913 0000  ttrnclip: movw 0, r[19];	;		;				| 
   1819  05 00 e 0 0 d914 0000  	movw 0, r[20];	;		;				| 
   181a  05 49 e 0 0 d8d1 0400  	movw d, r[17];		 1024->am;	;				| 
   181b  05 49 e 0 0 d8d2 0400  	movw d, r[18];		 1024->am;	;				| 
   181c  05 41 e 0 0 f8c1 0000  ttrstat: movw d, acc;		vstreg->am;	;				| Clear vme status register.
                                |   Limits number of octants to 4.
   181d  01 00 e 0 0 d84b 0000  tnshrt:	 movw,s r[11], y;		;		;				| Test r[11].
   181e  05 00 3 9 0 d916 1828  	movw 0, r[22];	;		cjp, ~neg tnoswap;		| r[22]= 0.
   181f  05 00 e 0 0 d80f 0000  	movw r[15], acc;		;		;				| 
   1820  04 00 e 0 f d96d 0000  	movw r[13], r[15];		;		;				| Swap x.
   1821  05 00 e 0 0 d88d 0000  	movw acc, r[13];		;		;				| 
   1822  05 00 e 0 0 d80e 0000  	movw r[14], acc;		;		;				| Swap y.
   1823  04 00 e 0 e d96c 0000  	movw r[12], r[14];		;		;				| 
   1824  05 00 e 0 0 d88c 0000  	movw acc, r[12];		;		;				| 
   1825  05 00 e 0 0 df6b 0000  	negw r[11], r[11];		;		;				| r[11]= -r[11].
   1826  05 00 e 0 0 df6a 0000  	negw r[10], r[10];		;		;				| r[10]= -r[10].
   1827  05 00 e 0 0 f1d8 0000  	bclrw 8,r[24];	;		;				| (Tvecs) Left side.
                                |   Clipper works with y positive going. If needed, r[22]
                                |   vector around the centerline.  Remember this in the r[22]
                                |   variable so it can be undone later.
   1828  01 00 e 0 0 d84a 0000  tnoswap: movw,s r[10], y;		;		;				| 
   1829  01 00 3 9 0 d84b 1830  	 movw,s r[11], y;		;		cjp, ~neg tbound;		| (Tvecs) (added test)
   182a  05 00 3 8 0 df6a 182c  	negw r[10], r[10];		;		cjp, ~zer tnoswap1;		| (Tvecs) (added cond code)
   182b  05 00 e 0 0 f1d8 0000  	bclrw 8,r[24];	;		;				| (Tvecs)
   182c  05 49 e 0 0 8612 0001  tnoswap1: subw d, r[18], acc;	1->am;		;				| size.y-1
   182d  05 00 e 0 0 980e 0000  	subw r[14], acc, r[14];	;		;				| pos0.y= (size.y-1) - pos0.y.
   182e  01 00 e 0 0 980c 0000  	subw,s r[12], acc, r[12];	;		;				| pos1.y= (size.y-1) - pos1.y.
   182f  15 00 3 0 0 c3d6 1831  	add2nw 1, r[22];	;		cjp, go tbound1;		| r[22] += 2
                                |   Bounds check for vector ending before rectangle or starting after.
   1830  01 00 e 0 0 d84c 0000  tbound:	 movw,s r[12], y;		;		;				| 
   1831  01 00 3 1 0 d84d 190e  tbound1:  movw,s r[13], y;		;		cjp, neg clipoff;		| if (pos1.y < 0 || pos1.x < 0)
   1832  05 00 3 1 0 d80f 190e  	movw r[15], acc;		;		cjp, neg clipoff;		| 
   1833  01 00 e 0 0 9011 0000  	subw,s r[17], acc, y;	;		;				| || pos0.x >= size.x
   1834  05 00 3 9 0 d80e 190e  	movw r[14], acc;		;		cjp, ~neg clipoff;		| 
   1835  01 44 e 0 0 9012 14c2  	subw,s r[18], acc, y;	=vropset1->brreg; ;				| || pos0.y >= size.y
                                |   If vector is vertical, or horizontal, use fast algorithm.
   1836  01 00 3 9 0 d84b 190e  tvert:	 movw,s r[11], y;		;		cjp, ~neg clipoff;		| (Tvecs) 
   1837  01 00 3 0 0 d80a 1839  	movw,s r[10], acc;		;		cjp, zer tvroptst;		| (Tvecs) Jump if vertical.
   1838  05 00 3 8 0 7140 1872  	;			;		cjp, ~zer tdxdy;		| Jump if not horizontal or vertical.
   1839  01 00 e 0 0 e7f8 0000  tvroptst: btstw,s 3,r[24]; ;		;				| (Tvecs) 
   183a  05 00 3 8 0 7140 183f  	;			;		cjp, ~zer tvhortst;		| Jump if no rop setup necessary.
   183b  11 00 1 0 0 d85a 14bf  tvrop:	 movw,s r[26], y;		;		cjs, go vropset;		| Set up raster r[28] chips.
   183c  05 00 e 0 0 b1db 0000  tvvrdone: romw 8, r[27], acc, 0xff00; ;		;				| instruction completes on next cycle.
   183d  05 53 e 0 0 ff00 8802  	;			0x8802->vloareg;;			| vhiareg unchanged.
   183e  05 0d 3 f 7 f880 183e  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   183f  01 00 e 0 0 d84b 0000  tvhortst:  movw,s r[11], y;		;		;				| (Tvecs)
   1840  01 09 3 8 0 d84e 185d  	 movw,s r[14], y;		am->am;		cjp, ~zer thoriz;		| (Tvecs) (d) Test (pos0.y < 0)
   1841  05 00 3 9 0 d80c 1846  	movw r[12], acc;		;		cjp, ~neg tvclip1;		| (Tvecs) tex->r[24].res_cliprt = 1.
   1842  01 00 e 0 0 f1f8 0000  	btstw,s 8,r[24];	;		;				| (Tvecs) if (tex->r[24].8)
   1843  05 00 3 0 0 d90e 1845  	movw 0, r[14];		;		cjp, zer tvclip1rt;		| (Tvecs)(cc) if (pos0.y < 0) pos0.y= 0.
   1844  15 00 3 0 0 ded7 1846  	negw d, r[23];		;		cjp, go tvclip1;		| (Tvecs)  r[23] = -r[14].
   1845  05 00 e 0 0 edb8 0000  tvclip1rt: bsetw 6,r[24]; ;		;				| (Tvecs) tex->r[24].res_cliprt = 1.
   1846  01 49 e 0 0 9012 0001  tvclip1: subw,s r[18], acc, y;	1->am;		;				| if (pos1.y >= size.y)
   1847  05 00 3 1 0 8612 184d  	subw d, r[18], acc;	;		cjp, neg tvclip2;		| pos1.y= size.y - 1.
   1848  01 00 e 0 0 f1f8 0000  	btstw,s 8,r[24];	;		;				| (Tvecs)
   1849  04 09 3 8 4 984c 184b  	rsubw r[12],acc,r[4];	am->am;		cjp, ~zer tvcl1art;		| (Tvecs) (if (!(tex->r[24].8))
   184a  15 00 3 0 0 9e97 184c  	addw d, r[23], r[23];	;		cjp, go tvclip1a;		| (Tvecs)  r[23] += r[12] - r[18] + 1.
   184b  05 00 e 0 0 f1b8 0000  tvcl1art: bsetw 8,r[24];	;		;				| (Tvecs) tex->r[24].res_cliprt = 1.
   184c  15 00 3 0 0 d88c 184e  tvclip1a: movw acc, r[12];		;		cjp, go tvclip3;		| 
   184d  05 00 e 0 0 d80c 0000  tvclip2:movw r[12], acc;		;		;				| ISN'T DY CORRECT ALREADY?
   184e  00 44 e 0 5 980e 1852  tvclip3: subw,s r[14], acc, r[5];	=tvnorefl->brreg; ;				| r[5]= pos1.y - pos0.y (clipped!)
   184f  01 49 e 0 0 96d6 0002  	andw,s d, r[22], y;	2->am;		;				| if (r[22] & 2)
   1850  0d 49 3 0 0 8612 0001  	subw d, r[18], acc;	1->am;		cjp, zer;			| size.y - 1
   1851  04 00 e 0 e 980c 0000  	subw r[12], acc, r[14];	;		;				| pos0.y= size.y - 1 - pos1.y.
   1852  05 00 3 f 0 d814 1852  tvnorefl:movw r[20], acc;	;		cjp, ~vir tvnorefl;		| 
   1853  14 00 1 0 2 988e 11c3  	addw r[14], acc, r[2];;		cjs, go MulSWid;		| cg2_roppixel (dmd, pos0.x, pos0.y)
   1854  05 54 e 0 0 d813 0060  	movw r[19], acc;	0x60->vctlreg;	;				| 
   1855  15 00 1 0 0 808f 14ee  	addw r[15], acc, acc;	;		cjs, go vcompvme;		| cg2_roppixel
   1856  04 00 e 0 4 df6a 0000  	negw r[10], r[4];		;		;				| (Tvecs) (majax = -r[10])
   1857  04 00 e 0 2 d965 0000  	movw r[5], r[2];	;		;				| 
   1858  05 09 e 0 0 d858 0000  	movw r[24],y;		am->am;		;				| move r[24] field
   1859  05 00 e 0 0 d8c7 0000  	movw d,r[7];		;		;				| 
   185a  05 49 e 0 0 d8c5 0004  	movw d,r[5];		0x4->am;	;				| REFLECT.
   185b  05 09 e 0 0 d857 0000  	movw  r[23],y;		am->am;		;				| 
   185c  15 00 3 0 0 d8c9 1941  	movw d,r[9];		;		cjp, go toctant;		| toctant will return to treset.
                                |   Horizontal lines.
   185d  01 09 e 0 0 d84f 0000  thoriz:	 movw,s r[15], y;		am->am;		;				| (Tvecs) test r[15]->d-latch
   185e  05 00 3 9 0 d80d 1861  	movw r[13], acc;		;		cjp, ~neg thclip1;		| Jump if r[15] positive
   185f  05 00 e 0 0 d90f 0000  	movw 0, r[15];		;		;				| 
   1860  05 00 e 0 0 ded7 0000  	negw d, r[23];		;		;				| (Tvecs)  r[23] = -r[15].
   1861  01 49 e 0 0 9011 0001  thclip1: subw,s r[17], acc, y;	1->am;		;				| if (pos1.x >= size.x)
   1862  05 00 3 1 0 8611 1865  	subw d, r[17], acc;	;		cjp, neg thclip2;		| pos1.x= size.x - 1.
   1863  05 00 e 0 0 edb8 0000  	bsetw 6,r[24];	;		;				| (Tvecs) tex->r[24].res_cliprt = 1.
   1864  15 00 3 0 0 d88d 1866  	movw acc,r[13];		;		cjp, go thclip3;		| (Tvecs)
   1865  05 00 e 0 0 d80d 0000  thclip2:movw r[13], acc;		;		;				| 
   1866  04 00 e 0 5 980f 0000  thclip3: subw r[15], acc, r[5];	;		;				| (Tvecs) r[5]= r[13] - r[15] (neg?)
   1867  05 00 3 f 0 d814 1867  thnorefl:movw r[20], acc;	;		cjp, ~vir thnorefl;		| 
   1868  14 00 1 0 2 988e 11c3  	addw r[14], acc, r[2];;		cjs, go MulSWid;		| cg2_roppixel (dmd, pos0.x, pos0.x)
   1869  05 54 e 0 0 d813 0060  	movw r[19], acc;	0x60->vctlreg;	;				| 
   186a  15 00 1 0 0 808f 14ee  	addw r[15], acc, acc;	;		cjs, go vcompvme;		| cg2_roppixel
   186b  04 00 e 0 4 df6b 0000  	negw r[11], r[4];		;		;				| (Tvecs) (majax = -r[11])
   186c  04 00 e 0 2 d965 0000  	movw r[5], r[2];	;		;				| 
   186d  05 49 e 0 0 d8c5 0005  	movw d,r[5];		0x5->am;	;				| 
   186e  05 09 e 0 0 d858 0000  	movw r[24],y;		am->am;		;				| move r[24] field
   186f  05 00 e 0 0 d8c7 0000  	movw d,r[7];		;		;				| 
   1870  05 09 e 0 0 d857 0000  	movw  r[23],y;		am->am;		;				| 
   1871  15 00 3 0 0 d8c9 1941  	movw d,r[9];		;		cjp, go toctant;		| toctant will return to treset.
                                |   One more reflection. Note that r[10] in acc from vertical test.
   1872  01 00 e 0 0 904b 0000  tdxdy:	rsubw,s r[11], acc, y;	;		;				| if (r[11] < r[10])...
   1873  05 00 3 9 0 d80f 187f  	movw r[15], acc;		;		cjp, ~neg tiniterr;		| Swap (pos0.x, pos0.y).
   1874  04 00 e 0 f d96e 0000  	movw r[14], r[15];		;		;				| 
   1875  05 00 e 0 0 d88e 0000  	movw acc, r[14];		;		;				| 
   1876  05 00 e 0 0 d80d 0000  	movw r[13], acc;		;		;				| Swap (pos1.x, pos1.y).
   1877  04 00 e 0 d d96c 0000  	movw r[12], r[13];		;		;				| 
   1878  05 00 e 0 0 d88c 0000  	movw acc, r[12];		;		;				| 
   1879  04 00 e 0 b d96a 0000  	movw r[10], r[11];		;		;				| 
   187a  04 00 e 0 a 980e 0000  	subw r[14], acc, r[10];	;		;				| Recompute r[10] (saves a cycle).
   187b  05 00 e 0 0 d811 0000  	movw r[17], acc;	;		;				| Swap (size.x, size.y).
   187c  04 00 e 0 1 d972 0000  	movw r[18], r[17];	;		;				| 
   187d  05 00 e 0 0 d892 0000  	movw acc, r[18];	;		;				| Swap complete.
   187e  05 00 e 0 0 dd76 0000  	incw r[22], r[22];	;		;				| r[22] += 1.
   187f  04 00 e 0 8 cc8b 0000  tiniterr:sr0w r[11], r[8];		;		;				| initerror= -(r[11] >> 1).
   1880  01 00 e 0 0 df68 0000  	negw,s r[8], r[8];	;		;				| 
   1881  05 00 3 a 0 db09 1883  	compw 0, r[9];		;		cjp, ~cry tierr1;		| 
   1882  05 00 e 0 0 dd69 0000  	incw r[9], r[9];	;		;				| 
   1883  00 09 e 0 7 d96f 0000  tierr1:	movw,s r[15], r[7];	am->am;		;				| start= pos0. 
   1884  04 00 e 0 6 d96e 0000  	movw r[14], r[6];	;		;				| 
   1885  05 00 3 9 0 de07 189a  	negw r[7], acc;	;		cjp, ~neg tadvy;		| initerr += -start.x * r[10].
   1886  05 00 e 0 0 ded7 0000  	negw d, r[23];		;		;				| (Tvecs) ( r[23] = -r[7])
   1887  14 00 1 0 2 d96a 116f  	movw r[10], r[2];	;		cjs, go multiply;		| pr_product
   1888  05 00 e 0 0 d801 0000  	movw r[1], acc;	;		;				| double precision add.
   1889  05 09 e 0 0 d840 0000  	movw r[0], y;		am->am;		;				| 
   188a  05 00 e 0 0 9e88 0000  	addw d, r[8], r[8];	;		;				| 
   188b  05 00 e 0 0 98a9 0000  	addcw r[9], acc, r[9];;		;				| 
   188c  05 00 e 0 0 d907 0000  	movw 0, r[7];		;		;				| start.x= 0.
   188d  04 09 e 0 4 c1eb 0000  	sub2nw 0, r[11], r[4];		am->am;		;				| r[5]= (initerr + (r[11]-1)) / r[11].
   188e  04 00 e 0 0 9e88 0000  	addw d, r[8], r[0];	;		;				| double precision add.
   188f  04 49 e 0 1 9ea9 0000  	addcw d, r[9], r[1];	0->am;		;				| 
   1890  15 00 1 0 0 d80b 11e0  	movw r[11], acc;		;		cjs, go divlong;		| 
   1891  04 00 e 0 5 d962 0000  	movw r[2], r[5];	;		;				| 
   1892  05 00 e 0 0 d806 0000  	movw r[6], acc;	;		;				| 
   1893  04 00 e 0 6 9885 0000  	addw r[5], acc, r[6];;		;				| start.y += r[5].
   1894  05 00 e 0 0 d805 0000  	movw r[5], acc;	;		;				| initerr -= r[5] * r[11].
   1895  14 00 1 0 2 d96b 116f  	movw r[11], r[2];	;		cjs, go multiply;		| pr_product
   1896  05 09 e 0 0 d841 0000  	movw r[1], y;		am->am;		;				| 
   1897  05 00 e 0 0 d800 0000  	movw r[0], acc;	;		;				| 
   1898  05 00 e 0 0 9848 0000  	rsubw r[8], acc, r[8];	;		;				| 
   1899  05 00 e 0 0 9e29 0000  	subcw d, r[9], r[9];	;		;				| 
   189a  05 00 e 0 0 d806 0000  tadvy:	movw r[6], acc;	;		;				| 
   189b  01 00 e 0 0 9012 0000  	subw,s r[18], acc, y;	;		;				| if (start.y >= size.y)
   189c  00 00 3 9 2 d966 190e  	movw,s r[6], r[2]; ;		cjp, ~neg clipoff;		| (Tvecs) If (start.y < 0), comp r[23] params.
   189d  05 00 3 9 0 d80d 18b7  	movw r[13], acc;		;		cjp, ~neg tcliprt;		| initerr += start.y * r[11].
   189e  15 00 1 0 0 d80b 116f  	movw r[11], acc;	;		cjs, go multiply;		| pr_product
   189f  05 00 e 0 0 d800 0000  	movw r[0], acc;	;		;				| double precision add.
   18a0  05 09 e 0 0 d841 0000  	movw r[1], y;		am->am;		;				| 
   18a1  05 00 e 0 0 9888 0000  	addw r[8], acc, r[8];	;		;				| 
   18a2  05 00 e 0 0 9ea9 0000  	addcw d, r[9], r[9];	;		;				| 
   18a3  05 00 e 0 0 d906 0000  tadvy1:	movw 0, r[6];		;		;				| start.y= 0.
   18a4  05 00 e 0 0 d80a 0000  	movw r[10], acc;		;		;				| 
   18a5  01 00 e 0 0 800b 0000  	subw,s r[11], acc, acc;	;		;				| r[5]= ((r[10]-r[11])-initerr) / r[10].
   18a6  05 09 3 9 0 f900 18a8  	movw 0, y;		am->am;		cjp, ~neg tadvy1a;		| d and acc (low) form (r[10]-r[11]).
   18a7  05 09 e 0 0 fb00 0000  	compw 0, y;		am->am;		;				| 
   18a8  04 00 e 0 0 9808 0000  tadvy1a:subw r[8], acc, r[0];	;		;				| double precision subtract.
   18a9  04 00 e 0 1 9e69 0000  	rsubcw d, r[9], r[1];	;		;				| 
   18aa  15 00 1 0 0 d80a 11e0  	movw r[10], acc;		;		cjs, go divlong;		| 
   18ab  04 09 e 0 5 d962 0000  	movw r[2], r[5];	am->am;		;				| 
   18ac  05 00 e 0 0 9e87 0000  	addw d, r[7], r[7];	;		;				| start.x += r[5].
   18ad  05 00 e 0 0 9e97 0000  	addw d, r[23], r[23];	;		;				| (Tvecs) ( r[23] += r[5]).
   18ae  05 00 e 0 0 d80a 0000  	movw r[10], acc;	;		;				| initerr += r[5] * r[10].
   18af  14 00 1 0 2 d965 116f  	movw r[5], r[2];	;		cjs, go multiply;		| pr_product
   18b0  05 00 e 0 0 d800 0000  	movw r[0], acc;	;		;				| double precision add.
   18b1  05 09 e 0 0 d841 0000  	movw r[1], y;		am->am;		;				| 
   18b2  05 00 e 0 0 9888 0000  	addw r[8], acc, r[8];	;		;				| 
   18b3  05 00 e 0 0 9ea9 0000  	addcw d, r[9], r[9];	;		;				| 
   18b4  05 00 e 0 0 d807 0000  tadvy3:	movw r[7], acc;	;		;				| 
   18b5  01 00 e 0 0 9011 0000  	subw,s r[17], acc, y;	;		;				| if (r[7] >= size.x)...
   18b6  05 00 3 9 0 d80d 190e  	movw r[13], acc;		;		cjp, ~neg clipoff;		| (Tvecs) If pos, comp clipping parameters.
   18b7  01 49 e 0 0 9011 0001  tcliprt: subw,s r[17], acc, y;	1->am;		;				| if (pos1.x >= size.x)...
   18b8  05 00 3 1 0 8611 18c5  	subw d, r[17], acc;	;		cjp, neg tlasty;		| pos1.x= size.x - 1.
   18b9  05 00 e 0 0 d88d 0000  	movw acc, r[13];		;		;				| 
   18ba  05 00 e 0 0 800f 0000  	subw r[15], acc, acc;	;		;				| (size.x-1) - pos0.x
   18bb  14 00 1 0 2 d96a 116f  	movw r[10], r[2];	;		cjs, go multiply;		| pr_product (..., r[10]).
   18bc  04 09 e 0 4 cc8b 0000  	sr0w r[11], r[4];		am->am;		;				| acc= (r[11] - r[11]>>1 - 1).  r[4] is junk.
   18bd  05 00 e 0 0 860b 0000  	subw d, r[11], acc;	;		;				| 
   18be  05 00 e 0 0 e185 0000  	sub2nw 0, acc;		;		;				| r[11] > 0 so that acc >= 0, and high acc = 0.
   18bf  05 00 e 0 0 9880 0000  	addw r[0], acc, r[0];	;		;				| double precision add:  prod + (r[11] - r[11]>>1 - 1).
   18c0  05 49 e 0 0 9ea1 0000  	addcw d, r[1], r[1];	0->am;		;				| 
   18c1  15 00 1 0 0 d80b 11e0  tcliprt2:movw r[11], acc;		;		cjs, go divlong;		| / r[11]
   18c2  05 00 e 0 0 d80e 0000  	movw r[14], acc;		;		;				| 
   18c3  04 00 e 0 c 9882 0000  	addw r[2], acc, r[12];	;		;				| pos1.y= pos0.y + (...) / r[11].
   18c4  05 00 e 0 0 edb8 0000  	bsetw 6,r[24];	;		;				| (Tvecs) tex->r[24].res_cliprt = 1.
   18c5  05 00 e 0 0 d80c 0000  tlasty:	movw r[12], acc;		;		;				| 
   18c6  01 00 e 0 0 9012 0000  	subw,s r[18], acc, y;	;		;				| if (pos1.y >= size.y)...
   18c7  04 09 3 1 5 c1f2 18d2  	sub2nw 0, r[18], r[21];	am->am;		cjp, neg tclipdone;		| pos1.y= size.y - 1.  r[21] junk reg for am->am.
   18c8  05 00 e 0 0 d8cc 0000  	movw d, r[12];		;		;				| 
   18c9  05 00 e 0 0 864e 0000  	rsubw d, r[14], acc;	;		;				| (size.y-1) - pos0.y
   18ca  14 00 1 0 2 d96b 116f  	movw r[11], r[2];	;		cjs, go multiply;		| pr_product (..., r[11]).
   18cb  04 09 e 0 4 cc8b 0000  	sr0w r[11], r[4];		am->am;		;				| r[11]>>1.  r[4] junk (can't use acc).
   18cc  05 00 e 0 0 9e80 0000  	addw d, r[0], r[0];	;		;				| + (r[11]>>1).  double precision add.
   18cd  05 49 e 0 0 9ea1 0000  	addcw d, r[1], r[1];	0->am;		;				| 
   18ce  15 00 1 0 0 d80a 11e0  tlasty0:movw r[10], acc;		;		cjs, go divlong;		| / r[10].
   18cf  05 00 e 0 0 d80f 0000  	movw r[15], acc;		;		;				| 
   18d0  04 00 e 0 d 9882 0000  	addw r[2], acc, r[13];	;		;				| 
   18d1  05 00 e 0 0 edb8 0000  	bsetw 6,r[24];	;		;				| (Tvecs) tex->r[24].res_cliprt = 1.
   18d2  01 00 e 0 0 e7f8 0000  tclipdone: btstw,s 3,r[24]; ;		;				| 
   18d3  05 44 e 0 0 d80d 14c2  	movw r[13], acc;		=vropset1->brreg; ;				| Test if rop chips need setup.
   18d4  04 00 3 8 5 9807 18d9  	subw r[7], acc, r[5]; ;		cjp, ~zer tcolor;		| r[5]= pos1.x-start.x. Jump if chips rop chips ok.
   18d5  11 00 1 0 0 d85a 14c0  	 movw,s r[26], y;		;		cjs, go vropseta;		| Set up rasterop chips.
   18d6  05 00 e 0 0 b1db 0000  tropdone: romw 8, r[27], acc, 0xff00; ;		;				| instruction completes on next cycle.
   18d7  05 53 e 0 0 ff00 8802  	;			0x8802->vloareg;;			| vhiareg unchanged.
   18d8  05 0d 3 f 7 f880 18d8  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   18d9  05 0d 3 f 0 d85b 18d9  tcolor:	movw r[27], y;		am->vwdreg;	cjp, ~vir .;			| load vwdreg for bresenham loop but don't write.
   18da  01 54 e 0 0 e1f6 0060  	btstw,s 0, r[22];	0x60->vctlreg;	;				| if (r[22] & 1)
   18db  01 00 3 0 0 e3f6 18f1  	btstw,s 1, r[22];	;		cjp, zer tmajx;			| if (r[22] & 2)
   18dc  05 00 3 0 0 d811 18df  	movw r[17], acc;	;		cjp, zer tmajy;			| 
   18dd  05 00 e 0 0 e185 0000  	sub2nw 0, acc;		;		;				| 
   18de  05 00 e 0 0 9807 0000  	subw r[7], acc, r[7];;		;				| start.x= ((size.x-1) - start.x).
   18df  05 00 e 0 0 d814 0000  tmajy:	movw r[20], acc;	;		;				| 
   18e0  14 00 1 0 2 9887 11c3  	addw r[7], acc, r[2];;		cjs, go MulSWid;		| cg2_roppixel (..., start.x).
   18e1  05 00 e 0 0 d813 0000  	movw r[19], acc;	;		;				| 
   18e2  15 00 1 0 0 8086 14ee  	addw r[6], acc, acc;	;		cjs, go vcompvme;		| cg2_roppixel (..., start.y, ...).
   18e3  05 00 e 0 0 d808 0000  	movw r[8], acc;		;		;				| 
   18e4  05 00 e 0 0 808a 0000  	addw r[10], acc, acc;	;		;				| 
                                |   Bump error so that test in octant is as if it were done after adding r[10].
   18e5  05 00 e 0 0 e185 0000  	sub2nw 0, acc;		;		;				| We can only directly test r[8] >= 0 not r[8] > 0.
   18e6  05 00 e 0 0 d960 0000  	movw r[0], r[0];	;		;				| 
   18e7  05 00 e 0 0 d961 0000  	movw r[1], r[1];	;		;				| 
   18e8  04 09 e 0 3 d96a 0000  	movw r[10], r[3];		am->am;		;				| (Tvecs) (these were switched!!!)
   18e9  04 00 e 0 4 df6b 0000  	negw r[11], r[4];		;		;				| (Tvecs) (majax)
   18ea  04 00 e 0 2 d965 0000  	movw r[5], r[2];	;		;				| 
   18eb  05 09 e 0 0 d857 0000  	movw  r[23],y;		am->am;		;				| 
   18ec  05 00 e 0 0 d8c9 0000  	movw d,r[9];		;		;				| 
   18ed  05 09 e 0 0 d858 0000  	movw r[24],y;		am->am;		;				| move r[24] field
   18ee  05 00 e 0 0 d8c7 0000  	movw d,r[7];		;		;				| 
   18ef  05 09 e 0 0 d856 0000  	movw r[22], y;	am->am;		;				| 
   18f0  15 00 3 0 0 d8c5 1941  	movw d, r[5];		;		cjp, go toctant;		| toctant will return to treset.
   18f1  05 00 3 0 0 d812 18f4  tmajx:	movw r[18], acc;	;		cjp, zer tmajx1;		| 
   18f2  05 00 e 0 0 e185 0000  	sub2nw 0, acc;		;		;				| 
   18f3  05 00 e 0 0 9806 0000  	subw r[6], acc, r[6];;		;				| start.x= ((size.x-1) - start.x).
   18f4  05 00 e 0 0 d814 0000  tmajx1:	movw r[20], acc;	;		;				| 
   18f5  14 00 1 0 2 9886 11c3  	addw r[6], acc, r[2];;		cjs, go MulSWid;		| cg2_roppixel (..., start.x).
   18f6  05 00 e 0 0 d813 0000  	movw r[19], acc;	;		;				| 
   18f7  15 00 1 0 0 8087 14ee  	addw r[7], acc, acc;	;		cjs, go vcompvme;		| cg2_roppixel (..., start.y, ...).
   18f8  05 00 e 0 0 d808 0000  	movw r[8], acc;		;		;				| 
   18f9  05 00 e 0 0 808a 0000  	addw r[10], acc, acc;	;		;				| 
                                |   Bump error so that test in octant is as if it were done after adding r[10].
   18fa  05 00 e 0 0 e185 0000  	sub2nw 0, acc;		;		;				| We can only directly test r[8] >= 0 not r[8] > 0.
   18fb  05 00 e 0 0 d960 0000  	movw r[0], r[0];	;		;				| 
   18fc  05 00 e 0 0 d961 0000  	movw r[1], r[1];	;		;				| 
   18fd  04 09 e 0 3 d96a 0000  	movw r[10], r[3];		am->am;		;				| 
   18fe  04 00 e 0 4 df6b 0000  	negw r[11], r[4];		;		;				| (Tvecs) Majax.
   18ff  04 00 e 0 2 d965 0000  	movw r[5], r[2];	;		;				| 
   1900  05 09 e 0 0 d857 0000  	movw  r[23],y;		am->am;		;				| 
   1901  05 00 e 0 0 d8c9 0000  	movw d,r[9];		;		;				| 
   1902  05 09 e 0 0 d858 0000  	movw r[24],y;		am->am;		;				| move r[24] field
   1903  05 00 e 0 0 d8c7 0000  	movw d,r[7];		;		;				| 
   1904  05 09 e 0 0 d856 0000  	movw r[22], y;	am->am;		;				| 
   1905  15 00 3 0 0 d8c5 1941  	movw d, r[5];		;		cjp, go toctant;		| toctant will return to treset.
   1906  01 45 e 0 0 e5f8 0190  treset:	btstw,s 2,r[24];  0x190->scrmemp; ;				| 
   1907  0d 59 a 0 4 d8cf 0000  	movw d, r[15];		scrmem->am;	crtn, zer;		scrmp +	| if no clipping we are done.
   1908  05 59 e 0 4 d8ce 0000  	movw d, r[14];		scrmem->am;	;			scrmp +	| 
   1909  05 59 e 0 4 d8cd 0000  	movw d, r[13];		scrmem->am;	;			scrmp +	| 
   190a  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];	;		;				| 
   190b  05 59 e 0 4 d8cc 0000  	movw d, r[12];		scrmem->am;	;			scrmp +	| 
   190c  04 00 e 0 a 9e4e 0000  	rsubw d, r[14], r[10];	;		;				| 
   190d  15 05 3 0 0 d850 180b  	movw r[16], y;	am->scrmemp;	cjp, go ttr;			| 
                                | "@(#)clipoff.pp.u 1.1 86/09/12"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | Written by Stuart Levy
                                |   Expects the following registers to be loaded:
                                |   		dx,dy,options.
                                |   Expects the following scratchpad memory locations to be loaded:
                                |   		stoff,patln,numsegs
                                |   Loads the following scratchpad memory locations for future use:
                                |   		polyoff,oldpatln,fatoff.
                                |   The options field is broken down as follows:
                                |  	 bit 15 - startpt	bit 14 - endpt		bit 13 - balancing	bit 12 - givenpattern
                                |  	 bit 11 - fat		bit 10 - poly		bit 9 - mvlist		bit 8 - righthalf
                                |   	 bit 7 - close		bit 6 - cliprt		bit 5 - solid		bit 4 - pixrect
                                |   	 bit 3 - nosetup	bit 2 - clipbit		bit 1 - firstvec
   190e  05 09 e 0 0 d858 0000  clipoff: movw r[24],y;		am->am;		;				| Options arrives in r[24].
   190f  05 00 e 0 0 d8c7 0000  	movw d, r[7];		;		;				| 
   1910  05 00 e 0 0 d80b 0000  	movw  r[11],acc;		;		;				| 
   1911  01 00 e 0 0 900a 0000  	subw,s  r[10],acc,y;	;		;				| X is  r[4] if ( r[11]- r[10]) >= 0.
   1912  01 00 3 1 0 f7e7 1915  clxmaj:	btstw,s  11, r[7];	;		cjp, neg clymaj;		| Preparation for clipcomp.
   1913  04 45 e 0 4 df6b 0120  	negw  r[11], r[4];		0x120->scrmemp; ;				|  r[4] = - r[11].
   1914  14 00 3 0 3 d96a 1918  	movw  r[10], r[3];		;		cjp, go clcomp2;		| 
   1915  04 45 e 0 4 df6a 0120  clymaj: negw  r[10], r[4];		0x120->scrmemp; ;				|  r[4] = - r[10].
   1916  14 00 3 0 3 d96b 1918  	movw  r[11], r[3];		;		cjp, go clcomp2;		| 
   1917  01 45 e 0 0 f7e7 0120  clipcomp: btstw,s  11, r[7];	0x120->scrmemp; ;				| Test if  11 (no < correction nec).
   1918  05 59 3 8 4 d8c8 193e  clcomp2: movw d, r[8];		scrmem->am;	cjp, ~zer clofat;	scrmp+	| Restore  r[8], jump if  11 vector..
   1919  05 59 e 0 4 d8ca 0000  	movw d, r[10];		scrmem->am;	;			scrmp+	| Restore  r[10]. 
   191a  01 44 e 0 0 e9e7 191e  	btstw,s  4, r[7]; =clltst->brreg; ;				| Check if called from pixrects.
   191b  05 59 3 0 0 d8cf 191d  	movw d, r[15];		scrmem->am;	cjp, zer clxf;			| Restore  r[15]. Jump if not  4.
   191c  1d 49 3 0 0 d8c6 0150  	movw d, r[6];		0x150->am;	cjp, go;			| Store address of xform pattern.
   191d  05 49 e 0 0 d8c6 0600  clxf:	movw d, r[6];		0x600->am;	;				| Store address of  4 pattern.
   191e  01 00 e 0 0 f1e7 0000  clltst:	btstw,s  8, r[7];	;		;				| Test if should write pattern backwards.
   191f  04 00 3 8 0 c1ef 1927  	sub2nw 0, r[15],r[0];	;		cjp, ~zer cplytst;		| Write in pattern reversed if on left side.
   1920  04 05 e 0 6 9e80 0000  clolft:	addw d,r[0], r[6];	am->scrmemp;	;				| LEFT SIDE.  r[6] +=  r[15] - 1.
   1921  01 00 e 0 0 ffe7 0000  	btstw,s  15, r[7]; ;		;				| Swapping start & end pts if on left.
   1922  01 00 3 0 0 fde7 1924  	btstw,s  14, r[7];	;		cjp, zer clftns;		| Jump if no startpoint.
   1923  15 00 3 0 0 fda7 1925  	bsetw  14, r[7];	;		cjp, go clftb1;			| Set endpoint, jump to next bit.
   1924  05 00 e 0 0 fdc7 0000  clftns:	bclrw  14, r[7];	;		;				| Clear endpoint field.
   1925  05 00 3 0 0 ffc7 1927  clftb1:	bclrw  15, r[7];	;		cjp, zer cplytst;		| Clear startpoint.
   1926  05 00 e 0 0 ffa7 0000  	bsetw  15, r[7];	;		;				| Set startpoint.
   1927  01 45 e 0 0 f5e7 0133  cplytst: btstw,s  10, r[7];	0x133->scrmemp; ;				| Test if polyline.
   1928  01 59 3 0 0 d84b 192b  	 movw,s  r[11], y;		scrmem->am;	cjp, zer clonp;			| Jump if not polyline.
   1929  05 45 e 0 0 d8c8 0132  	movw d, r[8];		0x132->scrmemp; ;				|  r[8] =  r[9].
   192a  15 0a 3 0 0 d848 192e  	movw  r[8],y;		am->scrmem;	cjp, go cloang2;		| tex->fatoff =  r[8] =  r[9].
   192b  05 45 e 0 0 7140 0131  clonp:	;			0x131->scrmemp; ;				| Is not a polyline.
   192c  05 0a e 0 4 d84a 0000  	movw  r[10],y;		am->scrmem;	;			scrmp+	| oldpatln =  r[10].
   192d  05 0a e 0 0 d848 0000  cloang:	movw  r[8],y;		am->scrmem;	;				| tex->fatoff =  r[8].
   192e  01 00 3 0 0 d84a 1931  cloang2:  movw,s  r[10], y;		;		cjp, zer coffstart;		| 
   192f  01 00 3 0 0 f9e7 1931  	btstw,s 12, r[7]; ;		cjp, zer coffstart;		| Test givenpattern field.
   1930  01 00 1 0 0 e9e7 1a5c  closet:	btstw,s  4, r[7]; ;		cjs, zer setinit;		| Call setpat if necessary.
   1931  04 45 e 0 0 df64 0131  coffstart: negw  r[4], r[0];	0x131->scrmemp; ;				| Move ( r[4]+1) -> dividend.
   1932  05 0a e 0 4 d80a 0000  	movw  r[10], acc;	am->scrmem;	;			scrmp+	|  r[10]-> acc & oldpatln =  r[10] (corr).
   1933  05 0a e 0 0 d848 0000  	movw  r[8],y;		am->scrmem;	;				| tex->fatoff =  r[8] (corr).
   1934  15 00 1 0 0 dd60 11c9  	incw  r[0], r[0];	;		cjs, go divide;			| 
   1935  01 45 e 0 0 f1e7 0133  	btstw,s  8, r[7];	0x133->scrmemp; ;				| This is testing if on  8 side.
   1936  04 09 3 8 1 9888 1938  	addw  r[8],acc, r[1];	am->am;		cjp, ~zer coffrt;		|  r[1] = mod +  r[8].
   1937  14 09 3 0 9 dd61 1939  cofflft: incw  r[1], r[9];	am->am;		cjp, go .+2;			| LEFT SIDE.  r[9] =  r[1] + 1.
   1938  04 09 e 0 9 c1e1 0000  coffrt:	sub2nw 0,  r[1], r[9];	am->am;		;				| RIGHT SIDE.   r[9] =  r[1] - 1.
   1939  01 00 e 0 0 964a 0000  	rsubw,s d, r[10],y;	;		;				| 
   193a  01 0a 3 1 0 d809 1906  	movw,s  r[9],acc;	am->scrmem;	cjp, neg treset;		| Jump if ( r[9] <  r[10]).
   193b  01 00 3 9 0 800a 193b  	subw,s  r[10],acc,acc;	;		cjp, ~neg .;			| Loop until  r[9] <  r[10].
   193c  05 00 e 0 0 808a 0000  	addw  r[10],acc,acc;	;		;				| This gets done twice more than it should.
   193d  14 0a 3 0 9 988a 1906  	addw  r[10],acc, r[9];	am->scrmem;	cjp, go treset;			| Store  r[9] in scrmem & return.
                                |   Note that for  11 vectors, you don't need numsegs restored.
   193e  05 45 e 0 0 7140 0131  clofat: ;			0x131->scrmemp; ;				| 
   193f  05 59 e 0 4 d8ca 0000  	movw d, r[10];		scrmem->am;	;			scrmp+	|  r[10] = oldpatln.
   1940  15 59 3 0 0 d8c8 1931  	movw d, r[8];		scrmem->am;	cjp, go coffstart;		|  r[8] = tex->fat_off.
                                | "@(#)texvec.pp.u 1.2 86/09/12"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | Written by Stuart Levy
                                |   Octant subroutine:  chooses octant (one of four) to draw in
                                |   and generates the points.
                                |   Expects the following registers to be loaded:
                                |   vwrdreg:		r[27].
                                |   vctlreg:		byte mode.
                                |   acc:		initial error.
                                |   Note: r[0], r[1], and r[2] had to be moved to avoid conflict when multiplying.  Error moved temporarily (setpattern).
                                |   r[0], vloareg:	low address. 
                                |   r[1], vhiareg:	high address.
                                |   r[2]:		number of pixels to draw.
                                |   r[3]:		minax (added to error if error is negative).
                                |   r[4]:		majax (added to error if error is positive).
                                |   r[5]:		reflect (determines which octant:  0 => 0, 1 => 1, 2 => 7, 3 => 6).
                                |   r[7]:		options (startpt, endpt, balanced, givenpattern; specified by the user)
                                |   r[8]:		stoff (starting offset, specified by the user)
                                |   r[9]:		cloff (clipping offset, used by the program)  
                                |   r[15]:		numsegs (number of segments, specified by the user)
                                |   r[24]:		right (says whether vector is on the right or left side)
                                |   The options field is broken down as follows:
                                |  	 bit 15 - startpt	bit 14 - endpt		bit 13 - balancing	bit 12 - givenpattern
                                |  	 bit 11 - fat		bit 10 - poly		bit 9 - mvlist		bit 8 - righthalf
                                |   	 bit 7 - close		bit 6 - cliprt		bit 5 - solid		bit 4 - pixrect
                                |   	 bit 3 - nosetup	bit 2 - clipbit		bit 1 - firstvec
                                | The count is 0 based.  Therefore a count of zero will draw 1 pixel.  This differs from the c-code, where the count
                                | is 1 based.  If the count is zero, and enters the main loop, it will draw 1 pixel, and then the rfct will detect
                                | that the counter is 0, and will not loop, but will jump to the endpoint routine.   
   1941  01 45 e 0 0 f7e7 0120  toctant: btstw,s  11, r[7];	 0x120->scrmemp; ;				| Test if  11 (no < correction nec).
   1942  05 59 3 8 4 d8c8 1969  	movw d, r[8];		scrmem->am;	cjp, ~zer toctfat;	scrmp+	| Restore  r[8], jump if  11 vector..
   1943  05 59 e 0 4 d8ca 0000  	movw d, r[10];		scrmem->am;	;			scrmp+	| Restore  r[10]. 
   1944  01 44 e 0 0 e9e7 1948  	btstw,s  4, r[7]; =toctltst->brreg; ;				| Check if called from pixrects.
   1945  05 59 3 0 4 d8cf 1947  	movw d, r[15];		scrmem->am;	cjp, zer toctxf;	scrmp+	| Restore  r[15]. Jump if not  4.
   1946  1d 49 3 0 0 d8c6 0150  	movw d, r[6];		0x150->am;	cjp, go;			| Store address of xform pattern.
   1947  05 49 e 0 0 d8c6 0600  toctxf:	movw d, r[6];		0x600->am;	;				| Store address of  4 pattern.
   1948  01 00 e 0 0 f1e7 0000  toctltst: btstw,s  8, r[7]; ;		;				| Test if should write pattern backwards.
   1949  05 00 3 8 0 7140 1952  	;			;		cjp, ~zer tocta;		| Write in pattern reversed if on left side.
   194a  04 00 e 0 6 9e8f 0000  toctlft: addw d, r[15], r[6]; ;		;				| LEFT SIDE. 
   194b  05 05 e 0 0 c1e6 0000  	sub2nw 0,  r[6];		am->scrmemp;	;				|  r[6] +=  r[15] - 1.
   194c  01 00 e 0 0 ffe7 0000  	btstw,s  15, r[7]; ;		;				| Swapping start & end pts if on left.
   194d  01 00 3 0 0 fde7 194f  	btstw,s  14, r[7];	;		cjp, zer tlftns;		| Jump if no startpoint.
   194e  15 00 3 0 0 fda7 1950  	bsetw  14, r[7];	;		cjp, go tlftb1;			| Set endpoint, jump to next bit.
   194f  05 00 e 0 0 fdc7 0000  tlftns:	bclrw  14, r[7];	;		;				| Clear endpoint field.
   1950  05 00 3 0 0 ffc7 1952  tlftb1:	bclrw  15, r[7];	;		cjp, zer tocta;			| Clear startpoint.
   1951  05 00 e 0 0 ffa7 0000  	bsetw  15, r[7];	;		;				| Set startpoint.
   1952  01 45 e 0 0 f5e7 0133  tocta:	btstw,s  10, r[7];	0x133->scrmemp; ;				| Test if polyline.
   1953  05 00 3 0 0 7140 1955  	;			;		cjp, zer toctnp;		| Jump if not polyline
   1954  15 59 3 0 0 d8c8 1957  	movw d, r[8];		scrmem->am;	cjp, go toctang;		|  r[8] = polyoff.
   1955  05 45 e 0 0 7140 0131  toctnp:	;			0x131->scrmemp; ;				| Is not a polyline.
   1956  05 0a e 0 0 d84a 0000  	movw  r[10],y;		am->scrmem;	;				| oldpatln =  r[10].
   1957  01 49 e 0 0 9605 0004  toctang: subw,s d, r[5],y;	0x4->am;	;				| Test if hor or vert by testing  r[5] <= 3.
   1958  01 00 3 9 0 f9e7 195a  	btstw,s 12, r[7]; ;		cjp, ~neg toctoff;		| Test givenpattern field.
   1959  01 00 1 0 0 e9e7 1a5c  toctset: btstw,s  4, r[7]; ;		cjs, zer setinit;		| Call setpat if necessary.
   195a  05 45 e 0 0 7140 0132  toctoff: ;			0x132->scrmemp; ;				| 
   195b  15 0a 3 0 0 d848 1ab4  	movw  r[8],y;		am->scrmem;	cjp, go offinit;		| tex->fat_off =  r[8].
   195c  01 49 e 0 0 fde7 1963  toctdrw: btstw,s  14, r[7];	=toct0176->am;	;				| Test endpoint. Don't touch label!!
   195d  01 04 3 0 0 9685 1961  	addw,s d,r[5],y;	am->brreg;	cjp, zer toctc;			| Step on  r[5] (not needed).
   195e  01 49 e 0 0 ede7 0002  	btstw,s  6, r[7];	2->am;		;				| Draw  14 if ( 14 && ! 6).
   195f  09 00 3 8 0 ffe7 0000  	btstw,s  15, r[7]; ;		cjp, ~zer;			| 
   1960  01 00 e 0 0 c1e2 0000  	sub2nw,s 0, r[2];		;		;				| Decrement count if endpoint needed.
   1961  09 49 3 9 0 ffe7 0002  toctc:	btstw,s  15, r[7]; 0x2->am;	cjp, ~neg;			| Choose octant on  r[5] if count >= 0.
   1962  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Draw endpoint if count was 1.
   1963  15 04 3 0 0 d842 1970  toct0176: movw r[2],y;		am->brreg;	cjp, go toct0;			| Get ready to ld cntr.
   1964  15 04 3 0 0 d842 1997  	movw r[2],y;		am->brreg;	cjp, go toct1;			| Get ready to ld cntr. (dx swapped w/ dy).
   1965  15 04 3 0 0 d842 19c1  	movw r[2],y;		am->brreg;	cjp, go toct7;			| Get ready to ld cntr.
   1966  15 04 3 0 0 d842 19ea  	movw r[2],y;		am->brreg;	cjp, go toct6;			| Get ready to ld cntr. (dx swapped w/ dy).
   1967  15 04 3 0 0 d842 1a34  	movw r[2],y;		am->brreg;	cjp, go toctv;			| Vertical.
   1968  15 04 3 0 0 d842 1a14  	movw r[2],y;		am->brreg;	cjp, go tocth;			| Horizontal.
                                |   Toctfat is reached for  11 vectors, after the first one is drawn, and therefore no angle correction is necessary. 
                                |   Offset calculation is still necessary because of clipping.   This makes the fucker rip!!!
   1969  05 45 e 0 0 7140 0130  toctfat: ;			0x130->scrmemp; ;				| MAKE sure initial  r[6]  8 for all vectors!!
   196a  05 59 e 0 0 d8c6 0000  	movw d, r[6];		scrmem->am;	;				| Restore  r[6]. 
   196b  05 45 e 0 0 7140 0131  	;			0x131->scrmemp; ;				| 
   196c  05 59 e 0 4 d8ca 0000  	movw d, r[10];		scrmem->am;	;			scrmp+	|  r[10] = oldpatln.
   196d  05 59 e 0 0 d8c8 0000  	movw d, r[8];		scrmem->am;	;				|  r[8] = tex->fat_off.
   196e  05 45 e 0 0 7140 0122  	;			0x122->scrmemp; ;				| 
   196f  15 59 3 0 0 d8cf 195a  	movw d, r[15];		scrmem->am;	cjp, go toctoff;		| Restore  r[15] & jump to  r[13] calc.
                                |   testing (-acc) < 0 is equivalent to testing (acc) > 0.
                                |   Main vector drawing loop.  Octant 0.
   1970  01 00 3 8 0 f1e7 198f  toct0:	btstw,s  8, r[7];	;		cjp, ~zer toct0st;		| Jump if should draw startpoint
   1971  05 09 3 0 0 d84e 1989  toct0a:	movw  r[14],y;		am->am;		cjp, zer toct0l;		| 
   1972  19 44 4 0 0 e1ee 1985  	btstw,s 0, r[14];		=tnegerr0->brreg; push, go;			| Set cond. code, ld cntr, push loop.
   1973  01 00 3 0 0 f880 1975  tvloop0:  movw,s acc, y;		;		cjp, zer tnwrt0;		| Skip over write if not needed.
   1974  01 00 3 f 7 f880 1974  	 movw,s acc, y;		;		cjp, ~vir .;		vmewr	| if acc < 0 goto negerr0.
   1975  0d 49 3 9 0 8083 0401  tnwrt0:	addw  r[3],acc,acc;	 1025->am;	cjp, ~neg;			| Jump if error is negative, update error.
   1976  01 13 e 0 0 dd60 0000  	incw,s  r[0], r[0];	am->vloareg;	;				| Increment x.
   1977  01 00 3 a 0 c1ed 1979  tnwrt0a: sub2nw,s 0, r[13];	;		cjp, ~cry tncry0;		| Jump if no carry was generated.
   1978  05 12 e 0 0 dd61 0000  	incw  r[1], r[1];	am->vhiareg;	;				| Incrememt high order address
   1979  05 09 3 0 0 d84e 197c  tncry0:	movw  r[14],y;		am->am;		cjp, zer newseg0;		| Jump if need to fetch new segment.
   197a  09 00 8 0 0 e1ee 0000  	btstw,s 0, r[14];		;		rfct;				| Top of loop if count != 0.
   197b  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test endpoint.
   197c  01 00 e 0 0 960f 0000  newseg0: subw,s d, r[15],y;	;		;				| Compute ( r[15] -  r[14]).
   197d  05 59 3 0 0 d8cd 1981  	movw d, r[13];		scrmem->am;	cjp, zer firseg0;		| Load new pattern length, jump if need first  r[14].
   197e  05 09 e 0 0 dd6e 0000  	incw  r[14], r[14];		am->am;		;				| Increment segment count.
   197f  09 00 8 0 4 e1ee 0000  	btstw,s 0, r[14];		;		rfct;			scrmp+	| Increment pointer for fetching next segment.
   1980  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   1981  05 05 e 0 0 d846 0000  firseg0: movw  r[6],y ;	am->scrmemp;	;				| Set new segment address.
   1982  05 59 e 0 0 d8cd 0000  	movw d, r[13];		scrmem->am;	;				| 
   1983  09 49 8 0 4 d8ce 0001  	movw,s d, r[14];		0x1->am;	rfct;			scrmp+	| Note: This is same as btstw 0, r[14]!
   1984  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   1985  01 13 e 0 0 9e80 0000  tnegerr0: addw,s d, r[0], r[0]; am->vloareg;	;				| Error was negative. 
   1986  05 00 e 0 0 8084 0000  	addw  r[4],acc,acc;	;		;				| 
   1987  01 00 3 a 0 c1ed 1979  	sub2nw,s 0, r[13];	;		cjp, ~cry tncry0;		| 
   1988  15 12 3 0 0 dd61 1979  	incw  r[1], r[1];	am->vhiareg;	cjp, go tncry0;			| 
   1989  19 44 4 0 0 e1ee 1985  toct0l:	btstw,s 0, r[14];		=tnegerr0->brreg; push, go;			| LEFT SIDE
   198a  05 05 e 0 0 9606 0000  	subw d, r[6],y;	am->scrmemp;	;				| 
   198b  01 00 3 8 0 f880 1975  	 movw,s acc, y;		;		cjp, ~zer tnwrt0;		| 
   198c  05 00 3 f 7 7140 198c  	;			;		cjp, ~vir .;		vmewr	| scrmemp=[( r[6]+ r[15]-1)- r[14]]
   198d  0d 49 3 9 0 8083 0401  	addw  r[3],acc,acc;	 1025->am;	cjp, ~neg;			| 
   198e  11 13 3 0 0 dd60 1977  	incw,s  r[0], r[0];	am->vloareg;	cjp, go tnwrt0a;		| 
   198f  01 00 e 0 0 d849 0000  toct0st:  movw,s  r[9], y;		;		;				| Draw if ( 15 &&  r[9]==0).
   1990  01 00 3 8 0 f1e7 1971  	btstw,s  8, r[7];	;		cjp, ~zer toct0a;		| 
   1991  05 04 3 f 7 f8c0 1991  	movw d,y;		am->brreg;	cjp, ~vir .;		vmewr	| Draw startpoint.
   1992  1d 44 4 0 0 7140 1985  	;			=tnegerr0->brreg; push, go;			| Put next address on stack.
   1993  01 00 9 0 0 f880 1975  	 movw,s acc, y;		;		rpct tnwrt0;			| Jump to change acc and addresses.
   1994  01 04 e 0 0 c1e2 0000  toct0rt: sub2nw,s 0, r[2];		am->brreg;	;				| Reload counter & pop stack.
   1995  01 00 b 9 0 f1e7 1971  toct0ra: btstw,s  8, r[7];	;		cjpp, ~neg toct0a;		| Finish tex vector if count >= 0
   1996  11 00 b 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjpp, go toctend;		| Go to endpoint routine.
   1997  01 00 3 8 0 f1e7 19b9  toct1:	btstw,s  8, r[7];	;		cjp, ~zer toct1st;		| Jump if should draw startpoint
   1998  05 09 3 0 0 d84e 19b1  toct1a:	movw  r[14],y;		am->am;		cjp, zer toct1l;		| 
   1999  19 44 4 0 0 e1ee 19ad  	btstw,s 0, r[14];		=tnegerr1->brreg; push, go;			| Set cond. code, ld cntr, push loop.
   199a  01 00 3 0 0 f880 199c  tvloop1:  movw,s acc, y;		;		cjp, zer tnwrt1;		| Skip over write if not needed.
   199b  01 00 3 f 7 f880 199b  	 movw,s acc, y;		;		cjp, ~vir .;		vmewr	| if acc < 0 goto negerr1.
   199c  0d 00 3 9 0 8083 0000  tnwrt1:	addw  r[3],acc,acc;	;		cjp, ~neg;			| Jump if error is negative, update error.
   199d  01 49 e 0 0 9e80 0400  	addw,s d, r[0], r[0];	 1024->am;	;				| Increment y.
   199e  05 13 3 a 0 d840 19a0  	movw  r[0],y;		am->vloareg;	cjp, ~cry tncry1;		| Jump if no carry was generated.
   199f  05 12 e 0 0 dd61 0000  	incw  r[1], r[1];	am->vhiareg;	;				| Incrememt high order address
   19a0  01 00 e 0 0 c1ed 0000  tncry1:	sub2nw,s 0, r[13];	;		;				| Decrement segment count.
   19a1  05 09 3 0 0 d84e 19a4  	movw  r[14],y;		am->am;		cjp, zer newseg1;		| Jump if need to fetch new segment.
   19a2  09 00 8 0 0 e1ee 0000  	btstw,s 0, r[14];		;		rfct;				| Top of loop if count != 0.
   19a3  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test endpoint.
   19a4  01 00 e 0 0 960f 0000  newseg1: subw,s d, r[15],y;	;		;				| Compute ( r[15] -  r[14]).
   19a5  05 59 3 0 0 d8cd 19a9  	movw d, r[13];		scrmem->am;	cjp, zer firseg1;		| Load new pattern length, jump if need first  r[14].
   19a6  05 09 e 0 0 dd6e 0000  	incw  r[14], r[14];		am->am;		;				| Increment segment count.
   19a7  09 00 8 0 4 e1ee 0000  	btstw,s 0, r[14];		;		rfct;			scrmp+	| Increment pointer for fetching next segment.
   19a8  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   19a9  05 05 e 0 0 d846 0000  firseg1: movw  r[6],y ;	am->scrmemp;	;				| Set new segment address.
   19aa  05 59 e 0 0 d8cd 0000  	movw d, r[13];		scrmem->am;	;				| 
   19ab  09 49 8 0 4 d8ce 0001  	movw,s d, r[14];		0x1->am;	rfct;			scrmp+	| Note: This is same as btstw 0, r[14]!
   19ac  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   19ad  01 49 e 0 0 9e80 0401  tnegerr1: addw,s d, r[0], r[0];  1025->am;	;				| Error was negative. 
   19ae  05 13 e 0 0 d840 0000  	movw  r[0],y;		am->vloareg;	;				| 
   19af  05 00 3 a 0 8084 19a0  	addw  r[4],acc,acc;	;		cjp, ~cry tncry1;		| 
   19b0  15 12 3 0 0 dd61 19a0  	incw  r[1], r[1];	am->vhiareg;	cjp, go tncry1;			| 
   19b1  19 44 4 0 0 e1ee 19ad  toct1l:	btstw,s 0, r[14];		=tnegerr1->brreg; push, go;			| LEFT SIDE
   19b2  05 05 e 0 0 9606 0000  	subw d, r[6],y;	am->scrmemp;	;				| 
   19b3  01 00 3 8 0 f880 199c  	 movw,s acc, y;		;		cjp, ~zer tnwrt1;		| 
   19b4  05 00 3 f 7 7140 19b4  	;			;		cjp, ~vir .;		vmewr	| 
   19b5  0d 00 3 9 0 8083 0000  	addw  r[3],acc,acc;	;		cjp, ~neg;			| 
   19b6  01 49 e 0 0 9e80 0400  	addw,s d, r[0], r[0];	 1024->am;	;				| Different from octant 0 !!
   19b7  05 13 3 a 0 d840 19a0  	movw  r[0],y;		am->vloareg;	cjp, ~cry tncry1;		| 
   19b8  15 12 3 0 0 dd61 19a0  	incw  r[1], r[1];	am->vhiareg;	cjp, go tncry1;			| 
   19b9  01 00 e 0 0 d849 0000  toct1st:  movw,s  r[9], y;		;		;				| Draw if ( 15 &&  r[9]==0).
   19ba  01 00 3 8 0 f1e7 1998  	btstw,s  8, r[7];	;		cjp, ~zer toct1a;		| 
   19bb  05 04 3 f 7 f8c0 19bb  	movw d,y;		am->brreg;	cjp, ~vir .;		vmewr	| Draw startpoint.
   19bc  1d 44 4 0 0 7140 19ad  	;			=tnegerr1->brreg; push, go;			| Put next address on stack.
   19bd  01 00 9 0 0 f880 199c  	 movw,s acc, y;		;		rpct tnwrt1;			| Jump to change acc and addresses.
   19be  01 04 e 0 0 c1e2 0000  toct1rt: sub2nw,s 0, r[2];		am->brreg;	;				| Reload counter & pop stack.
   19bf  01 00 b 9 0 f1e7 1998  toct1ra: btstw,s  8, r[7];	;		cjpp, ~neg toct1a;		| Finish tex vector if count >= 0.
   19c0  11 00 b 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjpp, go toctend;		| Go to endpoint routine.
   19c1  01 00 3 8 0 f1e7 19e2  toct7:	btstw,s  8, r[7];	;		cjp, ~zer toct7st;		| Jump if should draw startpoint
   19c2  05 09 3 0 0 d84e 19da  toct7a:	movw  r[14],y;		am->am;		cjp, zer toct7l;		| 
   19c3  19 44 4 0 0 e1ee 19d6  	btstw,s 0, r[14];		=tnegerr7->brreg; push, go;			| Set cond. code, ld cntr, push loop.
   19c4  01 00 3 0 0 f880 19c6  tvloop7:  movw,s acc, y;		;		cjp, zer tnwrt7;		| Skip over write if not needed.
   19c5  01 00 3 f 7 f880 19c5  	 movw,s acc, y;		;		cjp, ~vir .;		vmewr	| if acc < 0 goto negerr7.
   19c6  0d 49 3 9 0 8083 fc01  tnwrt7:	addw  r[3],acc,acc;	-1023->am;	cjp, ~neg;			| Jump if error is negative, update error.
   19c7  01 13 e 0 0 dd60 0000  	incw,s  r[0], r[0];	am->vloareg;	;				| Increment y.
   19c8  01 00 3 a 0 c1ed 19ca  	sub2nw,s 0, r[13];	;		cjp, ~cry tncry7;		| Jump if no carry was generated.
   19c9  05 12 e 0 0 dd61 0000  	incw  r[1], r[1];	am->vhiareg;	;				| Incrememt high order address
   19ca  05 09 3 0 0 d84e 19cd  tncry7:	movw  r[14],y;		am->am;		cjp, zer newseg7;		| Jump if need to fetch new segment.
   19cb  09 00 8 0 0 e1ee 0000  	btstw,s 0, r[14];		;		rfct;				| Top of loop if count != 0.
   19cc  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test endpoint.
   19cd  01 00 e 0 0 960f 0000  newseg7: subw,s d, r[15],y;	;		;				| Compute ( r[15] -  r[14]).
   19ce  05 59 3 0 0 d8cd 19d2  	movw d, r[13];		scrmem->am;	cjp, zer firseg7;		| Load new pattern length, jump if need first  r[14].
   19cf  05 09 e 0 0 dd6e 0000  	incw  r[14], r[14];		am->am;		;				| Increment segment count.
   19d0  09 00 8 0 4 e1ee 0000  	btstw,s 0, r[14];		;		rfct;			scrmp+	| Increment pointer for fetching next segment.
   19d1  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   19d2  05 05 e 0 0 d846 0000  firseg7: movw  r[6],y;	am->scrmemp;	;				| Set new segment address.
   19d3  05 59 e 0 0 d8cd 0000  	movw d, r[13];		scrmem->am;	;				| 
   19d4  09 49 8 0 4 d8ce 0001  	movw,s d, r[14];		0x1->am;	rfct;			scrmp+	| Note: This is same as btstw 0, r[14]!
   19d5  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   19d6  01 13 e 0 0 9e80 0000  tnegerr7: addw,s d, r[0], r[0]; am->vloareg;	;				| Error was negative. 
   19d7  05 00 e 0 0 8084 0000  	addw  r[4],acc,acc;	;		;				| 
   19d8  01 00 3 2 0 c1ed 19ca  	sub2nw,s 0, r[13];	;		cjp, cry tncry7;		|
   19d9  15 12 3 0 0 c1e1 19ca  	sub2nw 0,  r[1], r[1];	am->vhiareg;	cjp, go tncry7;			| 
   19da  19 44 4 0 0 e1ee 19d6  toct7l:	btstw,s 0, r[14];		=tnegerr7->brreg; push, go;			| LEFT SIDE
   19db  05 05 e 0 0 9606 0000  	subw d, r[6],y;	am->scrmemp;	;				| 
   19dc  01 00 3 8 0 f880 19c6  	 movw,s acc, y;		;		cjp, ~zer tnwrt7;		| 
   19dd  05 00 3 f 7 7140 19dd  	;			;		cjp, ~vir .;		vmewr	| 
   19de  0d 49 3 9 0 8083 fc01  	addw  r[3],acc,acc;	-1023->am;	cjp, ~neg;			| 
   19df  01 13 e 0 0 dd60 0000  	incw,s  r[0], r[0];	am->vloareg;	;				| 
   19e0  01 00 3 a 0 c1ed 19ca  	sub2nw,s 0, r[13];	;		cjp, ~cry tncry7;		| 
   19e1  15 12 3 0 0 dd61 19ca  	incw  r[1], r[1];	am->vhiareg;	cjp, go tncry7;			| 
   19e2  01 00 e 0 0 d849 0000  toct7st:  movw,s  r[9], y;		;		;				| Draw if ( 15 &&  r[9]==0).
   19e3  01 00 3 8 0 f1e7 19c2  	btstw,s  8, r[7];	;		cjp, ~zer toct7a;		| 
   19e4  05 04 3 f 7 f8c0 19e4  	movw d,y;		am->brreg;	cjp, ~vir .;		vmewr	| Draw startpoint.
   19e5  1d 44 4 0 0 7140 19d6  	;			=tnegerr7->brreg; push, go;			| Put next address on stack.
   19e6  01 00 9 0 0 f880 19c6  	 movw,s acc, y;		;		rpct tnwrt7;			| Jump to change acc and addresses.
   19e7  01 04 e 0 0 c1e2 0000  toct7rt: sub2nw,s 0, r[2];		am->brreg;	;				| Reload counter & pop stack.
   19e8  01 00 b 9 0 f1e7 19c2  toct7ra: btstw,s  8, r[7];	;		cjpp, ~neg toct7a;		| Finish tex vector if count >= 0.
   19e9  11 00 b 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjpp, go toctend;		| Go to endpoint routine.
   19ea  01 00 3 8 0 f1e7 1a0c  toct6:	btstw,s  8, r[7];	;		cjp, ~zer toct6st;		| Jump if should draw startpoint
   19eb  05 09 3 0 0 d84e 1a04  toct6a:	movw  r[14],y;		am->am;		cjp, zer toct6l;		| 
   19ec  19 44 4 0 0 e1ee 1a00  	btstw,s 0, r[14];		=tnegerr6->brreg; push, go;			| Set cond. code, ld cntr, push loop.
   19ed  01 00 3 0 0 f880 19ef  tvloop6:  movw,s acc, y;		;		cjp, zer tnwrt6;		| Skip over write if not needed.
   19ee  01 00 3 f 7 f880 19ee  	 movw,s acc, y;		;		cjp, ~vir .;		vmewr	| if acc < 0 goto negerr6.
   19ef  0d 00 3 9 0 8083 0000  tnwrt6: addw  r[3],acc,acc;	;		cjp, ~neg;			| Jump if error is negative, update error.
   19f0  01 49 e 0 0 9e00 0400  	subw,s d, r[0], r[0];	 1024->am;	;				| Decrement y.
   19f1  05 13 3 2 0 d840 19f3  	movw  r[0],y;		am->vloareg;	cjp, cry tncry6;		| Jump if no carry was generated.
   19f2  05 12 e 0 0 c1e1 0000  	sub2nw 0,  r[1], r[1];	am->vhiareg;	;				| Incrememt high order address
   19f3  01 00 e 0 0 c1ed 0000  tncry6:	sub2nw,s 0, r[13];	;		;				| Decrement segment count.
   19f4  05 09 3 0 0 d84e 19f7  	movw  r[14],y;		am->am;		cjp, zer newseg6;		| Jump if need to fetch new segment.
   19f5  09 00 8 0 0 e1ee 0000  	btstw,s 0, r[14];		;		rfct;				| Top of loop if count != 0.
   19f6  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test endpoint.
   19f7  01 00 e 0 0 960f 0000  newseg6: subw,s d, r[15],y;	;		;				| Compute ( r[15] -  r[14]).
   19f8  05 59 3 0 0 d8cd 19fc  	movw d, r[13];		scrmem->am;	cjp, zer firseg6;		| Load new pattern length, jump if need first  r[14].
   19f9  05 09 e 0 0 dd6e 0000  	incw  r[14], r[14];		am->am;		;				| Increment segment count.
   19fa  09 00 8 0 4 e1ee 0000  	btstw,s 0, r[14];		;		rfct;			scrmp+	| Increment pointer for fetching next segment.
   19fb  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   19fc  05 05 e 0 0 d846 0000  firseg6: movw  r[6],y ;	am->scrmemp;	;				| Set new segment address.
   19fd  05 59 e 0 0 d8cd 0000  	movw d, r[13];		scrmem->am;	;				| 
   19fe  09 49 8 0 4 d8ce 0001  	movw,s d, r[14];		0x1->am;	rfct;			scrmp+	| Note: This is same as btstw 0, r[14]!
   19ff  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   1a00  01 49 e 0 0 9e80 fc01  tnegerr6: addw,s d, r[0], r[0]; -1023->am;	;				| Error was negative. 
   1a01  05 13 e 0 0 d840 0000  	movw  r[0],y;		am->vloareg;	;				| 
   1a02  05 00 3 2 0 8084 19f3  	addw  r[4],acc,acc;	;		cjp, cry tncry6;		| 
   1a03  15 12 3 0 0 c1e1 19f3  	sub2nw 0,  r[1], r[1];	am->vhiareg;	cjp, go tncry6;			| 
   1a04  19 44 4 0 0 e1ee 1a00  toct6l:	btstw,s 0, r[14];		=tnegerr6->brreg; push, go;			| LEFT SIDE
   1a05  05 05 e 0 0 9606 0000  	subw d, r[6],y;	am->scrmemp;	;				| 
   1a06  01 00 3 8 0 f880 19ef  	 movw,s acc, y;		;		cjp, ~zer tnwrt6;		| 
   1a07  05 00 3 f 7 7140 1a07  	;			;		cjp, ~vir .;		vmewr	| 
   1a08  0d 00 3 9 0 8083 0000  	addw  r[3],acc,acc;	;		cjp, ~neg;			| 
   1a09  01 49 e 0 0 9e00 0400  	subw,s d, r[0], r[0];	 1024->am;	;				| 
   1a0a  05 13 3 2 0 d840 19f3  	movw  r[0],y;		am->vloareg;	cjp, cry tncry6;		| 
   1a0b  15 12 3 0 0 c1e1 19f3  	sub2nw 0,  r[1], r[1];	am->vhiareg;	cjp, go tncry6;			| 
   1a0c  01 00 e 0 0 d849 0000  toct6st:  movw,s  r[9], y;		;		;				| Draw if ( 15 &&  r[9]==0).
   1a0d  01 00 3 8 0 f1e7 19eb  	btstw,s  8, r[7];	;		cjp, ~zer toct6a;		| 
   1a0e  05 04 3 f 7 f8c0 1a0e  	movw d,y;		am->brreg;	cjp, ~vir .;		vmewr	| Draw startpoint.
   1a0f  1d 44 4 0 0 7140 1a00  	;			=tnegerr6->brreg; push, go;			| Put next address on stack.
   1a10  01 00 9 0 0 f880 19ef  	 movw,s acc, y;		;		rpct tnwrt6;			| Jump to change acc and addresses.
   1a11  01 04 e 0 0 c1e2 0000  toct6rt: sub2nw,s 0, r[2];		am->brreg;	;				| Reload counter & pop stack.
   1a12  01 00 b 9 0 f1e7 19eb  toct6ra: btstw,s  8, r[7];	;		cjpp, ~neg toct6a;		| Finish tex vector if count >= 0.
   1a13  11 00 b 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjpp, go toctend;		| Go to endpoint routine.
                                |   Horizontal and vertical vector routines
   1a14  01 00 3 8 0 f1e7 1a2c  tocth:	btstw,s  8, r[7];	;		cjp, ~zer tocthst;		| Jump if should draw startpoint
   1a15  05 09 3 0 0 d84e 1a28  toctha:	movw  r[14],y;		am->am;		cjp, zer tocthl;		| 
   1a16  19 00 4 0 0 e1ee 0000  	btstw,s 0, r[14];		;		push, go;			| Set cond. code, ld cntr, push loop.
   1a17  05 00 3 0 0 7140 1a19  tvlooph: ;			;		cjp, zer tnwrth;		| Skip over write if not needed.
   1a18  05 00 3 f 7 7140 1a18  	;			;		cjp, ~vir .;		vmewr	| 
   1a19  01 13 e 0 0 dd60 0000  tnwrth:	incw,s  r[0], r[0];	am->vloareg;	;				| Increment x.
   1a1a  01 00 3 a 0 c1ed 1a1c  tnwrtha: sub2nw,s 0, r[13];	;		cjp, ~cry tncryh;		| Jump if no carry was generated.
   1a1b  05 12 e 0 0 dd61 0000  	incw  r[1], r[1];	am->vhiareg;	;				| Incrememt high order address
   1a1c  05 09 3 0 0 d84e 1a1f  tncryh:	movw  r[14],y;		am->am;		cjp, zer newsegh;		| Jump if need to fetch new segment.
   1a1d  09 00 8 0 0 e1ee 0000  	btstw,s 0, r[14];		;		rfct;				| Top of loop if count != 0.
   1a1e  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test endpoint.
   1a1f  01 00 e 0 0 960f 0000  newsegh: subw,s d, r[15],y;	;		;				| Compute ( r[15] -  r[14]).
   1a20  05 59 3 0 0 d8cd 1a24  	movw d, r[13];		scrmem->am;	cjp, zer firsegh;		| Load new pattern length, jump if need first  r[14].
   1a21  05 09 e 0 0 dd6e 0000  	incw  r[14], r[14];		am->am;		;				| Increment segment count.
   1a22  09 00 8 0 4 e1ee 0000  	btstw,s 0, r[14];		;		rfct;			scrmp+	| Increment pointer for fetching next segment.
   1a23  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   1a24  05 05 e 0 0 d846 0000  firsegh: movw  r[6],y ;	am->scrmemp;	;				| Set new segment address.
   1a25  05 59 e 0 0 d8cd 0000  	movw d, r[13];		scrmem->am;	;				| 
   1a26  09 49 8 0 4 d8ce 0001  	movw,s d, r[14];		0x1->am;	rfct;			scrmp+	| Note: This is same as btstw 0, r[14]!
   1a27  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   1a28  19 00 4 0 0 e1ee 0000  tocthl:	btstw,s 0, r[14];		;		push, go;			| LEFT SIDE
   1a29  05 05 3 8 0 9606 1a19  	subw d, r[6],y;	am->scrmemp;	cjp, ~zer tnwrth;		| 
   1a2a  05 00 3 f 7 7140 1a2a  	;			;		cjp, ~vir .;		vmewr	| 
   1a2b  11 13 3 0 0 dd60 1a1a  	incw,s  r[0], r[0];	am->vloareg;	cjp, go tnwrtha;		| 
   1a2c  01 00 e 0 0 d849 0000  tocthst:  movw,s  r[9], y;		;		;				| Draw if ( 15 &&  r[9]==0).
   1a2d  01 00 3 8 0 f1e7 1a15  	btstw,s  8, r[7];	;		cjp, ~zer toctha;		| 
   1a2e  05 04 3 f 7 f8c0 1a2e  	movw d,y;		am->brreg;	cjp, ~vir .;		vmewr	| Draw startpoint.
   1a2f  1d 00 4 0 0 7140 0000  	;			;		push, go;			| Put next address on stack.
   1a30  01 00 9 0 0 f880 1a19  	 movw,s acc, y;		;		rpct tnwrth;			| Jump to change acc and addresses.
   1a31  01 04 e 0 0 c1e2 0000  tocthrt: sub2nw,s 0, r[2];		am->brreg;	;				| Reload counter & pop stack.
   1a32  01 00 b 9 0 f1e7 1a15  tocthra: btstw,s  8, r[7];	;		cjpp, ~neg toctha;		| Finish tex vector if count >= 0.
   1a33  11 00 b 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjpp, go toctend;		| Go to endpoint routine.
   1a34  01 00 3 8 0 f1e7 1a4e  toctv:	btstw,s  8, r[7];	;		cjp, ~zer toctvst;		| Jump if should draw startpoint
   1a35  05 09 3 0 0 d84e 1a49  toctva:	movw  r[14],y;		am->am;		cjp, zer toctvl;		| 
   1a36  19 00 4 0 0 e1ee 0000  	btstw,s 0, r[14];		;		push, go;			| Set cond. code, ld cntr, push loop.
   1a37  05 00 3 0 0 7140 1a39  tvloopv: ;			;		cjp, zer tnwrtv;		| Skip over write if not needed.
   1a38  05 00 3 f 7 7140 1a38  	;			;		cjp, ~vir .;		vmewr	| 
   1a39  01 49 e 0 0 9e80 0400  tnwrtv:	addw,s d, r[0], r[0];	 1024->am;	;				| Increment x.
   1a3a  05 13 e 0 0 d840 0000  	movw  r[0],y;		am->vloareg;	;				| 
   1a3b  01 00 3 a 0 c1ed 1a3d  tnwrtva: sub2nw,s 0, r[13];	;		cjp, ~cry tncryv;		| Jump if no carry was generated.
   1a3c  05 12 e 0 0 dd61 0000  	incw  r[1], r[1];	am->vhiareg;	;				| Incrememt high order address
   1a3d  05 09 3 0 0 d84e 1a40  tncryv:	movw  r[14],y;		am->am;		cjp, zer newsegv;		| Jump if need to fetch new segment.
   1a3e  09 00 8 0 0 e1ee 0000  	btstw,s 0, r[14];		;		rfct;				| Top of loop if count != 0.
   1a3f  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test endpoint.
   1a40  01 00 e 0 0 960f 0000  newsegv: subw,s d, r[15],y;	;		;				| Compute ( r[15] -  r[14]).
   1a41  05 59 3 0 0 d8cd 1a45  	movw d, r[13];		scrmem->am;	cjp, zer firsegv;		| Load new pattern length, jump if need first  r[14].
   1a42  05 09 e 0 0 dd6e 0000  	incw  r[14], r[14];		am->am;		;				| Increment segment count.
   1a43  09 00 8 0 4 e1ee 0000  	btstw,s 0, r[14];		;		rfct;			scrmp+	| Increment pointer for fetching next segment.
   1a44  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   1a45  05 05 e 0 0 d846 0000  firsegv: movw  r[6],y ;	am->scrmemp;	;				| Set new segment address.
   1a46  05 59 e 0 0 d8cd 0000  	movw d, r[13];		scrmem->am;	;				| 
   1a47  09 49 8 0 4 d8ce 0001  	movw,s d, r[14];		0x1->am;	rfct;			scrmp+	| Note: This is same as btstw 0, r[14]!
   1a48  11 00 3 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjp, go toctend;		| Test  14 field.
   1a49  19 00 4 0 0 e1ee 0000  toctvl:	btstw,s 0, r[14];		;		push, go;			| LEFT SIDE
   1a4a  05 05 3 8 0 9606 1a39  	subw d, r[6],y;	am->scrmemp;	cjp, ~zer tnwrtv;		| 
   1a4b  05 00 3 f 7 7140 1a4b  	;			;		cjp, ~vir .;		vmewr	| 
   1a4c  01 49 e 0 0 9e80 0400  	addw,s d, r[0], r[0];	 1024->am;	;				| 
   1a4d  15 13 3 0 0 d840 1a3b  	movw  r[0],y;		am->vloareg;	cjp, go tnwrtva;		| 
   1a4e  01 00 e 0 0 d849 0000  toctvst:  movw,s  r[9], y;		;		;				| Draw if ( 15 &&  r[9]==0).
   1a4f  01 00 3 8 0 f1e7 1a35  	btstw,s  8, r[7];	;		cjp, ~zer toctva;		| 
   1a50  05 04 3 f 7 f8c0 1a50  	movw d,y;		am->brreg;	cjp, ~vir .;		vmewr	| Draw startpoint.
   1a51  1d 00 4 0 0 7140 0000  	;			;		push, go;			| Put next address on stack.
   1a52  01 00 9 0 0 f880 1a39  	 movw,s acc, y;		;		rpct tnwrtv;			| Jump to change acc and addresses.
   1a53  01 04 e 0 0 c1e2 0000  toctvrt: sub2nw,s 0, r[2];		am->brreg;	;				| Reload counter & pop stack.
   1a54  01 00 b 9 0 f1e7 1a35  toctvra: btstw,s  8, r[7];	;		cjpp, ~neg toctva;		| Finish tex vector if count >= 0.
   1a55  11 00 b 0 0 fde7 1a56  	btstw,s  14, r[7];	;		cjpp, go toctend;		| Go to endpoint routine.
   1a56  05 45 e 0 0 7140 0131  toctend: ;			0x131->scrmemp; ;				| 
   1a57  05 0a 3 0 0 d84a 1906  	movw  r[10],y;		am->scrmem;	cjp, zer treset;		| Store oldpatln & jump to treset.
   1a58  01 00 e 0 0 ede7 0000  	btstw,s  6, r[7];	;		;				| Draw  14 if ( 14 && ! 6).
   1a59  05 00 3 8 0 7140 1906  	;			;		cjp, ~zer treset;		| 
   1a5a  05 00 3 f 7 7140 1a5a  toctenda: ;			;		cjp, ~vir .;		vmewr	| Draw endpoint.
   1a5b  15 00 3 0 0 7140 1906  	;			;		cjp, go treset;			| Jump to treset.
                                | "@(#)setpat.pp.u 1.1 86/09/12"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | Written by Stuart Levy
                                |   Expects the following registers to be loaded:
                                |   r[6]	minax
                                |   r[7]	majax
                                |   r[10]	segaddr - changed by this routine
                                |   r[11]	numsegs
                                |   acc		error
                                |   r[13]	patln
                                |   These registers are loaded by texvec.pp.u. Majax, minax, & numsegs are used. Addrlo,addrhi,cnt, & patln are stored.
                                |   Note: Majax and minax are moved to majerr and minerr, as the multiply and divide routines step on r[3] and r[4].
                                |   These registers are used by setpattern.pp.u. Note that  r[4],  r[3] &  r[15] (r 3,4 & 15) come from texvec.pp.u.
                                |    r[4] and  r[3] go into majerr and minerr, as r[3] and r[4] get stepped on in multiply and divide.
                                |    r[6] gets set and then isn't used in the routine, so the msb has been borrowed as a flag.
                                |   msb of  r[6] used for first time through	
   1a5c  05 49 e 0 0 d8d6 0150  setinit: movw d, r[22];		0x150->am;	;				|
   1a5d  05 49 e 0 0 d8ce 0160  	movw d, r[14];		0x160->am;	;
   1a5e  05 00 3 8 0 d90c 1a61  	movw 0, r[12];		;		cjp, ~zer setinx;		| 
   1a5f  05 49 e 0 0 d8d6 0600  	movw d, r[22];		0x600->am;	;				| adjust addresses if not pixrect call.
   1a60  05 49 e 0 0 d8ce 0700  	movw d, r[14];		0x700->am;	;				|
   1a61  01 45 e 0 0 f1e7 0140  setinx: btstw,s  8, r[7];   0x140->scrmemp; ;				| 
   1a62  05 0a e 0 4 d857 0000  	movw r[23],y;		am->scrmem;	;			scrmp+	| 
   1a63  05 0a e 0 4 d850 0000  	movw r[16],y;		am->scrmem;	;			scrmp+	| 
   1a64  05 0a e 0 4 f880 0000  	movw acc,y;		am->scrmem;	;			scrmp+	| 	Error.
   1a65  05 0a e 0 4 d840 0000  	movw  r[0],y;		am->scrmem;	;			scrmp+	| 	Addrlo.
   1a66  05 0a e 0 4 d841 0000  	movw  r[1],y;		am->scrmem;	;			scrmp+	| 	Addrhi.
   1a67  05 0a e 0 4 d842 0000  	movw  r[2],y;		am->scrmem;	;			scrmp+	| 	Cnt.
   1a68  05 0a e 0 4 d845 0000  	movw  r[5],y;		am->scrmem;	;			scrmp+	| 	Reflect
   1a69  05 0a e 0 0 d847 0000  	movw  r[7],y;		am->scrmem;	;				| 	Options
   1a6a  05 09 e 0 0 d84e 0000  	movw  r[14],y;		am->am;		;				| Get into d-latch.(added cycle) 
   1a6b  04 00 e 0 7 d964 0000  	movw  r[4], r[7];	;		;				| Move  r[4] into  r[7].
   1a6c  04 00 3 8 5 d963 1a6f  	movw  r[3], r[5];	;		cjp, ~zer setRt;		| Move  r[3] into  r[5], jump if Right.
   1a6d  04 00 e 0 6 9e8f 0000  setLft: addw d, r[15], r[6]; ;		;				|  r[6] = ACaddr +  r[15] - 1.
   1a6e  15 00 3 0 0 c1e6 1a70  	sub2nw 0,  r[6];		;		cjp, go setinita;		| 
   1a6f  05 00 e 0 0 d8c6 0000  setRt:	movw d, r[6];		;		;				|  r[6] = ACaddr.
                                setinita:
   1a70  05 00 e 0 0 d914 0000  	movw 0,r[20];	;		;				| Now initialize registers for set_pattern.
   1a71  05 49 e 0 0 d8d0 0001  	movw d, r[16];		0x1->am;	;				| 
   1a72  05 49 e 0 0 d8d1 0001  	movw d, r[17];		0x1->am;	;				| 
   1a73  05 00 e 0 0 d913 0000  	movw 0, r[19];		;		;				| 
   1a74  05 00 e 0 0 d912 0000  	movw 0, r[18];		;		;				| 
   1a75  05 00 e 0 0 d90d 0000  	movw 0, r[13];		;		;				| 
   1a76  01 00 e 0 0 d847 0000  setpat:	 movw,s  r[7], y;		;		;				| Need to set flags.
   1a77  04 00 e 0 2 cd07 0000  	srnovw  r[7],r[2];	;		;				| ==>  error = -(  r[4] >> 1)
   1a78  05 00 e 0 0 d802 0000  	movw r[2],acc;		;		;
   1a79  05 05 e 0 0 d856 0000  	movw  r[22],y;		am->scrmemp;	;				| (added cycle)
   1a7a  1d 00 4 0 0 d915 0000  	movw 0, r[21];		;		push, go;			| Load scrmemp w beg addr of given  + load  cnter.
   1a7b  05 59 e 0 0 9e8c 0000  outer:	addw d, r[12], r[12];	scrmem->am;	;				| seg_count += segment[i].
   1a7c  05 00 e 0 0 d897 0000  	movw acc,  r[23];	;		;				| Put error back in accumulator between segments.
   1a7d  05 00 e 0 0 d80c 0000  	movw  r[12],acc;	;		;				| For mult, need  r[12] in acc and  r[2].
   1a7e  15 00 1 0 0 d882 116f  	movw acc, r[2];	;		cjs, go multiply;		| diag_sq = seg_count * seg_count.
   1a7f  05 00 e 0 0 d811 0000  	movw  r[17],acc;		;		;				| Compute initial  r[13] (acc is in  r[23])
   1a80  05 00 e 0 0 8090 0000  	addw  r[16],acc,acc;	;		;				| 
   1a81  04 00 e 0 b 9840 0000  	rsubw  r[0],acc, r[11]; ;		;				|  r[13] =  r[0] - ( r[17] +  r[16])
   1a82  05 00 e 0 0 ffc6 0000  	bclrw  15, r[6];	;		;				| clear  15 time through
   1a83  1d 00 4 0 0 d817 0000  	movw  r[23],acc;	;		push, go;			| Put error in acc (don't forget to put back !)
   1a84  05 00 e 0 0 dd73 0000  inner:	incw  r[19], r[19];	;		;				| maj_count++.
   1a85  04 09 e 0 7 cc33 0000  	sl1w  r[19],r[23];	am->am;		;				| maj_sq += maj_count + maj_count + 1.
   1a86  01 00 e 0 0 8085 0000  	addw,s  r[5],acc,acc;	;		;				| error +=  r[3].
   1a87  05 00 3 1 0 9e91 1a8c  	addw d, r[17], r[17];	;		cjp, neg nominor;		| 
   1a88  05 00 e 0 0 dd72 0000  	incw  r[18], r[18];	;		;				| min_count ++.
   1a89  04 09 e 0 7 cc32 0000  	sl1w  r[18],r[23];	am->am;		;				| min_sq += min_count + min_count + 1.	
   1a8a  05 00 e 0 0 9e90 0000  	addw d, r[16], r[16];	;		;				| 
   1a8b  05 00 e 0 0 8087 0000  	addw  r[7],acc,acc;	;		;				| error -=  r[4].
   1a8c  01 00 e 0 0 ffe6 0000  nominor: btstw,s  15, r[6];	;		;				| seg_error = diag_sq - (maj_sq + min_sq). 
   1a8d  05 09 e 0 0 d850 0000  	movw  r[16],y;		am->am;		;				| 
   1a8e  04 00 3 0 7 9e91 1a90  	addw d, r[17],r[23];	;		cjp, zer begin;			| 
   1a8f  04 00 e 0 b d96d 0000  	movw  r[13], r[11];	;		;				| old_error = seg_error.
   1a90  05 09 e 0 0 d857 0000  begin:	movw r[23],y;		am->am;		;				| 
   1a91  00 00 e 0 d 9e00 0000  	subw,s d, r[0], r[13];	;		;				| Put  r[13] on y-bus (and in d-latch) for test
   1a92  05 09 e 0 0 d84d 0000  	movw  r[13],y;		am->am;		;				| 
   1a93  01 00 3 9 0 960b 1a96  	subw,s d, r[11],y;	;		cjp, ~neg posseg;		| If  r[13] pos, test (old -  r[14]) >= 0.
   1a94  05 09 e 0 0 df6d 0000  negseg: negw  r[13], r[13];	am->am;		;				| 
   1a95  01 00 e 0 0 960b 0000  	subw,s d, r[11],y;	;		;				| 
   1a96  0d 00 d 1 0 ffa6 0000  posseg: bsetw  15, r[6];	;		loop, neg;			| Loop until  r[13] >  r[11]. set flag.
   1a97  05 09 e 0 0 d84e 0000  	movw  r[14],y;		am->am;		;				| (added cycle)
   1a98  05 05 e 0 0 9695 0000  	addw d, r[21],y;	am->scrmemp;	;				| Write new pattern to section of scratch memory.
   1a99  05 09 e 0 0 d853 0000  	movw  r[19],y;		am->am;		;				| Just added (take out comment later).
   1a9a  05 0a e 0 0 9654 0000  	rsubw d,r[20],y;	am->scrmem;	;				| 
   1a9b  05 09 e 0 0 dd75 0000  	incw  r[21], r[21];	am->am;		;				| Thanks Stuart.
   1a9c  01 00 e 0 0 960f 0000  	subw,s d, r[15],y;	;		;				| Now  r[21] goes 1 to n, and  r[15] goes 1 to n
   1a9d  04 00 e 0 4 d973 0000  	movw  r[19],r[20];	;		;				|
   1a9e  05 09 e 0 0 d856 0000  	movw  r[22],y;		am->am;		;				| Load old count for next segment. (added cycle)
   1a9f  0d 05 d 0 0 9695 0000  	addw d, r[21],y;	am->scrmemp;	loop, zer;			| Go to top of outer loop if condition fails.
   1aa0  01 45 e 0 0 d848 0131  newstoff:  movw,s  r[8], y;	0x131->scrmemp; ;				| Note: Majcnt is new pattern length!!!
   1aa1  05 00 3 0 0 d813 1aa8  	movw  r[19],acc;	;		cjp, zer setres;		|  r[8]= r[8]* r[10]+oldpatln/2
   1aa2  14 00 1 0 2 d968 116f  	movw  r[8], r[2];	;		cjs, go multiply;		| Leaves low  r[0] in r[0] ( r[0] +  r[0])
   1aa3  05 59 e 0 0 ee81 0000  	sr0w d,acc;		scrmem->am;	;				| 
   1aa4  05 00 e 0 0 9880 0000  	addw  r[0],acc, r[0];	;		;				|  r[8]=( r[8]* r[10]+oldpatln/2)/oldpatln.
   1aa5  15 00 1 0 0 f8c1 11c9  	movw d, acc;		;		cjs, go divide;			| Divide wants top in r[0], bottom in r[1].
   1aa6  04 00 e 0 8 d962 0000  	movw  r[2], r[8];	;		;				| 
   1aa7  05 00 e 0 0 d813 0000  	movw  r[19],acc;	;		;				| 
   1aa8  05 00 e 0 0 d88a 0000  setres:	movw acc, r[10];		;		;				| Set new  r[10]= r[19].
   1aa9  05 00 e 0 0 ffc6 0000  	bclrw  15, r[6];	;		;				| Restore  r[6] (added cycle)
   1aaa  04 00 e 0 3 d965 0000  	movw  r[5], r[3];	;		;				| Restore  r[3]
   1aab  04 45 e 0 4 d967 0140  	movw  r[7], r[4];	 0x140->scrmemp; ;				| Restore  r[4]
   1aac  05 59 e 0 4 d8d7 0000  	movw d, r[23];		scrmem->am;	;			scrmp+	| Get ready to restore registers. 
   1aad  05 59 e 0 4 d8d0 0000  	movw d, r[16];		scrmem->am;	;			scrmp+	| 
   1aae  05 59 e 0 4 f8c1 0000  	movw d,acc;		scrmem->am;	;			scrmp+	| 	Error.
   1aaf  05 59 e 0 4 d8c0 0000  	movw d, r[0];		scrmem->am;	;			scrmp+	| 	Addrlo.
   1ab0  05 59 e 0 4 d8c1 0000  	movw d, r[1];		scrmem->am;	;			scrmp+	| 	Addrhi.
   1ab1  05 59 e 0 4 d8c2 0000  	movw d, r[2];		scrmem->am;	;			scrmp+	| 	Cnt. 
   1ab2  05 59 e 0 4 d8c5 0000  	movw d, r[5];		scrmem->am;	;			scrmp+	| 	Reflect.
   1ab3  1d 59 a 0 0 d8c7 0000  	movw d, r[7];		scrmem->am;	crtn, go;			| 	Options and jump to toctoff.
                                | "@(#)offset.pp.u 1.2 86/09/12"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | Written by Stuart Levy
                                |   Expects the following registers to be loaded:
                                |   		segaddr,stoff,majax,patln,givpatln,cloff.
                                |   Loads the following registers for future use.
                                |   		seg,offset,polyoff(stored in scrmem).
                                |    r[4] and  r[3] go into scrmem, so don't get stepped on in multiply and divide.
   1ab4  05 45 e 0 0 7140 0140  offinit: ;			 0x140->scrmemp; ;				| 	
   1ab5  05 0a e 0 4 f880 0000  	movw acc,y;		am->scrmem;	;			scrmp+	| 	Error
   1ab6  05 0a e 0 4 d840 0000  	movw  r[0],y;		am->scrmem;	;			scrmp+	| 	Addrlo
   1ab7  05 0a e 0 4 d841 0000  	movw  r[1],y;		am->scrmem;	;			scrmp+	| 	Addrhi
   1ab8  05 0a e 0 4 d842 0000  	movw  r[2],y;		am->scrmem;	;			scrmp+	| 	Cnt
   1ab9  05 0a e 0 4 d843 0000  	movw  r[3],y;		am->scrmem;	;			scrmp+	| 	Minax
   1aba  05 0a e 0 0 d844 0000  	movw  r[4],y;		am->scrmem;	;				| 	Majax
   1abb  04 00 e 0 0 df64 0000  offstart: negw  r[4],r[0];	;		;				| Majax is really (- r[4])!
   1abc  05 00 e 0 0 dd60 0000  	incw r[0], r[0];	;		;				| Move ( r[4] + 1) -> dividend.
   1abd  15 00 1 0 0 d80a 11c9  	movw  r[10], acc;	;		cjs, go divide;			| Move pattern length into divisor, call divide.
   1abe  05 00 e 0 0 d88c 0000  	movw acc, r[12];		;		;				| 
   1abf  01 45 e 0 0 f1e7 0133  	btstw,s  8, r[7];	0x133->scrmemp; ;				| This is testing if on  8 side.
   1ac0  04 09 3 8 1 9888 1ace  	addw  r[8],acc, r[1];	am->am;		cjp, ~zer offrt;		|  r[1] =  r[12] +  r[8], jump if on  8 side.
   1ac1  04 0a e 0 b dd61 0000  offlft:	incw  r[1], r[11];	am->scrmem;	;				| LEFT SIDE.  r[11] =  r[1] + 1.
   1ac2  05 00 e 0 0 860a 0000  	subw d, r[10],acc;	;		;				|  r[8] =  r[9] +  r[10] - ( r[12] +  r[8]).
   1ac3  01 00 e 0 0 fbe7 0000  	btstw,s  13, r[7]; ;		;				| Testing balanced field of  r[7].
   1ac4  00 09 3 0 8 9889 1acb  	addw,s  r[9],acc, r[8];	am->am;		cjp, zer offlt0;		| 
   1ac5  04 09 e 0 0 c1ef 0000  	sub2nw 0, r[15],r[0];	am->am;		;				| if (balanced),  r[8] +=  r[12]>>1 -  r[14][ r[15]-1]>>1.
   1ac6  05 05 e 0 0 9606 0000  	subw d, r[6],y;	am->scrmemp;	;				| 
   1ac7  05 59 e 0 0 ee81 0000  	sr0w d,acc;		scrmem->am;	;				|  r[14][ r[15]-1]>>1 -> acc.
   1ac8  04 09 e 0 0 cc8c 0000  	sr0w  r[12],r[0];		am->am;		;				| Note:  r[14][ r[15]-1] is at  r[6]-( r[15]-1)
   1ac9  05 00 e 0 0 e241 0000  	rsubw d,acc,acc;	;		;				|  r[12]>>1 -  r[14][ r[15]-1]>>1 in d-latch.
   1aca  01 09 e 0 0 9888 0000  	addw,s  r[8],acc, r[8];	am->am;		;				| 
   1acb  05 00 3 9 0 868a 1ad8  offlt0:	addw d, r[10],acc;	;		cjp, ~neg offsoff;		| Jump if  r[8] >= 0.
   1acc  01 09 c 0 0 d888 1ad8  offlt1:	movw,s acc, r[8];	am->am;		ldct offsoff;			| Load new  r[8] & put in d-latch.
   1acd  05 00 7 1 0 808a 1acc  	addw  r[10],acc,acc;	;		jrp, neg offlt1;		| while( r[8]<0),  r[8] +=  r[10], when fails=offsoff.
   1ace  04 0a e 0 b c1e1 0000  offrt:	sub2nw 0,  r[1], r[11];	am->scrmem;	;				| RIGHT SIDE.   r[11] =  r[1] - 1.
   1acf  05 00 e 0 0 d808 0000  	movw  r[8],acc;		;		;				| 
   1ad0  04 09 e 0 8 9889 0000  	addw  r[9],acc, r[8];	am->am;		;				|  r[8] +=  r[9].
   1ad1  01 00 e 0 0 fbe7 0000  	btstw,s  13, r[7]; ;		;				| Testing balanced field of  r[7].
   1ad2  05 05 3 0 0 d846 1ad8  	movw  r[6],y;		am->scrmemp;	cjp, zer offsoff;		|  r[8] += [ r[10] -  r[12]>>1] + segment[0]>>1
   1ad3  05 59 e 0 0 ee81 0000  	sr0w d,acc;		scrmem->am;	;				| 	segment[0]>>1 in accumulator
   1ad4  04 09 e 0 0 cc8c 0000  	sr0w  r[12],r[0];		am->am;		;				| 	 r[12]>>1 in d-latch
   1ad5  04 00 e 0 0 9e0a 0000  	subw d, r[10],r[0];	;		;				| 	 r[10] -  r[12]>>1
   1ad6  05 00 e 0 0 8080 0000  	addw r[0],acc,acc;	;		;				| 	[ r[10] -  r[12]>>1] + segment[0]>>1
   1ad7  05 09 e 0 0 9888 0000  	addw  r[8],acc, r[8];	am->am;		;				| 
   1ad8  01 00 e 0 0 964a 0000  offsoff: rsubw,s d, r[10],y;	;		;				| Note:  r[8] in d-latch!.
   1ad9  01 00 3 1 0 d808 1add  	movw,s  r[8],acc;	;		cjp, neg offpoff;		| Jump if ( r[8] <  r[10]).
   1ada  01 00 3 9 0 800a 1ada  	subw,s  r[10],acc,acc;	;		cjp, ~neg .;			| Loop until  r[8] <  r[10].
   1adb  05 00 e 0 0 808a 0000  	addw  r[10],acc,acc;	;		;				| This gets done twice more than it should.
   1adc  00 00 e 0 8 988a 0000  	addw,s  r[10],acc, r[8];	;		;				| 
   1add  05 09 e 0 0 d84b 0000  offpoff: movw  r[11],y;	am->am;		;				| 
   1ade  01 00 e 0 0 964a 0000  	rsubw,s d, r[10],y;	;		;				| 
   1adf  01 00 3 1 0 d80b 1ae3  	movw,s  r[11],acc;	;		cjp, neg offseg0;		| Jump if ( r[11] <  r[10]).
   1ae0  01 00 3 9 0 800a 1ae0  	subw,s  r[10],acc,acc;	;		cjp, ~neg .;			| Loop until  r[11] <  r[10].
   1ae1  05 45 e 0 0 808a 0133  	addw  r[10],acc,acc;	0x133->scrmemp; ;				| This gets done twice more than it should.
   1ae2  04 0a e 0 b 988a 0000  	addw  r[10],acc, r[11]; am->scrmem;	;				| Store  r[11] in scrmem.
   1ae3  01 00 e 0 0 d848 0000  offseg0:  movw,s  r[8], y;		;		;				| 
   1ae4  05 49 e 0 0 d8ce 0001  	movw d, r[14];		0x1->am;	;				| 
   1ae5  05 05 e 0 0 d846 0000  	movw  r[6],y;		am->scrmemp;	;				| Load starting address.
   1ae6  01 00 3 8 0 f1e7 1ae8  	btstw,s  8, r[7];	;		cjp, ~zer offloop;		| Jump if  r[8] != 0.
   1ae7  15 59 3 0 0 d8cd 1aff  	movw d, r[13];		scrmem->am;	cjp, go offres;			| Check order of operations! Inc pointer for next fetch.
   1ae8  05 00 3 0 0 7140 1af2  offloop: ;			;		cjp, zer offloopL;		| Jump if on left side.
   1ae9  01 59 e 0 0 8648 0000  offloopR: rsubw,s d, r[8],acc;	scrmem->am;	;				| Compute ( r[13] -  r[8])
   1aea  05 00 3 9 0 dd6e 1aec  	incw  r[14], r[14];		;		cjp, ~neg offgtR;		| Jump if >= 0, therfore  r[8] <  r[13]
   1aeb  15 00 3 0 4 de88 1ae9  	negw acc, r[8];		;		cjp, go offloopR;	scrmp+	|  r[8] -=  r[13].
   1aec  01 00 e 0 0 d88d 0000  offgtR:	movw,s acc, r[13];	;		;				|  r[13] -=  r[8].
   1aed  05 09 3 8 0 c1ee 1aff  	sub2nw 0, r[14], r[14];	am->am;		cjp, ~zer offres;		| Return if  r[13] != 0. Inc pointer for next fetch.
   1aee  01 00 e 0 0 960f 0000  	subw,s d, r[15],y;	;		;				| Check if ( r[14] >=  r[15]).
   1aef  05 05 3 0 0 9686 1afc  	addw d, r[6],y;	am->scrmemp;	cjp, zer offirst;		| 
   1af0  05 59 e 0 0 d8cd 0000  	movw d, r[13];		scrmem->am;	;				| Return if ( r[14] !=  r[15]).
   1af1  15 00 3 0 0 dd6e 1aff  	incw  r[14], r[14];		;		cjp, go offres;			| Increment  r[14] and restore.
   1af2  05 00 e 0 0 c1ee 0000  offloopL: sub2nw 0,  r[14] ;		;		;				| 
   1af3  01 59 e 0 0 8648 0000  offloopLa: rsubw,s d, r[8],acc;	scrmem->am;	;				| Compute ( r[13] -  r[8])
   1af4  05 09 3 9 0 dd6e 1af7  	incw  r[14], r[14];		am->am;		cjp, ~neg offgtL;		| Jump if >= 0, therfore  r[8] <  r[13]
   1af5  05 05 e 0 0 9606 0000  	subw d, r[6],y;	am->scrmemp;	;				| scrmemp =  r[6] -  r[14].
   1af6  15 00 3 0 0 de88 1af3  	negw acc, r[8];		;		cjp, go offloopLa;		|  r[8] -=  r[13].
   1af7  05 00 3 8 0 d88d 1aff  offgtL:	movw acc, r[13];	;		cjp, ~zer offres;		|  r[13] -=  r[8].
   1af8  01 00 e 0 0 960f 0000  	subw,s d, r[15],y;	;		;				| Check if ( r[14] >=  r[15]).
   1af9  05 05 3 0 0 9606 1afc  	subw d, r[6],y;	am->scrmemp;	cjp, zer offirst;		| 
   1afa  05 59 e 0 0 d8cd 0000  	movw d, r[13];		scrmem->am;	;				| Return if ( r[14] !=  r[15]). Inc pointer for next fetch.
   1afb  15 00 3 0 0 dd6e 1aff  	incw  r[14], r[14];		;		cjp, go offres;			| Increment  r[14] and restore.
   1afc  05 05 e 0 0 d846 0000  offirst: movw  r[6],y;	am->scrmemp;	;				| Load in first segment.
   1afd  05 59 e 0 0 d8cd 0000  	movw d, r[13];		scrmem->am;	;				| 
   1afe  05 49 e 0 0 d8ce 0001  	movw d, r[14];		0x1->am;	;				| Zero out  r[14],  r[13]=1st, Inc pointer for next fetch.
   1aff  05 45 e 0 0 7140 0140  offres:	;			 0x140->scrmemp; ;				| 	
   1b00  05 59 e 0 4 f8c1 0000  	movw d,acc;		scrmem->am;	;			scrmp+	| 	Error
   1b01  05 59 e 0 4 d8c0 0000  	movw d, r[0];		scrmem->am;	;			scrmp+	| 	Addrlo
   1b02  05 59 e 0 4 d8c1 0000  	movw d, r[1];		scrmem->am;	;			scrmp+	| 	Addrhi
   1b03  05 59 e 0 4 d8c2 0000  	movw d, r[2];		scrmem->am;	;			scrmp+	| 	Cnt
   1b04  05 59 e 0 4 d8c3 0000  	movw d, r[3];		scrmem->am;	;			scrmp+	| 	Minax
   1b05  05 59 e 0 4 d8c4 0000  	movw d, r[4];		scrmem->am;	;			scrmp+	| 	Majax 
   1b06  01 00 e 0 0 f1e7 0000  	btstw,s  8, r[7];	;		;				| Check if  8 or left side.
   1b07  05 09 3 0 0 d846 1b09  	movw  r[6],y;		am->am;		cjp, zer offresL;		| Reset scrmemp for either side.
   1b08  15 05 3 0 0 968e 195c  offresR: addw d, r[14],y;		am->scrmemp;	cjp, go toctdrw;		| Jump back to texvec.
   1b09  15 05 3 0 0 964e 195c  offresL: rsubw d, r[14],y;		am->scrmemp;	cjp, go toctdrw;		| 
                                | "@(#)fatvec.pp.u 1.2 86/09/12"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | Written by Stuart Levy
                                |   The options field is broken down as follows:
                                |  	 bit 15 - startpt	bit 14 - endpt		bit 13 - balancing	bit 12 - givenpattern
                                |  	 bit 11 - fat		bit 10 - poly		bit 9 - mvlist		bit 8 - righthalf
                                |   	 bit 7 - close		bit 6 - cliprt		bit 5 - solid		bit 4 - pixrect
                                |   	 bit 3 - nosetup	bit 2 - clipbit		bit 1 - firstvec
                                |   r[10] through r[15] & r[24] are set by texvector.pp.u
                                |   Segaddr is set by texvec, and stored (at savsegaddr) by fatvec.pp.u.
                                |   These vectors are in storage at savetex for texvec.pp.u
                                |   r[24] is options, and shouldn't be stepped on (defined in texvector.pp.u)
                                |   Space where vector endpoints are stored.
                                |   Space reserved for saving parameters when  r[21] > 64 & calling texvec.
                                |   Space where  r[6] is stored after first call to texvec routine.
   1b0a  00 00 c 0 0 c3f5 134a  fatcheck: sub2nw,s 1, r[21],r[16]; ;		ldct vop0;			| Sub 2 from  r[21], r[16] scratch reg.
   1b0b  01 00 3 9 0 ebf8 1b0d  	btstw,s  5, r[24];	;		cjp, ~neg fatstart;		| Jump if  11 vector.
   1b0c  05 00 7 0 0 f7d8 1803  fatthin: bclrw  11, r[24];	;		jrp, zer top0;			| Jump textured if zero,  5 if 1.
   1b0d  05 00 e 0 0 f7d8 0000  fatstart: bclrw  11, r[24];	;		;				| tex-> r[24]. 11 = 0.
   1b0e  05 49 e 0 0 d8d0 0001  	movw d, r[16];		0x1->am;	;				| Initialize registers.
   1b0f  05 49 e 0 0 d8d1 0001  	movw d, r[17];		0x1->am;	;				| 
   1b10  05 00 e 0 0 d913 0000  	movw 0, r[19];		;		;				| 
   1b11  05 00 e 0 0 d912 0000  	movw 0, r[18];		;		;				| 
   1b12  05 00 e 0 0 d906 0000  	movw 0, r[6];		;		;				| 
   1b13  05 00 e 0 0 d80b 0000  	movw  r[11],acc;		;		;				| Dx in acc for testing.
   1b14  01 00 e 0 0 914a 0000  	orw,s  r[10],acc,y;		;		;				| Test if ( r[11]==0 &&  r[10]==0).
   1b15  01 00 3 0 0 910a 1bf2  	xorw,s  r[10],acc,y;	;		cjp, zer fatpoint;		| Jump if  11, single point.
   1b16  05 00 3 1 0 d916 1b18  	movw 0, r[22];		;		cjp, neg fatdx;			| Jump if not same (slope is negative).
   1b17  05 00 e 0 0 dd16 0000  	incw 0, r[22];		;		;				| Slope is positive.
   1b18  01 00 e 0 0 d84b 0000  fatdx:	 movw,s  r[11], y;		;		;				| 
   1b19  01 00 3 9 0 d84a 1b1b  	 movw,s  r[10], y;		;		cjp, ~neg fatdy;		| Jump if  r[11] is positive.
   1b1a  05 00 e 0 0 df6b 0000  	negw  r[11], r[11];		;		;				| Negate  r[11]. 
   1b1b  05 00 3 9 0 d80b 1b1d  fatdy:	movw  r[11],acc;		;		cjp, ~neg fatmain;		| Get ready for  r[7], jump if  r[10] positive.
   1b1c  05 00 e 0 0 df6a 0000  	negw  r[10], r[10];		;		;				| Negate  r[10].
   1b1d  14 00 1 0 2 d96b 116f  fatmain: movw  r[11], r[2];	;		cjs, go multiply;		| Compute  r[11]* r[11].
   1b1e  04 00 e 0 5 d960 0000  	movw  r[0], r[5];	;		;				|  r[7] = sqrt ( r[11]* r[11] +  r[10]* r[10]).
   1b1f  04 00 e 0 6 d961 0000  	movw  r[1], r[6];	;		;				| 
   1b20  05 00 e 0 0 d80a 0000  	movw  r[10],acc;		;		;				| 
   1b21  14 00 1 0 2 d96a 116f  	movw  r[10], r[2];		;		cjs, go multiply;		| Compute  r[10]* r[10].
   1b22  05 09 e 0 0 d840 0000  	movw  r[0],y;		am->am;		;				| 
   1b23  01 00 e 0 0 9e85 0000  	addw,s d, r[5], r[5]; ;		;				| Add  r[11]**2 +  r[10]**2.
   1b24  05 09 e 0 0 d841 0000  	movw  r[1],y;		am->am;		;				| 
   1b25  05 00 3 a 0 9e86 1b27  	addw d, r[6], r[6];	;		cjp, ~cry fatsqrt;		| Jump if no carry generated.
   1b26  05 00 e 0 0 dd66 0000  	incw  r[6], r[6];	;		;				| 
   1b27  11 00 1 0 0 d845 1bf4  fatsqrt:  movw,s  r[5], y;	;		cjs, go sqrt;			| Compute square root ( r[7]).
   1b28  05 00 e 0 0 d815 0000  	movw  r[21],acc;		;		;				|  r[6] = [( r[11] *  r[21]) /  r[7]] >> 1.
   1b29  14 00 1 0 2 d96b 116f  	movw  r[11], r[2];		;		cjs, go multiply;		| 
   1b2a  01 00 c 0 0 d841 11e0  	 movw,s  r[1], y;	;		ldct divlong;			| Will call divlong if 32 bit result.
   1b2b  05 00 5 0 0 d807 11c9  	movw  r[7], acc;		;		jsrp, zer divide;		| Reslt &  r[0] &&  r[1] & divhi same reg.
   1b2c  04 00 e 0 6 cc82 0000  	sr0w  r[2], r[6];	;		;				| 
   1b2d  05 00 e 0 0 d815 0000  	movw  r[21],acc;		;		;				|  r[5] = [( r[10] *  r[21]) /  r[7]] >> 1.
   1b2e  14 00 1 0 2 d96a 116f  	movw  r[10], r[2];		;		cjs, go multiply;		| 
   1b2f  01 00 c 0 0 d841 11e0  	 movw,s  r[1], y;	;		ldct divlong;			| Will call divlong if 32 bit result.
   1b30  05 00 5 0 0 d807 11c9  	movw  r[7], acc;		;		jsrp, zer divide;		| Reslt &  r[0] &&  r[1] & divhi same reg.
   1b31  04 09 e 0 5 cc82 0000  	sr0w  r[2], r[5];	am->am;		;				| 
   1b32  01 00 e 0 0 9606 0000  	subw,s d, r[6],y;	;		;				| if ( r[5] >  r[6])
   1b33  04 09 3 9 8 cc06 1b62  fmajy:	sl0w  r[6], r[8];	am->am;		cjp, ~neg fmajx;		| Y is major axis.   r[8] = 2* r[6].
   1b34  04 00 e 0 7 9e45 0000  	rsubw d, r[5], r[7];	;		;				| error = 2* r[6] -  r[5].
   1b35  05 00 e 0 0 c1e7 0000  	sub2nw 0,  r[7];		;		;				| Subtract 1, so testing >= 0 == > 0.
   1b36  04 00 e 0 9 cc05 0000  	sl0w  r[5], r[9];	;		;				|  r[9] = 2* r[5]
   1b37  05 00 e 0 0 d815 0000  	movw  r[21],acc;		;		;				| 
   1b38  15 00 1 0 0 d882 116f  	movw acc, r[2];	;		cjs, go multiply;		| diag_sq =  r[21] *  r[21].
   1b39  01 00 e 0 0 d856 0000  	 movw,s  r[22], y;	;		;				| 
   1b3a  05 09 e 0 0 d845 0000  	movw  r[5],y;		am->am;		;				| Compute addresses after mults.
   1b3b  04 00 e 0 1 9e0f 0000  	subw d, r[15], r[1];		;		;				|  r[1] =  r[15] -  r[5].
   1b3c  04 00 e 0 2 9e0d 0000  	subw d, r[13], r[2];		;		;				|  r[2] =  r[13] -  r[5].
   1b3d  05 09 3 0 0 d846 1b40  fypslo:	movw  r[6],y;		am->am;		cjp, zer fynslo;		| 
   1b3e  04 00 e 0 3 9e8e 0000  	addw d, r[14], r[3];		;		;				|  r[3] =  r[14] +  r[6]. Slope positive.
   1b3f  14 00 3 0 4 9e8c 1b42  	addw d, r[12], r[4];		;		cjp, go fysgerr;		|  r[4] =  r[12] +  r[6].
   1b40  04 00 e 0 3 9e0e 0000  fynslo: subw d, r[14], r[3];		;		;				|  r[3] =  r[14] -  r[6]. Slope negative.
   1b41  04 00 e 0 4 9e0c 0000  	subw d, r[12], r[4];		;		;				|  r[4] =  r[12] -  r[6].
   1b42  05 49 e 0 0 d8d4 0040  fysgerr: movw d, r[20];		64->am;		;				| Arrcnt = 64 (only used for very  11).
   1b43  05 00 e 0 0 d810 0000  	movw  r[16],acc;		;		;				|  r[6] -  r[0] - ( r[17] +  r[16]).
   1b44  05 00 e 0 0 8091 0000  	addw  r[17],acc,acc;	;		;				| 
   1b45  04 00 e 0 6 9840 0000  	rsubw  r[0],acc, r[6]; ;		;				| 
   1b46  05 45 e 0 0 d807 0000  	movw  r[7], acc;	 0x0->scrmemp; ;				| Load address where to store coords.
   1b47  11 00 1 0 0 c1f4 1b91  fyloop:	sub2nw,s 0,  r[20];		;		cjs, go fatarray;		| Store endpoints in scratchpad mem.
   1b48  05 00 e 0 0 dd61 0000  	incw  r[1], r[1];		;		;				|  r[1]++
   1b49  05 00 e 0 0 dd62 0000  	incw  r[2], r[2];		;		;				|  r[2]++
   1b4a  05 00 e 0 0 dd73 0000  	incw  r[19], r[19];	;		;				|  r[19]++
   1b4b  04 09 e 0 9 cc33 0000  	sl1w  r[19], r[25];	am->am;		;				|  r[17] +=  r[19] +  r[19] + 1.
   1b4c  01 00 e 0 0 8088 0000  	addw,s  r[8], acc, acc;	;		;				| error +=  r[8]
   1b4d  05 00 3 1 0 9e91 1b58  	addw d, r[17], r[17];	;		cjp, neg fyerr;			| Jump if (error > 0) [effectively].
   1b4e  11 00 1 0 0 c1f4 1b91  fymin:	sub2nw,s 0,  r[20];		;		cjs, go fatarray;		| Store endpoints in scratchpad mem.
   1b4f  01 00 e 0 0 d856 0000  	 movw,s  r[22], y;	;		;				| 
   1b50  05 00 3 0 0 dd72 1b53  	incw  r[18], r[18];	;		cjp, zer fyminn;		| Jump if slope is negative.
   1b51  05 00 e 0 0 c1e3 0000  fyminp: sub2nw 0,  r[3];		;		;				|  r[3]--.
   1b52  15 00 3 0 0 c1e4 1b55  	sub2nw 0,  r[4];		;		cjp, go fymin2;			|  r[4]--.
   1b53  05 00 e 0 0 dd63 0000  fyminn: incw  r[3], r[3];		;		;				|  r[3]++.
   1b54  05 00 e 0 0 dd64 0000  	incw  r[4], r[4];		;		;				|  r[4]++.
   1b55  04 09 e 0 9 cc32 0000  fymin2:	sl1w  r[18], r[25];	am->am;		;				|  r[16] +=  r[18] +  r[18] + 1.
   1b56  05 00 e 0 0 9e90 0000  	addw d, r[16], r[16];	;		;				| 
   1b57  05 00 e 0 0 8009 0000  	subw  r[9], acc, acc;	;		;				| error -=  r[9].
   1b58  05 09 e 0 0 d851 0000  fyerr:	movw  r[17],y;		am->am;		;				|  r[6] =  r[0] - ( r[17] +  r[16]).
   1b59  04 00 e 0 9 9e90 0000  	addw d, r[16], r[25];	;		;				| 
   1b5a  04 00 e 0 5 d966 0000  	movw  r[6], r[5];	;		;				| old_error = seg_error.
   1b5b  05 09 e 0 0 d859 0000  	movw  r[25],y;		am->am;		;				| 
   1b5c  00 00 e 0 6 9e00 0000  	subw,s d, r[0], r[6];	;		;				| Put  r[6] on y-bus (and in d-latch) for test
   1b5d  05 09 3 9 0 d846 1b5f  	movw  r[6],y;		am->am;		cjp, ~neg fypseg;		| 
   1b5e  05 09 e 0 0 df66 0000  fynseg: negw  r[6], r[6];	am->am;		;				| 
   1b5f  01 00 e 0 0 9605 0000  fypseg:	subw,s d, r[5],y;	;		;				| 
   1b60  05 00 3 9 0 7140 1b47  	;			;		cjp, ~neg fyloop;		| Loop until  r[6] >  r[5]. 
   1b61  15 0a 1 0 0 fb00 1b97  	compw 0,y;		am->scrmem;	cjs, go fatdraw;		| Neg terminate & draw vectors.
   1b62  04 09 e 0 8 cc05 0000  fmajx: sl0w  r[5], r[8];	am->am;		;				|  r[8] = 2 *  r[5].
   1b63  04 00 e 0 9 cc06 0000  	sl0w  r[6], r[9];	;		;				|  r[9] = 2 *  r[6].
   1b64  04 00 e 0 7 9e46 0000  	rsubw d, r[6], r[7];	;		;				| error = 2 *  r[5] -  r[6].
   1b65  05 00 e 0 0 c1e7 0000  	sub2nw 0,  r[7];		;		;				| Subtract 1, so testing >= 0 == > 0.	
   1b66  05 00 e 0 0 d815 0000  	movw  r[21],acc;		;		;				| Compute  r[0] before change  r[21].
   1b67  15 00 1 0 0 d882 116f  	movw acc, r[2];	;		cjs, go multiply;		| diag_sq =  r[21] *  r[21].
   1b68  01 00 e 0 0 d856 0000  	 movw,s  r[22], y;	;		;				| 
   1b69  05 09 e 0 0 d846 0000  	movw  r[6],y;		am->am;		;				| Compute addresses after mults.
   1b6a  04 00 e 0 3 9e0e 0000  	subw d, r[14], r[3];		;		;				|  r[3] =  r[14] -  r[6].
   1b6b  04 00 e 0 4 9e0c 0000  	subw d, r[12], r[4];		;		;				|  r[4] =  r[12] -  r[6].  Jump if slope neg.
   1b6c  05 09 3 0 0 d845 1b6f  fxpslo:	movw  r[5],y;		am->am;		cjp, zer fxnslo;		| 
   1b6d  04 00 e 0 1 9e8f 0000  	addw d, r[15], r[1];		;		;				|  r[1] =  r[15] +  r[5]. Slope positive.
   1b6e  14 00 3 0 2 9e8d 1b71  	addw d, r[13], r[2];		;		cjp, go fxsgerr;		|  r[2] =  r[13] +  r[5].
   1b6f  04 00 e 0 1 9e0f 0000  fxnslo:	subw d, r[15], r[1];		;		;				|  r[1] =  r[15] -  r[5]. Slope negative.
   1b70  04 00 e 0 2 9e0d 0000  	subw d, r[13], r[2];		;		;				|  r[2] =  r[13] -  r[5].
   1b71  05 49 e 0 0 d8d4 0040  fxsgerr:movw d, r[20];		64->am;		;				| Arrcnt = 64.
   1b72  05 00 e 0 0 d810 0000  	movw  r[16],acc;		;		;				|  r[6] -  r[0] - ( r[17] +  r[16]).
   1b73  05 00 e 0 0 8091 0000  	addw  r[17],acc,acc;	;		;				| 
   1b74  04 00 e 0 6 9840 0000  	rsubw  r[0],acc, r[6]; ;		;				| 
   1b75  05 45 e 0 0 d807 0000  	movw  r[7], acc;	 0x0->scrmemp; ;				| Load address where to store coords.
   1b76  11 00 1 0 0 c1f4 1b91  fxloop:	sub2nw,s 0,  r[20];		;		cjs, go fatarray;		| Store endpoints in scratchpad mem.
   1b77  05 00 e 0 0 dd63 0000  	incw  r[3], r[3];		;		;				|  r[3]++
   1b78  05 00 e 0 0 dd64 0000  	incw  r[4], r[4];		;		;				|  r[4]++
   1b79  05 00 e 0 0 dd73 0000  	incw  r[19], r[19];	;		;				|  r[19]++
   1b7a  04 09 e 0 9 cc33 0000  	sl1w  r[19], r[25];	am->am;		;				|  r[17] +=  r[19] +  r[19] + 1.
   1b7b  01 00 e 0 0 8088 0000  	addw,s  r[8], acc, acc;	;		;				| error +=  r[8]
   1b7c  05 00 3 1 0 9e91 1b87  	addw d, r[17], r[17];	;		cjp, neg fxerr;			| Jump if (error > 0) [effectively].
   1b7d  11 00 1 0 0 c1f4 1b91  fxmin:	sub2nw,s 0,  r[20];		;		cjs, go fatarray;		| Store endpoints in scratchpad mem.
   1b7e  01 00 e 0 0 d856 0000  	 movw,s  r[22], y;	;		;				| 
   1b7f  05 00 3 0 0 dd72 1b82  	incw  r[18], r[18];	;		cjp, zer fxminn;		|  r[18]++.  Jump if slope negative.
   1b80  05 00 e 0 0 c1e1 0000  fxminp: sub2nw 0,  r[1];		;		;				|  r[1]--.
   1b81  15 00 3 0 0 c1e2 1b84  	sub2nw 0,  r[2];		;		cjp, go fxmin2;			|  r[2]--.
   1b82  05 00 e 0 0 dd61 0000  fxminn: incw  r[1], r[1];		;		;				|  r[1]++.
   1b83  05 00 e 0 0 dd62 0000  	incw  r[2], r[2];		;		;				|  r[2]++.
   1b84  04 09 e 0 9 cc32 0000  fxmin2:	sl1w  r[18], r[25];	am->am;		;				|  r[16] +=  r[18] +  r[18] + 1.
   1b85  05 00 e 0 0 9e90 0000  	addw d, r[16], r[16];	;		;				| 
   1b86  05 00 e 0 0 8009 0000  	subw  r[9], acc, acc;	;		;				| error -=  r[9].
   1b87  05 09 e 0 0 d851 0000  fxerr:	movw  r[17],y;		am->am;		;				|  r[6] =  r[0] - ( r[17] +  r[16]).
   1b88  04 00 e 0 9 9e90 0000  	addw d, r[16], r[25];	;		;				| 
   1b89  04 00 e 0 5 d966 0000  	movw  r[6], r[5];	;		;				| old_error = seg_error.
   1b8a  05 09 e 0 0 d859 0000  	movw  r[25],y;		am->am;		;				| 
   1b8b  00 00 e 0 6 9e00 0000  	subw,s d, r[0], r[6];	;		;				| Put  r[6] on y-bus (and in d-latch) for test
   1b8c  05 09 3 9 0 d846 1b8e  	movw  r[6],y;		am->am;		cjp, ~neg fxpseg;		| 
   1b8d  05 09 e 0 0 df66 0000  fxnseg: negw  r[6], r[6];	am->am;		;				| 
   1b8e  01 00 e 0 0 9605 0000  fxpseg:	subw,s d, r[5],y;	;		;				| 
   1b8f  05 00 3 9 0 7140 1b76  	;			;		cjp, ~neg fxloop;		| Loop until  r[6] >  r[5]. 
   1b90  15 0a 1 0 0 fb00 1b97  	compw 0,y;		am->scrmem;	cjs, go fatdraw;		| Neg terminate & draw vectors.
                                |   Fatarray loads locations in scratchpad memory with the x and y addresses of each vector.  This is done
                                |   for the first 64 vectors, after which we draw this 64, and proceed to the next 64.  This routine is
                                |   called, putting the address from where it was called on the stack.  When the routine jumps to fxdraw, the
                                |   return address is therefore that of the calling routine, so we will return to the right place, hopefully
                                |   with the right state.
   1b91  05 0a e 0 4 d841 0000  fatarray: movw  r[1],y;		am->scrmem;	;			scrmp+	|  r[1]
   1b92  05 0a e 0 4 d843 0000  	movw  r[3],y;		am->scrmem;	;			scrmp+	|  r[3]
   1b93  05 0a e 0 4 d842 0000  	movw  r[2],y;		am->scrmem;	;			scrmp+	|  r[2]
   1b94  0d 0a a 8 4 d844 0000  	movw  r[4],y;		am->scrmem;	crtn, ~zer;		scrmp+	|  r[4]. Return to main if array not full.
   1b95  05 0a e 0 0 fb00 0000  	compw 0,y;		am->scrmem;	;				| Negative terminate points list.
   1b96  15 00 3 0 0 c1f4 1b97  	sub2nw 0,  r[20];		;		cjp, go fatdraw;		| Dec  r[20],draw, save state & cont.
                                |   It is in this part of the code that we first distinguish between textured and  5 vectors.
                                |   Fatdraw saves the state of the registers needed for this routine (if necessary, ie, if the  r[21] is greater
                                |   than 64) and then goes into a loop where it pulls the 4 endpoints (until  r[15] == -1) and calls the textured or
                                |    5 vector code for each set of points.  We need to restore our  11 vector registers again if the  r[21] is > 64.  
   1b97  01 45 e 0 0 d854 0101  fatdraw:  movw,s  r[20], y;	 0x101->scrmemp; ;				| Check if ( r[21] <= 64).
   1b98  05 0a 3 9 4 d855 1bd6  fdsave:	movw  r[21],y;		am->scrmem;	cjp, ~neg fdlast;	scrmp+	|  r[21]. Jump if last vectors.
   1b99  05 0a e 0 4 f880 0000  	movw  acc,y;		am->scrmem;	;			scrmp+	|  acc
   1b9a  05 0a e 0 4 d840 0000  	movw  r[0],y;		am->scrmem;	;			scrmp+	|  r[0]
   1b9b  05 0a e 0 4 d841 0000  	movw  r[1],y;		am->scrmem;	;			scrmp+	|  r[1].  
   1b9c  05 0a e 0 4 d842 0000  	movw  r[2],y;		am->scrmem;	;			scrmp+	|  r[2]
   1b9d  05 0a e 0 4 d843 0000  	movw  r[3],y;		am->scrmem;	;			scrmp+	|  r[3]
   1b9e  05 0a e 0 4 d844 0000  	movw  r[4],y;		am->scrmem;	;			scrmp+	|  r[4]
   1b9f  05 0a e 0 4 d846 0000  	movw  r[6],y;		am->scrmem;	;			scrmp+	|  r[6]
   1ba0  05 0a e 0 4 d845 0000  	movw  r[5],y;		am->scrmem;	;			scrmp+	|  r[5]
   1ba1  05 0a e 0 4 d848 0000  	movw  r[8],y;		am->scrmem;	;			scrmp+	|  r[8]
   1ba2  05 0a e 0 4 d849 0000  	movw  r[9],y;		am->scrmem;	;			scrmp+	|  r[9]
   1ba3  05 0a e 0 4 d850 0000  	movw  r[16],y;		am->scrmem;	;			scrmp+	|  r[16]
   1ba4  05 0a e 0 4 d851 0000  	movw  r[17],y;		am->scrmem;	;			scrmp+	|  r[17]
   1ba5  05 0a e 0 4 d852 0000  	movw  r[18],y;		am->scrmem;	;			scrmp+	|  r[18]
   1ba6  05 0a e 0 4 d853 0000  	movw  r[19],y;		am->scrmem;	;			scrmp+	|  r[19]
   1ba7  05 0a e 0 0 d856 0000  	movw  r[22],y;		am->scrmem;	;				|  r[22] 
                                |	Fdbegin is for drawing 64 vectors, and then returning to compute more endpoints.	
   1ba8  05 05 e 0 0 d919 0000  fdbegin: movw 0,r[25];	am->scrmemp;	;				| Load address of coordinates.
   1ba9  01 59 e 0 4 d8cf 0000  	movw,s d, r[15];		scrmem->am;	;			scrmp+	|  r[15].
   1baa  05 59 3 1 4 d8ce 1bc3  	movw d, r[14];		scrmem->am;	cjp, neg fdres;		scrmp+	|  r[14]. Jump if done (terminated w/ -1).
   1bab  05 59 e 0 4 d8cd 0000  	movw d, r[13];		scrmem->am;	;			scrmp+	|  r[13].
   1bac  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];		;		;				| Restore  r[11].
   1bad  05 59 e 0 4 d8cc 0000  	movw d, r[12];		scrmem->am;	;			scrmp+	|  r[12].
   1bae  04 45 e 0 a 9e4e 0190  	rsubw d, r[14], r[10];		 0x190->scrmemp; ;				| Restore  r[10] + draw  5 or textured.
   1baf  01 00 c 0 0 ebf8 134a  	btstw,s  5, r[24];	;		ldct vop0;			| 
   1bb0  05 0a e 0 4 d84f 0000  	movw  r[15],y;		am->scrmem;	;			scrmp+	|  r[15]->scrmem (for clipping reasons).
   1bb1  05 0a e 0 4 d84e 0000  	movw  r[14],y;		am->scrmem;	;			scrmp+	|  r[14]->scrmem.
   1bb2  05 0a e 0 4 d84d 0000  	movw  r[13],y;		am->scrmem;	;			scrmp+	|  r[13]->scrmem.
   1bb3  05 0a 5 0 0 d84c 1803  	movw  r[12],y;		am->scrmem;	jsrp, zer top0;			|  r[12]->scrmem & call  5 or textured.
   1bb4  05 45 e 0 0 f7b8 0130  	bsetw  11, r[24];	0x130->scrmemp; ;				| Set  11 vector bit of  r[24] field.
   1bb5  05 0a e 0 0 d846 0000  	movw  r[6],y;		am->scrmem;	;				| Store  r[6] (once only).
   1bb6  05 05 e 0 0 c5d9 0000  	add2nw 2,r[25];	am->scrmemp;	;				| 
   1bb7  01 59 e 0 4 d8cf 0000  fdloop:	movw,s d, r[15];		scrmem->am;	;			scrmp+	|  r[15].
   1bb8  05 59 3 1 4 d8ce 1bc3  	movw d, r[14];		scrmem->am;	cjp, neg fdres;		scrmp+	|  r[14]. Jump if done (terminated w/ -1).
   1bb9  05 59 e 0 4 d8cd 0000  	movw d, r[13];		scrmem->am;	;			scrmp+	|  r[13].
   1bba  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];		;		;				| Restore  r[11].
   1bbb  05 59 e 0 4 d8cc 0000  	movw d, r[12];		scrmem->am;	;			scrmp+	|  r[12].
   1bbc  04 45 e 0 a 9e4e 0190  	rsubw d, r[14], r[10];		 0x190->scrmemp; ;				| Restore  r[10] + draw  5 or textured.
   1bbd  01 00 c 0 0 ebf8 134a  	btstw,s  5, r[24];	;		ldct vop0;			| 
   1bbe  05 0a e 0 4 d84f 0000  	movw  r[15],y;		am->scrmem;	;			scrmp+	|  r[15]->scrmem (for clipping reasons).
   1bbf  05 0a e 0 4 d84e 0000  	movw  r[14],y;		am->scrmem;	;			scrmp+	|  r[14]->scrmem.
   1bc0  05 0a e 0 4 d84d 0000  	movw  r[13],y;		am->scrmem;	;			scrmp+	|  r[13]->scrmem.
   1bc1  05 0a 5 0 0 d84c 1803  	movw  r[12],y;		am->scrmem;	jsrp, zer top0;			|  r[12]->scrmem & call  5 or textured.
   1bc2  15 05 3 0 0 c5d9 1bb7  	add2nw 2,r[25];	am->scrmemp;	cjp, go fdloop;			| 
   1bc3  05 45 e 0 0 7140 0101  fdres:	;			 0x101->scrmemp; ;				| Load addr for restoring. 
   1bc4  05 59 e 0 4 d8d5 0000  	movw d, r[21];		scrmem->am;	;			scrmp+	|  r[21]
   1bc5  05 59 e 0 4 f8c1 0000  	movw d, acc;		scrmem->am;	;			scrmp+	|  acc
   1bc6  05 59 e 0 4 d8c0 0000  	movw d, r[0];		scrmem->am;	;			scrmp+	|  r[0]
   1bc7  05 59 e 0 4 d8c1 0000  	movw d, r[1];		scrmem->am;	;			scrmp+	|  r[1]
   1bc8  05 59 e 0 4 d8c2 0000  	movw d, r[2];		scrmem->am;	;			scrmp+	|  r[2]
   1bc9  05 59 e 0 4 d8c3 0000  	movw d, r[3];		scrmem->am;	;			scrmp+	|  r[3]
   1bca  05 59 e 0 4 d8c4 0000  	movw d, r[4];		scrmem->am;	;			scrmp+	|  r[4]
   1bcb  05 59 e 0 4 d8c6 0000  	movw d, r[6];		scrmem->am;	;			scrmp+	|  r[6]
   1bcc  05 59 e 0 4 d8c5 0000  	movw d, r[5];		scrmem->am;	;			scrmp+	|  r[5]
   1bcd  05 59 e 0 4 d8c8 0000  	movw d, r[8];		scrmem->am;	;			scrmp+	|  r[8]
   1bce  05 59 e 0 4 d8c9 0000  	movw d, r[9];		scrmem->am;	;			scrmp+	|  r[9]
   1bcf  05 59 e 0 4 d8d0 0000  	movw d, r[16];		scrmem->am;	;			scrmp+	|  r[16]
   1bd0  05 59 e 0 4 d8d1 0000  	movw d, r[17];		scrmem->am;	;			scrmp+	|  r[17]
   1bd1  05 59 e 0 4 d8d2 0000  	movw d, r[18];		scrmem->am;	;			scrmp+	|  r[18]
   1bd2  05 59 e 0 4 d8d3 0000  	movw d, r[19];		scrmem->am;	;			scrmp+	|  r[19] 
   1bd3  05 59 e 0 0 d8d6 0000  	movw d, r[22];		scrmem->am;	;				|  r[22]
   1bd4  05 45 e 0 0 7140 0000  	;			 0x0->scrmemp; ;				| Load address where to write coords.
   1bd5  1d 49 a 0 0 d8d4 0040  fdstart: movw d, r[20];		64->am;		crtn, go;			| Arrcnt = 64, return to comp. vectors.
                                |   Fdlast is reached either when the  r[21] is less than 64, or we are drawing the last 64 vectors.
   1bd6  05 05 e 0 0 d919 0000  fdlast:	movw 0,r[25];	am->scrmemp;	;				| Load address of coordinates.
   1bd7  01 59 e 0 4 d8cf 0000  	movw,s d, r[15];		scrmem->am;	;			scrmp+	|  r[15].
   1bd8  05 59 b 1 4 d8ce 1bf1  	movw d, r[14];		scrmem->am;	cjpp, neg fdend;	scrmp+	|  r[14]. Jump & pop if done(-1 terminated).
   1bd9  05 59 e 0 4 d8cd 0000  	movw d, r[13];		scrmem->am;	;			scrmp+	|  r[13].
   1bda  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];		;		;				| Restore  r[11].
   1bdb  05 59 e 0 0 d8cc 0000  	movw d, r[12];		scrmem->am;	;				|  r[12].
   1bdc  04 45 e 0 a 9e4e 0190  	rsubw d, r[14], r[10];		 0x190->scrmemp; ;				| Restore  r[10] + draw  5 or textured.
   1bdd  01 00 c 0 0 ebf8 134a  	btstw,s  5, r[24];	;		ldct vop0;			| 
   1bde  05 0a e 0 4 d84f 0000  	movw  r[15],y;		am->scrmem;	;			scrmp+	|  r[15]->scrmem (for clipping reasons).
   1bdf  05 0a e 0 4 d84e 0000  	movw  r[14],y;		am->scrmem;	;			scrmp+	|  r[14]->scrmem.
   1be0  05 0a e 0 4 d84d 0000  	movw  r[13],y;		am->scrmem;	;			scrmp+	|  r[13]->scrmem.
   1be1  05 0a 5 0 0 d84c 1803  	movw  r[12],y;		am->scrmem;	jsrp, zer top0;			|  r[12]->scrmem & call  5 or textured.
   1be2  05 45 e 0 0 f7b8 0130  	bsetw  11, r[24];	0x130->scrmemp; ;				| Set  11 vector bit of  r[24] field.
   1be3  05 0a e 0 0 d846 0000  	movw  r[6],y;		am->scrmem;	;				| Store  r[6] (once only).
   1be4  05 05 e 0 0 c5d9 0000  	add2nw 2,r[25];	am->scrmemp;	;				| 
   1be5  01 59 e 0 4 d8cf 0000  fdlloop: movw,s d, r[15];		scrmem->am;	;			scrmp+	|  r[15].
   1be6  05 59 b 1 4 d8ce 1bf1  	movw d, r[14];		scrmem->am;	cjpp, neg fdend;	scrmp+	|  r[14]. Jump & pop if done(-1 terminated).
   1be7  05 59 e 0 4 d8cd 0000  	movw d, r[13];		scrmem->am;	;			scrmp+	|  r[13].
   1be8  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];		;		;				| Restore  r[11].
   1be9  05 59 e 0 4 d8cc 0000  	movw d, r[12];		scrmem->am;	;			scrmp+	|  r[12].
   1bea  04 45 e 0 a 9e4e 0190  	rsubw d, r[14], r[10];		 0x190->scrmemp; ;				| Restore  r[10] + draw  5 or textured.
   1beb  01 00 c 0 0 ebf8 134a  	btstw,s  5, r[24];	;		ldct vop0;			| 
   1bec  05 0a e 0 4 d84f 0000  	movw  r[15],y;		am->scrmem;	;			scrmp+	|  r[15]->scrmem (for clipping reasons).
   1bed  05 0a e 0 4 d84e 0000  	movw  r[14],y;		am->scrmem;	;			scrmp+	|  r[14]->scrmem.
   1bee  05 0a e 0 4 d84d 0000  	movw  r[13],y;		am->scrmem;	;			scrmp+	|  r[13]->scrmem.
   1bef  05 0a 5 0 0 d84c 1803  	movw  r[12],y;		am->scrmem;	jsrp, zer top0;			|  r[12]->scrmem & call  5 or textured.
   1bf0  15 05 3 0 0 c5d9 1be5  	add2nw 2,r[25];	am->scrmemp;	cjp, go fdlloop;		| 
   1bf1  1d 00 a 0 0 7140 0000  fdend:	;			;		crtn, go;			| All done !!
                                |   We reach fatpoint when we have a single point with  r[21].  We will draw a single  r[21] point, and since
                                |   we jump to the code, we will return to the calling routine.
   1bf2  01 00 c 0 0 ebf8 134a  fatpoint: btstw,s  5, r[24]; ;		ldct vop0;			| Are going to draw single point.
   1bf3  05 00 7 0 0 7140 1803  	;			;		jrp, zer top0;			| Jump textured if zero,  5 if 1.
                                | "@(#)squareroot.pp.u 1.2 86/09/12"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | Written by Stuart Levy
                                |   Result is in r[7], number to be square-rooted is in r[5] and r[6], where r[6]
                                |   must be zeroed out if not used.  Note that first instruction needs condition code to be
                                |   set by calling routine, are checking if squares is 0.
   1bf4  00 00 3 0 0 c1e5 1c25  sqrt:	sub2nw,s 0, r[5],r[0]; ;		cjp, zer sqzero;		| Will return zero if  r[5] 0 or 1.
   1bf5  04 00 3 0 7 d965 1c25  	movw  r[5], r[7];	;		cjp, zer sqzero;		| 
   1bf6  01 00 e 0 0 d846 0000  	 movw,s  r[6], y;		;		;				| Check if need to do double precision.
   1bf7  04 00 3 8 0 d965 1c09  	movw  r[5], r[0];		;		cjp, ~zer sqdbl;		| Jump if need to use double precision.
   1bf8  01 49 e 0 0 cc80 0011  sqshft:	sr0w,s  r[0], r[0];		17->am;		;				| while ( r[0]>>=2) x>>=1.
   1bf9  01 00 3 0 0 cc80 1bfc  	sr0w,s  r[0], r[0];		;		cjp, zer sqrt2;			| 
   1bfa  05 00 3 8 0 cc87 1bf8  	sr0w  r[7], r[7];	;		cjp, ~zer sqshft;		| 
   1bfb  05 00 e 0 0 cc47 0000  	slqw  r[7], r[7];	;		;				| Shift back once, using qlink (MSB).
   1bfc  05 00 e 0 0 dd67 0000  sqrt2:	incw  r[7], r[7];	;		;				| 
   1bfd  05 00 e 0 0 d807 0000  sqloop:	movw  r[7], acc;	;		;				| 
   1bfe  14 00 1 0 0 d965 11c9  	movw  r[5], r[0];	;		cjs, go divide;			| 
   1bff  05 09 e 0 0 d842 0000  	movw  r[2],y;		am->am;		;				|  r[2] = n/x. Q is in d-latch.
   1c00  01 00 e 0 0 9647 0000  sqloop2: rsubw,s d, r[7],y;	;		;				| Compute (q-x). Will jump if (x <= q).
   1c01  05 00 3 1 0 7140 1c07  	;			;		cjp, neg squpx;			| if (x <= q) =>  r[4] = x+2 
   1c02  04 09 e 0 4 c3c7 0000  	add2nw 1, r[7], r[4];	am->am;		;				| 
   1c03  01 00 e 0 0 9602 0000  	subw,s d, r[2],y;	;		;				| Check if (q <  r[4]), ie (q- r[4]) < 0.
   1c04  0d 09 a 1 0 d842 0000  	movw  r[2],y;		am->am;		crtn, neg;			| Return if (q <  r[4]).
   1c05  01 00 3 8 0 f880 1c07  	 movw,s  acc, y;		;		cjp, ~zer squpx;		| Continue if q !=  r[4]. 
   1c06  0d 00 a 0 0 7140 0000  	;			;		crtn, zer;			| Return if (q ==  r[4] && mod2==0). Q in d-latch.
   1c07  05 00 e 0 0 9e87 0000  squpx:	addw d, r[7], r[7];	;		;				| x = (x + q) >> 1.
   1c08  15 00 3 0 0 cc87 1bfd  	sr0w  r[7], r[7];	;		cjp, go sqloop;			| 
                                |   Double precision squareroot routine.  Note that mod moves to r[1] now.
   1c09  04 00 e 0 1 d966 0000  sqdbl: movw  r[6], r[1];	;		;				| Double precision squareroot.
   1c0a  04 00 e 0 3 d966 0000  	movw  r[6], r[3];	;		;				| 
   1c0b  01 00 e 0 0 cc81 0000  sqdshft: sr0w,s  r[1], r[1];	;		;				| While ( r[0]>>=2) x>>=1.
   1c0c  05 00 3 0 0 ccc0 1c12  	srqw  r[0], r[0];		;		cjp, zer sqrshft2;		| 
   1c0d  01 00 e 0 0 cc81 0000  	sr0w,s  r[1], r[1];	;		;				| Shift down upper word of  r[0] again.
   1c0e  05 00 3 0 0 ccc0 1c13  	srqw  r[0], r[0];		;		cjp, zer sqrres;		| Shift LSB of upper into MSB of lower.
   1c0f  01 00 e 0 0 cc83 0000  	sr0w,s  r[3], r[3];	;		;				| Here we know res is still double prec.
   1c10  15 00 3 0 0 ccc7 1c0b  	srqw  r[7], r[7];	;		cjp, go sqdshft;		| Loop.
   1c11  05 00 e 0 0 cc80 0000  sqrshft: sr0w  r[0], r[0];		;		;				| T is single prec., res is still double.
   1c12  05 00 e 0 0 cc80 0000  sqrshft2: sr0w  r[0], r[0];		;		;				| 
   1c13  01 00 e 0 0 cc83 0000  sqrres:	sr0w,s  r[3], r[3];	;		;				| Res should be single before  r[0] = 0. CHECK!
   1c14  05 00 3 8 0 ccc7 1c11  	srqw  r[7], r[7];	;		cjp, ~zer sqrshft;		| Loop as long as res is still double prec.
   1c15  01 49 e 0 0 cc80 0011  sqsshft: sr0w,s  r[0], r[0];		17->am;		;				| Code same as single prec. until divide!!
   1c16  01 00 3 0 0 cc80 1c19  	sr0w,s  r[0], r[0];		;		cjp, zer sqrtd2;		| 
   1c17  05 00 3 8 0 cc87 1c15  	sr0w  r[7], r[7];	;		cjp, ~zer sqsshft;		| 
   1c18  05 00 e 0 0 cc47 0000  	slqw  r[7], r[7];	;		;				| Shift back once, using qlink (MSB).
   1c19  05 00 e 0 0 dd67 0000  sqrtd2:	incw  r[7], r[7];	;		;				| x++
   1c1a  05 00 e 0 0 d807 0000  sqdloop: movw  r[7], acc;	;		;				| 
   1c1b  04 00 e 0 1 d966 0000  	movw  r[6], r[1];	;		;				| Load upper word in upper dividend word.
   1c1c  14 00 1 0 0 d965 11e0  	movw  r[5], r[0];	;		cjs, go divlong;		| Load lower word in dividend.
   1c1d  05 09 e 0 0 d842 0000  	movw  r[2],y;		am->am;		;				| Make sure can assume  r[7] is 16 bits.
   1c1e  01 00 e 0 0 9647 0000  sqdloop2: rsubw,s d, r[7],y;	;		;				| Compute (q-x). Will jump if (x <= q).
   1c1f  05 00 3 1 0 7140 1c23  	;			;		cjp, neg squdpx;		| if (x <= q) =>  r[4] = x+2 
   1c20  04 09 e 0 4 c3c7 0000  	add2nw 1, r[7], r[4];	am->am;		;				| 
   1c21  01 00 e 0 0 9642 0000  	rsubw,s d, r[2],y;	;		;				| Will return if (q <=  r[4]), ie ( r[4] - q) >= 0.
   1c22  0d 09 a 9 0 d842 0000  	movw  r[2],y;		am->am;		crtn, ~neg;			| 
   1c23  05 00 e 0 0 9e87 0000  squdpx:	addw d, r[7], r[7];	;		;				| x = (x + q) >> 1.
   1c24  15 00 3 0 0 cc87 1c1a  	sr0w  r[7], r[7];	;		cjp, go sqdloop;		| 
   1c25  1d 00 a 0 0 d907 0000  sqzero:	movw 0, r[7];		;		crtn, go;			| Move 0 to  r[7] if number is 0 or 1.
                                | "@(#)polyline.pp.u 1.2 86/09/12"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | Written by Stuart Levy
                                |   The  r[24] field is broken down as follows:
                                |  	 bit 15 - startpt	bit 14 - endpt		bit 13 - balancing	bit 12 - givenpattern
                                |  	 bit 11 - fat		bit 10 - poly		bit 9 - mvlist		bit 8 - righthalf
                                |   	 bit 7 - close		bit 6 - cliprt		bit 5 - solid		bit 4 - pixrect
                                |   	 bit 3 - nosetup	bit 2 - clipbit		bit 1 - firstvec
                                |   This routine assumes that the  5 &  9 fields have been filled in the  r[24] word.
                                |   For lines without a  9, the  7 field has also been filled in advance, but for lines with
                                |   a  9, the program fills in this field, with the value of the first  9 element.  
   1c26  05 61 3 d 0 d8c8 1c26  polyln:	movw d, r[8];		fifo1->am;	cjp, f1e .;			|  r[8]
   1c27  05 61 3 d 0 d8c9 1c27  	movw d, r[9];		fifo1->am;	cjp, f1e .;			|  r[9]
   1c28  05 61 3 d 0 d8d5 1c28  	movw d, r[21];		fifo1->am;	cjp, f1e .;			|  r[21]
   1c29  05 00 e 0 0 d902 0000  	movw 0,r[2];		;		;				| 0->numsegs
   1c2a  05 45 e 0 0 d904 0150  	movw 0,r[4];		0x150->scrmemp; ;				| 0->patln
   1c2b  01 61 3 d 0 d8c3 1c2b  polpatlp: movw,s d,r[3];	fifo1->am;	cjp, f1e .;			| pattern segments
   1c2c  05 00 3 0 0 9e84 1c2f  	addw d,r[4],r[4];	;		cjp, zer pol2;			| jump if zero,patln+=segment
   1c2d  05 0a e 0 4 f8c0 0000  	movw d,y;		am->scrmem;	;			scrmp+	| segment->scrmem
   1c2e  15 00 3 0 0 dd62 1c2b  	incw r[2],r[2];		;		cjp, go polpatlp;		| numsegs++, loop
   1c2f  05 61 3 d 0 d8c3 1c2f  pol2:	movw d,r[3];		fifo1->am;	cjp, f1e .;			| stoff
   1c30  05 45 e 0 0 e7d8 0120  	bclrw  3, r[24];	 0x120->scrmemp; ;				|  0x120->scrmemp, set  8 bit
   1c31  05 0a e 0 4 f8c0 0000  	movw d,y;		am->scrmem;	;			scrmp+	| stoff->scrmem
   1c32  05 61 3 d 0 d8d8 1c32  	movw d, r[24];		fifo1->am;	cjp, f1e .;			|  r[24]
   1c33  05 00 e 0 0 e9b8 0000  	bsetw  4, r[24];	;		;				| tex-> r[24]. 4=1.
   1c34  05 0a e 0 4 d844 0000  	movw r[4],y;		am->scrmem;	;			scrmp+	| patln->scrmem
   1c35  05 0a e 0 4 d842 0000  	movw r[2],y;		am->scrmem;	;			scrmp+	| numsegs->scrmem
   1c36  05 61 3 d 0 d8dc 1c36  	movw d,r[28];		fifo1->am;	cjp, f1e .;			| r[28]
   1c37  00 49 e 0 7 9f3c fffe  	norw,s d,r[28], r[23];	0xfffe->am;	;				| (PIX_DONTCLIP == 1) => ( r[23] == 0).
   1c38  05 00 3 0 0 e5d8 1c3a  	bclrw  2, r[24];	;		cjp, zer pol3;			| clear  r[23] in  r[24]
   1c39  05 00 e 0 0 e5b8 0000  	bsetw  2, r[24];	;		;				| set  r[23] in  r[24]
   1c3a  05 61 3 d 0 d8db 1c3a  pol3:	movw d,r[27];		fifo1->am;	cjp, f1e .;			| r[27]
   1c3b  05 00 e 0 0 979c 0000  	rolw 11,r[28],acc;		;		;				| r[27] in r[28]?
   1c3c  01 49 e 0 0 e2c1 07ff  	andw,s d,acc,acc;	0x7ff->am;	;				| 
   1c3d  05 00 3 0 0 cc9c 1c3f  	sr0w r[28],r[28];		;		cjp, zer pol4;			| r[28] >>= 1. 
   1c3e  05 00 e 0 0 d89b 0000  	movw acc,r[27];		;		;				| 
   1c3f  05 61 3 d 0 d8c7 1c3f  pol4:	movw d, r[7];		fifo1->am;	cjp, f1e .;			|  r[7]
                                |   Begin drawing.
   1c40  01 49 e 0 0 9607 0002  polyst:	subw,s d, r[7],y;	0x2->am;	;				| 
   1c41  09 00 a 1 0 f3f8 0000  	btstw,s  9, r[24];	;		crtn, neg;			| Return if  r[7] = 0 or  r[7] = 1.
   1c42  01 00 3 0 0 ebf8 1c5d  	btstw,s  5, r[24];	;		cjp, zer p3nmv;			| Jump if  9 doesn't exist.
                                |   Case 1.  At this point, we know we have a valid movelist and a textured vector.
   1c43  15 00 1 0 0 efd8 1c73  p1mvtex: bclrw  7, r[24];	;		cjs, go getxy0mv;		| Fetch  r[15], r[14], 9. Clear  7 field.
   1c44  01 00 3 0 0 ebf8 1c46  	btstw,s  5, r[24];	;		cjp, zer p1mv2;			| Jump if not closing polylines.
   1c45  05 00 e 0 0 efb8 0000  	bsetw  7, r[24];	;		;				| Are closing polylines.
   1c46  04 00 3 8 0 d96f 1c55  p1mv2:	movw  r[15], r[0];		;		cjp, ~zer p2mvsol;		| Jump to p2mvsol if  5 vector.
   1c47  15 00 3 0 0 f5d8 1c4c  	bclrw  10, r[24];	;		cjp, go p1new2;			| 
   1c48  05 00 e 0 0 f5d8 0000  p1newply: bclrw  10, r[24];	;		;				| Fetch  r[15], r[14],add offset,test  9.
   1c49  04 00 e 0 f d96d 0000  	movw  r[13], r[15];		;		;				|  r[15] =  r[13].
   1c4a  04 00 e 0 e d96c 0000  	movw  r[12], r[14];		;		;				|  r[14] =  r[12].
   1c4b  04 00 e 0 0 d96f 0000  	movw  r[15], r[0];		;		;				|  r[0] =  r[15]. Jump if  9 is set.
   1c4c  01 00 c 0 0 c1e7 1c68  p1new2:	sub2nw,s 0,  r[7];		;		ldct pend;			| Actually, want to return without drawing!!!
   1c4d  04 00 5 8 1 d96e 1c7b  	movw  r[14], r[1];		;		jsrp, ~zer getxy1mv1;		| 
   1c4e  01 00 5 0 0 eff8 1c91  	btstw,s  7, r[24];	;		jsrp, zer pdraw;		| Draw if  9 = 0, else to p1cldrw.
   1c4f  05 00 e 0 0 f5b8 0000  	bsetw  10, r[24];	;		;				| tex-> r[24]. 10 = 1.
   1c50  04 00 e 0 f d96d 0000  	movw  r[13], r[15];		;		;				|  r[15] =  r[13]. 
   1c51  01 00 c 0 0 c1e7 1c68  p1loop:	sub2nw,s 0,  r[7];		;		ldct pend;			|  r[7]-- (begin for loop).
   1c52  04 00 5 8 e d96c 1c7b  	movw  r[12], r[14];		;		jsrp, ~zer getxy1mv1;		|  r[14] =  r[12]. Fetch next if  r[7] != 0.
   1c53  01 00 5 0 0 eff8 1c91  	btstw,s  7, r[24];	;		jsrp, zer pdraw;		| Draw if  9=0, else to p1cldrw.
   1c54  14 00 3 0 f d96d 1c51  	movw  r[13], r[15];		;		cjp, go p1loop;			|  r[15] =  r[13] & loop.
                                |   Case 2.  At this point, we know we have a valid movelist and a  5 vector.
   1c55  01 00 c 0 0 c1e7 1c68  p2mvsol: sub2nw,s 0,  r[7];		;		ldct pend;			|  r[7]--.
   1c56  04 00 5 8 1 d96e 1c83  	movw  r[14], r[1];		;		jsrp, ~zer getxy1mv2;		|  r[1] =  r[14]. Fetch  r[13],  r[12] if ( r[7]).
   1c57  01 00 5 0 0 eff8 1c91  	btstw,s  7, r[24];	;		jsrp, zer pdraw;		| pdraw if  9=0, else to p2cldrw.
   1c58  04 00 e 0 f d96d 0000  	movw  r[13], r[15];		;		;				|  r[15] =  r[13].
   1c59  01 00 c 0 0 c1e7 1c68  p2loop:	sub2nw,s 0,  r[7];		;		ldct pend;			|  r[7]-- (begin for loop).
   1c5a  04 00 5 8 e d96c 1c83  	movw  r[12], r[14];		;		jsrp, ~zer getxy1mv2;		|  r[14] =  r[12]. Fetch next if  r[7] != 0.
   1c5b  01 00 5 0 0 eff8 1c91  	btstw,s  7, r[24];	;		jsrp, zer pdraw;		| Draw if  9=0, else to p1cldrw.
   1c5c  14 00 3 0 f d96d 1c59  	movw  r[13], r[15];		;		cjp, go p2loop;			|  r[15] =  r[13] & loop.
                                |   Case 3.  At this point, we have no  9 and don't care whether we have a solid or textured vector.
                                |   p3nmvtex: bclrw  7, r[24];	;	cjs, go getxy0mv;		| Fetch x,y,add offset,test  7.
                                |	btstw,s  5, r[24];	;		cjp, zer p3nmv2;		| Jump if not closing polylines.
                                |	bsetw  7, r[24];	;		;				| Are closing polylines.
   1c5d  04 61 3 d f 9e88 1c5d  p3nmv:	addw d, r[8], r[15];		fifo1->am;	cjp, f1e .;			| Loop while fifo empty.  r[15] +=  r[8].
   1c5e  04 61 3 d e 9e89 1c5e  	addw d, r[9], r[14];		fifo1->am;	cjp, f1e .;			| Loop while fifo empty.  r[14] +=  r[9].
   1c5f  04 00 e 0 0 d96f 0000  	movw  r[15], r[0];		;		;				|  r[0] =  r[15].
   1c60  04 00 e 0 1 d96e 0000  	movw  r[14], r[1];		;		;				|  r[14] =  r[1] & draw line.
   1c61  05 00 e 0 0 f5d8 0000  	bclrw  10, r[24];	;		;				| tex-> r[24]. 10 = 0.
   1c62  15 00 1 0 0 c1e7 1c8b  	sub2nw 0,  r[7];		;		cjs, go getxy1dr;		|  r[7]-- & fetch  r[13],  r[12].
   1c63  05 00 e 0 0 f5b8 0000  	bsetw  10, r[24];	;		;				| tex-> r[24]. 10 = 1.
   1c64  04 00 e 0 f d96d 0000  	movw  r[13], r[15];		;		;				|  r[15] =  r[13].
   1c65  01 00 c 0 0 c1e7 1c68  p3loop:	sub2nw,s 0,  r[7];		;		ldct pend;			|  r[7]-- & load brreg.
   1c66  04 00 5 8 e d96c 1c8b  	movw  r[12], r[14];		;		jsrp, ~zer getxy1dr;		|  r[14] =  r[12]. Fetch & draw if  r[7] != 0.
   1c67  14 00 3 0 f d96d 1c65  	movw  r[13], r[15];		;		cjp, go p3loop;			|  r[15] =  r[13] and loop.
   1c68  11 00 b 0 0 eff8 1c69  pend:	btstw,s  7, r[24];	;		cjpp, go pend2;			| Pop call off stack.
   1c69  0c 09 a 0 d d960 0000  pend2:	movw  r[0], r[13];		am->am;		crtn, zer;			|  r[13] =  r[0] & return if no  7.
   1c6a  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];		;		;				| Compute  r[11].
   1c6b  01 00 e 0 0 970f 0000  	xorw,s d, r[15],y;		;		;				| Test if  r[15] =  r[13].
   1c6c  04 09 3 8 c d961 1c6e  	movw  r[1], r[12];		am->am;		cjp, ~zer pend3;		|  r[12] =  r[1].Jump if  r[15] !=  r[13].
   1c6d  01 00 e 0 0 970e 0000  	xorw,s d, r[14],y;		;		;				| 
   1c6e  0c 45 a 0 a 9e4e 0190  pend3:	rsubw d, r[14], r[10];		 0x190->scrmemp; crtn, zer;			| Compute  r[10], return if all moves.
   1c6f  05 0a e 0 4 d84f 0000  	movw  r[15],y;		am->scrmem;	;			scrmp+	| Save	 r[15].
   1c70  05 0a e 0 4 d84e 0000  	movw  r[14],y;		am->scrmem;	;			scrmp+	| 	 r[14].
   1c71  05 0a e 0 4 d84d 0000  	movw  r[13],y;		am->scrmem;	;			scrmp+	| 	 r[13].
   1c72  15 0a 3 0 0 d84c 1b0a  	movw  r[12],y;		am->scrmem;	cjp, go fatcheck;		| 	 r[12] & draw.
                                |   Subroutines used by polyline routine.
                                |   Getxy#mv1 both fetch, and add the offsets to the x and y values of a point.  They also compute  r[11] and  r[10],
                                |   as well as in the case of xy1, load the branch register.
   1c73  04 61 3 d f 9e88 1c73  getxy0mv: addw d, r[8], r[15];	fifo1->am;	cjp, f1e .;			| Loop while fifo empty.  r[15] +=  r[8].
   1c74  05 09 e 0 0 d84f 0000  	movw  r[15],y;		am->am;		;				| 
   1c75  04 00 e 0 b 9e00 0000  	subw d, r[0], r[11];	;		;				| Compute  r[11] (based on  r[0]).
   1c76  04 61 3 d e 9e89 1c76  	addw d, r[9], r[14];		fifo1->am;	cjp, f1e .;			| Loop while fifo empty.  r[14] +=  r[9].
   1c77  05 09 e 0 0 d84e 0000  	movw  r[14],y;		am->am;		;				| 
   1c78  04 00 e 0 a 9e01 0000  	subw d, r[1], r[10];	;		;				| Compute  r[10] (based on  r[1]).
   1c79  01 61 3 d 0 f8c0 1c79  	movw,s d,y;		fifo1->am;	cjp, f1e .;			| Test  9.
   1c7a  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| Return.
   1c7b  04 61 3 d d 9e88 1c7b  getxy1mv1: addw d, r[8], r[13];	fifo1->am;	cjp, f1e .;			| Loop while fifo empty.  r[13] +=  r[8].
   1c7c  05 09 e 0 0 d84d 0000  	movw  r[13],y;		am->am;		;				| 
   1c7d  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];		;		;				| Compute  r[11].
   1c7e  04 61 3 d c 9e89 1c7e  	addw d, r[9], r[12];		fifo1->am;	cjp, f1e .;			| Loop while fifo empty.  r[12] +=  r[9].
   1c7f  05 09 e 0 0 d84c 0000  	movw  r[12],y;		am->am;		;				| 
   1c80  04 00 c 0 a 9e4e 1cb9  	rsubw d, r[14], r[10];		;		ldct p1cldrw;			| Compute  r[10] & load brreg.
   1c81  01 61 3 d 0 f8c0 1c81  	movw,s d,y;		fifo1->am;	cjp, f1e .;			| Test  9.
   1c82  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| Return.
                                |   The only difference between getxy1mv1 and 2 are the branch address, since for 2, don't want to go to newpolyline.
   1c83  04 61 3 d d 9e88 1c83  getxy1mv2: addw d, r[8], r[13];	fifo1->am;	cjp, f1e .;			| Loop while fifo empty.  r[13] +=  r[8].
   1c84  05 09 e 0 0 d84d 0000  	movw  r[13],y;		am->am;		;				| 
   1c85  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];		;		;				| Compute  r[11].
   1c86  04 61 3 d c 9e89 1c86  	addw d, r[9], r[12];		fifo1->am;	cjp, f1e .;			| Loop while fifo empty.  r[12] +=  r[9].
   1c87  05 09 e 0 0 d84c 0000  	movw  r[12],y;		am->am;		;				| 
   1c88  04 00 c 0 a 9e4e 1cc7  	rsubw d, r[14], r[10];		;		ldct p2cldrw;			| Compute  r[10] & load braddr.
   1c89  01 61 3 d 0 f8c0 1c89  	movw,s d,y;		fifo1->am;	cjp, f1e .;			| Test  9.
   1c8a  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| Return.
   1c8b  04 61 3 d d 9e88 1c8b  getxy1dr: addw d, r[8], r[13];	fifo1->am;	cjp, f1e .;			| Loop while fifo empty.  r[13] +=  r[8].
   1c8c  05 09 e 0 0 d84d 0000  	movw  r[13],y;		am->am;		;				| 
   1c8d  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];		;		;				| Compute  r[11].
   1c8e  04 61 3 d c 9e89 1c8e  	addw d, r[9], r[12];		fifo1->am;	cjp, f1e .;			| Loop while fifo empty.  r[12] +=  r[9].
   1c8f  05 09 e 0 0 d84c 0000  	movw  r[12],y;		am->am;		;				| 
   1c90  14 00 3 0 a 9e4e 1c91  	rsubw d, r[14], r[10];		;		cjp, go pdraw;			| Compute  r[10] & draw (note cjp, not cjs).
                                | For pdraw to work, it is necessary that the registers used by this routine are not stepping on any
                                | other register needed between calls to fatvec.  This suggests that they should be in the upper half
                                | of the register bank.  
                                |   Note that  r[15], r[14], r[13] and  r[12] are needed by the vector routines @  0x190 for clipping reasons
                                |   for thin vectors, and fat vectors (we call pdrfat) will save the coordinates there themselves.
   1c91  00 45 e 0 0 c3f5 0190  pdraw:	sub2nw,s 1, r[21], r[16];	 0x190->scrmemp; ;				| Save polyline state.
   1c92  05 0a 3 9 4 d84f 1ca8  	movw  r[15],y;		am->scrmem;	cjp, ~neg pdrfat;	scrmp+	| 	 r[15].
   1c93  15 0a 1 0 4 d84e 1c97  	movw  r[14],y;		am->scrmem;	cjs, go pdrstx1;	scrmp+	| 	 r[14].
   1c94  05 45 e 0 0 7140 0190  	;			 0x190->scrmemp; ;				| Restore state.
   1c95  15 59 3 0 4 d8cf 1c9f  	movw d, r[15];		scrmem->am;	cjp, go pdrres;		scrmp+	| 	 r[15].
                                | Pdrst was created to save space.  It fills in the scrmem, & will return to the place from where it was called
                                | directly from fatcheck.	
   1c96  05 0a e 0 4 d84e 0000  pdrst:	movw  r[14],y;		am->scrmem;	;			scrmp+	| 	 r[14]
   1c97  05 0a e 0 4 d84d 0000  pdrstx1: movw  r[13],y;		am->scrmem;	;			scrmp+	| 	 r[13].
   1c98  05 0a e 0 4 d84c 0000  	movw  r[12],y;		am->scrmem;	;			scrmp+	| 	 r[12].
   1c99  05 0a e 0 4 d855 0000  	movw  r[21],y;		am->scrmem;	;			scrmp+	| 	 r[21].
   1c9a  05 0a e 0 4 d847 0000  	movw  r[7],y;		am->scrmem;	;			scrmp+	| 	 r[7].
   1c9b  05 0a e 0 4 d840 0000  	movw  r[0],y;		am->scrmem;	;			scrmp+	| 	 r[0].
   1c9c  05 0a e 0 4 d841 0000  	movw  r[1],y;		am->scrmem;	;			scrmp+	| 	 r[1].
   1c9d  05 0a e 0 4 d848 0000  	movw  r[8],y;		am->scrmem;	;			scrmp+	| 	 r[8].
   1c9e  15 0a 3 0 0 d849 1b0a  	movw  r[9],y;		am->scrmem;	cjp, go fatcheck;		| 	 r[9] & draw vector.
                                | Pdrres is used for restoring the registers stored by pdrst.  It returns to the routine that originally
                                | called pdraw.	
   1c9f  05 59 e 0 4 d8ce 0000  pdrres:	movw d, r[14];		scrmem->am;	;			scrmp+	| 	 r[14].
   1ca0  05 59 e 0 4 d8cd 0000  	movw d, r[13];		scrmem->am;	;			scrmp+	| 	 r[13].
   1ca1  05 59 e 0 4 d8cc 0000  	movw d, r[12];		scrmem->am;	;			scrmp+	| 	 r[12].
   1ca2  05 59 e 0 4 d8d5 0000  	movw d, r[21];		scrmem->am;	;			scrmp+	| 	 r[21].
   1ca3  05 59 e 0 4 d8c7 0000  	movw d, r[7];		scrmem->am;	;			scrmp+	| 	 r[7].
   1ca4  05 59 e 0 4 d8c0 0000  	movw d, r[0];		scrmem->am;	;			scrmp+	| 	 r[0].
   1ca5  05 59 e 0 4 d8c1 0000  	movw d, r[1];		scrmem->am;	;			scrmp+	| 	 r[1].
   1ca6  05 59 e 0 4 d8c8 0000  	movw d, r[8];		scrmem->am;	;			scrmp+	| 	 r[8].
   1ca7  1d 59 a 0 0 d8c9 0000  	movw d, r[9];		scrmem->am;	crtn, go;			| 	 r[9] & return.
                                |   Pdrfat is reached when we have a fat polyline, and therefore do not want to save the coordinates at  0x190, as they
                                |   will get overwritten in the fat vector code.  Instead we store them at 0x115, and restore them from this location.
   1ca8  05 45 e 0 0 7140 0115  pdrfat:	;			0x115->scrmemp; ;				| Save polyline state for fat vecs.
   1ca9  15 0a 1 0 4 d84f 1c96  	movw  r[15],y;		am->scrmem;	cjs, go pdrst;		scrmp+	| 	 r[15] & call store routine.
   1caa  05 45 e 0 0 7140 0115  	;			0x115->scrmemp; ;				| Restore state.
   1cab  15 59 3 0 4 d8cf 1c9f  	movw d, r[15];		scrmem->am;	cjp, go pdrres;		scrmp+	| 	 r[15] & jump to restore routine.
                                |   Pdrawcl is used when closing polylines, and therefore saves  r[7],  r[15], r[14], r[13], r[12], r[21], r[7], r[8] &  r[9], & computes  r[11],  r[10].
   1cac  05 0a e 0 4 d84e 0000  pdrawcl: movw  r[14],y;		am->scrmem;	;			scrmp+	| 	 r[14].
   1cad  05 0a e 0 4 d840 0000  	movw  r[0],y;		am->scrmem;	;			scrmp+	| 	 r[13]= r[0].
   1cae  05 0a e 0 4 d841 0000  	movw  r[1],y;		am->scrmem;	;			scrmp+	| 	 r[12]= r[1].
   1caf  05 0a e 0 4 d855 0000  	movw  r[21],y;		am->scrmem;	;			scrmp+	| 	 r[21].
   1cb0  05 0a e 0 4 d847 0000  	movw  r[7],y;		am->scrmem;	;			scrmp+	| 	 r[7].
   1cb1  05 0a e 0 4 d848 0000  	movw  r[8],y;		am->scrmem;	;			scrmp+	| 	 r[8].
   1cb2  05 0a e 0 4 d849 0000  	movw  r[9],y;		am->scrmem;	;			scrmp+	| 	 r[9].
   1cb3  05 0a e 0 4 d84d 0000  	movw  r[13],y;		am->scrmem;	;			scrmp+	| 	 r[0]= r[13].
   1cb4  05 0a e 0 0 d84c 0000  	movw  r[12],y;		am->scrmem;	;				| 	 r[1]= r[12]
   1cb5  04 09 e 0 d d960 0000  	movw  r[0], r[13];		am->am;		;				|  r[13] =  r[0].
   1cb6  04 00 e 0 b 9e4f 0000  	rsubw d, r[15], r[11];		;		;				| Compute  r[11].
   1cb7  04 09 e 0 c d961 0000  	movw  r[1], r[12];		am->am;		;				|  r[12] =  r[1].
   1cb8  14 00 3 0 a 9e4e 1b0a  	rsubw d, r[14], r[10];		;		cjp, go fatcheck;		| Compute  r[10] & jump.
                                |   P1cldrw should cjpp newpolyline if  7 bit not set, otherwise it should draw & then cjpp to p1newply.
   1cb9  05 00 b 0 0 d800 1c48  p1cldrw: movw  r[0],acc;	;		cjpp, zer p1newply;		| Return if  7 bit not set.
   1cba  01 45 e 0 0 910f 0190  	xorw,s  r[15],acc,y;	 0x190->scrmemp; ;				| 
   1cbb  05 00 3 8 0 d801 1cbe  	movw  r[1],acc;	;		cjp, ~zer p1cl2;			| Jump if  r[15] !=  r[0].
   1cbc  01 00 e 0 0 910e 0000  	xorw,s  r[14],acc,y;	;		;				| 
   1cbd  05 00 b 0 0 7140 1c48  	;			;		cjpp, zer p1newply;		| Return if had multiple moves.
   1cbe  15 0a 1 0 4 d84f 1cac  p1cl2:	movw  r[15],y;		am->scrmem;	cjs, go pdrawcl;	scrmp+	| Save  r[15] + call draw routine.
   1cbf  05 49 e 0 0 d8c2 0190  	movw d,r[2];		 0x190->am;	;				| 
   1cc0  05 05 e 0 0 c5c2 0000  	add2nw 2,r[2],r[2];	am->scrmemp;	;				| Restore state.
   1cc1  05 59 e 0 4 d8d5 0000  	movw d, r[21];		scrmem->am;	;			scrmp+	| 	 r[21].
   1cc2  05 59 e 0 4 d8c7 0000  	movw d, r[7];		scrmem->am;	;			scrmp+	| 	 r[7].
   1cc3  05 59 e 0 4 d8c8 0000  	movw d, r[8];		scrmem->am;	;			scrmp+	| 	 r[8].
   1cc4  05 59 e 0 4 d8c9 0000  	movw d, r[9];		scrmem->am;	;			scrmp+	| 	 r[9].
   1cc5  05 59 e 0 4 d8cd 0000  	movw d, r[13];		scrmem->am;	;			scrmp+	| 	 r[13] (-> r[15], r[0]). 
   1cc6  15 59 b 0 0 d8cc 1c48  	movw d, r[12];		scrmem->am;	cjpp, go p1newply;		| 	 r[12] (-> r[14], r[1]).
                                |   P2cldrw should return if  7 bit not set, otherwise it should draw & then return.
   1cc7  0d 00 a 0 0 d800 0000  p2cldrw: movw  r[0],acc;	;		crtn, zer;			| Return if  7 bit not set.
   1cc8  01 45 e 0 0 910f 0190  	xorw,s  r[15],acc,y;	 0x190->scrmemp; ;				| 
   1cc9  05 00 3 8 0 d801 1cce  	movw  r[1],acc;	;		cjp, ~zer p2cl2;		| Jump if  r[15] !=  r[0].
   1cca  01 00 e 0 0 910e 0000  	xorw,s  r[14],acc,y;	;		;				| 
   1ccb  05 00 3 8 0 7140 1cce  	;			;		cjp, ~zer p2cl2;		| Jump to draw not both moves.
   1ccc  04 00 e 0 0 d96d 0000  	movw  r[13], r[0];		;		;				| New  r[0]= r[13].
   1ccd  1c 00 a 0 1 d96c 0000  	movw  r[12], r[1];		;		crtn, go;			| New  r[1]= r[12].
   1cce  15 0a 1 0 4 d84f 1cac  p2cl2:	movw  r[15],y;		am->scrmem;	cjs, go pdrawcl;	scrmp+	| Save  r[15] + call draw routine.
   1ccf  05 49 e 0 0 d8c2 0190  	movw d,r[2];		 0x190->am;	;				| 
   1cd0  05 05 e 0 0 c5c2 0000  	add2nw 2,r[2],r[2];	am->scrmemp;	;				| Restore state.
   1cd1  05 59 e 0 4 d8d5 0000  	movw d, r[21];		scrmem->am;	;			scrmp+	| 	 r[21].
   1cd2  05 59 e 0 4 d8c7 0000  	movw d, r[7];		scrmem->am;	;			scrmp+	| 	 r[7].
   1cd3  05 59 e 0 4 d8c8 0000  	movw d, r[8];		scrmem->am;	;			scrmp+	| 	 r[8].
   1cd4  05 59 e 0 4 d8c9 0000  	movw d, r[9];		scrmem->am;	;			scrmp+	| 	 r[9].
   1cd5  05 59 e 0 4 d8c0 0000  	movw d, r[0];		scrmem->am;	;			scrmp+	| 	 r[0]= r[13].
   1cd6  05 59 e 0 0 d8c1 0000  	movw d, r[1];		scrmem->am;	;				| 	 r[1]= r[12].
   1cd7  04 00 e 0 d d960 0000  	movw  r[0], r[13];		;		;				| Restore  r[13].
   1cd8  1c 00 a 0 c d961 0000  	movw  r[1], r[12];		;		crtn, go;			| Restore  r[12] & return.
                                |  "@(#)xfline.pp.u 1.2 86/09/12"   
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | Written by Stuart Levy
                                |   The options field is broken down as follows:
                                |  	 bit 15 - startpt	bit 14 - endpt		bit 13 - balancing	bit 12 - givenpattern
                                |  	 bit 11 - fat		bit 10 - poly		bit 9 - mvlist		bit 8 - righthalf
                                |   	 bit 7 - close		bit 6 - cliprt		bit 5 - solid		bit 4 - pixrect
                                |   	 bit 3 - nosetup	bit 2 - clipbit		bit 1 - firstvec
                                |   This routine assumes that the  r[24] field has been initialized properly ( 5,1 & nosetup bits),  
                                |   and for the first vector, that the  r[21] and  r[24] registers are already loaded.
   1cd9  05 61 3 d 0 d8cf 1cd9  xfline:	movw d, r[15];		fifo1->am;	cjp, f1e .;			| fifo1-> r[15].
   1cda  05 45 e 0 0 f1b8 0190  	bsetw  8, r[24];	 0x190->scrmemp; ;				| tex-> r[24]. 8 = 1.
   1cdb  05 0a e 0 4 d84f 0000  	movw  r[15],y;		am->scrmem;	;			scrmp+	|  r[15]->scrmem.
   1cdc  05 61 3 d 0 d8ce 1cdc  	movw d, r[14];		fifo1->am;	cjp, f1e .;			| fifo1-> r[14].
   1cdd  05 0a e 0 4 d84e 0000  	movw  r[14],y;		am->scrmem;	;			scrmp+	|  r[14]->scrmem.
   1cde  05 00 e 0 0 f5d8 0000  	bclrw  10, r[24];	;		;				| tex-> r[24]. 10 = 0.
   1cdf  05 00 e 0 0 e5d8 0000  	bclrw  2, r[24];	;		;				| tex-> r[24]. r[23] = 0.
   1ce0  05 61 3 d 0 d8cd 1ce0  	movw d, r[13];		fifo1->am;	cjp, f1e .;			| fifo1-> r[13].
   1ce1  05 0a e 0 4 d84d 0000  	movw  r[13],y;		am->scrmem;	;			scrmp+	|  r[13]->scrmem.
   1ce2  04 44 e 0 b 9e4f 1cff  	rsubw d, r[15], r[11];		=xldraw->brreg;	;				|  r[11] =  r[13]- r[15]. Load branch reg.
   1ce3  05 61 3 d 0 d8cc 1ce3  	movw d, r[12];		fifo1->am;	cjp, f1e .;			| fifo1-> r[12].
   1ce4  05 0a e 0 0 d84c 0000  	movw  r[12],y;		am->scrmem;	;				|  r[12]->scrmem.
   1ce5  01 00 e 0 0 ebf8 0000  	btstw,s  5, r[24];	;		;				| Test if  5 (fat) vector.
   1ce6  04 00 3 8 a 9e4e 1cf6  	rsubw d, r[14], r[10];		;		cjp, ~zer xlsolid;		|  r[10] =  r[12]- r[14], jump if  5. 
   1ce7  05 61 3 d 0 d8dc 1ce7  	movw d,r[28];		fifo1->am;	cjp, f1e .;			| fifo1->r[28].
   1ce8  00 49 e 0 7 9f3c fffe  	norw,s d,r[28], r[23];	0xfffe->am;	;				| (PIX_DONTCLIP == 1) => ( r[23] == 0).
   1ce9  05 00 3 0 0 979c 1ceb  	rolw 11,r[28],acc;		;		cjp, zer xlvecol;		| Rotate r[28] to get at r[27].
   1cea  05 00 e 0 0 e5b8 0000  	bsetw  2, r[24];	;		;				| tex-> r[24]. r[23] = 1.
   1ceb  05 61 3 d 0 d8db 1ceb  xlvecol: movw d,r[27];		fifo1->am;	cjp, f1e .;			| fifo1->r[27].
   1cec  01 49 e 0 0 e2c1 07ff  	andw,s d,acc,acc;	0x7ff->am;	;				| Get r[27] from r[28].
   1ced  05 00 3 0 0 cc9c 1cef  	sr0w r[28],r[28];		;		cjp, zer xlfirst;		| Jump if r[27] not in r[28].
   1cee  05 00 e 0 0 d89b 0000  	movw acc,r[27];		;		;				| 
   1cef  01 45 e 0 0 e3f8 0135  xlfirst: btstw,s 1, r[24];  0x135->scrmemp; ;				| 
   1cf0  0d 00 3 8 0 e3d8 0000  	bclrw 1, r[24];	;		cjp, ~zer;			| Draw if first vector.
   1cf1  01 59 e 0 4 970f 0000  xlpoly:	xorw,s d, r[15],y;		scrmem->am;	;			scrmp+	| Check if  r[15] = x1old.
   1cf2  05 59 3 8 4 d8d5 1cf5  	movw d, r[21];		scrmem->am;	cjp, ~zer xlmvvec;	scrmp+	| Jump if not polyline.
   1cf3  01 59 e 0 4 970e 0000  	xorw,s d, r[14],y;		scrmem->am;	;			scrmp+	| Check if  r[14] = y1old.
   1cf4  0d 45 3 0 0 f5b8 0135  	bsetw  10, r[24];	 0x135->scrmemp; cjp, zer;			| Set  10 bit, & draw if  10.
   1cf5  1d 45 3 0 0 f5d8 0135  xlmvvec: bclrw  10, r[24];	 0x135->scrmemp; cjp,go;			| Clear  10 bit, & draw.
   1cf6  05 61 3 d 0 d8dc 1cf6  xlsolid: movw d,r[28];		fifo1->am;	cjp, f1e .;			| fifo1->r[28].
   1cf7  00 49 e 0 7 9f3c fffe  	norw,s d,r[28], r[23];	0xfffe->am;	;				| (PIX_DONTCLIP == 1) => ( r[23] == 0).
   1cf8  05 45 e 0 0 979c 0136  	rolw 11,r[28],acc;		0x136->scrmemp; ;				| Rotate r[28] to get at r[27].
   1cf9  05 61 3 d 0 d8db 1cf9  	movw d,r[27];		fifo1->am;	cjp, f1e .;			| fifo1->r[27].
   1cfa  01 49 e 0 0 e2c1 07ff  	andw,s d,acc,acc;	0x7ff->am;	;				| Get r[27] from r[28].
   1cfb  05 00 3 0 0 cc9c 1cfd  	sr0w r[28],r[28];		;		cjp, zer xlsol1;		| Jump if r[27] not in r[28].
   1cfc  05 00 e 0 0 d89b 0000  	movw acc,r[27];		;		;				| 
   1cfd  05 59 e 0 0 d8d5 0000  xlsol1:	movw d, r[21];		scrmem->am;	;				| Restore  r[21].
   1cfe  1d 45 3 0 0 7140 0135  	;			 0x135->scrmemp; cjp, go;			| Draw vector.
   1cff  05 0a e 0 4 d84d 0000  xldraw:	movw  r[13],y;		am->scrmem;	;			scrmp+	| Store  r[13].
   1d00  05 0a e 0 4 d855 0000  	movw  r[21],y;		am->scrmem;	;			scrmp+	| Store  r[21].
   1d01  15 0a 1 0 0 d84c 1b0a  	movw  r[12],y;		am->scrmem;	cjs, go fatcheck;		| Store  r[12] & draw.
   1d02  05 00 2 0 0 7140 1128  	;			;		jmap start;			| Fatcheck needed something on the stack.
                                |  "@(#)xflineinit.pp.u 1.2 86/09/12"   
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | Written by Stuart Levy
                                |   The options field is broken down as follows:
                                |  	 bit 15 - startpt	bit 14 - endpt		bit 13 - balancing	bit 12 - givenpattern
                                |  	 bit 11 - fat		bit 10 - poly		bit 9 - mvlist		bit 8 - righthalf
                                |   	 bit 7 - close		bit 6 - cliprt		bit 5 - solid		bit 4 - pixrect
                                |   	 bit 3 - nosetup	bit 2 - clipbit		bit 1 - firstvec
                                |   This routine does initialization necessary for t1vec.  It transfers numsegs,patln and stoff from the
                                |   attribute area of scrmem to the 'scratch' section of memory where it is accessed by the pixrect level
                                |   code.  It also fills in the firstvec and solid (if applicable) fields of the options word, and puts 
                                |   it in the appropriate register.  The width is also placed in a register.  The addresses used for the
                                |   vector attributes are defined in pp.h, while those in 'scratch' memory are defined here.
   1d03  05 45 e 0 0 e9d8 0185  xflineinit: bclrw  4, r[24]; 0x185->scrmemp; ;			| tex-> r[24]. 4 = 0.
   1d04  05 00 e 0 0 e7d8 0000  	bclrw  3, r[24];	;		;				| Must initially setup rop chips.
   1d05  05 59 e 0 4 d8c0 0000  	movw d, r[0];		scrmem->am;	;			scrmp+	| scrmem(att)-> r[0].
   1d06  05 59 e 0 4 d8c1 0000  	movw d, r[1];		scrmem->am;	;			scrmp+	| scrmem(att)-> r[1].
   1d07  05 59 e 0 4 d8c2 0000  	movw d, r[2];		scrmem->am;	;			scrmp+	| scrmem(att)-> r[2].
   1d08  05 59 e 0 4 d8d8 0000  	movw d, r[24];		scrmem->am;	;			scrmp+	| scrmem(att)-> r[24].
   1d09  05 59 e 0 0 d8d5 0000  	movw d, r[21];		scrmem->am;	;				| scrmem(att)-> r[21].
   1d0a  05 45 e 0 0 e3b8 0600  	bsetw 1, r[24];	0x600->scrmemp; ;				| tex-> r[24].1=1.
   1d0b  01 59 e 0 0 f8c0 0000  	movw,s d,y;		scrmem->am;	;				| Check first pattern segment.
   1d0c  05 00 3 0 0 ebb8 1d11  	bsetw  5, r[24];	;		cjp, zer xfinitsol;		| Set  5 bit jump.
   1d0d  05 45 e 0 0 ebd8 0120  	bclrw  5, r[24];	 0x120->scrmemp; ;				| Is a textured vector.
   1d0e  05 0a e 0 4 d842 0000  	movw  r[2],y;		am->scrmem;	;			scrmp+	|  r[2]->scrmem (for toctant).
   1d0f  05 0a e 0 4 d841 0000  	movw  r[1],y;		am->scrmem;	;			scrmp+	|  r[1]->scrmem.
   1d10  15 0a 3 0 0 d840 1128  	movw  r[0],y;		am->scrmem;	cjp, go start;			|  r[0]->scrmem & return.
   1d11  05 45 e 0 0 7140 0136  xfinitsol: ;			0x136->scrmemp; ;				| If  5 vector, want to save
   1d12  15 0a 3 0 0 d855 1128  	movw  r[21],y;		am->scrmem;	cjp, go start;			|   r[21] at location in scrmem.
                                |  "@(#)setlineatts.pp.u 1.2 86/09/12" 
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | Written by Stuart Levy
                                |   Setlinetex expects to receive the starting offset, the  r[3] field (from which it determines if we are
                                |   dealing with a 5080 texture or not), and then the pattern, which is either less than sixteen segments long,
                                |   and null terminated, or it is exactly 16 long, and is not null terminated.
   1d13  05 61 3 d 0 d8c2 1d13  setlinetex: movw d, r[2];	fifo1->am;	cjp, f1e .;			| fifo1-> r[2].
   1d14  05 45 e 0 0 7140 0187  	;			0x187->scrmemp; ;				| 
   1d15  05 0a e 0 4 d842 0000  	movw  r[2],y;		am->scrmem;	;			scrmp+	|  r[2]->scrmem.
   1d16  01 61 3 d 0 e190 1d16  	btstw,s  0,d;	fifo1->am;	cjp, f1e .;			| fifo1-> r[3].
   1d17  05 0a 3 8 4 d8c3 1d28  	movw d, r[3];		am->scrmem;	cjp, ~zer set5080tex;	scrmp+	| Jump if are dealing w/5080 texture.
   1d18  05 45 e 0 0 d900 0600  	movw 0, r[0];		0x600->scrmemp; ;				| Load addr. where to store pattern.
   1d19  05 61 3 d 0 d901 1d19  	movw 0, r[1];		fifo1->am;	cjp, f1e .;			| 
   1d1a  01 0a c 0 4 f8c0 000e  	movw,s d,y;		am->scrmem;	ldct 14;		scrmp+	| Load counter (0 based) w/15.
   1d1b  05 00 3 0 0 9e81 1d20  	addw d, r[1], r[1];	;		cjp, zer setsvnum;		|  r[1] += segment. Jump if solid.
   1d1c  01 61 3 d 0 f8c1 1d1c  setloop: movw,s d,acc;		fifo1->am;	cjp, f1e .;			| Test value.
   1d1d  05 00 3 0 0 dd60 1d20  	incw  r[0], r[0];	;		cjp, zer setsvnum;		|  r[0]++, jump if hit zero segment.
   1d1e  05 00 e 0 0 9e81 0000  	addw d, r[1], r[1];	;		;				|  r[1] += segment.
   1d1f  05 0a 9 0 4 f8c0 1d1c  	movw d,y;		am->scrmem;	rpct setloop;		scrmp+	| segment->scrmem, are pulling 16 max.
   1d20  05 45 e 0 0 7140 0185  setsvnum: ;			0x185->scrmemp; ;				| Load address to store attributes.
   1d21  05 0a e 0 4 d840 0000  	movw  r[0],y;		am->scrmem;	;			scrmp+	|  r[0]->scrmem.
   1d22  15 0a 3 0 0 d841 1128  	movw  r[1],y;		am->scrmem;	cjp, go start;			|  r[1]->scrmem & return.
   1d23  05 61 3 d 0 7140 1d23  setlinewidth: ;			fifo1->am;	cjp, f1e .;			| Width->am.
   1d24  05 45 e 0 0 7140 0189  	;			0x189->scrmemp; ;				| 
   1d25  05 0a e 0 4 f8c0 0000  	movw d,y;		am->scrmem;	;			scrmp+	| width->scrmem.
   1d26  05 61 3 d 0 7140 1d26  swloop:	;			fifo1->am;	cjp, f1e .;			| 
   1d27  05 0a 2 0 0 f8c0 1128  	movw d,y;		am->scrmem;	jmap start;			| width.options->scrmem & return.
                                |   For the first segment, we want to compute 'on' if the highest bit is set, ie, our first segment is r[2].
                                |   This is because we do not want to enter the onseg routine, and not return (because r[2] is zero, indicating
                                |   the last segment was r[3]), and send a non-existant 'off' segment.  For the offseg routine all is fine,
                                |   since 'on' is zero and we just return.
                                set5080tex: 
   1d28  05 45 e 0 0 d903 0600  	movw 0,r[3];		0x600->scrmemp; ;				| Load address to store pattern.
   1d29  05 00 e 0 0 d904 0000  	movw 0,r[4];		;		;				| 
   1d2a  05 00 e 0 0 df81 0000  	mov2nw 15,r[1];	;		;				| 
   1d2b  05 61 3 d 0 d8c0 1d2b  	movw d,r[0] ;		fifo1->am;	cjp, f1e .;			| 1st wd->r[0].
   1d2c  01 00 c 0 0 ffe0 1d69  	btstw,s 15,r[0];	;		ldct onseg;			| 
   1d2d  05 00 3 0 0 c185 1d2f  sfiron:	mov2nw 0,r[5];	;		cjp, zer sfiroff;		| Jump if first segment is r[3].
   1d2e  15 00 3 0 0 c5c2 1d32  	add2nw 2,r[2];		;		cjp, go t14;			| 
   1d2f  15 00 3 0 4 d905 1d31  sfiroff: movw 0,r[5];	;		cjp, go t15a;		scrmp+	| If first is r[3], start at 2nd loc.
   1d30  01 00 c 0 0 ffe0 1d69  t5080lp: btstw,s 15,r[0];	;		ldct onseg;			| 
   1d31  01 00 5 0 0 d842 1d6d  t15a:	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 15
   1d32  01 00 e 0 0 fde0 0000  t14:	btstw,s 14,r[0];	;		;				| 
   1d33  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 14
   1d34  01 00 e 0 0 fbe0 0000  	btstw,s 13,r[0];	;		;				| 
   1d35  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 13
   1d36  01 00 e 0 0 f9e0 0000  	btstw,s 12,r[0];	;		;				| 
   1d37  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 12
   1d38  01 00 e 0 0 f7e0 0000  	btstw,s 11,r[0];	;		;				| 
   1d39  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 11
   1d3a  01 00 e 0 0 f5e0 0000  	btstw,s 10,r[0];	;		;				| 
   1d3b  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 10
   1d3c  01 00 e 0 0 f3e0 0000  	btstw,s 9,r[0];	;		;				| 
   1d3d  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 9
   1d3e  01 00 e 0 0 f1e0 0000  	btstw,s 8,r[0];	;		;				| 
   1d3f  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 8
   1d40  01 00 e 0 0 efe0 0000  	btstw,s 7,r[0];	;		;				| 
   1d41  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 7
   1d42  01 00 e 0 0 ede0 0000  	btstw,s 6,r[0];	;		;				| 
   1d43  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 6
   1d44  01 00 e 0 0 ebe0 0000  	btstw,s 5,r[0];	;		;				| 
   1d45  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 5
   1d46  01 00 e 0 0 e9e0 0000  	btstw,s 4,r[0];	;		;				| 
   1d47  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 4
   1d48  01 00 e 0 0 e7e0 0000  	btstw,s 3,r[0];	;		;				| 
   1d49  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 3
   1d4a  01 00 e 0 0 e5e0 0000  	btstw,s 2,r[0];	;		;				| 
   1d4b  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 2
   1d4c  01 00 e 0 0 e3e0 0000  	btstw,s 1,r[0];	;		;				| 
   1d4d  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 1
   1d4e  01 00 e 0 0 e1e0 0000  	btstw,s 0,r[0];	;		;				| 
   1d4f  01 00 5 0 0 d842 1d6d  	 movw,s r[2], y;		;		jsrp, zer offseg;		| bit 0
   1d50  01 00 c 0 0 cc81 1d30  	sr0w,s r[1],r[1];	;		ldct t5080lp;			| 
   1d51  05 00 3 0 0 7140 1d53  	;			;		cjp, zer t5done;		| Loop until shift out a 1.
   1d52  05 61 7 d 0 d8c0 1d52  	movw d,r[0];		fifo1->am;	jrp, f1e .;			| Pull word, then loop.
   1d53  01 00 e 0 0 d842 0000  t5done:	 movw,s r[2], y;		;		;				| Test last segment.
   1d54  01 00 3 0 0 d845 1d5a  	 movw,s r[5], y;	;		cjp, zer tlstoff;		| Test first segment.
                                |   Here we do alot of jumping around depending r[2] the first and last segment.  If the first segment was r[2],
                                |   we don't care about the last.  If the first segment was off, we deal with one of two cases.  If the last was on,
                                |   we write this into the first, and this becomes our offset.  If the last was r[3], we decrement r[4], add this 
                                |   to the initial pattern address (both are zero based), and fetch the next to last segment (which is r[2]), and this 
                                |   becomes our new first segment.  The last segment (r[3]), gets added to the second segment, and we adjust our offset
                                |   so that we skip the first, and part of the second segments the first time around.
   1d55  05 0a 3 8 0 d842 1d64  tlston:	movw r[2],y;		am->scrmem;	cjp, ~zer t5null;		| Last r[2], jump if 1st r[2].
   1d56  04 45 e 0 6 d962 0600  tfofflon: movw r[2],r[6];	0x600->scrmemp; ;				| 1st r[3], last r[2].
   1d57  05 0a e 0 0 d842 0000  	movw r[2],y;		am->scrmem;	;				| New 1st=last, r[6]=1st.
   1d58  04 49 e 0 7 c1c4 0600  	add2nw 0,r[4],r[7];	0x600->am; ;				| 
   1d59  15 05 3 0 0 9687 1d64  	addw d,r[7],y;		am->scrmemp;	cjp, go t5null;			| Set up address where to null terminate.
   1d5a  05 0a 3 8 4 d843 1d64  tlstoff: movw r[3],y;		am->scrmem;	cjp, ~zer t5null;	scrmp+	| Last r[3], jump if 1st r[2].
   1d5b  05 49 e 0 0 7140 0600  tfoffloff: ;			0x600->am; ;				| 1st & last r[3]. 2nd to last->1st.
   1d5c  05 05 e 0 0 9684 0000  	addw d,r[4],y;	am->scrmemp;	;				| Fetch 2nd to last (is r[2]).
   1d5d  04 59 e 0 6 9e83 0000  	addw d,r[3],r[6];	scrmem->am;	;				| r[6] = new 1st segment + last segment.
   1d5e  05 0a e 0 0 f900 0000  	movw 0,y;		am->scrmem;	;				| Null terminate pattern.
   1d5f  05 45 e 0 0 c1e4 0600  	sub2nw 0, r[4];		0x600->scrmemp; ;				| Will put 2nd to last in first.
   1d60  05 0a e 0 4 f8c0 0000  	movw d,y;		am->scrmem;	;			scrmp+	| 2nd to last->scrmem (1st).
   1d61  05 00 e 0 0 7140 0000  	;			;		;				| Need to wait one cycle before rd.
   1d62  05 59 e 0 0 9e83 0000  	addw d,r[3],r[3];		scrmem->am;	;				| 2nd seg += last seg.
   1d63  15 0a 3 0 0 d843 1d65  	movw r[3],y;		am->scrmem;	cjp, go t5nul2;			| new 2nd seg->scrmem.
   1d64  05 0a e 0 0 f900 0000  t5null:	movw 0,y;		am->scrmem;	;				| Null terminate pattern.
   1d65  05 45 e 0 0 7140 0185  t5nul2:	;			0x185->scrmemp; ;				| 
   1d66  05 0a e 0 4 dd64 0000  	incw r[4],r[4];	am->scrmem;	;			scrmp+	| ++r[4]->scrmem.
   1d67  05 4a e 0 4 7140 0400  	;			1024->scrmem;	;			scrmp+	| patln(1024)->scrmem.
   1d68  15 0a 3 0 0 d846 1128  	movw r[6],y;		am->scrmem;	cjp, go start;			| New r[6]->scrmem.
   1d69  0d 00 a 8 0 c5c2 0000  onseg:	add2nw 2,r[2];		;		crtn, ~zer;			| Return if last bit was r[2].
   1d6a  05 0a e 0 4 d843 0000  	movw r[3],y;		am->scrmem;	;			scrmp+	| r[3]->scrmem.
   1d6b  05 00 e 0 0 dd64 0000  	incw r[4],r[4];	;		;				| r[4]++.
   1d6c  1d 00 a 0 0 d903 0000  	movw 0,r[3];		;		crtn, go;			| Clear r[3] & return.
   1d6d  0d 00 a 0 0 c5c3 0000  offseg:	add2nw 2,r[3];		;		crtn, zer;			| Return if last bit was r[3].
   1d6e  05 0a e 0 4 d842 0000  	movw r[2],y;		am->scrmem;	;			scrmp+	| r[2]->scrmem.
   1d6f  05 00 e 0 0 dd64 0000  	incw r[4],r[4];	;		;				| r[4]++.
   1d70  1d 00 a 0 0 d902 0000  	movw 0,r[2];		;		crtn, go;			| Clear r[2] & return.
                                |  @(#)roptex.pp.u 1.2 86/09/12 SMI
                                | Copyright (c) 1986 by Sun Microsystems, Inc.
                                |   Support for textured polygons and replrop.
                                |   ldtex:  #27.  Args: Width, Height, Depth, Pixels.
                                |   8 bit pixels are loaded 2 per 16 bit word.
                                |   Also used to load 1 bit deep textures, in which case the Width (in Pixels)
                                |   will not be directly used for transfer.
   1d71  05 61 3 d 0 f8c1 1d71  ldtex:	movw d, acc;		fifo1->am;	cjp, f1e .;			| r[15] -> acc for multiply.
   1d72  05 45 e 0 0 7140 018b  	;			0x18b->scrmemp; ;				| 
   1d73  05 0a e 0 0 d88f 0000  	movw acc, r[15];	am->scrmem;	;				| 
   1d74  05 61 3 d 0 d8ce 1d74  	movw d, r[14];		fifo1->am;	cjp, f1e .;			| r[14]
   1d75  05 00 e 0 4 7140 0000  	;			;		;			scrmp+	| Take advantage of 3 cycle fifo turnaround.
   1d76  05 0a e 0 0 d84e 0000  	movw r[14], y;		am->scrmem;	;				| 
   1d77  05 61 3 d 0 d8cd 1d77  	movw d, r[13];		fifo1->am;	cjp, f1e .;			| 
   1d78  01 00 e 0 0 e7ed 0000  	btstw,s 3, r[13];	;		;				| if (r[13] != 8)
   1d79  04 00 3 8 1 99ef 1d7e  	rolw 12, r[15], r[1];	;		cjp, ~zer ldt8;			| Convert r[15] to number of 16 bit words.
   1d7a  01 49 e 0 0 96c1 f000  	andw,s d, r[1], y;	0xf000->am;	;				| if (r[15] % 16) last word is padded.
   1d7b  05 49 e 0 0 86c1 0fff  	andw d, r[1], acc;	0xfff->am;	;				| 
   1d7c  05 00 3 0 0 7140 1d80  	;			;		cjp, zer ldtcol;		| Reload accumulator for multiply.
   1d7d  15 00 3 0 0 fc81 1d80  	incw acc, acc;		;		cjp, go ldtcol;			| 
   1d7e  05 00 e 0 0 dc0f 0000  ldt8:	incw r[15], acc;	;		;				| r[15]= (r[15] + 1) >> 1
   1d7f  05 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;				| 
   1d80  14 00 1 0 2 d96e 116f  ldtcol:	movw r[14], r[2];	;		cjs, go multiply;		| r[15] * r[14]
   1d81  05 04 e 0 0 c1e0 0000  	sub2nw 0, r[0], r[0];	am->brreg;	;				| r[12]--
   1d82  1d 45 4 0 0 7140 0800  	;			 0x800->scrmemp; push, go;			| 
   1d83  05 61 3 d 0 f8c1 1d83  	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   1d84  0d 0a 8 0 4 f880 0000  	movw acc, y;		am->scrmem;	rfct;			scrmp+	| 
   1d85  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
   1d86  15 00 1 0 0 7140 1309  roptex1: ;			;		cjs, go ropreg;			| 
   1d87  05 61 3 d 0 d8ce 1d87  	movw d, r[14];	fifo1->am;	cjp, f1e .;			| 
   1d88  04 00 e 0 2 d96e 0000  	movw r[14], r[2]; ;		;				| 
   1d89  05 61 3 d 0 d8cf 1d89  	movw d, r[15];	fifo1->am;	cjp, f1e .;			| 
   1d8a  05 61 3 d 0 d8ca 1d8a  	movw d, r[10];	fifo1->am;	cjp, f1e .;			| 
   1d8b  15 00 1 0 0 d80f 116f  	movw r[15], acc;	;		cjs, go multiply;		| 
   1d8c  05 61 3 d 0 d8cb 1d8c  	movw d, r[11];		fifo1->am;	cjp, f1e .;			| 
   1d8d  05 00 e 0 0 d8d1 0000  	movw d, r[17];	;		;				| 
   1d8e  05 61 3 d 0 d8da 1d8e  	movw d, r[26];		fifo1->am;	cjp, f1e .;			| 
   1d8f  05 00 e 0 0 d800 0000  	movw r[0], acc;		;		;				| From multiply
   1d90  05 00 e 0 0 d890 0000  	movw acc, r[16];	;		;				| 
   1d91  05 61 3 d 0 d8db 1d91  	movw d, r[27];		fifo1->am;	cjp, f1e .;			| 
   1d92  05 61 3 d 0 d8c9 1d92  	movw d, r[9];		fifo1->am;	cjp, f1e .;			| 
   1d93  05 45 e 0 0 7140 01c1  	;			0x1c1->scrmemp; ;				| Reset scrmem Pattern (Ropchip Pattreg changes).
   1d94  05 4a e 0 0 7140 ffff  	;			0xffff->scrmem;	;				| 
   1d95  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   1d96  05 00 3 f 0 7140 1d96  	;			;		cjp, ~vir .;			| 
   1d97  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   1d98  05 53 e 0 0 7140 a000  	;			0xa000->vloareg; ;				| Use r[29] mask and pattern to control r[27].
   1d99  05 0d 3 f 7 d85b 1d99  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1d9a  05 53 e 0 0 7140 8006  	;			 0x8006->vloareg; ;			| 
   1d9b  05 0d 3 f 7 fb00 1d9b  	compw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| Pattern is all ones in r[29] with ones in r[27].
   1d9c  05 53 e 0 0 7140 a000  	;			0xa000->vloareg; ;				| 
   1d9d  05 0d 3 f 7 da5b 1d9d  	compw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1d9e  05 53 e 0 0 7140 8006  	;			 0x8006->vloareg; ;			| 
   1d9f  05 0d 3 f 7 f900 1d9f  	movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| Pattern is all zeros in r[29] with zeros in r[27]
   1da0  05 53 e 0 0 7140 a000  	;			0xa000->vloareg; ;				| 
   1da1  05 0d 3 f 7 d85d 1da1  	movw r[29], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| Restore proper r[29] mask.
                                |   Loop back to here on each new strip.
   1da2  05 61 3 d 0 d8cc 1da2  rt1strip: movw d, r[12];	fifo1->am;	cjp, f1e .;			| 
   1da3  05 61 3 d 0 d8c6 1da3  	movw d, r[6];		fifo1->am;	cjp, f1e .;			| 
   1da4  04 00 e 0 5 d966 0000  	movw r[6], r[5];		;		;				| Interleave fifo and 0, 1, or 2 other instructions.
   1da5  05 61 3 d 0 d8c3 1da5  	movw d, r[3];		fifo1->am;	cjp, f1e .;			| 
   1da6  05 61 3 d 0 d8c4 1da6  	movw d, r[4];		fifo1->am;	cjp, f1e .;			| 
   1da7  04 00 e 0 7 d963 0000  	movw r[3], r[7];	;		;				| dst= dst0
   1da8  04 00 e 0 8 d964 0000  	movw r[4], r[8];	;		;				| 
                                |   switch (r[9]) {
   1da9  00 44 e 0 0 c3e9 1dd2  	sub2nw,s 1, r[9], r[0];	=rt1w0->brreg;	;				| r[9]-- (twice because fastloop done at least once).
                                |   Handle case 0: and case 1: in same loop at rt1w0.
   1daa  09 53 3 1 0 d85a 8010  	 movw,s r[26], y;		0x8010->vloareg; cjp, neg;		| cg2_setwidth (,, 2, 2)
   1dab  05 00 3 0 0 7140 1db0  	;			;		cjp, zer rt1loop;		| 
   1dac  05 49 e 0 0 9e09 0002  	subw d, r[9], r[9];		2->am;		;				| r[9] -= 2
   1dad  05 0d 3 f 7 f8c0 1dad  	movw d, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1dae  05 53 e 0 0 7140 8012  	;			0x8012->vloareg; ;			| 
   1daf  05 0d 3 f 7 f8c0 1daf  	movw d, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1db0  01 00 e 0 0 c1eb 0000  rt1loop: sub2nw,s 0, r[11], r[11];	;		;				| while (--SizeY >= 0)
   1db1  04 00 3 1 7 d963 1df2  	movw r[3], r[7];	;		cjp, neg rt1end;		| 
   1db2  04 00 e 0 8 d964 0000  	movw r[4], r[8];	;		;				| bx= by
   1db3  01 00 e 0 0 d84c 0000  	 movw,s r[12], y;		;		;				| 
   1db4  01 00 3 0 0 d85a 1db9  	 movw,s r[26], y;		;		cjp, zer rt1primed;		| 
   1db5  15 00 1 0 0 7140 1de9  	;			;		cjs, go rt1texword;		| if (r[12]) {
   1db6  01 53 e 0 0 d85a 8002  	 movw,s r[26], y;		 0x8002->vloareg; ;			| Get ready for cg2_setrsource ()
   1db7  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   1db8  05 0d 3 f 7 d84d 1db8  	movw r[13], y;	am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setrsource (,, *(mwa)--)
   1db9  05 13 3 0 0 d847 1dc0  rt1primed: movw r[7], y;	am->vloareg;	cjp, zer rt1dst1;		| if (~r[26]) goto rt1dst1
   1dba  15 12 1 0 0 d848 1de9  	movw r[8], y;		am->vhiareg;	cjs, go rt1texword;		| 
   1dbb  05 0d 3 f 7 d84d 1dbb  	movw r[13], y;	am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1dbc  15 00 1 0 1 c5c7 1de9  	add2nw 2, r[7], r[7];	;		cjs, go rt1texword;	varegs+	| incr varegs for next word,
   1dbd  05 49 e 0 1 9ea8 0000  	addcw d, r[8], r[8];	0->am;		;			varegs+	| add 4 to dst.
   1dbe  05 0d 3 f 7 d84d 1dbe  	movw r[13], y;	am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1dbf  15 00 1 0 0 d80a 14e7  	movw r[10], acc;	;		cjs, go vropmode;		| statusreg.r[10]= r[10]
   1dc0  01 00 e 0 0 d849 0000  rt1dst1:  movw,s r[9], y;		;		;				| 
   1dc1  04 04 3 0 0 c1e9 1dc8  	sub2nw 0, r[9], r[0];	am->brreg;	cjp, zer rt1last;		| ready to load counter for fastloop
   1dc2  1d 00 4 0 0 7140 0000  	;			;		push, go;			| 
                                |   fastloop (r[9], *dst++ = *mwa++)
   1dc3  15 13 1 0 0 d847 1de9  	movw r[7], y;		am->vloareg;	cjs, go rt1texword;		| 
   1dc4  05 12 e 0 0 d848 0000  	movw r[8], y;		am->vhiareg;	;				| 
   1dc5  05 0d 3 f 7 d84d 1dc5  	movw r[13], y;	am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1dc6  05 00 e 0 0 c3c7 0000  	add2nw 1, r[7], r[7];	;		;				| 
   1dc7  0d 49 8 0 0 9ea8 0000  	addcw d, r[8], r[8];	0->am;		rfct;				| 
   1dc8  01 49 e 0 0 d85a 0002  rt1last:  movw,s r[26], y;		2->am;	;				| 
   1dc9  05 00 1 8 0 f8c1 14e7  	movw d, acc;		;		cjs, ~zer vropmode;		| statusreg.r[10]= 2
   1dca  15 13 1 0 0 d847 1de9  	movw r[7], y;		am->vloareg;	cjs, go rt1texword;		| 
   1dcb  05 12 e 0 0 d848 0000  	movw r[8], y;		am->vhiareg;	;				| 
                                |	movw 0, r[13];	;		;				| DEBUG
   1dcc  05 0d 3 f 7 d84d 1dcc  	movw r[13], y;	am->vwdreg;	cjp, ~vir .;		vmewr	| *((short *) bx)++= *mwa
   1dcd  05 49 e 0 0 9e83 0080  	addw d, r[3], r[3];	 128->am;	;				| dst0 += linebytes
   1dce  05 49 e 0 0 9ea4 0000  	addcw d, r[4], r[4]; 0->am;		;				| 
   1dcf  05 09 e 0 0 d84e 0000  	movw r[14], y;	am->am;		;				| 
   1dd0  05 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;				| 
   1dd1  14 00 3 0 5 d966 1db0  	movw r[6], r[5];		;		cjp, go rt1loop;		| 
   1dd2  05 0d 3 f 7 d849 1dd2  rt1w0:	movw r[9], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cgw_setwidth (,, 2, 2)
   1dd3  05 53 e 0 0 7140 8012  	;			0x8012->vloareg; ;			| 
   1dd4  05 0d 3 f 7 d849 1dd4  	movw r[9], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cgw_setwidth (,, 2, 2)
   1dd5  05 00 e 0 0 c1e9 0000  	sub2nw 0, r[9], r[9];		;		;				| 0 or 1 => -1 or 0.
   1dd6  01 00 e 0 0 c1eb 0000  rt1w0loop: sub2nw,s 0, r[11], r[11]; ;		;				| while (--SizeY >= 0)
                                |	movw,s r[9], y;		;		;				| DEBUG
                                |	;			;		cjp, zer .+2;			| DEBUG
                                |	andw d, r[5], r[5];	0xfffe->am;	;				| DEBUG this
                                |	movw 0, r[12];		;		;				| DEBUG or this
                                |	movw,s r[11], y;	;		;				| DEBUG
   1dd7  01 00 3 1 0 d84c 1df2  	 movw,s r[12], y;		;		cjp, neg rt1end;		| 
   1dd8  05 00 3 0 0 7140 1ddd  	;			;		cjp, zer rt1w0primed;		| 
   1dd9  15 00 1 0 0 7140 1de9  	;			;		cjs, go rt1texword;		| 
                                |	movw,s r[9], y;		;		;				| DEBUG
                                |	;			;		cjp, zer .+2;			| DEBUG
                                |	movw d, r[13];	0xffff->am;	;				| DEBUG
   1dda  05 53 e 0 0 7140 8002  	;			 0x8002->vloareg; ;			| Get ready for cg2_setrsource ()
   1ddb  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   1ddc  05 0d 3 f 7 d84d 1ddc  	movw r[13], y;	am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setrsource (,, *(sx)--)
   1ddd  15 13 1 0 0 d847 1de9  rt1w0primed: movw r[7], y;	am->vloareg;	cjs, go rt1texword;		| Get r[13]
   1dde  05 12 e 0 0 d848 0000  	movw r[8], y;		am->vhiareg;	;				| 
                                |	movw d, r[13];	0x7777->am;	;				| DEBUG
   1ddf  05 0d 3 f 7 d84d 1ddf  	movw r[13], y;	am->vwdreg;	cjp, ~vir .;		vmewr	| *dst= r[13]
   1de0  01 00 e 0 1 d849 0000  	 movw,s r[9], y;		;		;			varegs+	| 
   1de1  05 00 3 1 1 7140 1de4  	;			;		cjp, neg rt1w0y;	varegs+	| 
   1de2  15 00 1 0 0 7140 1de9  	;			;		cjs, go rt1texword;		| 
                                |	movw,s r[9], y;		;		;				| DEBUG
                                |	;			;		cjp, zer .+2;			| DEBUG
                                |	movw d, r[13];	0x3333->am;	;				| DEBUG
   1de3  05 0d 3 f 7 d84d 1de3  	movw r[13], y;	am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1de4  05 49 e 0 0 9e87 0080  rt1w0y:	addw d, r[7], r[7];	 128->am;	;				| dst += linebytes
   1de5  05 49 e 0 0 9ea8 0000  	addcw d, r[8], r[8];	0->am;		;				| 
   1de6  05 09 e 0 0 d84e 0000  	movw r[14], y;	am->am;		;				| 
   1de7  05 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;				| 
   1de8  14 00 3 0 5 d966 1dd6  	movw r[6], r[5];		;		cjp, go rt1w0loop;		| 
   1de9  05 00 e 0 0 d810 0000  rt1texword: movw r[16], acc; ;		;				| 
   1dea  00 00 e 0 0 9845 0000  	rsubw,s r[5], acc, r[0]; ;		;				| if (r[5] >= total words) r[5] -= r[16]
   1deb  04 00 3 1 1 9846 1dee  	rsubw r[6], acc, r[1];	;		cjp, neg rt1tw1;		| 
   1dec  04 00 e 0 5 d960 0000  	movw r[0], r[5];		;		;				| 
   1ded  04 00 e 0 6 d961 0000  	movw r[1], r[6];	;		;				| 
   1dee  04 49 e 0 0 9e85 0800  rt1tw1:	addw d, r[5], r[0];	 0x800->am;	;				| 
   1def  05 05 e 0 0 d840 0000  	movw r[0], y;		am->scrmemp;	;				| 
   1df0  05 59 e 0 0 d8cd 0000  	movw d, r[13];	scrmem->am;	;				| 
                                |	movw d, r[13];	0xadde->am;	;				| DEBUG
   1df1  1d 00 a 0 0 dd65 0000  	incw r[5], r[5];		;		crtn, go;			| 
   1df2  01 61 3 d 0 f8c1 1df2  rt1end:	movw,s d, acc;		fifo1->am;	cjp, f1e .;			| 
   1df3  05 12 3 1 0 d85e 1128  	movw r[30], y;		am->vhiareg;	cjp, neg start;			| 
   1df4  05 53 e 0 0 7140 800a  	;			0x800a->vloareg; ;			| 
   1df5  05 0d 3 f 7 f880 1df5  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1df6  05 53 e 0 0 7140 8008  	;			0x8008->vloareg; ;			| 
   1df7  05 61 3 d 0 f8c1 1df7  	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   1df8  05 0d 3 f 7 f880 1df8  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1df9  05 53 e 0 0 7140 800c  	;			0x800c->vloareg; ;			| 
   1dfa  05 61 3 d 0 f8c1 1dfa  	movw d, acc;		fifo1->am;	cjp, f1e .;			| 
   1dfb  05 0d 3 f 7 f880 1dfb  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
                                |	;			0x8010->vloareg; ;			| 
   1dfc  05 61 3 d 0 d8c9 1dfc  	movw d, r[9];		fifo1->am;	cjp, f1e .;			| 
                                |	movw r[9], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
                                |	;			0x8012->vloareg; ;			| 
                                |	movw r[9], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1dfd  05 00 e 0 0 d811 0000  	movw r[17], acc;	;		;				| 
   1dfe  15 00 3 0 0 d88b 1da2  	movw acc, r[11];	;		cjp, go rt1strip;		| 
                                |   plgtex1:  #28.  Assume texture is loaded into scratch memory and shinit has
                                |   been called to set up the rasterop chips.
                                |   Will have similar structure to plgtex8
   1dff  05 61 3 d 0 d8cf 1dff  plgtex1: movw d, r[15];		fifo1->am;	cjp, f1e .;			| 
   1e00  05 61 3 d 0 d8cd 1e00  	movw d, r[13];		fifo1->am;	cjp, f1e .;			| 
   1e01  05 61 3 d 0 d8cc 1e01  	movw d, r[12];		fifo1->am;	cjp, f1e .;			| 
   1e02  00 00 e 0 b 9e4d 0000  	rsubw,s d, r[13], r[11];	;		;				| 
   1e03  05 00 e 0 0 c1eb 0000  	sub2nw 0, r[11];		;		;				| Don't draw pixel of last point (for fitting).
   1e04  05 61 3 d 0 d8db 1e04  	movw d, r[27];		fifo1->am;	cjp, f1e .;			| 
   1e05  05 61 3 d 0 d8d3 1e05  	movw d, r[19];		fifo1->am;	cjp, f1e .;			| 
   1e06  05 61 3 d 0 d8dc 1e06  	movw d, r[28];		fifo1->am;	cjp, f1e .;			| 
   1e07  05 61 3 d 0 d8c7 1e07  	movw d, r[7];		fifo1->am;	cjp, f1e .;			| 
   1e08  05 49 e 0 0 f8c1 fffe  	movw d, acc;		0xfffe->am;	;				| 
   1e09  05 61 3 d 0 d8c6 1e09  	movw d, r[6];		fifo1->am;	cjp, f1e .;			| 
   1e0a  04 00 3 0 0 993c 1128  	norw r[28], acc, r[16];	;		cjp, zer start;			| 
   1e0b  05 00 e 0 0 cc9c 0000  	sr0w r[28], r[28];		;		;				| r[28] >> 1
   1e0c  05 49 e 0 0 9edc 000f  	andw d, r[28], r[28];		0xf->am;	;				| 
   1e0d  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   1e0e  05 00 3 f 0 7140 1e0e  	;			;		cjp, ~vir .;			| Wait till vctlreg ready.
   1e0f  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   1e10  05 49 e 0 0 d8d9 1e48  	movw d, r[25];	=rt1draw->am;	;				| 
   1e11  05 45 e 0 0 7140 01c0  	;			0x1c0->scrmemp; ;				| 
   1e12  01 59 e 0 0 961c 0000  	subw,s d, r[28], y;	scrmem->am;	;				| 
   1e13  05 0a 3 0 4 d85c 1e16  	movw r[28], y;		am->scrmem;	cjp, zer rt1rej;	scrmp +	| 
   1e14  05 53 e 0 0 7140 800e  	;			 0x800e->vloareg; ;			| vhiareg unchanged.
   1e15  05 0d 3 f 7 d85c 1e15  	movw r[28], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setfunction (..., r[28]).
   1e16  01 44 e 0 0 d84f 1128  rt1rej:	movw,s r[15], y;		=start->brreg;	;				| 
   1e17  09 49 3 1 0 960f 0400  	subw,s d, r[15], y;	 1024->am;	cjp, neg;			| if (r[15] < 0) trivial rejection.
   1e18  09 00 3 9 0 d84c 0000  	movw,s r[12], y;		;		cjp, ~neg;			| if (r[15] >  1024) trivial rejection.
   1e19  09 49 3 1 0 960d 0400  	subw,s d, r[13], y;	 1024->am;	cjp, neg;			| if (r[12] < 0) trivial rejection.
   1e1a  09 44 3 9 0 d84d 1e1d  	movw,s r[13], y;		=rt1x0ok->brreg; cjp, ~neg;			| if (r[13] >  1024) trivial rejection.
   1e1b  09 49 3 9 0 960c 0400  	subw,s d, r[12], y;	 1024->am;	cjp, ~neg;			| 
   1e1c  05 00 e 0 0 d90d 0000  	movw 0, r[13];		;		;				| 
   1e1d  05 00 3 1 0 7140 1e1f  rt1x0ok: ;			;		cjp, neg rt1x1ok;		| 
   1e1e  05 49 e 0 0 d8cc 03ff  	movw d, r[12];		 1023->am;	;				| 
   1e1f  01 45 e 0 0 d850 0190  rt1x1ok:  movw,s r[16], y;		 0x190->scrmemp; ;				| 
   1e20  05 0a 3 0 4 d84f 1e3d  	movw r[15], y;		am->scrmem;	cjp, zer rt1draw0;	scrmp +	| 
   1e21  05 0a e 0 4 d84d 0000  	movw r[13], y;		am->scrmem;	;			scrmp +	| 
   1e22  05 0a e 0 4 d84c 0000  	movw r[12], y;		am->scrmem;	;			scrmp +	| 
   1e23  05 0a e 0 4 d847 0000  	movw r[7], y;		am->scrmem;	;			scrmp +	| 
   1e24  05 0a e 0 4 d846 0000  	movw r[6], y;		am->scrmem;	;			scrmp +	| 
   1e25  05 49 e 0 0 d8d5 0500  	movw d, r[21];	0x500->am;	;				| 
   1e26  05 45 e 0 0 7140 0500  	;			0x500->scrmemp; ;				| 
   1e27  01 59 e 0 4 d8c9 0000  rt1clip: movw,s d, r[9];	scrmem->am;	;			scrmp +	| 4 tests for rejection follow.
   1e28  05 00 3 1 0 dc0d 1128  	incw r[13], acc;		;		cjp, neg start;			| Recreate r[12]
   1e29  04 00 e 0 c 988b 0000  	addw r[11], acc, r[12];	;		;				| 
   1e2a  01 00 e 0 0 960c 0000  	subw,s d, r[12], y;	;		;				| 
   1e2b  05 59 3 1 4 d8c8 1e3f  	movw d, r[8];	scrmem->am;	cjp, neg rt1reset;	scrmp +	| 
   1e2c  01 00 e 0 0 960f 0000  	subw,s d, r[15], y;	;		;				| 
   1e2d  05 59 3 1 4 8689 1e3f  	addw d, r[9], acc;	scrmem->am;	cjp, neg rt1reset;	scrmp +	| r[10] + r[9]
   1e2e  05 00 e 0 0 d88a 0000  	movw acc, r[10];	;		;				| save in r[10]
   1e2f  01 00 e 0 0 904d 0000  	rsubw,s r[13], acc, y;	;		;				| 
   1e30  05 59 3 9 0 8688 1e3f  	addw d, r[8], acc;	scrmem->am;	cjp, ~neg rt1reset;		| r[20] + r[8]
   1e31  01 00 e 0 0 904f 0000  	rsubw,s r[15], acc, y;	;		;				| 
   1e32  05 00 3 9 0 d809 1e3f  	movw r[9], acc;	;		cjp, ~neg rt1reset;		| Last rejection test.
   1e33  01 00 e 0 0 800d 0000  	subw,s r[13], acc, acc;	;		;				| 
   1e34  05 00 3 1 0 7140 1e37  	;			;		cjp, neg rt1right;		| 
   1e35  04 00 e 0 d d969 0000  	movw r[9], r[13];	;		;				| 
   1e36  05 00 e 0 0 9887 0000  	addw r[7], acc, r[7];	;		;				| 
   1e37  05 00 e 0 0 d80a 0000  rt1right: movw r[10], acc;	;		;				| 
   1e38  01 00 e 0 0 800c 0000  	subw,s r[12], acc, acc;	;		;				| 
   1e39  05 00 3 9 0 7140 1e3b  	;			;		cjp, ~neg rt1drawdx;		| 
   1e3a  05 00 e 0 0 988c 0000  	addw r[12], acc, r[12];	;		;				| 
   1e3b  05 09 e 0 0 dc4d 0000  rt1drawdx: incw r[13], y;		am->am;		;				| Restore r[11].
   1e3c  04 00 e 0 b 9e0c 0000  	subw d, r[12], r[11];		;		;				| 
   1e3d  05 04 e 0 0 d859 0000  rt1draw0: movw r[25], y;	am->brreg;	;				| 
                                |	;			;		cjs, go rt1draw;		| OLD
   1e3e  1d 00 1 0 0 7140 0000  	;			;		cjs, go;			| 
   1e3f  01 45 e 0 0 d850 0190  rt1reset:  movw,s r[16], y;		 0x190->scrmemp; ;				| 
   1e40  05 59 3 0 4 d8cf 1128  	movw d, r[15];		scrmem->am;	cjp, zer start;		scrmp +	| 
   1e41  05 59 e 0 4 d8cd 0000  	movw d, r[13];		scrmem->am;	;			scrmp +	| 
   1e42  05 59 e 0 4 d8cc 0000  	movw d, r[12];		scrmem->am;	;			scrmp +	| 
   1e43  04 00 e 0 b 9e4d 0000  	rsubw d, r[13], r[11];	;		;				| Restore r[11] for next r[16] rectangle.
   1e44  05 59 e 0 4 d8c7 0000  	movw d, r[7];		scrmem->am;	;			scrmp +	| 
   1e45  05 59 e 0 4 d8c6 0000  	movw d, r[6];		scrmem->am;	;			scrmp +	| 
   1e46  05 49 e 0 0 7140 0004  	;			4->am;		;				| 
   1e47  15 05 3 0 0 9e95 1e27  	addw d, r[21], r[21]; am->scrmemp;	cjp, go rt1clip;		| 
                                |   rt1draw:  shaded 2d segments.
                                |   Use repeated subtraction for finding modulus functions since in the average case
                                |   where r[7] might be 576 and r[10] 32 the division routine would take about 47 instructions
                                |   whereas repeated subtraction takes 18.  ENHANCEMENT:  use priw instruction to branch between
                                |   div routine or repeated subtraction.
   1e48  05 45 e 0 0 7140 0000  rt1draw: ;			0->scrmemp;	;				| Save values that rt1draw clobbers, for rt1ropchip
                                |	movw d, acc;		160->am;	;				| DEBUG
                                |	;			;		cjs, go flash;			| DEBUG
   1e49  05 0a e 0 4 d84a 0000  	movw r[10], y;		am->scrmem;	;			scrmp +	| 
   1e4a  05 0a e 0 4 d849 0000  	movw r[9], y;	am->scrmem;	;			scrmp +	| 
   1e4b  01 45 e 0 0 d846 018b  	movw,s r[6], y;		0x18b->scrmemp; ;				| Find addr of 1st pixel in row of texture.
   1e4c  05 59 e 0 4 d8ca 0000  	movw d, r[10];		scrmem->am;	;			scrmp +	| 
   1e4d  01 59 3 1 0 9e86 1e4d  	addw,s d, r[6], r[6];	scrmem->am;	cjp, neg .;			| 
   1e4e  01 59 3 9 0 9e06 1e4e  	subw,s d, r[6], r[6];	scrmem->am;	cjp, ~neg .;			| scrmem == TexHt. 
   1e4f  05 00 e 0 0 9e86 0000  	addw d, r[6], r[6];		;		;				| r[6] is 2 * TexHt below negative.
   1e50  04 00 e 0 2 9e86 0000  	addw d, r[6], r[2];	;		;				| r[6] mod TexHt => r[2] for multiply.
   1e51  04 00 e 0 0 c1ea 0000  	sub2nw 0, r[10], r[0];	;		;				| r[8]= (0x18b - 1) >> 4
   1e52  05 00 e 0 0 9980 0000  	rolw 12, r[0], acc;	;		;				| 
   1e53  05 49 e 0 0 c2c8 0fff  	andw d, acc, r[8];	0xfff->am;	;				| 
   1e54  15 00 1 0 0 dc08 116f  	incw r[8], acc;	;		cjs, go multiply;		| 
   1e55  04 49 e 0 4 9e80 0800  	addw d, r[0], r[4];	 0x800->am;	;				| r[4]=  0x800 + r[6] * (r[8] + 1)
   1e56  01 00 e 0 0 d807 0000  	movw,s r[7], acc;		;		;				| 
   1e57  01 00 3 1 0 808a 1e57  	addw,s r[10], acc, acc; ;		cjp, neg .;			| Find r[7] modulo texture width.
   1e58  01 00 3 9 0 800a 1e58  	subw,s r[10], acc, acc; ;		cjp, ~neg .;			| Find r[7] modulo texture width.
   1e59  05 00 e 0 0 808a 0000  	addw r[10], acc, acc;	;		;				| acc will be 2 * r[10] below negative.
   1e5a  05 00 e 0 0 808a 0000  	addw r[10], acc, acc;	;		;				| Restore acc.
   1e5b  05 00 e 0 0 d887 0000  	movw acc, r[7];		;		;				| r[7]= r[7] mod TexHt
   1e5c  04 49 e 0 9 9ec7 000f  	andw d, r[7], r[9];	0xf->am;	;				| r[9]= r[7] & 0xf
   1e5d  04 00 e 0 5 99e7 0000  	rolw 12, r[7], r[5];	;		;				| r[5]= r[7] >> 4
   1e5e  05 49 e 0 0 9ec5 0fff  	andw d, r[5], r[5]; 0xfff->am;	;				| 
   1e5f  05 00 e 0 0 d804 0000  	movw r[4], acc;	;		;				| 
   1e60  05 05 e 0 0 9085 0000  	addw r[5], acc, y;	am->scrmemp;	;				|  0x800= r[4] + r[5]
   1e61  05 59 e 0 0 d8c3 0000  	movw d, r[3];		scrmem->am;	;				| r[3]= * 0x800.  Get first word.
   1e62  05 03 e 0 0 d849 0000  	movw r[9], y;	am->nreg;	;				| 
   1e63  07 00 e 0 0 81e3 0000  	rolw n, r[3], r[3];	;		;				| r[4] bit indicates presence or absence of pixel.
   1e64  05 00 e 0 0 c1ea 0000  	sub2nw 0, r[10], r[10]; ;		;				| r[6]= (r[10] - 1) & 0xf
   1e65  04 49 e 0 6 9eca 000f  	andw d, r[10], r[6]; 0xf->am;	;				| 
   1e66  05 00 e 0 0 d805 0000  	movw r[5], acc;	;		;				| if (r[5]==r[8]) r[9]= r[6]-r[9]
   1e67  01 00 e 0 0 9008 0000  	subw,s r[8], acc, y; ;		;				| 
   1e68  05 00 3 0 0 d806 1e6a  	movw r[6], acc;	;		cjp, zer .+2;			| 
   1e69  05 49 e 0 0 f8c1 000f  	movw d, acc;		15->am;		;				| else r[9]= 15 - r[9]
   1e6a  01 00 e 0 0 9809 0000  	subw,s r[9], acc, r[9]; ;		;				| 
   1e6b  05 00 3 9 0 7140 1e72  	;			;		cjp, ~neg rt1prime;		| if (r[9] < 0) {
   1e6c  05 00 e 0 0 d905 0000  	movw 0, r[5];	;		;				| r[5]= 0
   1e6d  05 05 e 0 0 d844 0000  	movw r[4], y;		am->scrmemp;	;				|  0x800= r[4]
   1e6e  05 59 e 0 0 d8c3 0000  	movw d, r[3];		scrmem->am;	;				| r[3]= (* 0x800) << (-r[9])
   1e6f  05 03 e 0 0 de49 0000  	negw r[9], y;	am->nreg;	;				| 
   1e70  07 00 e 0 0 81e3 0000  	rolw n, r[3], r[3];	;		;				| 
   1e71  05 49 e 0 0 9e49 000f  	rsubw d, r[9], r[9]; 15->am;	;				| r[9]= 15 - r[9] }
   1e72  01 00 e 0 0 d843 0000  rt1prime: movw,s r[3], y;	;		;				| 
   1e73  05 00 3 1 0 d81b 1e75  	movw r[27], acc;	;		cjp, neg .+2;			| 
   1e74  05 00 e 0 0 f901 0000  	movw 0, acc;		;		;				| 
   1e75  15 00 1 0 0 83e3 1ff3  	rolw 1, r[3], r[3];	;		cjs, go rt8prime;		| 
   1e76  01 00 e 0 0 c1e9 0000  	sub2nw,s 0, r[9];		;		;				| 
   1e77  05 00 1 1 0 7140 1e89  	;			;		cjs, neg rt1patt;		| INITIALIZE LOOP.
   1e78  14 00 1 0 2 d96f 11c3  rt1fb:	movw r[15], r[2];		;		cjs, go MulSWid;		| Calculate fb address.
   1e79  05 00 e 0 0 d80d 0000  	movw r[13], acc;		;		;				| 
   1e7a  05 13 e 0 0 9880 0000  	addw r[0], acc, r[0];	am->vloareg;	;				| 
   1e7b  05 49 e 0 0 86a1 0020  	addcw d, r[1], acc;	0x20->am;	;				| Pixel mode memory.
   1e7c  05 12 e 0 0 909f 0000  	addw r[31], acc, y;	am->vhiareg;	;				| 
   1e7d  05 44 e 0 0 7140 1e81  	;			=rt1dloop->brreg; ;				| 
   1e7e  05 00 3 f 0 7140 1e7e  	;			;		cjp, ~vir .;			| 
   1e7f  05 54 e 0 0 d80b 0060  	movw r[11], acc;		0x60->vctlreg;	;				| 
   1e80  11 00 3 0 0 d843 1e82  	movw,s r[3], y;		;		cjp, go rt1col;			| JUMP into middle of loop.
   1e81  01 00 e 0 1 d843 0000  rt1dloop: movw,s r[3], y;	;		;			varegs+	| 
   1e82  04 00 3 9 2 d973 1e84  rt1col:	movw r[19], r[18];	;		cjp, ~neg .+2;			| 
   1e83  04 00 e 0 2 d97b 0000  	movw r[27], r[18];	;		;				| 
   1e84  05 00 e 0 0 83e3 0000  	rolw 1, r[3], r[3];	;		;				| 
   1e85  01 00 e 0 0 c1e9 0000  	sub2nw,s 0, r[9];		;		;				| 
   1e86  01 00 1 1 0 e185 1e89  	sub2nw,s 0, acc;		;		cjs, neg rt1patt;		| 
   1e87  0d 0d 3 9 f d852 1e87  rt1wr:	movw r[18], y;		am->vwdreg;	cjp, ~neg.3 .;		vmewr	| 
   1e88  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   1e89  05 09 e 0 0 dd65 0000  rt1patt: incw r[5], r[5];	am->am;		;				| if (++r[5] > r[8])
   1e8a  01 00 e 0 0 9648 0000  	rsubw,s d, r[8], y;	;		;				| 
   1e8b  05 00 3 0 4 7140 1e92  	;			;		cjp, zer rt1patt0;	scrmp +	| 
   1e8c  05 00 3 1 0 7140 1e93  	;			;		cjp, neg rt1patt1;		| 
   1e8d  05 49 e 0 0 d8c9 000f  	movw d, r[9];	15->am;		;				| { r[9]= 15
   1e8e  01 00 e 0 0 964a 0000  	rsubw,s d, r[10], y;	;		;				| if (r[10] < 16) r[9]= r[10]
   1e8f  05 00 3 1 0 d905 1e91  	movw 0, r[5];	;		cjp, neg .+2;			| r[5]= 0
   1e90  04 00 e 0 9 d96a 0000  	movw r[10], r[9];	;		;				| 
   1e91  15 05 3 0 0 d844 1e94  	movw r[4], y;		am->scrmemp;	cjp, go rt1patt2;		| 
   1e92  14 00 3 0 9 d966 1e94  rt1patt0: movw r[6], r[9]; ;		cjp, go rt1patt2;		| } else if (r[5] == r[8]) { r[9]= r[10]
   1e93  05 49 e 0 0 d8c9 000f  rt1patt1: movw d, r[9];	15->am;		;				| } else { r[9]= 15
   1e94  05 59 e 0 0 d8c3 0000  rt1patt2: movw d, r[3];		scrmem->am;	;				| r[3]= * 0x800
   1e95  19 00 a 0 0 f880 0000  	movw,s acc, y;		;		crtn, go;			| 
                                |   Uses rasterop chips to draw textured 1 bit deep rop lines 16 pixels at a time.
   1e96  05 45 e 0 0 7140 0000  rt1ropchip: ;			0->scrmemp;	;				| Retrieve scratch values
   1e97  05 59 e 0 4 d8ca 0000  	movw d, r[10];		scrmem->am;	;			scrmp +	| 
   1e98  05 59 e 0 4 d8c9 0000  	movw d, r[9];	scrmem->am;	;			scrmp +	| 
   1e99  05 53 e 0 0 7140 a000  	;			0xa000->vloareg; ;				| 
   1e9a  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   1e9b  05 00 3 f 0 7140 1e9b  	;			;		cjp, ~vir .;			| Wait till vctlreg ready.
   1e9c  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   1e9d  05 0d 3 f 7 d85d 1e9d  	movw r[29], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| write ppmask.reg.
   1e9e  05 45 e 0 0 7140 01c0  	;			0x1c0->scrmemp; ;				| 
   1e9f  01 59 e 0 0 961c 0000  	subw,s d, r[28], y;	scrmem->am;	;				| 
   1ea0  05 0a 3 0 4 d85c 1ea3  	movw r[28], y;		am->scrmem;	cjp, zer rtcpatt0;	scrmp +	| 
   1ea1  05 53 e 0 0 7140 800e  	;			 0x800e->vloareg; ;			| vhiareg unchanged.
   1ea2  05 0d 3 f 7 d85c 1ea2  	movw r[28], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setfunction (..., r[28]).
   1ea3  05 53 e 0 0 7140 8006  rtcpatt0: ;			 0x8006->vloareg; ;			| vhiareg unch.
   1ea4  01 59 e 0 0 f8c0 0000  	 movw,s d, y;		scrmem->am;	;				| 
   1ea5  05 49 e 0 0 d8c3 adde  	movw d, r[3];		0xadde->am;	;				| DEBUG
                                |	movw 0, r[3];		;		;				| DEBUG
   1ea6  05 0a 3 0 4 d843 1ea8  	movw r[3], y;		am->scrmem;	cjp, zer rtcpatt1;	scrmp +	| 
   1ea7  05 0d 3 f 7 d843 1ea7  	movw r[3], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1ea8  01 00 e 0 0 d850 0000  rtcpatt1:  movw,s r[16], y;		;		;				| if (r[16]) ...
   1ea9  01 00 3 0 0 d84d 1eb1  	 movw,s r[13], y;		;		cjp, zer rtcnclip;		| if (pos0.x > 0)
   1eaa  05 00 3 9 0 d80c 1eac  	movw r[12], acc;		;		cjp, ~neg rtcx1;		| 
   1eab  05 00 e 0 0 d90d 0000  	movw 0, r[13];		;		;				| pos0.x= 0
   1eac  01 00 e 0 0 800a 0000  rtcx1:	subw,s r[10], acc, acc;	;		;				| if (pos1.x >= size.x)
   1ead  05 09 3 1 0 c1ea 1eaf  	sub2nw 0, r[10];		am->am;		cjp, neg rtcdx;			| pos1.x= size.x - 1
   1eae  05 00 e 0 0 d8cc 0000  	movw d, r[12];		;		;				| 
   1eaf  05 00 e 0 0 d80c 0000  rtcdx:	movw r[12], acc;		;		;				| 
   1eb0  04 00 e 0 b 980d 0000  	subw r[13], acc, r[11];	;		;				| r[11]= pos1.x - pos0.x
   1eb1  05 00 e 0 0 d80d 0000  rtcnclip: movw r[13], acc;		;		;				| 
   1eb2  05 00 e 0 0 808b 0000  	addw r[11], acc, acc;	;		;				| 
   1eb3  05 59 e 0 0 d8c0 0000  	movw d, r[0];		scrmem->am;	;				| 
   1eb4  05 53 e 0 0 8089 800a  	addw r[9], acc, acc;	0x800a->vloareg; ;			| cg2_prd_skew (dmd, pos1.x). vhiareg unchanged.
   1eb5  05 49 e 0 0 c2d1 000f  	andw d, acc, r[17];	0xf->am;	;				| r[17]= cg2_prd_skew
   1eb6  05 49 e 0 0 8691 01b0  	addw d, r[17], acc;	0x1b0->am;	;				| rmasktable [r[17]]
   1eb7  05 05 e 0 0 f880 0000  	movw acc, y;		am->scrmemp;	;				| 
   1eb8  01 59 e 0 0 9600 0000  	subw,s d, r[0], y ;	scrmem->am;	;				| 
   1eb9  05 00 3 0 0 d80d 1ebe  	movw r[13], acc;		;		cjp, zer rtcm1;			| 
   1eba  05 59 e 0 0 d8c0 0000  	movw d, r[0];		scrmem->am;	;				| 
   1ebb  05 45 e 0 0 7140 01c2  	;			 0x1c2->scrmemp; ;				| 
   1ebc  05 0a e 0 0 d840 0000  	movw r[0], y;		am->scrmem;	;				| 
   1ebd  05 0d 3 f 7 d840 1ebd  	movw r[0], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1ebe  05 53 e 0 0 8089 8008  rtcm1:	addw r[9], acc, acc;	0x8008->vloareg; ;			| cg2_prd_skew (dmd, pos0.x) vhiareg unchanged.
   1ebf  05 49 e 0 0 c2d1 000f  	andw d, acc, r[17];	0xf->am;	;				| r[17]= cg2_prd_skew
   1ec0  05 49 e 0 0 8691 01a0  	addw d, r[17], acc;	0x1a0->am;	;				| 
   1ec1  05 05 e 0 0 f880 0000  	movw acc, y;		am->scrmemp;	;				| 
   1ec2  05 59 e 0 0 d8c0 0000  	movw d, r[0];		scrmem->am;	;				| 
   1ec3  05 45 e 0 0 7140 01c3  	;			 0x1c3->scrmemp; ;				| 
   1ec4  01 59 e 0 0 9600 0000  	subw,s d, r[0], y;	scrmem->am;	;				| 
   1ec5  05 0a 3 0 4 d840 1ec7  	movw r[0], y;		am->scrmem;	cjp, zer rtcrm;		scrmp +	| 
   1ec6  05 0d 3 f 7 d840 1ec6  	movw r[0], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1ec7  01 49 e 0 0 d85a 0004  rtcrm:	 movw,s r[26], y;		4->am;	;				| 
   1ec8  05 00 3 8 0 d8d6 1eca  	movw d, r[22];	;		cjp, ~zer rtcropmode;		| if (r[26]) r[22]= 4
   1ec9  05 49 e 0 0 d8d6 0006  	movw d, r[22];	6->am;	;				| else r[22]= 6
   1eca  05 49 e 0 0 f8c1 0006  rtcropmode: movw d, acc;	6->am;	;				| 
   1ecb  15 00 1 0 0 7140 14e7  	;			;		cjs, go vropmode;		| 
   1ecc  05 00 e 0 0 d80b 0000  	movw r[11], acc;		;		;				| r[17]= (r[11]+r[17])>>4.  (>>4 == <<12).
   1ecd  05 49 e 0 0 9891 0fff  	addw r[17], acc, r[17];	0xfff->am;	;				| 
   1ece  05 53 e 0 0 99f1 8010  	rolw 12, r[17], r[17];	0x8010->vloareg; ;			| vhiareg unchanged.  mask off high bits of rotate.
   1ecf  05 00 e 0 0 9ed1 0000  	andw d, r[17], r[17];	;		;				| 
   1ed0  01 59 e 0 0 9611 0000  	subw,s d, r[17], y;	scrmem->am;	;				| 
   1ed1  05 0a 3 0 4 d851 1ed3  	movw r[17], y;		am->scrmem;	cjp, zer rtccnt;	scrmp +	| 
   1ed2  05 0d 3 f 7 d851 1ed2  	movw r[17], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 1st 1/2 cg2_setwidth (..., r[17], r[17]).
   1ed3  05 53 e 0 0 7140 8012  rtccnt:	;			0x8012->vloareg; ;			| vhiareg unchanged.
   1ed4  01 59 e 0 0 9611 0000  	subw,s d, r[17], y;	scrmem->am;	;				| 
   1ed5  05 0a 3 0 4 d851 1ed7  	movw r[17], y;		am->scrmem;	cjp, zer rtcsh;		scrmp +	| 
   1ed6  05 0d 3 f 7 d851 1ed6  	movw r[17], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 2nd 1/2 cg2_setwidth (..., r[17], r[17]).
   1ed7  05 53 e 0 0 7140 800c  rtcsh:	;			0x800c->vloareg; ;			| vhiareg unchanged.
   1ed8  01 59 e 0 0 f195 0000  	sub2nw,s 8, d, y;	scrmem->am;	;				| 
   1ed9  05 0a 3 0 4 f196 1edb  	mov2nw 8, y;		am->scrmem;	cjp, zer rtcsrc2a;	scrmp +	| 
   1eda  05 0d 3 f 7 f196 1eda  	mov2nw 8, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setshift (..., 0, 1).
   1edb  05 00 e 0 0 d81b 0000  rtcsrc2a: movw r[27], acc;	;		;				| 
   1edc  05 00 e 0 0 b1db 0000  	romw 8, r[27], acc, 0xff00; ;		;				| instruction completes on next cycle.
   1edd  05 53 e 0 0 ff00 8804  	;			0x8804->vloareg; ;			| vhiareg unchanged.
   1ede  05 59 e 0 0 e200 0000  	subw d, acc, y;		scrmem->am;	;				| 
   1edf  05 0d 3 f 7 f880 1edf  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1ee0  05 00 e 0 0 d80f 0000  rtcrwrd: movw r[15], acc;		;		;				| 
   1ee1  15 00 1 0 0 d882 11c6  	movw acc, r[2];	;		cjs, go MulSWWid;		| cg2_ropword (dmd, 0, pos0.x, pos0.x)
   1ee2  05 00 e 0 0 9b8d 0000  	rolw 13, r[13], acc;	;		;				| cg2_ropword: (x>>4)*(sizeof(short))
   1ee3  05 49 e 0 0 e2c1 1ffe  	andw d, acc, acc;	0x1ffe->am;	;				| a5_adr= cg2_ropword	
   1ee4  05 13 e 0 0 9880 0000  	addw r[0], acc, r[0]; am->vloareg;	;				| 
   1ee5  05 49 e 0 0 86bf 0020  	addcw d, r[31], acc;	0x20->am;	;				| 
   1ee6  05 12 e 0 0 9881 0000  	addw r[1], acc, r[1]; am->vhiareg;	;				| 
                                | switch (d5_count) unwrapped.  r[26] part separated out.
   1ee7  01 00 e 0 0 d85a 0000  rtccolor:  movw,s r[26], y;	;		;				| 
   1ee8  05 04 3 8 0 d851 1eee  	movw r[17], y;		am->brreg;	cjp, ~zer rtcnodst;		| 
   1ee9  1d 00 4 0 0 7140 0000  	;			;		push, go;			| 
   1eea  05 0d 3 f 7 d85b 1eea  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| value written is immaterial.
   1eeb  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   1eec  0d 00 8 0 1 7140 0000  	;			;		rfct;			varegs +| 
   1eed  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   1eee  01 49 e 0 0 9611 0002  rtcnodst: subw,s d, r[17], y;	2->am;		;				| 
   1eef  01 00 3 9 0 d851 1ef5  	 movw,s r[17], y;		;		cjp, ~neg rtc2;			| 
   1ef0  05 0d 3 f 7 d85b 1ef0  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1ef1  0d 00 a 0 1 7140 0000  	;			;		crtn, zer;		varegs +| 
   1ef2  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   1ef3  05 00 3 f 7 7140 1ef3  	;			;		cjp, ~vir .;		vmewr	| 
   1ef4  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
   1ef5  05 12 e 0 0 d85e 0000  rtc2:	movw r[30], y;		am->vhiareg;	;				| 
   1ef6  05 53 e 0 0 e386 8010  	mov2nw 1, acc;		0x8010->vloareg; ;			| 
   1ef7  05 45 e 0 0 7140 01c4  	;			0x1c4->scrmemp; ;				| 
   1ef8  01 59 e 0 0 e395 0000  	sub2nw,s 1, d, y;	scrmem->am;	;				| 
   1ef9  05 0a 3 0 4 e396 1efb  	mov2nw 1, y;		am->scrmem;	cjp, zer rtccnt1;	scrmp +	| 
   1efa  05 0d 3 f 7 f880 1efa  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 1st 1/2 cg2_setwidth (..., 2, 2).
   1efb  05 53 e 0 0 7140 8012  rtccnt1: ;			0x8012->vloareg; ;			| vhiareg unchanged.
   1efc  01 59 e 0 0 e395 0000  	sub2nw,s 1, d, y;	scrmem->am;	;				| 
   1efd  05 0a 3 0 4 e396 1eff  	mov2nw 1, y;		am->scrmem;	cjp, zer rtccol0;	scrmp +	| 
   1efe  05 0d 3 f 7 f880 1efe  rtccount1: movw acc, y;		am->vwdreg;	cjp, ~vir rtccount1;	vmewr	| 2nd 1/2 cg2_setwidth (..., 2, 2).
   1eff  05 13 e 0 0 d840 0000  rtccol0: movw r[0], y;	am->vloareg;	;				| 
   1f00  05 12 e 0 0 d841 0000  	movw r[1], y;		am->vhiareg;	;				| 
   1f01  05 0d 3 f 7 d85b 1f01  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| *(a5_adr)++= d3_color (value is immaterial)
   1f02  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   1f03  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   1f04  05 00 3 f 7 7140 1f04  	;			;		cjp, ~vir .;		vmewr	| *(a5_adr)++= d3_color (value is immaterial)
   1f05  01 49 e 0 1 9e11 0003  	subw,s d, r[17], r[17];	3->am;		;			varegs +| r[17] less 3 so "fastloop" right num
   1f06  05 00 3 1 1 7140 1f17  	;			;		cjp, neg rtcvmewr3;	varegs +| 
   1f07  15 00 1 0 0 d816 14e7  	movw r[22], acc;	;		cjs, go vropmode;		| 
   1f08  01 49 e 0 0 9e80 0004  	addw,s d, r[0], r[0];4->am;		;				| Sync r[0] with vme addr counter.
   1f09  05 13 3 a 0 d840 1f0b  	movw r[0], y;		am->vloareg;	cjp, ~cry rtcncry1;		| 
   1f0a  05 00 e 0 0 dd61 0000  	incw r[1], r[1];	;		;				| Sync r[1] with vme addr counter.
   1f0b  05 04 e 0 0 d851 0000  rtcncry1: movw r[17], y;	am->brreg;	;				| Get ready to load counter.
   1f0c  1d 12 4 0 0 d841 0000  	movw r[1], y;		am->vhiareg;	push, go;			| 
   1f0d  05 0d 3 f 7 d85b 1f0d  	movw r[27], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| (value is immaterial)
   1f0e  05 00 e 0 1 7140 0000  	;			;		;			varegs +| 
   1f0f  0d 49 8 0 1 7140 0006  	;			6->am;	rfct;			varegs +| 
   1f10  15 00 1 0 0 f8c1 14e7  	movw d, acc;		;		cjs, go vropmode;		| 
   1f11  04 00 e 0 2 cc11 0000  	sl0w r[17], r[18];	;		;				| 
   1f12  01 49 e 0 0 8692 0002  	addw,s d, r[18], acc;	2->am;		;				| 
   1f13  01 13 3 a 0 9880 1f15  	addw,s r[0], acc, r[0];am->vloareg;	cjp, ~cry rtcvmewr2;		| 
   1f14  05 00 e 0 0 dc41 0000  	incw r[1], y;		;		;				| 
   1f15  05 12 3 a 0 d841 1f17  rtcvmewr2: movw r[1], y;	am->vhiareg;	cjp, ~cry rtcvmewr3;		| 
   1f16  05 12 e 0 0 dc41 0000  	incw r[1], y;		am->vhiareg;	;				| 
   1f17  05 0d 3 f 7 f900 1f17  rtcvmewr3: movw 0, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| (value is immaterial)
   1f18  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
                                |   plgtex8:  #29.
   1f19  05 61 3 d 0 d8cf 1f19  plgtex8: movw d, r[15];		fifo1->am;	cjp, f1e .;			| 
   1f1a  05 61 3 d 0 d8cd 1f1a  	movw d, r[13];		fifo1->am;	cjp, f1e .;			| 
   1f1b  05 61 3 d 0 d8cc 1f1b  	movw d, r[12];		fifo1->am;	cjp, f1e .;			| 
   1f1c  05 09 e 0 0 c1ec 0000  	sub2nw 0, r[12], r[12];	am->am;		;				| ?
   1f1d  00 00 e 0 b 9e4d 0000  	rsubw,s d, r[13], r[11];	;		;				| 
   1f1e  05 61 3 d 0 d8dc 1f1e  	movw d, r[28];		fifo1->am;	cjp, f1e .;			| 
   1f1f  05 61 3 d 0 d8c7 1f1f  	movw d, r[7];		fifo1->am;	cjp, f1e .;			| 
   1f20  05 49 e 0 0 f8c1 fffe  	movw d, acc;		0xfffe->am;	;				| 
   1f21  05 61 3 d 0 d8c6 1f21  	movw d, r[6];		fifo1->am;	cjp, f1e .;			| 
   1f22  05 00 3 0 0 7140 1128  	;			;		cjp, zer start;			| 
   1f23  15 00 1 0 0 7140 1f80  	;			;		cjs, go rt8prep;		| 
   1f24  15 00 1 0 0 7140 1f91  	;			;		cjs, go rt8line;		| 
   1f25  15 00 3 0 0 7140 1128  	;			;		cjp, go start;			| 
                                |   roptex8:  #30.
   1f26  05 61 3 d 0 d8cd 1f26  roptex8: movw d, r[13];		fifo1->am;	cjp, f1e .;			| 
   1f27  05 61 3 d 0 d8cf 1f27  	movw d, r[15];		fifo1->am;	cjp, f1e .;			| 
   1f28  05 61 3 d 0 d8cc 1f28  	movw d, r[12];		fifo1->am;	cjp, f1e .;			| 
   1f29  05 09 e 0 0 c1ec 0000  	sub2nw 0, r[12], r[12];	am->am;		;				| ?
   1f2a  00 00 e 0 b 9e4d 0000  	rsubw,s d, r[13], r[11];	;		;				| 
   1f2b  04 61 3 d e 9e8f 1f2b  	addw d, r[15], r[14];		fifo1->am;	cjp, f1e .;			| 
   1f2c  05 61 3 d 0 d8dc 1f2c  	movw d, r[28];		fifo1->am;	cjp, f1e .;			| 
   1f2d  05 61 3 d 0 d8c7 1f2d  	movw d, r[7];		fifo1->am;	cjp, f1e .;			| 
   1f2e  05 49 e 0 0 f8c1 fffe  	movw d, acc;		0xfffe->am;	;				| 
   1f2f  05 61 3 d 0 d8c6 1f2f  	movw d, r[6];		fifo1->am;	cjp, f1e .;			| 
   1f30  05 00 3 0 0 7140 1128  	;			;		cjp, zer start;			| 
   1f31  15 00 1 0 0 7140 1f80  	;			;		cjs, go rt8prep;		| 
   1f32  15 00 1 0 0 7140 1f34  	;			;		cjs, go rt8rop;			| 
   1f33  15 00 3 0 0 7140 1128  rt8end:	;			;		cjp, go start;			| 	
   1f34  01 00 e 0 0 d84e 0000  rt8rop:	movw,s r[14], y;		;		;				| 
   1f35  09 49 a 1 0 960f 0400  	subw,s d, r[15], y;	 1024->am;	crtn, neg;			| if (r[14] < 0) trivial rejection.
   1f36  09 00 a 9 0 d84c 0000  	movw,s r[12], y;		;		crtn, ~neg;			| if (r[15] >  1024) trivial rejection.
   1f37  09 49 a 1 0 960d 0400  	subw,s d, r[13], y;	 1024->am;	crtn, neg;			| if (r[12] < 0) trivial rejection.
   1f38  09 44 a 9 0 d84d 1f3b  	movw,s r[13], y;		=rt8x0ok->brreg; crtn, ~neg;			| if (r[13] >  1024) trivial rejection.
   1f39  09 49 3 9 0 960c 0400  	subw,s d, r[12], y;	 1024->am;	cjp, ~neg;			| 
   1f3a  05 00 e 0 0 d90d 0000  	movw 0, r[13];		;		;				| 
   1f3b  05 00 3 1 0 7140 1f3d  rt8x0ok: ;			;		cjp, neg rt8x1ok;		| 
   1f3c  05 49 e 0 0 d8cc 03ff  	movw d, r[12];		 1023->am;	;				| 
   1f3d  01 45 e 0 0 d850 0190  rt8x1ok:  movw,s r[16], y;		 0x190->scrmemp; ;				| 
   1f3e  05 0a 3 0 4 d84f 1f65  	movw r[15], y;		am->scrmem;	cjp, zer rt8scan0;	scrmp +	| 
   1f3f  05 0a e 0 4 d84e 0000  	movw r[14], y;		am->scrmem;	;			scrmp +	| 
   1f40  05 0a e 0 4 d84d 0000  	movw r[13], y;		am->scrmem;	;			scrmp +	| 
   1f41  05 0a e 0 4 d84c 0000  	movw r[12], y;		am->scrmem;	;			scrmp +	| 
   1f42  05 0a e 0 4 d84b 0000  	movw r[11], y;		am->scrmem;	;			scrmp +	| 
   1f43  05 0a e 0 4 d847 0000  	movw r[7], y;		am->scrmem;	;			scrmp +	| 
   1f44  05 0a e 0 4 d846 0000  	movw r[6], y;		am->scrmem;	;			scrmp +	| 
   1f45  05 49 e 0 0 d8d5 0500  	movw d, r[21];	0x500->am;	;				| 
   1f46  05 45 e 0 0 7140 0500  	;			0x500->scrmemp; ;				| 
   1f47  01 59 e 0 4 d8c9 0000  rt8clip: movw,s d, r[9];	scrmem->am;	;			scrmp +	| 4 tests for rejection follow.
   1f48  0d 00 a 1 0 dc0d 0000  	incw r[13], acc;		;		crtn, neg;			| Recreate r[12]
   1f49  04 00 e 0 c 988b 0000  	addw r[11], acc, r[12];	;		;				| 
   1f4a  01 00 e 0 0 960c 0000  	subw,s d, r[12], y;	;		;				| 
   1f4b  05 59 3 1 4 d8c8 1f76  	movw d, r[8];	scrmem->am;	cjp, neg rt8reset;	scrmp +	| 
   1f4c  01 00 e 0 0 960e 0000  	subw,s d, r[14], y;	;		;				| 
   1f4d  05 59 3 1 4 8689 1f76  	addw d, r[9], acc;	scrmem->am;	cjp, neg rt8reset;	scrmp +	| r[10] + r[9]
   1f4e  05 00 e 0 0 d88a 0000  	movw acc, r[10];	;		;				| save in r[10]
   1f4f  01 00 e 0 0 904d 0000  	rsubw,s r[13], acc, y;	;		;				| 
   1f50  05 59 3 9 0 8688 1f76  	addw d, r[8], acc;	scrmem->am;	cjp, ~neg rt8reset;		| r[20] + r[8]
   1f51  05 00 e 0 0 d894 0000  	movw acc, r[20];	;		;				| save in r[20]
   1f52  01 00 e 0 0 904f 0000  	rsubw,s r[15], acc, y;	;		;				| Last rejection test.
   1f53  05 00 3 9 0 d809 1f76  	movw r[9], acc;	;		cjp, ~neg rt8reset;		| 
   1f54  01 00 e 0 0 800d 0000  	subw,s r[13], acc, acc;	;		;				| Test for rop crossing left boundary.
   1f55  05 00 3 1 0 7140 1f58  	;			;		cjp, neg rt8y0;			| 
   1f56  04 00 e 0 d d969 0000  	movw r[9], r[13];	;		;				| 
   1f57  05 00 e 0 0 9887 0000  	addw r[7], acc, r[7];	;		;				| 
   1f58  05 00 e 0 0 d808 0000  rt8y0:	movw r[8], acc;	;		;				| 
   1f59  01 00 e 0 0 800f 0000  	subw,s r[15], acc, acc;	;		;				| Test for rop crossing top boundary.
   1f5a  05 00 3 1 0 7140 1f5d  	;			;		cjp, neg rt8right;		| 
   1f5b  04 00 e 0 f d968 0000  	movw r[8], r[15];	;		;				| 
   1f5c  05 00 e 0 0 9886 0000  	addw r[6], acc, r[6];	;		;				| 
   1f5d  05 00 e 0 0 d80a 0000  rt8right: movw r[10], acc;	;		;				| Test for rop crossing right boundary.
   1f5e  01 00 e 0 0 800c 0000  	subw,s r[12], acc, acc;	;		;				| 
   1f5f  05 00 3 9 0 7140 1f61  	;			;		cjp, ~neg rt8below;		| 
   1f60  05 00 e 0 0 988c 0000  	addw r[12], acc, r[12];	;		;				| 
   1f61  05 00 e 0 0 d814 0000  rt8below: movw r[20], acc;	;		;				| Test for rop crossing bottom boundary.
   1f62  01 00 e 0 0 800e 0000  	subw,s r[14], acc, acc;	;		;				| 
   1f63  05 00 3 9 0 7140 1f65  	;			;		cjp, ~neg rt8scan0;		| 
   1f64  05 00 e 0 0 988e 0000  	addw r[14], acc, r[14];	;		;				| 
   1f65  05 00 e 0 0 d807 0000  rt8scan0: movw r[7], acc;		;		;				| 
   1f66  05 00 e 0 0 d898 0000  	movw acc, r[24];	;		;				| 
   1f67  05 00 e 0 0 d806 0000  	movw r[6], acc;		;		;				| 
   1f68  05 00 e 0 0 d897 0000  	movw acc, r[23];	;		;				| 
   1f69  05 00 e 0 0 d80c 0000  	movw r[12], acc;		;		;				| 
   1f6a  05 00 e 0 0 d896 0000  	movw acc, r[22];	;		;				| 
   1f6b  05 09 e 0 0 d84f 0000  	movw r[15], y;		am->am;		;				| Prepare dreg for loop.
   1f6c  01 00 e 0 0 964e 0000  rt8scan: rsubw,s d, r[14], y;	;		;				| 
   1f6d  05 00 3 9 0 d818 1f76  	movw r[24], acc;	;		cjp, ~neg rt8reset;		| 
   1f6e  05 00 e 0 0 d887 0000  	movw acc, r[7];		;		;				| 
   1f6f  05 00 e 0 0 d817 0000  	movw r[23], acc;	;		;				| 
   1f70  05 00 e 0 0 d886 0000  	movw acc, r[6];		;		;				| 
   1f71  05 00 e 0 0 d816 0000  	movw r[22], acc;	;		;				| 
   1f72  05 00 e 0 0 d88c 0000  	movw acc, r[12];		;		;				| 
   1f73  04 00 e 0 b 980d 0000  	subw r[13], acc, r[11];	;		;				| 
   1f74  15 00 1 0 0 dd77 1fc2  	incw r[23], r[23];	;		cjs, go rt8draw;		| 
   1f75  15 09 3 0 0 dd6f 1f6c  	incw r[15], r[15];		am->am;		cjp, go rt8scan;		| 
   1f76  01 45 e 0 0 d850 0190  rt8reset:  movw,s r[16], y;		 0x190->scrmemp; ;				| 
   1f77  0d 59 a 0 4 d8cf 0000  	movw d, r[15];		scrmem->am;	crtn, zer;		scrmp +	| 
   1f78  05 59 e 0 4 d8ce 0000  	movw d, r[14];		scrmem->am;	;			scrmp +	| 
   1f79  05 59 e 0 4 d8cd 0000  	movw d, r[13];		scrmem->am;	;			scrmp +	| 
   1f7a  05 59 e 0 4 d8cc 0000  	movw d, r[12];		scrmem->am;	;			scrmp +	| 
   1f7b  05 59 e 0 4 d8cb 0000  	movw d, r[11];		scrmem->am;	;			scrmp +	| 
   1f7c  05 59 e 0 4 d8c7 0000  	movw d, r[7];		scrmem->am;	;			scrmp +	| 
   1f7d  05 59 e 0 4 d8c6 0000  	movw d, r[6];		scrmem->am;	;			scrmp +	| 
   1f7e  05 49 e 0 0 7140 0004  	;			4->am;		;				| 
   1f7f  15 05 3 0 0 9e95 1f47  	addw d, r[21], r[21]; am->scrmemp;	cjp, go rt8clip;		| 
   1f80  04 00 e 0 0 993c 0000  rt8prep: norw r[28], acc, r[16];	;		;				| 
   1f81  05 00 e 0 0 cc9c 0000  	sr0w r[28], r[28];		;		;				| r[28] >> 1
   1f82  05 49 e 0 0 9edc 000f  	andw d, r[28], r[28];		0xf->am;	;				| 
   1f83  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   1f84  05 00 3 f 0 7140 1f84  	;			;		cjp, ~vir .;			| Wait till vctlreg ready.
   1f85  05 54 e 0 0 7140 0073  	;			0x73->vctlreg; ;				| 
   1f86  05 45 e 0 0 7140 01c0  	;			0x1c0->scrmemp; ;				| 
   1f87  01 59 e 0 0 961c 0000  	subw,s d, r[28], y;	scrmem->am;	;				| 
   1f88  05 0a 3 0 4 d85c 1f8b  	movw r[28], y;		am->scrmem;	cjp, zer rt8dst;	scrmp +	| 
   1f89  05 53 e 0 0 7140 800e  	;			 0x800e->vloareg; ;			| vhiareg unchanged.
   1f8a  05 0d 3 f 7 d85c 1f8a  	movw r[28], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| cg2_setfunction (..., r[28]).
                                | PIXOP_NEEDS_DST (r[28] << 1)= (r[28]^(r[28] << 1)) & 0xa
   1f8b  05 00 e 0 0 d81c 0000  rt8dst:	movw r[28], acc;		;		;				| 
   1f8c  05 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;				| 
   1f8d  05 00 e 0 0 811c 0000  	xorw r[28], acc, acc;	;		;				| 
   1f8e  01 49 e 0 0 e2c1 000a  	andw,s d, acc, acc;	0xa->am;	;				| 
   1f8f  0d 00 a 8 0 d91a 0000  	movw 0, r[26];		;		crtn, ~zer;			| 
   1f90  1d 00 a 0 0 dd1a 0000  	incw 0, r[26];		;		crtn, go;			| 
   1f91  01 00 e 0 0 d84f 0000  rt8line: movw,s r[15], y;		;		;				| 
   1f92  09 49 a 1 0 960f 0400  	subw,s d, r[15], y;	 1024->am;	crtn, neg;			| if (r[15] < 0) trivial rejection.
   1f93  09 00 a 9 0 d84c 0000  	movw,s r[12], y;		;		crtn, ~neg;			| if (r[15] >  1024) trivial rejection.
   1f94  09 49 a 1 0 960d 0400  	subw,s d, r[13], y;	 1024->am;	crtn, neg;			| if (r[12] < 0) trivial rejection.
   1f95  09 44 a 9 0 d84d 1f98  	movw,s r[13], y;		=rt8lx0ok->brreg; crtn, ~neg;			| if (r[13] >  1024) trivial rejection.
   1f96  09 49 3 9 0 960c 0400  	subw,s d, r[12], y;	 1024->am;	cjp, ~neg;			| 
   1f97  05 00 e 0 0 d90d 0000  	movw 0, r[13];		;		;				| 
   1f98  05 00 3 1 0 7140 1f9a  rt8lx0ok: ;			;		cjp, neg rt8lx1ok;		| 
   1f99  05 49 e 0 0 d8cc 03ff  	movw d, r[12];		 1023->am;	;				| 
   1f9a  01 45 e 0 0 d850 0190  rt8lx1ok:  movw,s r[16], y;		 0x190->scrmemp; ;				| 
   1f9b  05 0a 3 0 4 d84f 1fb8  	movw r[15], y;		am->scrmem;	cjp, zer rt8ldraw0;	scrmp +	| 
   1f9c  05 0a e 0 4 d84d 0000  	movw r[13], y;		am->scrmem;	;			scrmp +	| 
   1f9d  05 0a e 0 4 d84c 0000  	movw r[12], y;		am->scrmem;	;			scrmp +	| 
   1f9e  05 0a e 0 4 d847 0000  	movw r[7], y;		am->scrmem;	;			scrmp +	| 
   1f9f  05 0a e 0 4 d846 0000  	movw r[6], y;		am->scrmem;	;			scrmp +	| 
   1fa0  05 49 e 0 0 d8d5 0500  	movw d, r[21];	0x500->am;	;				| 
   1fa1  05 45 e 0 0 7140 0500  	;			0x500->scrmemp; ;				| 
   1fa2  01 59 e 0 4 d8c9 0000  rt8lclip: movw,s d, r[9];	scrmem->am;	;			scrmp +	| 4 tests for rejection follow.
   1fa3  0d 00 a 1 0 dc0d 0000  	incw r[13], acc;		;		crtn, neg;			| Recreate r[12]
   1fa4  04 00 e 0 c 988b 0000  	addw r[11], acc, r[12];	;		;				| 
   1fa5  01 00 e 0 0 960c 0000  	subw,s d, r[12], y;	;		;				| 
   1fa6  05 59 3 1 4 d8c8 1fb9  	movw d, r[8];	scrmem->am;	cjp, neg rt8lreset;	scrmp +	| 
   1fa7  01 00 e 0 0 960f 0000  	subw,s d, r[15], y;	;		;				| 
   1fa8  05 59 3 1 4 8689 1fb9  	addw d, r[9], acc;	scrmem->am;	cjp, neg rt8lreset;	scrmp +	| r[10] + r[9]
   1fa9  05 00 e 0 0 d88a 0000  	movw acc, r[10];	;		;				| save in r[10]
   1faa  01 00 e 0 0 904d 0000  	rsubw,s r[13], acc, y;	;		;				| 
   1fab  05 59 3 9 0 8688 1fb9  	addw d, r[8], acc;	scrmem->am;	cjp, ~neg rt8lreset;		| r[20] + r[8]
   1fac  01 00 e 0 0 904f 0000  	rsubw,s r[15], acc, y;	;		;				| 
   1fad  05 00 3 9 0 d809 1fb9  	movw r[9], acc;	;		cjp, ~neg rt8lreset;		| Last rejection test.
   1fae  01 00 e 0 0 800d 0000  	subw,s r[13], acc, acc;	;		;				| 
   1faf  05 00 3 1 0 7140 1fb2  	;			;		cjp, neg rt8lright;		| 
   1fb0  04 00 e 0 d d969 0000  	movw r[9], r[13];	;		;				| 
   1fb1  05 00 e 0 0 9887 0000  	addw r[7], acc, r[7];	;		;				| 
   1fb2  05 00 e 0 0 d80a 0000  rt8lright: movw r[10], acc;	;		;				| 
   1fb3  01 00 e 0 0 800c 0000  	subw,s r[12], acc, acc;	;		;				| 
   1fb4  05 00 3 9 0 7140 1fb6  	;			;		cjp, ~neg rt8ldrawdx;		| 
   1fb5  05 00 e 0 0 988c 0000  	addw r[12], acc, r[12];	;		;				| 
   1fb6  05 09 e 0 0 d84d 0000  rt8ldrawdx: movw r[13], y;		am->am;		;				| Restore r[11].
   1fb7  04 00 e 0 b 9e0c 0000  	subw d, r[12], r[11];		;		;				| 
   1fb8  15 00 1 0 0 7140 1fc2  rt8ldraw0: ;			;		cjs, go rt8draw;		| 
   1fb9  01 45 e 0 0 d850 0190  rt8lreset:  movw,s r[16], y;	 0x190->scrmemp; ;				| 
   1fba  0d 59 a 0 4 d8cf 0000  	movw d, r[15];		scrmem->am;	crtn, zer;		scrmp +	| 
   1fbb  05 59 e 0 4 d8cd 0000  	movw d, r[13];		scrmem->am;	;			scrmp +	| 
   1fbc  05 59 e 0 4 d8cc 0000  	movw d, r[12];		scrmem->am;	;			scrmp +	| 
   1fbd  04 00 e 0 b 9e4d 0000  	rsubw d, r[13], r[11];	;		;				| Restore r[11] for next r[16] rectangle.
   1fbe  05 59 e 0 4 d8c7 0000  	movw d, r[7];		scrmem->am;	;			scrmp +	| 
   1fbf  05 59 e 0 4 d8c6 0000  	movw d, r[6];		scrmem->am;	;			scrmp +	| 
   1fc0  05 49 e 0 0 7140 0004  	;			4->am;		;				| 
   1fc1  15 05 3 0 0 9e95 1fa2  	addw d, r[21], r[21]; am->scrmemp;	cjp, go rt8lclip;		| 
                                |   rt8draw:  shaded 2d segments.
                                |   Use repeated subtraction for finding modulus functions since in the average case
                                |   where r[7] might be 576 and r[10] 32 the division routine would take about 47 instructions
                                |   whereas repeated subtraction takes 18.  ENHANCEMENT:  use priw instruction to branch between
                                |   div routine or repeated subtraction.
   1fc2  00 45 e 0 0 d966 018b  rt8draw: movw,s r[6], r[0];	0x18b->scrmemp; ;				| Find addr of 1st pixel in row of texture.
   1fc3  05 59 e 0 4 d8ca 0000  	movw d, r[10];		scrmem->am;	;			scrmp+	| 
   1fc4  01 59 3 1 0 9e80 1fc4  	addw,s d, r[0], r[0];	scrmem->am;	cjp, neg .;			| 
   1fc5  01 59 3 9 0 9e00 1fc5  	subw,s d, r[0], r[0];	scrmem->am;	cjp, ~neg .;			| Get TexHt from scratch memory.
   1fc6  04 00 e 0 2 9e80 0000  	addw d, r[0], r[2];	;		;				| r[6] is 2 * TexHt below negative.
   1fc7  05 00 e 0 0 9e82 0000  	addw d, r[2], r[2];	;		;				| r[6] mod TexHt => r[2] for multiply.
   1fc8  05 00 e 0 0 dc0a 0000  	incw r[10], acc;	;		;				| 
   1fc9  15 00 1 0 0 ec81 116f  	sr0w acc, acc;		;		cjs, go multiply;		| (r[6] mod TexHt) * (r[10] / 2)
   1fca  01 00 e 0 0 d807 0000  	movw,s r[7], acc;		;		;				| Find r[13] modulo texture width.
   1fcb  01 00 3 9 0 800a 1fcb  	subw,s r[10], acc, acc; ;		cjp, ~neg .;			| 
   1fcc  05 00 e 0 0 808a 0000  	addw r[10], acc, acc;	;		;				| r[12]= r[7] mod r[10].
   1fcd  04 00 e 0 c 988a 0000  	addw r[10], acc, r[12];	;		;				| r[12]= r[7] mod r[10].
   1fce  05 49 e 0 0 8680 0800  	addw d, r[0], acc;	 0x800->am;	;				|  0x800 + (r[6] mod TexHt) * r[10].
   1fcf  05 00 e 0 0 d884 0000  	movw acc, r[4];	;		;				| 
   1fd0  04 00 e 0 0 cc8c 0000  	sr0w r[12], r[0];		;		;				| 
   1fd1  05 05 e 0 0 8080 0000  	addw r[0], acc, acc;	am->scrmemp;	;				|  0x800 + (r[7] mod r[10]) + (r[6] mod TexHt)*r[10]
   1fd2  01 00 e 0 0 e1ec 0000  	btstw,s 0, r[12];		;		;				| 
   1fd3  05 59 3 8 0 f8c1 1fd6  	movw d, acc;		scrmem->am;	cjp, ~zer rt8half;		| 
   1fd4  05 00 e 0 0 f19d 0000  	rolw 8, acc, acc;	;		;				| 
   1fd5  15 00 3 0 0 d903 1fd7  	movw 0, r[3];	;		cjp, go rt8mask0;		| 
   1fd6  05 00 e 0 4 dd03 0000  rt8half: incw 0, r[3];	;		;			scrmp+	| 
   1fd7  05 49 e 0 0 e2c1 00ff  rt8mask0: andw d, acc, acc;	0xff->am;	;				| 
   1fd8  15 00 1 0 0 7140 1ff3  	;			;		cjs, go rt8prime;		| Get first r[27]. scrmp will be incr at rt8dec.
   1fd9  14 00 1 0 2 d96f 11c3  	movw r[15], r[2];		;		cjs, go MulSWid;		| Calculate address.
   1fda  05 44 e 0 0 d80d 1fe4  	movw r[13], acc;		=rt8loop->brreg; ;				| 
   1fdb  05 13 e 0 0 9880 0000  	addw r[0], acc, r[0];	am->vloareg;	;				| 
   1fdc  05 49 e 0 0 86a1 0020  	addcw d, r[1], acc;	0x20->am;	;				| Pixel mode memory.
   1fdd  05 12 e 0 0 909f 0000  	addw r[31], acc, y;	am->vhiareg;	;				| 
   1fde  05 00 3 f 0 d80a 1fde  	movw r[10], acc;	;		cjp, ~vir .;			| 
   1fdf  05 54 e 0 0 980c 0060  	subw r[12], acc, r[12];	0x60->vctlreg;	;				| r[12]= r[10] - r[12]
   1fe0  05 00 e 0 0 d80b 0000  	movw r[11], acc;		;		;				| 
   1fe1  00 00 e 0 b 980c 0000  rt8majloop: subw,s r[12], acc, r[11];	;		;				| r[11]= r[11] - r[12]
   1fe2  05 00 3 1 0 7140 1ff2  	;			;		cjp, neg rt8dec;		| 
   1fe3  15 00 3 0 0 d80c 1ff2  	movw r[12], acc;		;		cjp, go rt8dec;			| 
   1fe4  05 00 e 0 1 dd63 0000  rt8loop: incw r[3], r[3]; ;		;			varegs+	| 
   1fe5  01 00 e 0 0 e1e3 0000  rt8dec0: btstw,s 0, r[3];	;		;				| 
   1fe6  05 59 3 8 0 b020 1fe8  	rolw 8, d, r[0];	scrmem->am;	cjp, ~zer rt8mask;		| 
   1fe7  05 59 e 0 4 d8c0 0000  	movw d, r[0];		scrmem->am;	;			scrmp+	| 
   1fe8  05 49 e 0 0 9ec0 00ff  rt8mask: andw d, r[0], r[0];	0xff->am;	;				| 
   1fe9  01 00 e 0 0 e185 0000  	sub2nw,s 0, acc;		;		;				| dec loop counter.
   1fea  0d 0d 3 9 f d840 1fea  	movw r[0], y;		am->vwdreg;	cjp, ~neg.3 .;		vmewr	| write r[27]
   1feb  01 00 e 0 0 d80b 0000  	movw,s r[11], acc;		;		;				| 
   1fec  0d 05 a 1 1 d844 0000  	movw r[4], y;		am->scrmemp;	crtn, neg;		varegs+	| 
   1fed  05 59 e 0 0 b020 0000  	rolw 8, d, r[0];	scrmem->am;	;				| 
   1fee  05 49 e 0 0 9ec0 00ff  	andw d, r[0], r[0];	0xff->am;	;				| 
   1fef  05 0d 3 f 7 d840 1fef  	movw r[0], y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1ff0  05 00 e 0 0 d903 0000  	movw 0, r[3];	;		;				| 
   1ff1  14 00 3 0 c d96a 1fe1  	movw r[10], r[12];	;		cjp, go rt8majloop;		| 
   1ff2  15 00 3 0 0 e185 1fe5  rt8dec:	sub2nw 0, acc;		;		cjp, go rt8dec0;		| 
                                |   rt8prime:  Expects r[27] in acc.  r[0] will be clobbered.
   1ff3  05 00 3 f 0 d880 1ff3  rt8prime: movw acc, r[0];	;		cjp, ~vir .;			| 
   1ff4  05 54 e 0 0 b1c0 0061  	romw 8, r[0], acc, 0xff00; 0x61->vctlreg; ;				| 
   1ff5  05 53 e 0 0 ff00 8804  	;			0x8804->vloareg; ;			| 
   1ff6  05 12 e 0 0 d85e 0000  	movw r[30], y;		am->vhiareg;	;				| 
   1ff7  05 0d 3 f 7 f880 1ff7  	movw acc, y;		am->vwdreg;	cjp, ~vir .;		vmewr	| 
   1ff8  1d 00 a 0 0 7140 0000  	;			;		crtn, go;			| 
                                stop
   1ff9  05 00 e 0 0 f8e0 0000  stopit:	movw 0xa, y;		;		;				| 
   1ffa  15 02 3 0 0 000a 1ff9  	;			am->stlreg;	cjp, go stopit;			| 


