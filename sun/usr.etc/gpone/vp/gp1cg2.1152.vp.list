Warning: file main.vp.u, line 21: instr. moves fl2reg to am29116 & has D reg. as an am29116 operand

Sun Microsystems GP-1 Viewing Processor Microassembler -- Version 1.2 (26 October 1984) -- Company Confidential

   addr  fl mv s b d  alu  var  source line

                                | "@(#)main.vp.u 1.3 86/09/13"
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                | @(#)vp.h 1.4 86/09/13 SMI
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                | Microcode Version Number 1.0  (format is xx.xx where x is a hex digit)
                                | Origin of PP microcode
                                | Default board addresses  (top 8 bits of 24-bit VME address)
                                | Graphics Buffer inquiry routine constants:
                                | 0xFFFF if no gb, otherwise index (0-3) of corresponding cg2 board
                                | Naming convention:  TEX alone refers to 1-dimensional linear textures.
                                | TEX2 refers to 2-dimensional textures, either 1-bit or 8-bit.
                                | Global static block offsets (block 0)
                                | Static frame parameter offsets
                                | PP Commands
                                	org 0
                                	debug off
      0  02 01 e 0 0 f190 0000  reset:	btstw,s 8,d;		fl2reg->am;	;		;
      1  0a 00 3 0 0 7140 0012  	;			;		cjp,zer vpinit;	;
      2  0a 00 2 0 0 7140 1123  	;			;		jmap 0x1123;	;
      3  1a 27 a 7 0 f8c1 0101  gp1_code_ver: movw d,acc;	0x0101->am;crtn,go;	;			  | version number
      4  12 27 a 7 0 f8c1 0021  gp1_board_addr: movw,s d,acc;	0x21->am; crtn,go;	;			  | GP1: top 8 bits of 24-bit VME address
                                											  | change to 0xFFFF for release
      5  12 27 a 7 0 f8c1 0040  cg2_board_addr0: movw,s d,acc;	0x40->am; crtn,go;	;			  | board #0
                                											  | change to 0xFFFF for release
      6  12 27 a 7 0 f8c1 ffff  cg2_board_addr1: movw,s d,acc;	0xFFFF->am; crtn,go;	;			  | board #1
      7  12 27 a 7 0 f8c1 ffff  cg2_board_addr2: movw,s d,acc;	0xFFFF->am; crtn,go;	;			  | board #2
      8  12 27 a 7 0 f8c1 ffff  cg2_board_addr3: movw,s d,acc;	0xFFFF->am; crtn,go;	;			  | board #3
      9  12 27 a 7 0 f8c1 0000  gb_board_inq: movw,s d,acc;	0->am;	crtn,go;	;			  | graphics buffer inquiry routine
                                											  | change to 0xFFFF for release
                                											  | returns: 0xFFFF if no gb, otherwise
                                											  | index (0-3) of corresponding cg2 board
      a  282247502d3120         	sccsid("GP-1 Microcode 1.0 85/07/17 Copyr 1985 Sun Micro")
      b  4d6963726f636f         
      c  646520312e3020         
      d  38352f30372f31         
      e  3720436f707972         
      f  20313938352053         
     10  756e204d696372         
     11  6f222900000000         
     12  0a 2f e 0 0 7140 0002  vpinit:	;			2->shmemp;;		;
     13  0a 17 e 0 0 f8c1 0000  	movw d,acc;		shmem->am;	;		;
     14  0a 27 e 0 0 e2c1 00ff  	andw d,acc,acc;		0xFF->am;	;		;			  | set high byte of shared memory location
     15  0a 0a e 0 0 f182 0000  	bsetw 8,acc;		am->shmem;	;		;			  | 2 (2) to 0x1 to indicate
                                											  | 3.2FCS or later microcode
     16  0a 2f e 0 0 7140 01fc  	;			508->shmemp;;		;
     17  0a 2a e 0 2 7140 0302  	;			0x0302->shmem;;		;		shp+	  | set release number and serial number
     18  0a 2a e 0 0 7140 0107  	;			0x0107->shmem;;		;			  | in 508 and 508+1 (508,509)
     19  1a 00 4 f 0 d91f 0000  	movw 0,r[31];		;		push,~go;	;			  | r[31] <- 0
     1a  1a 26 d 4 0 7140 0003  	;			 3->fifo1;	loop,f1nf;	;			  | send  3 command to PP
     1b  0a 00 1 7 0 7140 0004  	;			;		cjs,go gp1_board_addr;;			  | get GP1 address
     1c  0a 00 3 1 0 7140 001b  	;			;		cjp,neg .-1;	;			  | loop if GP1 addr == 0xFFFF
     1d  0a 06 3 c 0 f880 001d  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			  | send address to PP
     1e  0a 00 1 7 0 f901 0082  	movw 0,acc;		;		cjs,go getfbaddr;;			  | send a valid fb address to PP and 
                                											  | set r[28] to correct value
     1f  0a 2f e 0 0 f901 01fe  	movw 0,acc;		510->shmemp; ;		;			  | zero acc, load initial value for which
     20  0a 2a e 0 2 7140 ffff  	;			0xffff->shmem;	;		;		shp+	  |  frames texture is on pp = -1.
     21  0a 2a e 0 0 7140 ffff  	;			0xffff->shmem;	;		;			  | Set ptr to 2d texture to -1.
     22  0a 27 e 0 0 7140 0008  vpidle:	;			0x8->am;	;		;
     23  0a 0f e 0 0 e280 0000  	addw d,acc,y;		am->shmemp;	;		;
     24  12 17 4 7 0 d8de 0000  	movw,s d,r[30];	shmem->am;	push,go;	;
     25  12 17 d 8 0 d8de 0000  	movw,s d,r[30];	shmem->am;	loop,~zer;	;
     26  0a 2a e 0 0 dd7f 0000  	incw r[31],r[31];	0->shmem;	;		;
     27  0a 0f e 0 0 d85e 0000  getcmd:	movw r[30],y;		am->shmemp;	;		;
     28  0a 17 e 0 2 b020 0000  	rolw 8,d,r[0];		shmem->am;	;		;		shp+
     29  02 27 e 0 0 96c0 00c0  	andw,s d,r[0],y;		0xC0->am;	;		;			  | test bits 6 & 7 of r[0]
     2a  0a 27 e 0 0 86c0 003f  	andw d,r[0],acc;		0x3F->am;	;		;
     2b  0a 27 e 0 0 91e0 002e  	rolw 8,r[0],r[0];		=cmdtbl->am;	;		;
     2c  0a 08 3 8 0 e280 006e  	addw d,acc,y;		am->brreg;	cjp,~zer badcmd;;			  | if r[0] bits 6 or 7 are set, goto badcmd
     2d  1a 27 3 7 0 86c0 00ff  	andw d,r[0],acc;		0xFF->am;	cjp,go;		;
     2e  02 00 2 0 0 efe0 006f  cmdtbl:	btstw,s	7,r[0];		;		jmap EOCL;	;			  | 0
     2f  0a 00 2 0 0 f39d 007a  	rolw 9,acc,acc;		;		jmap USEFRAME;	;			  | 1
     30  02 17 2 0 0 961c 0094  	subw,s d,r[28],y;	shmem->am;	jmap PRVEC;	;			  | 2
     31  02 17 2 0 0 961c 00c4  	subw,s d,r[28],y;	shmem->am;	jmap PRROPNF;	;			  | 3
     32  02 17 2 0 0 961c 012a  	subw,s d,r[28],y;	shmem->am;	jmap PRROPFF;	;			  | 4
     33  02 17 2 0 0 961c 00ad  	subw,s d,r[28],y;	shmem->am;	jmap PRPOLYSOL;	;			  | 5
     34  0a 0f 2 0 0 d85d 0fee  	movw r[29],y;	am->shmemp;	jmap SETZBUF;	;			  | 6
     35  0a 00 2 0 0 dd7e 10bc  	incw r[30],r[30];	;		jmap SETHIDDENSURF;;			  | 7
     36  0a 00 2 0 0 dd7e 10bf  	incw r[30],r[30];	;		jmap SELECTMATRIX;;			  | 8
     37  0a 17 2 0 0 deca 03e6  	negw d,r[10];		shmem->am;	jmap MUL_POINT_FLT_2D;;			  | 9
     38  0a 17 2 0 0 deca 0800  	negw d,r[10];		shmem->am;	jmap MUL_POINT_FLT_3D;;			  | 10
     39  0a 17 2 0 0 d8cb 0996  	movw d,r[11];		shmem->am;	jmap XFPOLYGON_3D;;			  | 11 (r[11] is nbnds)
     3a  0a 17 2 0 0 d8cb 0559  	movw d,r[11];		shmem->am;	jmap XFPOLYGON_2D;;			  | 12 (r[11] is nbnds)
     3b  0a 17 2 0 0 deca 0799  	negw d,r[10];		shmem->am;	jmap CORENDCVEC_3D;;			  | 13
     3c  0a 17 2 0 0 deca 0376  	negw d,r[10];		shmem->am;	jmap CGIVEC;	;			  | 14
     3d  02 17 2 0 2 d8c0 10ca  	movw,s d,r[0];		shmem->am;	jmap SETCLPLST;	;		shp+	  | 15
     3e  0a 00 2 0 0 dd7e 10a4  	incw r[30],r[30];	;		jmap SETFBINDX;	;			  | 16
     3f  0a 0e 2 0 0 f900 10c3  	movw 0,y;		am->fpdp;	jmap SETVWP_3D; ;			  | 17
     40  0a 0e 2 0 0 f900 02b4  	movw 0,y;		am->fpdp;	jmap SETVWP_2D; ;			  | 18
     41  0a 17 2 0 0 c3de 10a1  	add2nw 1,r[30],r[30];	shmem->am;	jmap SETROP;	;			  | 19
     42  0a 00 2 0 0 dd7e 029f  	incw r[30],r[30];	;		jmap SETCLIPPLANES;;			  | 20
     43  0a 17 2 0 0 deca 03f0  	negw d,r[10];		shmem->am;	jmap MUL_POINT_INT_2D;;			  | 21	
     44  0a 17 2 0 0 deca 080a  	negw d,r[10];		shmem->am;	jmap MUL_POINT_INT_3D;;			  | 22
     45  0a 00 2 0 0 dd7e 10a7  	incw r[30],r[30];	;		jmap SETPIXPLANES;;			  | 23
     46  0a 0e 2 0 0 f900 10aa  	movw 0,y;		am->fpdp;	jmap SETMATRIX_3D;;			  | 24
     47  0a 17 2 0 0 deca 0789  	negw d,r[10];		shmem->am;	jmap XFVEC_3D;	;			  | 25
     48  0a 00 2 0 0 7140 006e  	;			;		jmap badcmd;	;			  | 26
                                |	mov2nw 1,acc;		shmem->am;	jmap PASSTHRU;	;		shp+	  | 26
     49  0a 17 2 0 0 deca 03cf  	negw d,r[10];		shmem->am;	jmap XFVEC_2D;	;			  | 27
     4a  0a 00 2 0 0 dd7e 109e  	incw r[30],r[30];	;		jmap SETCOLOR;	;			  | 28
     4b  0a 0e 2 0 0 f900 02a2  	movw 0,y;		am->fpdp;	jmap SETMATRIX_2D;;			  | 29
     4c  0a 17 2 0 0 d8cb 0994  	movw d,r[11];		shmem->am;	jmap CORENDCPOLY_3D;;			  | 30 (r[11] is nbnds)
     4d  0a 00 2 0 0 7140 006e  	;			;		jmap badcmd;	;			  | 31
                                |	;			;		jmap ZOOM;	;			  | 31
     4e  0a 17 2 0 2 eb99 043b  	rolw 5,d,acc;		shmem->am;	jmap MATMUL_2D;	;		shp+	  | 32
     4f  0a 17 2 0 2 eb99 0815  	rolw 5,d,acc;		shmem->am;	jmap MATMUL_3D;	;		shp+	  | 33
     50  0a 0e 2 0 0 f900 02aa  	movw 0,y;		am->fpdp;	jmap GETMATRIX_2D;;			  | 34
     51  0a 0e 2 0 0 f900 10b2  	movw 0,y;		am->fpdp;	jmap GETMATRIX_3D;;			  | 35
     52  0a 17 2 0 0 deca 07be  	negw d,r[10];		shmem->am;	jmap COREWLDVECNDC_3D;;			  | 36
     53  0a 17 2 0 0 d8cb 0c03  	movw d,r[11];		shmem->am;	jmap COREWLDPOLYNDC_3D;;		  | 37 (r[11] is nbnds)
     54  0a 17 2 0 0 d8cb 072d  	movw d,r[11];		shmem->am;	jmap PROC_PGON_FLT_2D; ;		  | 38 (r[11] is nbnds)
                                |	mov2nw 12,acc;		;		jmap SET_5080_TEX; ;			  | 39 Set 5080 line texture.
     55  0a 00 2 0 0 7140 006e  	;			;		jmap badcmd;	;			  | 39
     56  02 17 2 0 0 961c 0096  	subw,s d,r[28],y;	shmem->am;	jmap PR_LINE;	;			  | 40 Textured & fat vectors.
     57  02 17 2 0 0 961c 0098  	subw,s d,r[28],y;	shmem->am;	jmap PR_POLYLINE; ;			  | 41 Textured & fat polylines.
     58  02 00 2 0 0 fd00 10dc  	incw,s 0,y;		;		jmap SET_LINE_TEX; ;			  | 42 Set line texture.
     59  0a 0e 2 0 0 f900 10f2  	movw 0,y;		am->fpdp;	jmap SET_LINE_WIDTH; ;			  | 43 Set line width.
     5a  0a 17 2 0 0 deca 0372  	negw d,r[10];		shmem->am;	jmap CGI_LINE;	;			  | 44 CGI textured & fat vectors.
     5b  0a 00 2 0 0 dd7e 0397  	incw r[30],r[30];	;		jmap XF_LINE_FLT_2D; ;			| 45 
     5c  0a 00 2 0 0 dd7e 0749  	incw r[30],r[30];	;		jmap XF_LINE_FLT_3D; ;			| 46
     5d  0a 00 2 0 0 dd7e 0766  	incw r[30],r[30];	;		jmap XF_LINE_INT_3D; ;			| 47
     5e  02 17 2 0 0 961c 009a  	subw,s d, r[28], y;	shmem->am;	jmap PR_POLYTEX; ;			| 48
     5f  02 17 2 0 0 961c 01d5  	subw,s d, r[28], y;	shmem->am;	jmap PR_ROPTEX1; ;			| 49
     60  0a 00 2 0 0 7140 0242  	;			;		jmap PR_ROPTEX8; ;			| 50
     61  0a 00 2 0 0 f39d 02f3  	rolw 9, acc, acc;	;		jmap SET_TEXFRAME; ;			| 51
     62  0a 00 2 0 0 7140 02fa  	;			;		jmap SET_TEX;	;			| 52
     63  0a 00 2 0 0 c3de 032e  	add2nw 1, r[30], r[30]; ;		jmap SET_SXSYSCRN; ;			| 53
     64  0a 0e 2 0 0 f900 0338  	movw 0, y;		am->fpdp;	jmap SET_TEXOFF2D; ;			| 54
     65  0a 0e 2 0 0 f900 0342  	movw 0, y;		am->fpdp;	jmap SET_TEXOFF3D; ;			| 55
     66  0a 00 2 0 0 7140 006e  	;			;		jmap badcmd;	;			| 56
     67  0a 00 2 0 0 dd7e 03b3  	incw r[30],r[30];	;		jmap XF_LINE_INT_2D; ;			  | 57  
     68  0a 17 2 0 0 d8cb 0556  	movw d,r[11];		shmem->am;	jmap XF_PGON_INT_2D; ;			  | 58 (r[11] is nbnds)
     69  0a 17 2 0 0 d8cb 072b  	movw d,r[11];		shmem->am;	jmap PROC_PGON_INT_2D;;			  | 59 (r[11] is nbnds)
     6a  0a 17 2 0 0 deca 03fd  	negw d,r[10];		shmem->am;	jmap PROC_LINE_FLT_2D;;			  | 60	
     6b  0a 17 2 0 0 deca 03fb  	negw d,r[10];		shmem->am;	jmap PROC_LINE_INT_2D;;			  | 61
     6c  0a 17 2 0 0 deca 07bc  	negw d,r[10];		shmem->am;	jmap PROC_LINE_INT_3D;;			  | 62
     6d  0a 17 2 0 0 d8cb 0c01  	movw d,r[11];		shmem->am;	jmap PROC_PGON_INT_3D;;			  | 63
                                stop
     6e  0a 00 3 7 0 7140 006e  badcmd:	;			;		cjp,go .;	;			  | hang GP until restarted
                                |	btstw,s	7,r[0];		;		jmap EOCL;	;
     6f  1a 27 4 f 0 86df 00ff  EOCL:	andw d,r[31],acc;	0xFF->am;	push,~go;	;
     70  1a 26 d 4 0 7140 0001  	;			 1->fifo1;	loop,f1nf;	;
     71  0a 06 3 c 0 d85f 0071  	movw r[31],y;		am->fifo1;	cjp,f1f .;	;
     72  02 17 3 0 2 d8c0 0022  freebf:	movw,s d,r[0];		shmem->am;	cjp,zer vpidle;	;		shp+
     73  02 17 3 0 0 d8c1 0077  	movw,s d,r[1];		shmem->am;	cjp,zer frbf2;	;
     74  0a 2f e 0 0 7140 0005  frbf1:	;			5->shmemp;;		;
     75  0a 17 e 0 0 9f00 0000  	xorw d,r[0],r[0];	shmem->am;	;		;
     76  0a 0a 3 0 0 d840 0022  	movw r[0],y;		am->shmem;	cjp,zer vpidle;	;
     77  0a 2f e 0 0 7140 0006  frbf2:	;			6->shmemp;;		;
     78  0a 17 e 0 0 9f01 0000  	xorw d,r[1],r[1];	shmem->am;	;		;
     79  0a 0a 3 7 0 d841 0022  	movw r[1],y;		am->shmem;	cjp,go vpidle;	;
                                |	rolw 9,acc,acc;		;		jmap USEFRAME;	;
     7a  0a 27 e 0 0 c2dd 0e00  USEFRAME: andw d,acc,r[29];	0x0E00->am;	;		;
     7b  0a 27 e 0 0 9e9d 3000  	addw d,r[29],r[29];0x3000->am;	;		;
     7c  0a 00 2 0 0 dd7e 0027  	incw r[30],r[30];	;		jmap getcmd;	;
     7d  1a 06 a 4 0 f880 0000  wrfifo:	movw acc,y;		am->fifo1;	crtn,f1nf;	;
     7e  0a 00 3 7 0 7140 007d  	;			;		cjp,go wrfifo;	;
                                			| set up shmemp, fpdp, and counter prior to call
     7f  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+
     80  0a 1b 9 0 2 7140 007f  shm_to_fpr: ;			shmem->fpregh;	rpct .-1;	;		shp+
     81  1b 1b a 7 c 7140 0000  	;			shmem->fpregl;	crtn,go;	;		shp+,dp+
     82  0a 27 e 0 0 c2dc 0003  getfbaddr: andw d,acc,r[28];	0x3->am;	;		;
     83  0a 27 e 0 0 869c 0005  	addw d,r[28],acc;	=cg2_board_addr0->am;;		;
     84  0a 08 e 0 0 f880 0000  	movw acc,y;		am->brreg;	;		;
     85  1a 00 1 7 0 7140 0000  	;			;		cjs,go;		;
     86  0a 00 1 1 0 7140 008b  	;			;		cjs,neg getvalidfb;;
     87  1a 00 4 f 0 7140 0000  	;			;		push,~go;	;
     88  1a 26 d 4 0 7140 0006  	;			6->fifo1;loop,f1nf;	;			  | send 6 command to PP
     89  0a 06 3 c 0 f880 0089  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			  | send address
     8a  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;
     8b  0a 00 1 7 0 d91c 0005  getvalidfb: movw 0,r[28];	;		cjs,go cg2_board_addr0;;		  | cycle through all 4 boards until a
     8c  1a 00 a 9 0 7140 0000  	;			;		crtn,~neg;	;			  | valid address is found;  set r[28] to
     8d  0a 00 1 7 0 dd7c 0006  	incw r[28],r[28];	;		cjs,go cg2_board_addr1;;		  | correspond to this address;  return
     8e  1a 00 a 9 0 7140 0000  	;			;		crtn,~neg;	;			  | top 8 bits of address in acc
     8f  0a 00 1 7 0 dd7c 0007  	incw r[28],r[28];	;		cjs,go cg2_board_addr2;;
     90  1a 00 a 9 0 7140 0000  	;			;		crtn,~neg;	;
     91  0a 00 1 7 0 dd7c 0008  	incw r[28],r[28];	;		cjs,go cg2_board_addr3;;
     92  1a 00 a 9 0 7140 0000  	;			;		crtn,~neg;	;
     93  0a 00 3 7 0 7140 008b  	;			;		cjp,go getvalidfb;;			  | try again until succeed
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)pixrect.vp.u 1.3 86/09/12 SMI
                                |	subw,s d,r[28],y;	shmem->am;	jmap PRVEC;	;
     94  0a 17 1 8 0 f8c1 0082  PRVEC:	movw d,acc;		shmem->am;	cjs,~zer getfbaddr;;
     95  0a 00 2 0 0 7140 100c  	;			;		jmap prvec_pp;	;			| 
                                |	subw,s d,r[28],y;	shmem->am;	jmap PR_LINE;	;	
     96  0a 17 1 8 0 f8c1 0082  PR_LINE: movw d,acc;		shmem->am;	cjs,~zer getfbaddr; ;			| 
     97  0a 00 2 0 0 7140 1017  	;			;		jmap pr_line_pp; ;			| 
                                |	subw,s d,r[28],y;	shmem->am;	jmap PR_POLYLINE; ;	
                                PR_POLYLINE:	
     98  0a 17 1 8 0 f8c1 0082  	movw d,acc;		shmem->am;	cjs,~zer getfbaddr; ;			| 
     99  0a 00 2 0 0 7140 102b  	;			;		jmap pr_polyline_pp;	;			| 
                                |   Textured 2D polygons.
                                |   Defined registers must match SET_TEX.
                                |   Can't use r[0] because PR_POLYTEX needs cmd (r[0]) preserved for use by PR_POLYSOL.
                                |   	subw,s d, r[28], y;	shmem->am;	jmap PR_POLYTEX; ;			| 
     9a  0a 17 1 8 2 f8c1 0082  PR_POLYTEX: movw d, acc;	shmem->am;	cjs, ~zer getfbaddr; ;		shp+	| if r[28] has changed get new address.
     9b  0a 00 3 c 0 7140 009b  	;			;		cjp, f1f .;	;			| 
     9c  0a 26 e 0 0 7140 001b  	;			 27->fifo1;	;		;			| 
     9d  0a 00 1 7 0 7140 0322  	;			;		cjs, go stprep;	;			| see SET_TEX.
     9e  0a 06 3 c 0 d84e 009e  	movw r[14], y;		am->fifo1;	cjp, f1f .;	;			| 
     9f  0a 08 e 0 0 d84c 0000  	movw r[12], y;		am->brreg;	;		;			| 
     a0  0a 06 3 c 0 d84d 00a0  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
     a1  08 00 e 0 b d96d 0000  	movw r[13], r[11];	;		;		;			| 
     a2  0a 06 3 c 0 d84f 00a2  	movw r[15], y;		am->fifo1;	cjp, f1f .;	;			| 
     a3  12 00 4 7 0 c1eb 0000  prptld:	sub2nw,s 0, r[11], r[11];	;		push, go;	;			| 
     a4  0a 16 3 c 0 d80f 00a4  	movw r[15], acc;	shmem->fifo1;	cjp, f1f .;	;			| 
     a5  1a 00 8 0 2 dd7e 0000     	incw r[30], r[30];	;		rfct;		;		shp+	| 
     a6  0a 08 3 8 0 d84c 00a3     	movw r[12], y;		am->brreg;	cjp, ~zer prptld; ;			| 
                                |   PRPOLYSOL1_PP does jmap getcmd.
     a7  0a 17 e 0 2 d8d5 0000  	movw d, r[21];		shmem->am;	;		;		shp+	| 
     a8  0a 17 e 0 2 d8d6 0000  	movw d, r[22];		shmem->am;	;		;		shp+	| 
     a9  0a 2f e 0 0 d890 01ff  	movw acc, r[16];	511->shmemp; ;	;			| Set PP tex block ptr to PIXRECT type.
     aa  0a 2a e 0 0 7140 ffff  	;			0xffff->shmem;	;		;			| Always load texture if -1 is block ptr.
     ab  0a 27 e 0 0 9e9e 0005  	addw d, r[30], r[30];	5->am;		;		;			| 5= r[15], r[14], r[13], r[21], r[22].
     ac  08 0f 2 0 2 c3de 1055  	add2nw 1, r[30], r[18]; am->shmemp;	jmap PRPOLYSOL1_PP; ;		| 
                                |	subw,s d,r[28],y;	shmem->am;	jmap PRPOLYSOL;	;
     ad  0a 17 1 8 2 f8c1 0082  PRPOLYSOL: movw d,acc;		shmem->am;	cjs,~zer getfbaddr;;		shp+	  | if r[28] has changed, get new address
     ae  0a 00 2 0 0 d910 1055  	movw 0, r[16];	;		jmap PRPOLYSOL1_PP; ;			| Solid => no texture.
     af  2b 0e e 0 0 c1ea 0230  doscan:	sub2nw 0,r[10],r[10];	am->fpdp;	;		lmode rn,ai,pipe,fast;	  | set Weitek mode
     b0  03 2b e 0 0 d84b 0000  	movw,s r[11],y;	0->fpregl;	;		;			  | load NULL r[10] for last edge
     b1  0a 00 3 1 0 9c0b 00c3  	subw,s r[11],400,r[11];;		cjp,neg noscan;	;			  | if # of edges > 400, goto noscan
     b2  02 27 e 0 0 0190 0017  	;			23->am;		;		;			  | compute real # of edges
     b3  0a 0c 3 0 0 d8cd 00c3  	movw d,r[13];		am->fpap;	cjp,zer noscan;	;			  | if # of edges == 0, goto noscan
     b4  2a 00 e 0 0 f8e1 00a0  	movw 5,acc;		;		;		floata,la,hi;		  | convert xmin and xmax in each edge
     b5  2b 00 e 0 4 0005 00a0  	;			;		;		;		ap+	  | structure to floats; start at xmax of
     b6  28 0e e 0 c d96d 00a0  	movw r[13],r[12];	am->fpdp;	;		floata,la,hi;		  | first real edge (address 23)
     b7  2b 0c e 0 0 988d 00a0  	addw r[13],acc,r[13];	am->fpap;	;		;
     b8  2a 00 e 0 0 f8e0 00a0  	movw =fltloop,y;	;		;		floata,la,hi;
     b9  2b 08 e 0 4 00be 00a0  	;			am->brreg;	;		;		ap+
     ba  3a 00 c 0 0 7140 00a0  	;			;		ldct;		floata,la,hi;		  | 2910 R reg is fltloop
     bb  2b 0c e 0 0 988d 00a0  	addw r[13],acc,r[13];	am->fpap;	;		;
     bc  2a 00 e 0 0 f8e0 00a2  	movw =doscan1,y;	;		;		floata,la,a,hi;
     bd  2b 08 e 0 4 00c2 00a2  	;			am->brreg;	;		;		ap+	  | brreg is doscan1; pipe now full
     be  22 00 e 0 0 c1eb 00a3  fltloop: sub2nw,s 0,r[11],r[11];;		;		floata,la,a,st,hi;	  | store xmax
     bf  2b 0c e 0 6 988d 00a3  	addw r[13],acc,r[13];	am->fpap;	;		;		dp+	  | reload fpap, increment fpdp
     c0  2a 00 e 0 0 7140 00a3  	;			;		;		floata,la,a,st,hi;	  | store xmin
     c1  3b 0e 7 0 4 988c 00a3  	addw r[12],acc,r[12];	am->fpdp;	jrp,zer;	;		ap+	  | reload fpdp, increment fpap; loop until
                                											  | all edges are done
     c2  0a 00 1 7 0 7140 0c5e  doscan1: ;			;		cjs,go polyscan; ;			| call scan conversion routine
     c3  0a 00 2 0 0 7140 0027  noscan:	;			;		jmap getcmd;	;			| 
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)ropnull.vp.u 1.2 86/09/12 SMI
                                |   Null to frame buffer rops.
                                |	subw,s d, r[28], y;	shmem->am;	jmap PRROPNF;	;
     c4  0a 17 1 8 2 f8c1 0082  PRROPNF: movw d, acc;		shmem->am;	cjs, ~zer getfbaddr; ;		shp+	| 
     c5  0a 28 e 0 0 f8e1 007d  	movw  8, acc;	=wrfifo->brreg;	;		;			| 
     c6  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs, f1f;	;			| 
     c7  1a 27 1 7 0 86c0 00ff  	andw d, r[0], acc;	0xff->am;	cjs, go;	;			| low 8 bits of r[0]
     c8  0a 17 1 7 2 d8cb 010d  	movw d, r[11];		shmem->am;	cjs, go roprect; ;		shp+	| 
                                |   SetUp ()
     c9  02 27 e 0 0 96cb 0001  	andw,s d, r[11], y;	1->am;		;		;			| if (!(r[11] & PIX_DONTCLIP)) prclip ()
     ca  0a 00 1 0 0 7140 0115  	;			;		cjs, zer prclip2;;			| 
     cb  02 00 e 0 0 de46 0000  	negw,s r[6], y;	;		;		;			| if ((dst.size.x <= 0) ||
     cc  02 00 3 9 0 de47 010b  	negw,s r[7], y;	;		cjp, ~neg prrnend;;			| (dst.size.y <= 0)) return
     cd  0a 00 3 9 0 7140 010b  	;			;		cjp, ~neg prrnend;;			| 
     ce  0a 28 e 0 0 f8e1 007d  	movw 4, acc;		=wrfifo->brreg;	;		;			| 
     cf  1a 06 1 c 0 0004 0000  	;			am->fifo1;	cjs, f1f;	;			| pp command
     d0  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| dst.pos.x += dbd->cgpr_offset.x
     d1  0a 00 e 0 0 9884 0000  	addw r[4], acc, r[4];	;		;		;			| 
     d2  0a 00 e 0 0 d801 0000  	movw r[1], acc;		;		;		;			| dst.pos.y += dbd->cgpr_offset.y
     d3  0a 00 e 0 0 9885 0000  	addw r[5], acc, r[5];	;		;		;			| 
     d4  08 27 e 0 f 9ec4 000f  	andw d, r[4], r[15];	0xf->am;	;		;			| skew= cg2_prskew (dst.pos.x) == r[4] & 15
     d5  0a 07 e 0 0 c1ef 0000  	sub2nw 0, r[15], r[15];	am->am;		;		;			| r[8]= (dst.size.x + skew - 1) >> 4.
     d6  0a 00 e 0 0 8686 0000  	addw d, r[6], acc;	;		;		;			| 
     d7  0a 00 e 0 0 b808 0000  	rolw 12, acc, r[8];	;		;		;			| 
     d8  0a 27 e 0 0 9ec8 0fff  	andw d, r[8], r[8];		0xfff->am;	;		;			| 
     d9  08 00 e 0 9 97eb 0000  	rolw 11, r[11], r[9];	;		;		;			| r[9]= PIX_COLOR (r[11])= (r[11] >> 5) & 0xff.
     da  0a 27 e 0 0 9ec9 00ff  	andw d, r[9], r[9];	0xff->am;	;		;			| 
     db  0a 00 e 0 0 cc8b 0000  	sr0w r[11], r[11];		;		;		;			| r[11]= (r[11] >> 1) & 0xf
     dc  0a 27 e 0 0 9ecb 000f  	andw d, r[11], r[11];		0xf->am;	;		;			| 
                                |   SetPPMask ()
     dd  0a 00 e 0 0 d80b 0000  	movw r[11], acc;		;		;		;			| PIXOP_NEEDS_DST (r[11]<<1)= (r[11]^(r[11]<<1)) &0xa
     de  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
     df  0a 28 e 0 0 810b 007d  	xorw r[11], acc, acc;	=wrfifo->brreg;	;		;			| 
     e0  02 27 e 0 0 e2c1 000a  	andw,s d, acc, acc;	0xa->am;	;		;			| 
     e1  0a 27 e 0 0 d8d0 0006  	movw d, r[16];	6->am;		;		;			| PWRWRD->am
     e2  0a 00 3 8 0 d911 00e5  	movw 0, r[17];		;		cjp, ~zer rnrop; ;			| 
     e3  0a 27 e 0 0 d8d0 0004  	movw d, r[16];	4->am;		;		;			| PRRWRD->am
     e4  0a 00 e 0 0 dd11 0000  	incw 0, r[17];		;		;		;			| 
     e5  1a 27 1 7 0 f8c1 0006  rnrop:	movw d, acc;		6->am;		cjs, go;	;			| PWRWRD->fifo1
     e6  1a 06 1 c 0 d80b 0000  rnopf:	movw r[11], acc;		am->fifo1;	cjs, f1f;	;			| cg2_setfunction (fb, CG2_ALLROP, r[11])
     e7  1a 06 1 c 0 f901 0000  	movw 0, acc;		am->fifo1;	cjs, f1f;	;			| RRPattern= 0
     e8  0a 27 e 0 0 86c4 000f  	andw d, r[4], acc;	0xf->am;	;		;			| RRMask1= mrc_lmasktable [dst.pos.x&0xf]
     e9  0a 27 e 0 0 e281 1000  	addw d, acc, acc;	4096->am;	;		;			| 
     ea  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
     eb  08 07 e 0 e c1e6 0000  	sub2nw 0, r[6], r[14];	am->am;		;		;			| RRMask2= mrc_rmasktable
     ec  0a 00 e 0 0 8684 0000  	addw d, r[4], acc;	;		;		;			| [(dst.pos.x+dst.size.x-1)&0xf]
     ed  0a 21 e 0 0 d8cf 0000  	movw d, r[15];		vpprom->am;	;		;			| r[15]= RRMask1
     ee  0a 27 e 0 0 e2c1 000f  	andw d, acc, acc;	0xf->am;	;		;			| 
     ef  0a 27 e 0 0 e281 1010  	addw d, acc, acc;	4112->am;	;		;			| 
     f0  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
     f1  0a 00 e 0 0 7140 0000  	;			;		;		;			| 
     f2  0a 00 e 0 0 7140 0000  	;			;		;		;			| 
     f3  0a 20 3 c 0 7140 00f3  rnrmaskf:;			vpprom->fifo1;	cjp, f1f rnrmaskf; ;			| Mask2
     f4  0a 06 3 c 0 d84f 00f4  rnlmaskf:movw r[15], y;		am->fifo1;	cjp, f1f rnlmaskf;;			| Mask1
     f5  0a 06 3 c 0 d848 00f5  rnwidf1:movw r[8], y;		am->fifo1;	cjp, f1f rnwidf1;;			| cg2_setwidth (fb, CG2_ALLROP, r[8], ...)
     f6  0a 06 3 c 0 d848 00f6  rnwidf2:movw r[8], y;		am->fifo1;	cjp, f1f rnwidf2;;			| cg2_setwidth (,,, r[8])
     f7  0a 27 e 0 0 f199 0001  	rolw 8, d, acc;		1->am;		;		;			| cg2_setshift (fb, CG2_ALLROP, 0, 1)
     f8  0a 06 3 c 0 f880 00f8  rnshiftf:movw acc, y;		am->fifo1;	cjp, f1f rnshiftf;;			| cg2_setshift (fb, CG2_ALLROP, 0, 1)
     f9  0a 00 e 0 0 9189 0000  	rolw 8, r[9], acc;	;		;		;			| RRSource2= r[9] | r[9] << 8
     fa  0a 00 e 0 0 8149 0000  	orw r[9], acc, acc;	;		;		;			| 
     fb  0a 06 3 c 0 f880 00fb  rnsr2f:	movw acc, y;		am->fifo1;	cjp, f1f rnsr2f;;			| 
     fc  08 00 1 7 e d965 0125  	movw r[5], r[14];	;		cjs, go MulSWWid;;			| by= cg2_ropwordaddr (fb,0,r[4],r[5])
     fd  0a 00 1 7 0 7140 01d2  	;			;		cjs, go fbaddr;	;			| 
     fe  0a 00 e 0 0 d88a 0000  	movw acc, r[10];		;		;		;			| 
     ff  0a 00 e 0 0 9b84 0000  	rolw 13, r[4], acc;	;		;		;			| 
    100  0a 27 e 0 0 e2c1 1fff  	andw d, acc, acc;	0x1fff->am;	;		;			| 
    101  0a 00 e 0 0 988d 0000  	addw r[13], acc, r[13];;		;		;			| 	
    102  0a 27 e 0 0 86aa 0020  	addcw d, r[10], acc;	0x20->am;	;		;			| RopFB->am
    103  0a 06 3 c 0 d84d 0103  rnalof:	movw r[13], y;		am->fifo1;	cjp, f1f rnalof;;			| 
    104  0a 00 e 0 0 988c 0000  	addw r[12], acc, r[12];;		;		;			| 
    105  0a 06 3 c 0 d84c 0105  rnahif:	movw r[12], y;		am->fifo1;	cjp, f1f rnahif;;			| 
    106  0a 06 3 c 0 d847 0106  rnrechtf:movw r[7], y;		am->fifo1;	cjp, f1f rnrechtf;;			| 
    107  0a 06 3 c 0 d849 0107  rncolorf:movw r[9], y;		am->fifo1;	cjp, f1f rncolorf;;			| 
    108  0a 06 3 c 0 d848 0108  rnwf:	movw r[8], y;		am->fifo1;	cjp, f1f rnwf;	;			| 
    109  0a 06 3 c 0 d851 0109  rnnodstf:movw r[17], y;		am->fifo1;	cjp, f1f rnnodstf;;			| 
    10a  0a 06 3 c 0 d850 010a  rnropmf:movw r[16], y;	am->fifo1;	cjp, f1f rnropmf;;			| 
    10b  0a 27 e 0 0 9e9e 000b  prrnend:addw d, r[30], r[30];	11->am;		;		;			| 
    10c  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;			| 
    10d  0a 17 e 0 2 d8c0 0000  roprect: movw d, r[0];		shmem->am;	;		;		shp+	| 
    10e  0a 17 e 0 2 d8c1 0000  	movw d, r[1];		shmem->am;	;		;		shp+	| 
    10f  0a 17 e 0 2 d8c2 0000  	movw d, r[2];		shmem->am;	;		;		shp+	| 
    110  0a 17 e 0 2 d8c3 0000  	movw d, r[3];		shmem->am;	;		;		shp+	| 
    111  0a 17 e 0 2 d8c4 0000  	movw d, r[4];		shmem->am;	;		;		shp+	| 
    112  0a 17 e 0 2 d8c5 0000  	movw d, r[5];		shmem->am;	;		;		shp+	| 
    113  0a 17 e 0 2 d8c6 0000  	movw d, r[6];		shmem->am;	;		;		shp+	| 
    114  1a 17 a 7 2 d8c7 0000  	movw d, r[7];		shmem->am;	crtn, go;	;		shp+	| 
    115  02 07 e 0 0 d844 0000  prclip2:movw,s r[4], y;		am->am;		;		;			| 
    116  02 00 3 9 0 d845 0119  	movw,s r[5], y;		;		cjp, ~neg prclip2a;;			| 
    117  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| 
    118  0a 00 e 0 0 d904 0000  	movw 0, r[4];		;		;		;			| 
    119  0a 07 3 9 0 d845 011c  prclip2a:movw r[5], y;		am->am;		cjp, ~neg prclip2b;;			| 
    11a  0a 00 e 0 0 9e87 0000  	addw d, r[7], r[7];	;		;		;			| 
    11b  0a 00 e 0 0 d905 0000  	movw 0, r[5];		;		;		;			| 
    11c  0a 07 e 0 0 d844 0000  prclip2b:movw r[4], y;		am->am;		;		;			| 
    11d  0a 00 e 0 0 8602 0000  	subw d, r[2], acc;	;		;		;			| 
    11e  02 00 e 0 0 9006 0000  	subw,s r[6], acc, y;	;		;		;			| 
    11f  0a 07 3 9 0 d845 0121  	movw r[5], y;		am->am;		cjp, ~neg prclip2c;;			| 
    120  0a 00 e 0 0 d886 0000  	movw acc, r[6];	;		;		;			| 
    121  0a 00 e 0 0 8603 0000  prclip2c:subw d, r[3], acc;	;		;		;			| 
    122  02 00 e 0 0 9007 0000  	subw,s r[7], acc, y;	;		;		;			| 
    123  1a 00 a 9 0 7140 0000  	;			;		crtn, ~neg;	;			| 
    124  1a 00 a 7 0 d887 0000  	movw acc, r[7];	;		crtn, go;	;			| 
                                |   Multiply by SWWidth (SWidth/8).  Number comes in r[14]
                                |   and goes out in r[0] (low) and r[1] (high).
                                |   Must save accumulator.
                                |   y * 144 = y * 128 + y * 16 = y << 7 + y << 4 = (y << 3 + y) << 4
                                |   y < (1 << 10).
                                |   y << 3 needs no masking because y is < 1024.
    125  0a 00 e 0 0 878e 0000  MulSWWid:rolw 3, r[14], acc;;		;		;			| y << 3.  Highbits 0.
    126  0a 00 e 0 0 808e 0000  	addw r[14], acc, acc;;		;		;			| y << 3 + y.
    127  0a 00 e 0 0 a80c 0000  	rolw 4, acc, r[12];	;		;		;			| (y << 3 + y) << 4.
    128  08 27 e 0 d 9ecc fff0  	andw d, r[12], r[13];	0xfff0->am;	;		;			| 
    129  1a 27 a 7 0 9ecc 000f  	andw d, r[12], r[12];	0xf->am;	crtn, go;	;			| 
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)ropfb.vp.u 1.2 86/09/12 SMI
                                |   Frame buffer to frame buffer rops.
                                |	subw,s d, r[28], y;	shmem->am;	jmap PRROPFF;	;
    12a  0a 17 1 8 2 f8c1 0082  PRROPFF: movw d, acc;		shmem->am;	cjs, ~zer getfbaddr; ;		shp+	| 
    12b  0a 28 e 0 0 f8e1 007d  	movw  8, acc;	=wrfifo->brreg;	;		;			| 
    12c  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs, f1f;	;			| 
    12d  1a 27 1 7 0 86c0 00ff  	andw d, r[0], acc;	0xff->am;	cjs, go;	;			| low 8 bits of r[0]
    12e  0a 17 1 7 2 d8d8 010d  	movw d, r[24];		shmem->am;	cjs, go roprect; ;		shp+	| 
    12f  0a 17 e 0 2 d8c8 0000  	movw d, r[8];		shmem->am;	;		;		shp+	| 
    130  0a 17 e 0 2 d8c9 0000  	movw d, r[9];		shmem->am;	;		;		shp+	| 
    131  0a 17 e 0 2 d8ca 0000  	movw d, r[10];		shmem->am;	;		;		shp+	| 
    132  0a 17 e 0 2 d8cb 0000  	movw d, r[11];		shmem->am;	;		;		shp+	| 
    133  0a 17 e 0 2 d8d2 0000  	movw d, r[18];		shmem->am;	;		;		shp+	| 
    134  0a 17 e 0 2 d8d3 0000  	movw d, r[19];		shmem->am;	;		;		shp+	| 
                                |   SetUp ()
    135  02 27 e 0 0 9738 fffe  	norw,s d, r[24], y;	0xfffe->am;	;		;			| if (!(r[24] & PIX_DONTCLIP)) prclip ()
    136  0a 00 1 8 0 7140 01ae  	;			;		cjs, ~zer prclip;;			| 
    137  02 00 e 0 0 de46 0000  	negw,s r[6], y;	;		;		;			| if ((dst.size.x <= 0)
    138  02 00 3 9 0 de47 019e  	negw,s r[7], y;	;		cjp, ~neg prrfend;;			| (dst.size.y <= 0)) return
    139  0a 00 3 9 0 7140 019e  	;			;		cjp, ~neg prrfend;;			| 
    13a  0a 28 e 0 0 f8e1 007d  	movw 5, acc;		=wrfifo->brreg;	;		;			| 
    13b  1a 06 1 c 0 0005 0000  	;			am->fifo1;	cjs, f1f;	;			| pp command
    13c  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| dst.pos.x += dbd->cgpr_offset.x
    13d  0a 00 e 0 0 9884 0000  	addw r[4], acc, r[4];	;		;		;			| 
    13e  0a 00 e 0 0 d801 0000  	movw r[1], acc;		;		;		;			| dst.pos.y += dbd->cgpr_offset.y
    13f  0a 00 e 0 0 9885 0000  	addw r[5], acc, r[5];	;		;		;			| 
    140  08 27 e 0 f 9ec4 000f  	andw d, r[4], r[15];	0xf->am;	;		;			| skew= cg2_prskew (dst.pos.x) == r[4] & 15
    141  0a 07 e 0 0 c1ef 0000  	sub2nw 0, r[15], r[15];	am->am;		;		;			| r[20]= (dst.size.x + skew - 1) >> 4.
    142  0a 00 e 0 0 8686 0000  	addw d, r[6], acc;	;		;		;			| 
    143  0a 00 e 0 0 b814 0000  	rolw 12, acc, r[20];	;		;		;			| 
    144  0a 27 e 0 0 9ed4 0fff  	andw d, r[20], r[20];		0xfff->am;	;		;			| 
    145  0a 00 e 0 0 cc98 0000  	sr0w r[24], r[24];		;		;		;			| r[24]= (r[24] >> 1) & 0xf
    146  0a 27 e 0 0 9ed8 000f  	andw d, r[24], r[24];		0xf->am;	;		;			| 
                                |   End SetUp ()
    147  0a 00 e 0 0 d808 0000  	movw r[8], acc;		;		;		;			| src.pos.x += sbd->cgpr_offset.x
    148  0a 00 e 0 0 9892 0000  	addw r[18], acc, r[18];	;		;		;			| 
    149  0a 00 e 0 0 d809 0000  	movw r[9], acc;		;		;		;			| src.pos.y += sbd->cgpr_offset.y
    14a  0a 00 e 0 0 9893 0000  	addw r[19], acc, r[19];	;		;		;			| 
    14b  0a 00 e 0 0 d804 0000  	movw r[4], acc;		;		;		;			| r[22]= rop_direction ()
    14c  0a 00 e 0 0 8080 0000  	addw r[0], acc, acc;	;		;		;			| 
    14d  0a 00 e 0 0 8012 0000  	subw r[18], acc, acc;	;		;		;			| 
    14e  02 00 e 0 0 8008 0000  	subw,s r[8], acc, acc;	;		;		;			| 
    14f  0a 00 3 9 0 d916 0151  	movw 0, r[22];		;		cjp, ~neg rfdir;;			| 
    150  0a 00 e 0 0 c396 0000  	mov2nw 1, r[22];		;		;		;			| 
    151  0a 00 e 0 0 d805 0000  rfdir:	movw r[5], acc;		;		;		;			| 
    152  0a 00 e 0 0 8081 0000  	addw r[1], acc, acc;	;		;		;			| 
    153  0a 00 e 0 0 8013 0000  	subw r[19], acc, acc;	;		;		;			| 
    154  02 00 e 0 0 8009 0000  	subw,s r[9], acc, acc;	;		;		;			| 
    155  0a 00 3 1 0 dd76 015a  	incw r[22], r[22];		;		cjp, neg rfsetpp;;			| if (rop_isdown (r[22]))
    156  0a 00 e 0 0 c1f6 0000  	sub2nw 0, r[22], r[22];	;		;		;			| 
    157  0a 27 e 0 0 8607 0001  	subw d, r[7], acc;	1->am;		;		;			| src.pos.y += dst.size.y - 1
    158  0a 00 e 0 0 9893 0000  	addw r[19], acc, r[19];	;		;		;			| 
    159  0a 00 e 0 0 9885 0000  	addw r[5], acc, r[5];	;		;		;			| dst.pos.y += dst.size.y - 1
                                |   SetPPMask () (actually no longer sets per plane mask).
    15a  0a 00 e 0 0 d818 0000  rfsetpp:movw r[24], acc;		;		;		;			| PIXOP_NEEDS_DST (r[24]<<1)= (r[24]^(r[24]<<1)) &0xa
    15b  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
    15c  0a 28 e 0 0 8118 007d  	xorw r[24], acc, acc;	=wrfifo->brreg;	;		;			| 
    15d  02 27 e 0 0 e2c1 000a  	andw,s d, acc, acc;	0xa->am;	;		;			| 
    15e  0a 27 e 0 0 d8d0 0006  	movw d, r[16];	6->am;		;		;			| PWRWRD->am
    15f  0a 00 3 8 0 d911 0162  	movw 0, r[17];		;		cjp, ~zer rfrop; ;			| 
    160  0a 27 e 0 0 d8d0 0004  	movw d, r[16];	4->am;		;		;			| PRRWRD->am
    161  0a 00 e 0 0 dd11 0000  	incw 0, r[17];		;		;		;			| 
    162  1a 27 1 7 0 f8c1 0006  rfrop:	movw d, acc;		6->am;		cjs, go;	;			| PWRWRD->fifo1
    163  1a 00 1 7 0 d818 0000  	movw r[24], acc;		;		cjs, go;	;			| cg2_setfunction (fb, CG2_ALLROP, r[24])
    164  1a 06 1 c 0 f901 0000  	movw 0, acc;		am->fifo1;	cjs, f1f;	;			| RRPattern= 0
    165  02 27 e 0 0 e3f6 0001  	btstw,s 1, r[22];		1->am;		;		;			| if (rop_isright (r[22]) && r[20])
    166  02 00 3 8 0 d854 0178  	movw,s r[20], y;		;		cjp, ~zer rfleft;;			| 
    167  0a 00 3 0 0 8606 0178  	subw d, r[6], acc;	;		cjp, zer rfleft;;			| dst.size.x - 1
    168  0a 00 e 0 0 9892 0000  	addw r[18], acc, r[18];	;		;		;			| src.pos.x += dst.size.x - 1
    169  0a 00 e 0 0 9884 0000  	addw r[4], acc, r[4];	;		;		;			| dst.pos.x += dst.size.x - 1
    16a  0a 27 e 0 0 8606 0001  	subw d, r[6], acc;	1->am;		;		;			| RRMask2= mrc_lmasktable[(dst.size.x)&0xf]
    16b  0a 00 e 0 0 8044 0000  	rsubw r[4], acc, acc;	;		;		;			| 
    16c  0a 27 e 0 0 e2c1 000f  	andw d, acc, acc;	0xf->am;	;		;			| 
    16d  0a 27 e 0 0 e281 1000  	addw d, acc, acc;	4096->am;	;		;			| 
    16e  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
    16f  0a 00 3 c 0 7140 016f  rfmask2:;			;		cjp, f1f rfmask2; ;			| 
    170  0a 00 e 0 0 7140 0000  	;			;		;		;			| 
    171  0a 20 e 0 0 7140 0000  	;			vpprom->fifo1;	;		;			| 
    172  0a 27 e 0 0 d8ce 1010  	movw d, r[14];		4112->am;	;		;			| SKEW (0, mrc_rmasktable)
    173  0a 00 1 7 0 d90f 01a0  	movw 0, r[15];		;		cjs, go rfskew;	;			| 
    174  02 00 e 0 0 900f 0000  	subw,s r[15], acc, y;	;		;		;			| r[23]= srcskew <= skew
    175  0a 00 3 9 0 dd17 0177  	incw 0, r[23];		;		cjp, ~neg rfprim1;;			| 
    176  0a 00 e 0 0 d917 0000  	movw 0, r[23];		;		;		;			| 
    177  0a 00 3 7 0 7140 0185  rfprim1:;			;		cjp, go rfsrc2;	;			| 
    178  0a 27 e 0 0 8606 0001  rfleft:	subw d, r[6], acc;	1->am;		;		;			| RRMask2= mrc_rmasktable[(dst.size.x)&0xf]
    179  0a 00 e 0 0 8084 0000  	addw r[4], acc, acc;	;		;		;			| 
    17a  0a 27 e 0 0 e2c1 000f  	andw d, acc, acc;	0xf->am;	;		;			| 
    17b  0a 27 e 0 0 e281 1010  	addw d, acc, acc;	4112->am;	;		;			| 
    17c  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
    17d  0a 00 3 c 0 7140 017d  rfmask2a:;			;		cjp, f1f rfmask2a; ;			| 
    17e  0a 00 e 0 0 7140 0000  	;			;		;		;			| 
    17f  0a 20 e 0 0 7140 0000  	;			vpprom->fifo1;	;		;			| 
    180  0a 27 e 0 0 d8ce 1000  	movw d, r[14];		4096->am;	;		;			| SKEW (1, mrc_lmasktable)
    181  0a 00 1 7 0 dd0f 01a0  	incw 0, r[15];		;		cjs, go rfskew;	;			| 
    182  02 00 e 0 0 904f 0000  	rsubw,s r[15], acc, y;	;		;		;			| 
    183  0a 00 3 9 0 dd17 0185  	incw 0, r[23];		;		cjp, ~neg rfsrc2; ;			| 
    184  0a 00 e 0 0 d917 0000  	movw 0, r[23];		;		;		;			| 
    185  0a 06 3 c 0 f900 0185  rfsrc2:	movw 0, y;		am->fifo1;	cjp, f1f rfsrc2; ;			| dummy src2
    186  0a 00 e 0 0 d813 0000  	movw r[19], acc;		;		;		;			| 
    187  0a 00 1 7 0 d88e 0125  	movw acc, r[14];	;		cjs, go MulSWWid;;			| sy= cg2_ropwordaddr (fb,0,r[18],r[19])
    188  0a 00 1 7 0 7140 01d2  	;			;		cjs, go fbaddr;	;			| 
    189  0a 00 e 0 0 d895 0000  	movw acc, r[21];		;		;		;			| 
    18a  0a 00 e 0 0 9b92 0000  	rolw 13, r[18], acc;	;		;		;			| 
    18b  0a 27 e 0 0 e2c1 1fff  	andw d, acc, acc;	0x1fff->am;	;		;			| 
    18c  0a 00 e 0 0 988d 0000  	addw r[13], acc, r[13];;		;		;			| 
    18d  0a 27 e 0 0 86b5 0020  	addcw d, r[21], acc;	0x20->am;	;		;			| RopFB->am
    18e  0a 06 3 c 0 d84d 018e  rfalof0:movw r[13], y;		am->fifo1;	cjp, f1f rfalof0;;			| 
    18f  0a 00 e 0 0 988c 0000  	addw r[12], acc, r[12];;		;		;			| 
    190  0a 06 3 c 0 d84c 0190  rfahif0:movw r[12], y;		am->fifo1;	cjp, f1f rfahif0;;			| 
    191  08 00 1 7 e d965 0125  	movw r[5], r[14];	;		cjs, go MulSWWid;;			| by= cg2_ropwordaddr (fb,0,r[4],r[5])
    192  0a 00 e 0 0 9b84 0000  	rolw 13, r[4], acc;	;		;		;			| 
    193  0a 27 e 0 0 e2c1 1fff  	andw d, acc, acc;	0x1fff->am;	;		;			| 
    194  0a 00 e 0 0 988d 0000  	addw r[13], acc, r[13];;		;		;			| 
    195  0a 27 e 0 0 86b5 0020  	addcw d, r[21], acc;	0x20->am;	;		;			| RopFB->am
    196  0a 06 3 c 0 d84d 0196  rfalof:	movw r[13], y;		am->fifo1;	cjp, f1f rfalof;;			| 
    197  0a 00 e 0 0 988c 0000  	addw r[12], acc, r[12];;		;		;			| 
    198  0a 06 3 c 0 d84c 0198  rfahif:	movw r[12], y;		am->fifo1;	cjp, f1f rfahif;;			| 
    199  0a 06 3 c 0 d854 0199  rfwf:	movw r[20], y;		am->fifo1;	cjp, f1f rfwf;	;			| 
    19a  0a 06 3 c 0 d850 019a  rfropmf:movw r[16], y;	am->fifo1;	cjp, f1f rfropmf;;			| 
    19b  0a 06 3 c 0 d847 019b  rfrechtf:movw r[7], y;		am->fifo1;	cjp, f1f rfrechtf;;			| 
    19c  0a 06 3 c 0 d856 019c  rfdirf:	movw r[22], y;		am->fifo1;	cjp, f1f rfdirf;;			| 
    19d  0a 06 3 c 0 d857 019d  rfprime:movw r[23], y;		am->fifo1;	cjp, f1f rfprime;;			| 
    19e  0a 27 e 0 0 9e9e 0011  prrfend:addw d, r[30], r[30];	17->am;		;		;			| 
    19f  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;			| 
                                |   SKEW (a,b)
                                |   (b) masktable address in r[14].  (a) is 0 or 1 in r[15].
                                |   Returns srcskew in r[15], and skew in acc.  Loads RRMask1 into fifo.
    1a0  0a 27 e 0 0 86c4 000f  rfskew:	andw d, r[4], acc;	0xf->am;	;		;			| skew= cg2_prskew (dst.pos.x)
    1a1  0a 09 e 0 0 908e 0000  	addw r[14], acc, y;	am->vppromp;	;		;			| *(b + (dst.pos.x & 0xf))
    1a2  08 00 e 0 0 91ef 0000  	rolw 8, r[15], r[0];	;		;		;			| Reuse r[24] reg.
    1a3  0a 07 e 0 0 d852 0000  	movw r[18], y;		am->am;		;		;			| 
    1a4  0a 00 e 0 0 d8ce 0000  	movw d, r[14];		;		;		;			| 
    1a5  08 27 e 0 f 9ece 000f  	andw d, r[14], r[15];	0xf->am;	;		;			| srcskew= cg2_prskew (src.pos.x).
    1a6  08 00 e 0 e 980f 0000  	subw r[15], acc, r[14];	;		;		;			| cg2_setshift (,, (skew - srcskew)&0xf, a)
    1a7  0a 00 e 0 0 9ece 0000  	andw d, r[14], r[14];	;		;		;			| 
    1a8  0a 20 3 c 0 7140 01a8  rfskew3:;			vpprom->fifo1;	cjp, f1f rfskew3;;			| RRMask1
    1a9  0a 06 3 c 0 d854 01a9  rfwidf1:movw r[20], y;		am->fifo1;	cjp, f1f rfwidf1;;			| cg2_setwidth (fb, CG2_ALLROP, r[20], ...)
    1aa  0a 06 3 c 0 d854 01aa  rfwidf2:movw r[20], y;		am->fifo1;	cjp, f1f rfwidf2;;			| cg2_setwidth (,,, r[20])
    1ab  0a 07 e 0 0 d84e 0000  	movw r[14], y;		am->am;		;		;			| 
    1ac  0a 06 3 c 0 9740 01ac  rfskew1:orw d, r[0], y;		am->fifo1;	cjp, f1f rfskew1;;			| RRShift
    1ad  1a 00 a 7 0 7140 0000  	;			;		crtn, go;	;			| 
                                |   First:  pr_clip1 (dstp, &dstp->size, srcp)
    1ae  02 07 e 0 0 d844 0000  prclip:	movw,s r[4], y;		am->am;		;		;			| if ((pra)->pos.x < 0)
    1af  02 00 3 9 0 d845 01b3  	movw,s r[5], y;		;		cjp, ~neg prclipa;;			| if ((pra)->pos.y < 0)
    1b0  0a 00 e 0 0 9e12 0000  	subw d, r[18], r[18];	;		;		;			| (prb)->pos.x -= (pra)->pos.x
    1b1  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| (size)->x += (pra)->pos.x
    1b2  0a 00 e 0 0 d904 0000  	movw 0, r[4];		;		;		;			| (pra)->pos.x = 0
    1b3  0a 07 3 9 0 d845 01b7  prclipa:movw r[5], y;		am->am;		cjp, ~neg prclipb;;			| 
    1b4  0a 00 e 0 0 9e13 0000  	subw d, r[19], r[19];	;		;		;			| (prb)->pos.y -= (prb)->pos.y
    1b5  0a 00 e 0 0 9e87 0000  	addw d, r[7], r[7];	;		;		;			| (size)->y += (pra)->pos.y
    1b6  0a 00 e 0 0 d905 0000  	movw 0, r[5];		;		;		;			| (pra)->pos.y = 0
                                |   The statement:  if ((a+b) > c) b= c-a; is equivalent to:  if (b > (c-a)) b= c-a;
                                |   Notice the common c-a expression.  The rest of the prclip code has been reordered for this.
    1b7  0a 07 e 0 0 d844 0000  prclipb:movw r[4], y;		am->am;		;		;			| 
    1b8  0a 00 e 0 0 8602 0000  	subw d, r[2], acc;	;		;		;			| (pra)->pr->pr_size.x - (pra)->pos.x
    1b9  02 00 e 0 0 9006 0000  	subw,s r[6], acc, y;	;		;		;			| < (size)->x.  { (c-a) < b }
    1ba  0a 07 3 9 0 d845 01bc  	movw r[5], y;		am->am;		cjp, ~neg prclipc;;			| 
    1bb  0a 00 e 0 0 d886 0000  	movw acc, r[6];	;		;		;			| b= c-a
    1bc  0a 00 e 0 0 8603 0000  prclipc:subw d, r[3], acc;	;		;		;			| (pra)->pr->pr_size.y - (pra)->pos.y
    1bd  02 00 e 0 0 9007 0000  	subw,s r[7], acc, y;	;		;		;			| < (size)->y.  { (c-a) < b }
    1be  0a 00 3 9 0 7140 01c0  	;			;		cjp, ~neg prclip1;;			| 
    1bf  0a 00 e 0 0 d887 0000  	movw acc, r[7];	;		;		;			| b= c-a
                                |   Second:  pr_clip1 (srcp, &dstp->size, dstp)
    1c0  02 07 e 0 0 d852 0000  prclip1:movw,s r[18], y;		am->am;		;		;			| if ((pra)->pos.x < 0)
    1c1  02 00 3 9 0 d853 01c5  	movw,s r[19], y;		;		cjp, ~neg prclip1a;;			| if ((pra)->pos.y < 0)
    1c2  0a 00 e 0 0 9e04 0000  	subw d, r[4], r[4];	;		;		;			| (prb)->pos.x -= (pra)->pos.x
    1c3  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| (size)->x += (pra)->pos.x
    1c4  0a 00 e 0 0 d912 0000  	movw 0, r[18];		;		;		;			| (pra)->pos.x = 0
    1c5  0a 07 3 9 0 d853 01c9  prclip1a:movw r[19], y;		am->am;		cjp, ~neg prclip1b;;			| 
    1c6  0a 00 e 0 0 9e05 0000  	subw d, r[5], r[5];	;		;		;			| (prb)->pos.y -= (prb)->pos.y
    1c7  0a 00 e 0 0 9e87 0000  	addw d, r[7], r[7];	;		;		;			| (size)->y += (pra)->pos.y
    1c8  0a 00 e 0 0 d913 0000  	movw 0, r[19];		;		;		;			| (pra)->pos.y = 0
                                |   The statement:  if ((a+b) > c) b= c-a; is equivalent to:  if (b > (c-a)) b= c-a;
                                |   Notice the common c-a expression.  The rest of the prclip code has been reordered for this.
    1c9  0a 07 e 0 0 d852 0000  prclip1b:movw r[18], y;		am->am;		;		;			| 
    1ca  0a 00 e 0 0 860a 0000  	subw d, r[10], acc;	;		;		;			| (pra)->pr->pr_size.x - (pra)->pos.x
    1cb  02 00 e 0 0 9006 0000  	subw,s r[6], acc, y;	;		;		;			| < (size)->x.  { (c-a) < b }
    1cc  0a 07 3 9 0 d853 01ce  	movw r[19], y;		am->am;		cjp, ~neg prclip1c;;			| 
    1cd  0a 00 e 0 0 d886 0000  	movw acc, r[6];	;		;		;			| b= c-a
    1ce  0a 00 e 0 0 860b 0000  prclip1c:subw d, r[11], acc;	;		;		;			| (pra)->pr->pr_size.y - (pra)->pos.y
    1cf  02 00 e 0 0 9007 0000  	subw,s r[7], acc, y;	;		;		;			| < (size)->y.  { (c-a) < b }
    1d0  1a 00 a 9 0 7140 0000  	;			;		crtn, ~neg;	;			| 
    1d1  1a 00 a 7 0 d887 0000  	movw acc, r[7];	;		crtn, go;	;			| b= c-a
    1d2  0a 27 e 0 0 869c 0005  fbaddr:	addw d,r[28],acc;	=cg2_board_addr0->am; ;		;			| 
    1d3  0a 08 e 0 0 f880 0000  	movw acc,y;		am->brreg;	;		;
    1d4  1a 00 3 7 0 7140 0000  	;			;		cjp, go;	;			| cg2_board_addrx will do crtn, go.
                                | Copyright (c) 1986 by Sun Microsystems, Inc.
                                |  @(#)roptex.vp.u 1.2 86/09/12 SMI
                                |   Textured area rasterops:  pr_replrop ().
                                |   Depth, Width, Height, Words, Rows must match SET_TEX.
                                |	subw,s d, r[28], y;	shmem->am;	jmap PR_ROPTEX1; ;			|
    1d5  0a 00 2 0 0 dd7e 0027  PR_ROPTEX1: incw r[30], r[30]; ;		jmap getcmd;	;			| Go through PR_ROPTEX8 to rt1setup.
                                |   ELIMINATE and modify main.vp.u as well.
                                |   Follows code for cg2_rop.c, case 2d.2, memory to cg2.
                                |   Do texture in vertical strips maximum width of a strip is width of texture.  PP gets one strip at time.
                                |   A strip on the left or the right can be less wide.
                                rt1setup: 
    1d6  02 00 e 0 0 d808 0000  	movw,s r[8], acc;		;		;		;			| (r[8] mod r[14]).
    1d7  02 00 3 1 0 808e 01d7  	addw,s r[14], acc, acc; ;		cjp, neg .;	;			| r[8] might be negative.
    1d8  02 00 3 9 0 800e 01d8  	subw,s r[14], acc, acc; ;		cjp, ~neg .;	;			| 
    1d9  0a 00 e 0 0 808e 0000  	addw r[14], acc, acc;	;		;		;			| 
    1da  08 07 1 7 8 988e 0223  	addw r[14], acc, r[8];	am->am;		cjs, go rt1stripw; ;			| cjs Calculate strip width.
    1db  02 00 e 0 0 d809 0000  	movw,s r[9], acc;		;		;		;			| (r[9] mod r[13]).
    1dc  02 00 3 1 0 808d 01dc  	addw,s r[13], acc, acc; ;		cjp, neg .;	;			| r[9] might be negative.
    1dd  02 00 3 9 0 800d 01dd  	subw,s r[13], acc, acc; ;		cjp, ~neg .;	;			| 
    1de  0a 00 e 0 0 808d 0000  	addw r[13], acc, acc;	;		;		;			| 
    1df  08 00 e 0 9 988d 0000  	addw r[13], acc, r[9];	;		;		;			| 
    1e0  0a 28 e 0 0 f8e1 007d  	movw 2, acc;	=wrfifo->brreg;	;		;			| 
    1e1  1a 06 1 c 0 0002 0000  	;			am->fifo1;	cjs, f1f;	;			| pp command
    1e2  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| dst.pos.x += dbd->cgpr_offset.x
    1e3  0a 00 e 0 0 9884 0000  	addw r[4], acc, r[4];	;		;		;			| Now have screen coord r[4].
    1e4  0a 00 e 0 0 d801 0000  	movw r[1], acc;		;		;		;			| dst.pos.y += dbd->cgpr_offset.y
    1e5  0a 00 1 7 0 9885 0228  	addw r[5], acc, r[5];	;		cjs, go rt1w;	;			| Calculate r[22], r[20], and r[11].
    1e6  08 00 e 0 2 97f0 0000  	rolw 11, r[16], r[18]; ;		;		;			| r[18]= PIX_COLOR (r[17]) = (r[17] >> 5) & 0xff
    1e7  02 27 e 0 0 9ed2 00ff  	andw,s d, r[18], r[18];	0xff->am;	;		;			| 
    1e8  08 00 3 8 1 cc90 01ea  	sr0w r[16], r[17];	;		cjp, ~zer .+2;	;			| r[17]= (r[17] >> 1) & 0xf
    1e9  0a 27 e 0 0 d8d2 00ff  	movw d, r[18];		0xff->am;	;		;			| if (r[18] == 0) r[18]= -1
    1ea  0a 27 e 0 0 9ed1 000f  	andw d, r[17], r[17];		0xf->am;	;		;			| 
    1eb  0a 00 e 0 0 d811 0000  	movw r[17], acc;		;		;		;			| PIXOP_NEEDS_DST (r[17]<<1)= (r[17]^(r[17]<<1)) &0xa
    1ec  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
    1ed  0a 28 e 0 0 8111 007d  	xorw r[17], acc, acc;	=wrfifo->brreg;	;		;			| 
    1ee  02 27 e 0 0 e2c1 000a  	andw,s d, acc, acc;	0xa->am;	;		;			| r[19] depends on r[23]
    1ef  0a 27 e 0 0 d8d3 0002  	movw d, r[19];	2->am;		;		;			| PWWWRD->am
    1f0  0a 00 3 8 0 d917 01f3  	movw 0, r[23];		;		cjp, ~zer rt1rop; ;			| r[23]= 0
    1f1  0a 00 e 0 0 dd17 0000  	incw 0, r[23];		;		;		;			| r[23]= 1
    1f2  0a 27 e 0 0 d8d3 0000  	movw d, r[19];	0->am;		;		;			| PRWWRD->am
    1f3  1a 27 1 7 0 f8c1 0002  rt1rop:	movw d, acc;		2->am;		cjs, go;	;			| PWWWRD->fifo1.  First of pp ropreg values.
                                | cg2_setfunction (fb, CG2_ALLROP, r[17])
    1f4  1a 00 1 7 0 8991 0000  	rolw 4, r[17], acc;	;		cjs, go;	;			| r[17] & pattern mask.
    1f5  1a 06 1 c 0 f901 0000  	movw 0, acc;		am->fifo1;	cjs, f1f;	;			| RRPattern= 0
    1f6  0a 00 1 7 0 7140 0234  	;			;		cjs, go rt1mask; ;			| Set right and left mask and send to pp.
    1f7  0a 06 3 c 0 d854 01f7  	movw r[20], y;		am->fifo1;	cjp, f1f .;	;			| cg2_setwidth (fb, CG2_ALLROP, r[20], ...)
    1f8  0a 06 3 c 0 d854 01f8  	movw r[20], y;		am->fifo1;	cjp, f1f .;	;			| cg2_setwidth (,,, r[20])
    1f9  0a 06 3 c 0 d84b 01f9  	movw r[11], y;		am->fifo1;	cjp, f1f .;	;			| RRShift
    1fa  0a 06 3 c 0 f900 01fa  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Dummy src2
                                |   End of pp ropreg subroutine fifo values.
    1fb  0a 06 3 c 0 dc4c 01fb  	incw r[12], y;		am->fifo1;	cjp, f1f .;	;			| texture width in r[12].
    1fc  08 00 e 0 f d96c 0000  	movw r[12], r[15];	;		;		;			| Copy r[12] before it is clobbered.
    1fd  0a 06 3 c 0 d84d 01fd  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| texture height.
    1fe  0a 06 3 c 0 d853 01fe  	movw r[19], y;	am->fifo1;	cjp, f1f .;	;			| 
    1ff  0a 06 3 c 0 d847 01ff  	movw r[7], y;		am->fifo1;	cjp, f1f .;	;			| 
    200  0a 06 3 c 0 d857 0200  	movw r[23], y;		am->fifo1;	cjp, f1f .;	;			| 
    201  0a 06 3 c 0 d852 0201  	movw r[18], y;		am->fifo1;	cjp, f1f .;	;			| 
    202  0a 06 3 c 0 d854 0202  	movw r[20], y;		am->fifo1;	cjp, f1f .;	;			| 
                                |   Loop back to here.
    203  0a 06 3 c 0 d856 0203  rt1strip: movw r[22], y;	am->fifo1;	cjp, f1f .;	;			| 
    204  0a 00 e 0 0 dc0f 0000  	incw r[15], acc;	;		;		;			| src= (r[12] + 1) * r[9] + (r[8] >> 4)
    205  08 00 e 0 a d964 0000  	movw r[4], r[10];	;		;		;			| move r[4] out of the way of multiply.
    206  08 00 1 7 2 d969 0fce  	movw r[9], r[2];		;		cjs, go multiply; ;			| 
    207  0a 00 e 0 0 9988 0000  	rolw 12, r[8], acc;	;		;		;			| 
    208  0a 27 e 0 0 e2c1 0fff  	andw d, acc, acc;	0xfff->am;	;		;			| 
    209  0a 06 3 c 0 9080 0209  	addw r[0], acc, y;	am->fifo1;	cjp, f1f .;	;			| Src address.
                                |	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| DEBUG.  Dummy src address.
    20a  08 00 1 7 4 d96a 01d2  	movw r[10], r[4];	;		cjs, go fbaddr;	;			| r[4] was saved in r[10] before multiply
    20b  0a 00 e 0 0 d895 0000  	movw acc, r[21];		;		;		;			| 
    20c  08 00 1 7 e d965 0125  	movw r[5], r[14];	;		cjs, go MulSWWid;;			| by= cg2_ropwordaddr (fb,0,r[4],r[5])
    20d  0a 00 e 0 0 9b84 0000  	rolw 13, r[4], acc;	;		;		;			| 
    20e  0a 27 e 0 0 e2c1 1fff  	andw d, acc, acc;	0x1fff->am;	;		;			| r[4] >> 3 (byte addressing)
    20f  0a 06 3 c 0 908d 020f  	addw r[13], acc, y;	am->fifo1;	cjp, f1f .;	;			| physical fb hi addr dest. 
    210  0a 27 e 0 0 86b5 0020  	addcw d, r[21], acc;	0x20->am;	;		;			| RopFB->am
    211  0a 06 3 c 0 908c 0211  	addw r[12], acc, y;	am->fifo1;	cjp, f1f .;	;			| physical fb lo addr dest. 
                                |   Compute new values for next pp strip or exit from here if all strips done.
    212  0a 00 e 0 0 d818 0000  	movw r[24], acc;	;		;		;			| 
    213  0a 00 e 0 0 9884 0000  	addw r[4], acc, r[4];	;		;		;			| r[4] += r[24]
    214  02 00 e 0 0 9806 0000  	subw,s r[6], acc, r[6]; ;		;		;			| r[6] = r[24] - r[6].
    215  0a 00 3 9 0 df66 0220  	negw r[6], r[6];	;		cjp, ~neg rt1end0; ;			| r[6] = -r[6]. (r[6] - r[24])
    216  0a 07 e 0 0 9888 0000  	addw r[8], acc, r[8];	am->am;		;		;			| r[8] += r[24]
    217  02 00 e 0 0 9659 0000  	rsubw,s d, r[25], y;	;		;		;			| if (r[8] >= r[25])
    218  0a 00 3 1 0 d819 021a  	movw r[25], acc;	;		cjp, neg .+2;	;			| 
    219  0a 07 e 0 0 9848 0000  	rsubw r[8], acc, r[8];	am->am;		;		;			| r[8] -= r[25]
    21a  0a 00 1 7 0 7140 0223  	;			;		cjs, go rt1stripw; ;			| 
    21b  0a 00 1 7 0 7140 0228  	;			;		cjs, go rt1w;	;			| Calculate r[22], r[20], and r[11].
    21c  0a 00 1 7 0 7140 0234  	;			;		cjs, go rt1mask; ;			| Set right and left mask and send to pp.
    21d  0a 06 3 c 0 d84b 021d  	movw r[11], y;		am->fifo1;	cjp, f1f .;	;			| 
    21e  0a 06 3 c 0 d854 021e  	movw r[20], y;		am->fifo1;	cjp, f1f .;	;			| Send r[20] (r[20], RRWidth, RROpCount)
    21f  0a 00 3 7 0 7140 0203  	;			;		cjp, go rt1strip; ;			| 
    220  0a 06 3 c 0 fb00 0220  rt1end0: compw 0, y;		am->fifo1;	cjp, f1f .;	;			| Send pp end of r[0] flag.
    221  0a 27 e 0 0 9e9e 0010  rt1end:addw d, r[30], r[30];	16->am;		;		;			| 16:Cmd,fb,r[17],2 rects,sd,sw,sh,r[8],r[9].
    222  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;			| 
                                |   if adding 16 collapse two previous lines.
                                |   Calculate strip width.  Expects r[8] in the d latch.
    223  08 00 e 0 8 9e19 0000  rt1stripw: subw d, r[25], r[24]; ;	;		;			| r[24]= r[25] - r[8]
    224  0a 00 e 0 0 d806 0000  	movw r[6], acc;	;		;		;			| 
    225  02 00 e 0 0 9018 0000  	subw,s r[24], acc, y; ;		;		;			| if (r[24] > r[6]) r[24]=r[6]
    226  1a 00 a 9 0 7140 0000  	;			;		crtn, ~neg;	;			| 
    227  1a 00 a 7 0 d898 0000  	movw acc, r[24];	;		crtn, go;	;			| 
                                rt1w:
    228  0a 27 e 0 0 86c4 000f  	andw d, r[4], acc;	0xf->am;	;		;			| r[20]= cg2_prskew (dst.pos.x) == r[4] & 15
    229  08 00 e 0 b 9ec8 0000  	andw d, r[8], r[11];	;		;		;			| r[11]= mprs_skew (r[8] + (src offset x == 0))
    22a  02 00 e 0 0 980b 0000  	subw,s r[11], acc, r[11]; ;		;		;			| r[22]= (r[11] >= r[20]). Shift= (r[20]-r[11]) & 15
    22b  0a 00 3 0 0 dd16 022e  	incw 0, r[22];		;		cjp, zer .+3;	;			| 
    22c  0a 00 3 1 0 7140 022e  	;			;		cjp, neg .+2;	;			| 
    22d  0a 00 e 0 0 d916 0000  	movw 0, r[22];		;		;		;			| 
    22e  0a 27 e 0 0 e201 0001  	subw d, acc, acc;	1->am;		;		;			| r[20]= (dst.size.x + r[20] - 1) >> 4.
    22f  0a 00 e 0 0 8098 0000  	addw r[24], acc, acc; ;		;		;			| First Strip (use r[24] as dst.size.x)
    230  0a 00 e 0 0 b814 0000  	rolw 12, acc, r[20];	;		;		;			| >> 4
    231  0a 27 e 0 0 9ed4 0fff  	andw d, r[20], r[20];		0xfff->am;	;		;			| 
    232  0a 27 e 0 0 9ecb 000f  	andw d, r[11], r[11];	0xf->am;	;		;			| 
    233  1a 27 a 7 0 9e8b 0100  	addw d, r[11], r[11];	0x100->am;	crtn, go;	;			| 
    234  0a 27 e 0 0 8618 0001  rt1mask: subw d, r[24], acc; 1->am;	;		;			| RRMask2= mrc_rmasktable []
    235  0a 00 e 0 0 8084 0000  	addw r[4], acc, acc;	;		;		;			| [(dst.pos.x + dst.size.x - 1) & 0xF]
    236  0a 27 e 0 0 e2c1 000f  	andw d, acc, acc;	0xf->am;	;		;			| 
    237  0a 27 e 0 0 e281 1010  	addw d, acc, acc;	4112->am;	;		;			| 
    238  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
    239  0a 00 e 0 0 7140 0000  	;			;		;		;			| Wait for vpprom?
    23a  0a 00 e 0 0 7140 0000  	;			;		;		;			| Wait for vpprom?
    23b  0a 20 3 c 0 d804 023b  	movw r[4], acc;		vpprom->fifo1;	cjp, f1f .;	;			| RRMask2
    23c  0a 27 e 0 0 e2c1 000f  	andw d, acc, acc;	0xf->am;	;		;			| RRMask1= mrc_lmasktable [dst.pos.x & 0xF]
    23d  0a 27 e 0 0 e281 1000  	addw d, acc, acc;	4096->am;	;		;			| 
    23e  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
    23f  0a 00 e 0 0 7140 0000  	;			;		;		;			| Wait for vpprom?
    240  0a 00 3 c 0 7140 0240  	;			;		cjp, f1f .;	;			| Wait for vpprom?
    241  1a 20 a 7 0 7140 0000  	;			vpprom->fifo1;	crtn, go;	;			| RRMask1
                                |   PR_ROPTEX8:
                                |   Can't use r[0] until later parts of PR_ROPTEX.
                                |   #define r[0]	r[0]
                                |	subw,s d, r[28], y;	shmem->am;	jmap PR_ROPTEX8; ;			|
    242  0a 17 1 8 2 f8c1 0082  PR_ROPTEX8:movw d, acc;		shmem->am;	cjs, ~zer getfbaddr; ;		shp+	| if fb index has changed get new address.
    243  0a 28 e 0 0 f8e1 007d  	movw  8, acc;	=wrfifo->brreg;	;		;			| 
    244  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs, f1f;	;			| 
    245  1a 27 1 7 0 86c0 00ff  	andw d, r[0], acc;	0xff->am;	cjs, go;	;			| 
    246  0a 17 1 7 2 d8d0 010d  	movw d, r[16];	shmem->am;	cjs, go roprect; ;		shp+	| dst pixrect and region
    247  0a 00 1 7 0 7140 0115  	;			;		cjs, go prclip2; ;			| prclip2 mustn't alter brreg.
    248  0a 00 1 7 0 7140 0322  	;			;		cjs, go stprep;	;			| get texture size and calcs wordwidth
                                |	subw,s d, r[4], y;	362->am;	;		;			| DEBUG
                                |	;			;		cjp, ~zer .+4;	;			| DEBUG
                                |	subw,s d, r[5], y;	302->am;	;		;			| DEBUG
                                |	;			;		cjp, ~zer .+2;	;			| DEBUG
                                |	;			;		cjp, go prrtzip; ;			| DEBUG
    249  02 00 e 0 0 de46 0000  	negw,s r[6], y;	;		;		;			| if (dst.size.x <= 0) || (y <= 0) return
    24a  02 00 3 9 0 de47 024c  	negw,s r[7], y;	;		cjp, ~neg prrtzip; ;			| 
    24b  0a 00 3 1 0 7140 0250  	;			;		cjp, neg prrtprep; ;			| 
    24c  08 00 e 0 2 d96b 0000  prrtzip: movw r[11], r[2];	;		;		;			| "consume" texture words from r[0] buffer.
    24d  0a 00 1 7 0 dc0c 0fce  	incw r[12], acc;	;		cjs, go multiply; ;			| r[12] is less one due to push, rfct.
    24e  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| 
    24f  0a 00 3 7 0 989e 029e  	addw r[30], acc, r[30]; ;		cjp, go prrtend; ;			| 
    250  0a 27 e 0 0 f8c1 001b  prrtprep: movw d, acc;		 27->am;	;		;			| Assumes prclip2 hasn't altered brreg.
    251  0a 06 3 c 0 f880 0251  	movw acc, y;		am->fifo1;	cjp, f1f .;	;			| 
    252  0a 06 3 c 0 d84e 0252  	movw r[14], y;		am->fifo1;	cjp, f1f .;	;			| 
                                |   	movw r[12], y;		am->brreg;	;		;			| DONE by stprep (SET_TEX).
    253  0a 06 3 c 0 d84d 0253  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    254  08 00 e 0 b d96d 0000  	movw r[13], r[11];	;		;		;			| 
    255  0a 06 3 c 0 d84f 0255  	movw r[15], y;		am->fifo1;	cjp, f1f .;	;			| 
    256  12 00 4 7 0 c1eb 0000  prrtld:	sub2nw,s 0, r[11], r[11];	;		push, go;	;			| 
    257  0a 16 3 c 0 7140 0257  	;			shmem->fifo1;	cjp, f1f .;	;			| 
    258  1a 00 8 0 2 dd7e 0000     	incw r[30], r[30];	;		rfct;		;		shp+	| 
    259  0a 08 3 8 0 d84c 0256     	movw r[12], y;		am->brreg;	cjp, ~zer prrtld; ;			| 
    25a  0a 17 e 0 2 d8c8 0000  	movw d, r[8];		shmem->am;	;		;		shp+	| 
    25b  0a 17 e 0 2 d8c9 0000  	movw d, r[9];		shmem->am;	;		;		shp+	| 
    25c  0a 2f e 0 0 7140 01ff  	;			511->shmemp; ;	;			| Set PP tex block ptr to PIXRECT type.
    25d  0a 2a e 0 0 d80e ffff  	movw r[14], acc;	0xffff->shmem;	;		;			| Always load texture if -1 is block ptr.
    25e  02 00 e 0 0 e1ef 0000  	btstw,s 0, r[15];	;		;		;			| 
    25f  0a 00 3 8 0 d899 01d6  	movw acc, r[25];	;		cjp, ~zer rt1setup; ;			| 
    260  0a 28 e 0 0 7140 007d  rt8:	;			=wrfifo->brreg;	;		;			| 
    261  1a 27 1 7 0 f8c1 000a  	movw d, acc;		10->am;	cjs, go;	;			| LATER make loading 1 clip rect a routine?
    262  0a 06 3 c 0 fd00 0262  	incw 0, y;		am->fifo1;	cjp, f1f .;	;			| 1 clip rect.
    263  0a 06 3 c 0 d840 0263  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    264  0a 06 3 c 0 d841 0264  	movw r[1], y;		am->fifo1;	cjp, f1f .;	;			| 
    265  0a 06 3 c 0 d842 0265  	movw r[2], y;		am->fifo1;	cjp, f1f .;	;			| send dst pixrect x size
    266  0a 06 3 c 0 d843 0266  	movw r[3], y;		am->fifo1;	cjp, f1f .;	;			| send dst pixrect y size
    267  1a 27 1 7 0 f8c1 0015  	movw d, acc;		21->am;	cjs, go;	;			| 
    268  0a 07 e 0 0 d840 0000  	movw r[0], y;		am->am;		;		;			| Make x1
    269  0a 00 e 0 0 9e84 0000  	addw d, r[4], r[4];	;		;		;			| 
    26a  08 00 e 0 1 cc90 0000  	sr0w r[16], r[17];	;		;		;			| 
    26b  0a 27 e 0 0 9ed1 000f  	andw d, r[17], r[17];		0xf->am;	;		;			| 
                                | PIXOP_NEEDS_DST (r[17] << 1)= (r[17]^(r[17] << 1)) & 0xa
    26c  0a 00 e 0 0 d811 0000  	movw r[17], acc;		;		;		;			| 
    26d  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
    26e  0a 00 e 0 0 8111 0000  	xorw r[17], acc, acc;	;		;		;			| 
    26f  02 27 e 0 0 e281 000a  	addw,s d, acc, acc;	0xa->am;	;		;			| 
    270  0a 00 3 0 0 7140 0273  	;			;		cjp, zer prrtnodst; ;			| 
    271  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| SWWPIX
    272  0a 00 3 7 0 7140 0274  	;			;		cjp, go prrtropreg; ;			| 
    273  0a 27 e 0 0 7140 0001  prrtnodst: ;			1->am;		;		;			| SRWPIX
    274  0a 06 3 c 0 f8c0 0274  prrtropreg: movw d, y;		am->fifo1;	cjp, f1f .;	;			| RopMode
    275  0a 07 e 0 0 d841 0000  	movw r[1], y;		am->am;		;		;			| Make y1
    276  0a 00 e 0 0 9e85 0000  	addw d, r[5], r[5];	;		;		;			| 
    277  0a 06 3 c 0 d851 0277  	movw r[17], y;		am->fifo1;	cjp, f1f .;	;			| Op
    278  0a 07 e 0 0 d844 0000  	movw r[4], y;		am->am;		;		;			| Make x2
    279  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| 
    27a  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| Patt
    27b  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| Mask2
    27c  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| Mask1
    27d  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| r[14]
    27e  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| OpCnt
    27f  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| Shift
    280  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| PrimeSrc2
    281  02 00 e 0 0 e1ef 0000  	btstw,s 0, r[15];	;		;		;			| 
    282  0a 00 3 0 0 7140 0295  	;			;		cjp, zer prrtpp8; ;			| 
    283  0a 00 e 0 0 9790 0000  	rolw 11, r[16], acc;	;		;		;			| r[18]= PIX_COLOR(r[17]) = (r[17]>>5) & 0xff
    284  02 27 e 0 0 c2d2 07ff  	andw,s d, acc, r[18];	0x7ff->am;	;		;			| if (r[18] == 0) r[18]= all ones.
    285  0a 00 3 8 0 7140 0287  	;			;		cjp, ~zer .+2;	;			| 
    286  0a 27 e 0 0 d8d2 ffff  	movw d, r[18];		0xffff->am;	;		;			| 
    287  08 27 e 0 1 9ed0 001f  	andw d, r[16], r[17];	0x1f->am;	;		;			| 
    288  02 28 e 0 0 c1e7 007d  prrtpp1:sub2nw,s 0, r[7], r[7]; =wrfifo->brreg; ;		;			| 
    289  0a 00 3 1 0 7140 029e  	;			;		cjp, neg prrtend; ;			| 
    28a  1a 27 1 7 0 f8c1 001c  	movw d, acc;		28->am;	cjs, go;	;			| 
    28b  0a 06 3 c 0 d845 028b  	movw r[5], y;		am->fifo1;	cjp, f1f .;	;			| 
    28c  0a 00 e 0 0 dd65 0000  	incw r[5], r[5];	;		;		;			| 
    28d  0a 06 3 c 0 d844 028d  	movw r[4], y;		am->fifo1;	cjp, f1f .;	;			| 
    28e  0a 06 3 c 0 d846 028e  	movw r[6], y;		am->fifo1;	cjp, f1f .;	;			| 
    28f  0a 06 3 c 0 d852 028f  	movw r[18], y;		am->fifo1;	cjp, f1f .;	;			| 
    290  0a 06 3 c 0 f900 0290  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| color0= 0
    291  0a 06 3 c 0 d851 0291  	movw r[17], y;		am->fifo1;	cjp, f1f .;	;			| 
    292  0a 06 3 c 0 d848 0292  	movw r[8], y;		am->fifo1;	cjp, f1f .;	;			| 
    293  0a 06 3 c 0 d969 0293  	movw r[9], r[9];		am->fifo1;	cjp, f1f .;	;			| 
    294  0a 00 3 7 0 dd69 0288  	incw r[9], r[9];		;		cjp, go prrtpp1; ;			| 
    295  0a 28 e 0 0 7140 007d  prrtpp8:;			=wrfifo->brreg;	;		;			| 
    296  1a 27 1 7 0 f8c1 0023  	movw d, acc;		35->am;	cjs, go;	;			| PP command.
    297  0a 06 3 c 0 d844 0297  	movw r[4], y;		am->fifo1;	cjp, f1f .;	;			| 
    298  0a 06 3 c 0 d845 0298  	movw r[5], y;		am->fifo1;	cjp, f1f .;	;			| 
    299  0a 06 3 c 0 d846 0299  	movw r[6], y;		am->fifo1;	cjp, f1f .;	;			| 
    29a  0a 06 3 c 0 d847 029a  	movw r[7], y;		am->fifo1;	cjp, f1f .;	;			| 
                                |   	movw r[16], acc;	;		;		;			| r[17]= (r[17] >> 1) & 0xf
                                |   	sr0w acc, acc;		;		;		;			| 
                                |   	andw d, acc, acc;	0xf->am;	cjs, go;	;			| 
    29b  0a 06 3 c 0 d850 029b  	movw r[16], y;	am->fifo1;	cjp, f1f .;	;			| 
    29c  0a 06 3 c 0 d808 029c  	movw r[8], acc;		am->fifo1;	cjp, f1f .;	;			| 
    29d  0a 06 3 c 0 d809 029d  	movw r[9], acc;		am->fifo1;	cjp, f1f .;	;			| 
    29e  0a 00 2 0 0 c9de 0027  prrtend: add2nw 4, r[30], r[30]; ;		jmap getcmd;	;			| 16:Cmd,fb,r[17],2 rects,sd,sw,sh,r[8],r[9].
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)attributes.vp.u 1.3 86/09/13 SMI
                                | vector attributes
                                | polygon attributes
                                |	incw r[30],r[30];	;		jmap SETCLIPPLANES;;
                                SETCLIPPLANES:
    29f  0a 00 e 0 0 949d 0000  	addw r[29], 4,y;;	;		;
    2a0  0a 0f e 0 0 0004 0000  	;			am->shmemp;	;		;
    2a1  0a 0a 2 0 0 f880 0027  	movw acc,y;		am->shmem;	jmap getcmd;	;
                                |	movw 0,y;		am->fpdp;	jmap SETMATRIX_2D; ;			  | zero fpr dst ptr
    2a2  0a 07 4 7 0 eb9c 0005  SETMATRIX_2D: rolw 5,acc,y;	am->am;		push,go 5;	;			  | d <- index*32 (index is passed in acc)
    2a3  0a 1b e 0 2 ea81 0000  	addw d, 64,acc;	shmem->fpregh;	;		;		shp+	  | copy from r[0] list in shmem to fpr[0]
    2a4  1b 1b 8 0 c 0040 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+  | acc <-  64 + index*32
    2a5  0a 0f e 0 0 909d 0000  	addw r[29],acc,y;	am->shmemp;	;		;			  | shmemp <- addr to store matrix
    2a6  0a 0c 4 7 0 f900 0005  	movw 0,y;		am->fpap;	push,go 5;	;			  | zero fpr src ptr
    2a7  0a 3a e 0 2 f8e1 0000  	movw 13,acc;		fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to frame in shmem
    2a8  1b 3a 8 0 b 000d 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
    2a9  0a 00 2 0 0 989e 0027  	addw r[30],acc,r[30];	;		jmap getcmd;	;
                                |	movw 0,y;		am->fpdp;	jmap GETMATRIX_2D; ;			  | zero fpr dst ptr
    2aa  0a 2c e 0 0 eb9d 0000  GETMATRIX_2D: rolw 5,acc,acc;	0->fpap;	;		;			  | acc <- index*32 (index is passed in acc)
    2ab  0a 27 e 0 0 e281 0040  	addw d,acc,acc;		 64->am;;		;			  | fpap <- 0
    2ac  0a 0f 4 7 0 909d 0005  	addw r[29],acc,y;	am->shmemp;	push,go 5;	;			  | shmemp <- addr to retrieve matrix
    2ad  0a 1b e 0 2 dc1e 0000  	incw r[30],acc;	shmem->fpregh;	;		;		shp+	  | copy from frame in shmem to fpr[0]
    2ae  1b 1b 8 0 c 7140 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+  | acc has shmem addr of flag
    2af  0a 0f 4 7 0 fc80 0005  	incw acc,y;		am->shmemp;	push,go 5;	;			  | shmemp <- addr to store matrix
    2b0  0a 3a e 0 2 c49e 0000  	addw acc,13,r[30];	fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to shmem r[0] area
    2b1  1b 3a 8 0 b 000d 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | r[30] += 14
    2b2  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
    2b3  0a 0a 2 0 0 f900 0027  	movw 0,y;		am->shmem;	jmap getcmd;	;			  | flag <- 0; jump to r[0] loop
                                |	movw 0,y;		am->fpdp;	jmap SETVWP_2D; ;			  | zero fpr dst ptr
    2b4  0a 0c 4 7 0 f900 0003  SETVWP_2D: movw 0,y;		am->fpap;	push,go 3;	;			  | zero fpr src ptr
    2b5  0a 1b e 0 2 f8e1 0000  	movw  52,acc;shmem->fpregh;	;		;		shp+	  | copy from r[0] list in shmem to fpr[0]
    2b6  1b 1b 8 0 c 0034 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+
    2b7  0a 0f 4 7 0 909d 0003  	addw r[29],acc,y;	am->shmemp;	push,go 3;	;			  | add r[29] and viewport frame offset
    2b8  0a 3a e 0 2 f8e1 0000  	movw 9,acc;		fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to frame in shmem
    2b9  1b 3a 8 0 b 0009 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
    2ba  0a 00 2 0 0 989e 0027  	addw r[30],acc,r[30];	;		jmap getcmd;	;
                                |	tvec_attr -- setup attributes for drawing fat and textured vectors
                                |
                                |	Input Parameters:	shmemp -- points at frame's texture
    2bb  02 17 2 0 0 f8c0 1104  tvec_attr: movw,s d,y;		shmem->am;	jmap tvec_attr_pp; ;			| Test first segment of pattern.
                                |	vec_attr -- setup attributes for drawing vectors
                                |
                                |	Input Parameters:	shmemp -- points at beginning of attribute frame
    2bc  1a 27 4 f 0 d8d1 000d  vec_attr: movw d,r[17];	 13->am;	push, ~go;	;			  | will send solid vec r[0] to fifo
    2bd  1a 26 d 4 0 7140 000c  	;			12->fifo1; loop, f1nf;	;			  | initialization for solid xf vectors
    2be  02 17 e 0 0 961c 0000  	subw,s d,r[28],y;	shmem->am;	;		;			  | tst oldfbindx - newfbindx
    2bf  0a 17 1 8 2 f8c1 0082  vecatt2: movw d,acc;		shmem->am;	cjs,~zer getfbaddr; ;		shp+	  | if oldfbindx != newfbindx, send to PP
    2c0  0a 28 e 0 0 f8e1 007d  	movw  8,acc;	=wrfifo->brreg;	;		;			  | send  8 command to PP
    2c1  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs,f1f;	;
    2c2  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | send bit plane mask
    2c3  0a 17 e 0 2 d8cd 0000  	movw d,r[13];		shmem->am;	;		;		shp+	  | save r[13]
    2c4  0a 17 e 0 2 d8cc 0000  	movw d,r[12];		shmem->am;	;		;		shp+	  | save r[12]
    2c5  0a 17 e 0 2 d8cb 0000  	movw d,r[11];	shmem->am;	;		;		shp+	  | save r[11]
    2c6  1a 17 4 f 2 d8c9 0000  	movw d,r[9];	shmem->am;	push,~go;	;		shp+	  | save r[9]
    2c7  1a 26 d 4 0 f186 000a  	mov2nw 8,acc;		10->fifo1;loop,f1nf;	;			  | send Rectlist
    2c8  0a 0f e 0 0 909d 0000  	addw r[29],acc,y;	am->shmemp;	;		;			  | starts at frame offset 0x100
    2c9  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | Number of rectangles.
    2ca  02 00 4 7 0 e185 0003  vecatt1:sub2nw,s 0,acc;		;		push,go 3;	;			  | 4 values in one rectangle
    2cb  0a 16 3 c 0 7140 02cb  	;			shmem->fifo1;	cjp,f1f .;	;
    2cc  1a 00 8 0 2 7140 0000  	;			;		rfct;		;		shp+
    2cd  0a 00 3 8 0 7140 02ca  	;			;		cjp, ~zer vecatt1;;
    2ce  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;
                                polygon_attr_3D:
                                |   Low byte of arg passed in acc indicates shading style:
                                |   constant: 0, Gouraud: 1, textured: 2 (high byte assumed to be 0).  After
                                |   setting up regular 2-D polygon attributes, check hidden surface
                                |   flag.  Return if no hidden surface removal (HSR) else check whether
                                |   gbuffer is present.  If not, return; else test if gbuffer is
                                |   associated with the current frame buffer; if not, return; else
                                |   set bit 8 of shade style register and return.  Upper byte of
                                |   r[24] indicates hidden surface method: none: 0,
                                |   zbuffer: 1.
    2cf  0a 00 1 7 0 d898 02df  	movw acc, r[24]; ;		cjs,go polygon_attr_2D; ;		| Move low byte of command to style.
    2d0  0a 27 e 0 0 869d 0006  	addw d,r[29],acc;	6->am;;		;			  | 
    2d1  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;			  | 
    2d2  0a 17 e 0 2 f8c1 0000  	movw d, acc;		shmem->am;	;		;		shp+	| 
    2d3  02 00 e 0 0 e3f8 0000  	btstw,s 1, r[24]; ;		;		;			| if (shadestyle & 2) textured.
    2d4  0a 17 3 0 0 d8c0 02d9  	movw d, r[0];		shmem->am;	cjp, zer pa3hsr; ;			| Get depth.
    2d5  02 00 e 0 0 e7e0 0000  	btstw,s 3, r[0];	;		;		;			| if (depth == 8)
    2d6  0a 00 3 0 0 e3d8 02d8  	bclrw 1, r[24]; ;		cjp, zer pa3tex1; ;			| 
    2d7  0a 00 3 7 0 f5b8 02d9  	bsetw 10, r[24]; ;		cjp, go pa3hsr;	;			| 
    2d8  0a 00 e 0 0 f3b8 0000  pa3tex1: bsetw 9, r[24]; ;		;		;			| else (depth == 1)
    2d9  02 00 e 0 0 f880 0000  pa3hsr:	movw,s acc, y;		;		;		;			| Test acc for HSR.
    2da  1a 00 a 0 0 7140 0000  	;			;		crtn,zer;	;			  | return if no hidden surface removal
    2db  0a 00 1 7 0 7140 0009  	;			;		cjs,go gb_board_inq;;			  | 
    2dc  12 00 a 1 0 911c 0000  	xorw,s r[28],acc,y;	;		crtn,neg;	;			  | 
    2dd  1a 00 a 8 0 7140 0000  	;			;		crtn,~zer;	;			  | 
    2de  1a 00 a 7 0 f1b8 0000  	bsetw 8,r[24];	;		crtn,go;	;			  | 
                                polygon_attr_2D:
    2df  02 17 e 0 0 961c 0000  	subw,s d,r[28],y;	shmem->am;	;		;			  | tst oldfbindx - newfbindx
    2e0  0a 17 1 8 2 f8c1 0082  	movw d,acc;		shmem->am;	cjs,~zer getfbaddr;;		shp+	  | if oldfbindx != newfbindx, send to PP
    2e1  0a 28 e 0 0 f8e1 007d  	movw  8,acc;	=wrfifo->brreg;	;		;			  | send  8 command to PP
    2e2  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs,f1f;	;
    2e3  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | send bit plane mask
    2e4  0a 17 e 0 2 f8c1 0000  	movw d,acc;		shmem->am;	;		;		shp+	  | get r[13]
    2e5  0a 27 e 0 0 e2c1 001f  	andw d,acc,acc;		0x1F->am;	;		;			  | mask off upper 11 bits
    2e6  0a 17 e 0 2 aa2d 0000  	rolw 5,d,r[13];	shmem->am;	;		;		shp+	  | get r[12]
    2e7  0a 27 e 0 0 9ecd 1fe0  	andw d,r[13],r[13]; 0x1FE0->am;;		;			  | mask out noncolor bits
    2e8  0a 00 e 0 0 994d 0000  	orw r[13],acc,r[13];;	;		;			  | combine r[12] and r[13] into r[13]
    2e9  0a 17 e 0 2 d8cc 0000  	movw d,r[12];	shmem->am;	;		;		shp+	  | save r[11]
    2ea  1a 17 4 f 2 d8c9 0000  	movw d,r[9];	shmem->am;	push,~go;	;		shp+	  | save r[9]
    2eb  1a 26 d 4 0 f186 000a  	mov2nw 8,acc;		10->fifo1;loop,f1nf;	;			  | send Rectlist
    2ec  0a 0f e 0 0 909d 0000  	addw r[29],acc,y;	am->shmemp;	;		;			  | starts at frame offset 0x100
    2ed  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | acc <- # of rectangles & send to PP
    2ee  02 00 4 7 0 e185 0003  plyatt1:sub2nw,s 0,acc;		;		push,go 3;	;			  | 4 values in one rectangle.
    2ef  0a 16 3 c 0 7140 02ef  	;			shmem->fifo1;	cjp,f1f .;	;
    2f0  1a 00 8 0 2 7140 0000  	;			;		rfct;		;		shp+
    2f1  0a 00 3 8 0 7140 02ee  	;			;		cjp, ~zer plyatt1;;
    2f2  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;
                                | "@(#)%M 1.2 86/09/12 SMI"
                                | Copyright (c) 1986 by Sun Microsystems, Inc.
                                |   Utilities for texture.
                                |   	rolw 9, acc, acc;	;		jmap SET_TEXFRAME; ;			|
    2f3  02 27 e 0 0 e2c0 f1ff  SET_TEXFRAME: andw,s d, acc, y;	0xf1ff->am;	;		;			| Check for out of range block. comp 0x0e00
    2f4  0a 00 3 0 0 dd7e 02f6  	incw r[30], r[30];	;		cjp, zer stfok;	;			| 
    2f5  0a 00 3 7 0 fb01 02f7  	compw 0, acc;		;		cjp, go stfshm;	;			| Invalid tex frame is -1.
    2f6  0a 27 e 0 0 e281 3000  stfok:	addw d, acc, acc;	0x3000->am;	;		;			| Similar to USEFRAME
    2f7  0a 00 e 0 0 949d 0000  stfshm:	addw r[29], 10, y; ;	;		;			| 
    2f8  0a 0f e 0 0 000a 0000  	;			am->shmemp;	;		;			| 
    2f9  0a 0a 2 0 0 f880 0027  	movw acc, y;		am->shmem;	jmap getcmd;	;			| 
                                |   Can't use r[0] in stprep or stexld because PR_POLYTEX needs cmd (r[0]) preserved for use by PR_POLYSOL.
                                |   Loads 8-bit pixels packed two per 16 bit word.
    2fa  0a 00 e 0 0 949d 0000  SET_TEX: addw r[29], 10, y; ;	;		;			| Check for valid block ptr.
    2fb  0a 0f e 0 0 000a 0000  	;			am->shmemp;	;		;			| 
    2fc  02 17 e 0 0 d8ca 0000  	movw,s d, r[10];	shmem->am;	;		;			| -1 == invalid tex frame.
    2fd  0a 0f 3 9 0 dc5e 0309  	incw r[30], y;		am->shmemp;	cjp, ~neg stcmdok; ;			| restore r[30].
    2fe  0a 17 e 0 2 d8cf 0000  	movw d, r[15];		shmem->am;	;		;		shp+	| 
    2ff  0a 17 e 0 2 d8c2 0000  	movw d, r[2];		shmem->am;	;		;		shp+	| r[14].  Pad it out.
    300  02 00 e 0 0 e7ef 0000  	btstw,s 3, r[15];	;		;		;			| 
    301  0a 00 3 0 0 c5de 0304  	add2nw 2, r[30], r[30]; ;		cjp, zer stbad1; ;			| 4= r[0], depth, width, height
    302  0a 27 e 0 0 9e82 0001  	addw d, r[2], r[2];	1->am;		;		;			| 8-bit:  r[14]= (r[14] + 1) >> 1
    303  0a 00 3 7 0 cc82 0307  	sr0w r[2], r[2];	;		cjp, go stbad0;	;			| 
    304  0a 27 e 0 0 9e82 000f  stbad1:	addw d, r[2], r[2];	15->am;		;		;			| 1-bit:  r[14]= (r[14] + 15) >> 4
    305  0a 00 e 0 0 99e2 0000  	rolw 12, r[2], r[2];	;		;		;			| 
    306  0a 27 e 0 0 9ec2 0fff  	andw d, r[2], r[2];	0xfff->am;	;		;			| 
    307  0a 17 1 7 2 f8c1 0fce  stbad0:	movw d, acc;		shmem->am;	cjs, go multiply; ;		shp+	| NumWords= r[14] * r[13]...
    308  0a 00 2 0 0 989e 0027  	addw r[30], acc, r[30]; ;		jmap getcmd;	;			| Skip r[30] over texture.
    309  0a 00 3 c 0 7140 0309  stcmdok: ;			;		cjp, f1f .;	;			| 
    30a  0a 26 e 0 0 7140 001b  	;			 27->fifo1;	;		;			| 
    30b  0a 00 1 7 0 7140 0322  	;			;		cjs, go stprep;	;			| 
    30c  12 00 4 7 0 c1eb 0000  stexld0:sub2nw,s 0, r[11], r[11];	;		push, go;	;			| Copy texture into floating pt. regs.
    30d  1b 1b 8 0 c 7140 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+| 
    30e  0a 08 3 8 0 d84c 030c  	movw r[12], y;		am->brreg;	cjp, ~zer stexld0; ;			| 
    30f  0a 06 3 c 0 d84e 030f  	movw r[14], y;		am->fifo1;	cjp, f1f .;	;			| stores d,r[20],h and setups shmemp.
    310  0a 00 e 0 0 949d 0000  	addw r[29], 7, y; ;	;		;			| 
    311  0a 0f e 0 0 0007 0000  	;			am->shmemp;	;		;			| 
    312  0a 06 3 c 0 d84d 0312  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    313  0a 0a e 0 2 d84f 0000  	movw r[15], y;		am->shmem;	;		;		shp+	| 
    314  0a 0a e 0 2 d84e 0000  	movw r[14], y;		am->shmem;	;		;		shp+	| 
    315  0a 0a e 0 2 d84d 0000  	movw r[13], y;		am->shmem;	;		;		shp+	| 
    316  0a 06 3 c 0 d84f 0316  	movw r[15], y;		am->fifo1;	cjp, f1f .;	;			| 
    317  0a 2f e 0 0 7140 01ff  	;			511->shmemp; ;	;			| What texture is on PP.
    318  0a 0a e 0 0 d84a 0000  	movw r[10], y;		am->shmem;	;		;			| 
    319  0a 0f e 0 0 d84a 0000  	movw r[10], y;		am->shmemp;	;		;			| TexBlock pointer -> shmemp.
    31a  0a 08 e 0 0 d84c 0000  	movw r[12], y;		am->brreg;	;		;			| 
    31b  08 2c e 0 b d96d 00e6  	movw r[13], r[11];	230->fpap; ;		;			| 
    31c  12 00 4 7 0 c1eb 0000  stexld:	sub2nw,s 0, r[11], r[11];	;		push, go;	;			| Copy from fl. pt. regs to shmem & fifo
    31d  0b 36 3 c 0 7140 031d     	;			fpregl->fifo1;	cjp, f1f .;	;			| 
    31e  0b 3a e 0 4 dd7e 0000  	incw r[30], r[30];	fpregl->shmem;	;		;		ap+	| 
    31f  1a 27 8 0 2 f8c1 0004  	movw d, acc;		4->am;		rfct;		;		shp+	| shp+,ap+ illegal combination of controls
    320  0a 08 3 8 0 d84c 031c  	movw r[12], y;		am->brreg;	cjp, ~zer stexld; ;			| 
    321  0a 00 2 0 0 989e 0027  streturn: addw r[30], acc, r[30]; ;		jmap getcmd;	;			| 
                                |   stprep does not adjust r[30], which must account for 3 items (d, r[20], h) taken from shared memory.
    322  0a 17 e 0 2 d8cf 0000  stprep:	movw d, r[15];		shmem->am;	;		;		shp+	| 
    323  0a 17 e 0 2 d8ce 0000  	movw d, r[14];		shmem->am;	;		;		shp+	| 
    324  0a 17 e 0 2 d8cd 0000  	movw d, r[13];		shmem->am;	;		;		shp+	| 
    325  02 28 e 0 0 e7ef 032b  	btstw,s 3, r[15];	=stex8->brreg;	;		;			| 
    326  12 27 3 8 0 96ce 000f  	andw,s d, r[14], y;	0xf->am;	cjp, ~zer;	;			| Is r[14] a multiple of 16?
    327  08 27 e 0 c 99ee 0fff  	rolw 12, r[14], r[12];	0xfff->am;	;		;			| r[12]= r[14] >> 4
    328  0a 08 3 8 0 9ecc 032a  	andw d, r[12], r[12];	am->brreg;	cjp, ~zer .+2;	;			| 
    329  0a 08 e 0 0 c1ec 0000  	sub2nw 0, r[12], r[12];	am->brreg;	;		;			| If (r[14] not a multiple of 16) r[12]++
    32a  18 2e a 7 b d96d 00e6  	movw r[13], r[11];	230->fpdp; crtn, go;	;			| Really decrement r[12] for loop.
    32b  08 00 e 0 c c1ee 0000  stex8:	sub2nw 0, r[14], r[12];	;		;		;			| 
    32c  0a 08 e 0 0 cc8c 0000  	sr0w r[12], r[12];	am->brreg;	;		;			| Packed 2 per 16 bit word.
    32d  18 2e a 7 b d96d 00e6  	movw r[13], r[11];	230->fpdp; crtn, go;	;			| 230 to avoid matrices.
                                |   	add2nw 1, r[30], r[30]; ;		jmap SET_SXSYSCRN; ;			| 
    32e  0a 17 e 0 2 d8c0 0000  SET_SXSYSCRN:movw d, r[0];	shmem->am;	;		;		shp+	| temp store sx.
    32f  0a 17 e 0 0 d8c1 0000  	movw d, r[1];		shmem->am;	;		;			| temp store sy.
    330  0a 27 e 0 0 869d 000c  	addw d, r[29], acc;	 12->am; ;		;			| 
    331  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    332  0a 0a e 0 2 d840 0000  	movw r[0], y;		am->shmem;	;		;		shp+	| store sx.
    333  0a 0a e 0 0 d841 0000  	movw r[1], y;		am->shmem;	;		;			| store sy.
    334  0a 27 e 0 0 869d 0018  	addw d, r[29], acc;	24->am; ;	;			| Set kind = screen sx sy
    335  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    336  0a 2a e 0 0 7140 0000  	;			0->shmem; ;		;			| 
    337  0a 00 2 0 0 dd7e 0027  	incw r[30], r[30];	;		jmap getcmd;	;			| 
                                |   	movw 0, y;		am->fpdp;	jmap SET_TEXOFF2D; ;			| 
    338  0a 0c 4 7 0 f900 0001  SET_TEXOFF2D:movw 0, y;		am->fpap;	push, go 1;	;			| 
    339  0a 1b e 0 2 f8e1 0000  	movw 14, acc; shmem->fpregh; ;		;		shp+	| 
    33a  1b 1b 8 0 c 000e 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+| 
    33b  0a 0f 4 7 0 909d 0001  	addw r[29], acc, y;	am->shmemp;	push, go 1;	;			| 
    33c  0a 3a e 0 2 f8e1 0000  	movw 5, acc;		fpregh->shmem;	;		;		shp+	| 
    33d  1b 3a 8 0 2 0005 0000  	;			fpregl->shmem;	rfct;		;		shp+	| 
    33e  08 27 e 0 0 9e9d 0018  	addw d, r[29], r[16]; 24->am; ;	;			| Set kind = 2D
    33f  0a 0f e 0 0 d850 0000  	movw r[16], y;		am->shmemp;	;		;			| 
    340  0a 2a e 0 0 7140 0001  	;			 1->shmem; ;		;			| 
    341  0a 00 2 0 0 989e 0027  	addw r[30], acc, r[30]; ;		jmap getcmd;	;			| 
                                |   	movw 0, y;		am->fpdp;	jmap SET_TEXOFF3D; ;			| 
    342  0a 0c 4 7 0 f900 0002  SET_TEXOFF3D:movw 0, y;		am->fpap;	push, go 2;	;			| 
    343  0a 1b e 0 2 f8e1 0000  	movw 18, acc; shmem->fpregh; ;		;		shp+	| 
    344  1b 1b 8 0 c 0012 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+| 
    345  0a 0f 4 7 0 909d 0002  	addw r[29], acc, y;	am->shmemp;	push, go 2;	;			| 
    346  0a 3a e 0 2 f8e1 0000  	movw 7, acc;		fpregh->shmem;	;		;		shp+	| 
    347  1b 3a 8 0 2 0007 0000  	;			fpregl->shmem;	rfct;		;		shp+	| 
    348  08 27 e 0 0 9e9d 0018  	addw d, r[29], r[16]; 24->am; ;	;			| Set kind = 3D
    349  0a 0f e 0 0 d850 0000  	movw r[16], y;		am->shmemp;	;		;			| 
    34a  0a 2a e 0 0 7140 0002  	;			 2->shmem; ;		;			| 
    34b  0a 00 2 0 0 989e 0027  	addw r[30], acc, r[30]; ;		jmap getcmd;	;			| 
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)recip.vp.u 1.2 86/09/12 SMI
                                |   Reciprocal and integer multiplication routines for viewing processor.
                                |	Recip -- compute reciprocal of floating point number (IEEE single precision)
                                |
                                |	Input Parameters:	fpap -- Address of X, number to be reciprocated
                                |				recaddr -- register containing fpreg address for Y, the reciprocal
                                |				N.B.: fpap and recaddr cannot point to the same location
                                |
                                |	Method:	1) Initial Guess
                                |		   Y0 = (2B-lambda)-X
                                |			A 32-bit integer subtraction
                                |			The constant 2B-lambda is looked up in a table stored in the VP Prom
                                |			The table index is the 1st 11 bits of the mantissa of X
                                |			See notes by W. Kahan and D. Hough
                                |		2) Iteration
                                |		   Y1 = Y0 + Y0 * (1.0 - X * Y0)
                                |			Floating point operations
                                |			The approximation Y1 is taken to be Y, i.e. only one iteration
    34c  0b 37 e 0 0 f8c1 0000  recip:	movw d,acc;		fpregl->am;	;		;			  | get low order X
    34d  0a 37 e 0 0 78c1 0000  	movb d,acc;		fpregh->am;	;		;		 	  | get low 8 bits of high order X
    34e  0a 27 e 0 0 eb9d 0ffe  	rolw 5,acc,acc;		0xFFE->am;	;		;			  | compute address of low order 2B-lambda
    34f  0a 09 e 0 0 e2c1 0000  	andw d,acc,acc;		am->vppromp;	;		;			  | load address into VP Prom pointer
    350  0b 37 e 0 0 d8c1 0000  	movw d,r[1];		fpregl->am;	;		;			  | low order X again
    351  02 37 e 0 0 d8c0 0000  	movw,s d,r[0];		fpregh->am;	;		;			  | high order X again, save sign of X
    352  0a 21 e 0 0 ffc0 0000  	bclrw 15,r[0];		vpprom->am;	;		;			  | compute positive X
    353  0a 09 e 0 0 fc80 0000  	incw acc,y;		am->vppromp;	;		;			  | Prom address for high order 2B-lambda
    354  0a 0e e 0 0 d842 0000  	movw r[2],y;		am->fpdp;	;		;			  | set up fpdp
    355  0b 0b e 0 0 9e41 0000  	rsubw d,r[1],r[1];	am->fpregl;	;		;			  | low order 2B - lambda - X
    356  0a 21 3 1 0 9e60 0358  	rsubcw d,r[0],r[0];	vpprom->am;	cjp,neg negrecip;;			  | high order 2B - lambda - X
    357  0a 0b 3 7 0 ffc0 0359  	bclrw 15,r[0];		am->fpregh;	cjp,go recip1;	;			  | store positive reciprocal
    358  0a 0b e 0 0 ffa0 0000  negrecip: bsetw 15,r[0];		am->fpregh;	;		;			  | store negative reciprocal
    359  2a 0d e 0 0 d842 0230  recip1:	movw r[2],y;		am->fpbp;	;		lmode rn,ai,flow,fast;	  | do iteration step in flow mode
    35a  22 00 e 0 0 e186 0010  	mov2nw,s 0,acc;		;		;		maba,lab,hi;		  | x * Y0; acc <- 1
    35b  2b 0b e 0 0 f900 0010  	movw 0,y;		am->fpregl;	;		;			  | fpr[r[2]] <- low order 1.0
    35c  0a 2b e 0 0 7140 3f80  	;			0x3F80->fpregh;	;		;			  | fpr[r[2]] <- high order 1.0
    35d  02 00 3 9 0 e185 035d  	sub2nw,s 0,acc;		;		cjp,~neg .;	;			  | delay until unload
    35e  2a 00 e 0 0 7140 0104  	;			;		;		adda,m,hi;		  | enable unload
    35f  2b 00 e 0 0 7140 0104  	;			;		;		;
    360  22 00 e 0 0 e186 0198  	mov2nw,s 0,acc;		;		;		rsubr,lab,hi;		  | 1.0 - (X*Y0); acc <- 1
    361  2b 0b e 0 0 d841 0198  	movw r[1],y;		am->fpregl;	;		;			  | fpr[r[2]] <- low order Y0
    362  0a 0b e 0 0 d840 0000  	movw r[0],y;		am->fpregh;	;		;			  | fpr[r[2]] <- high order Y0
    363  02 00 3 9 0 e185 0363  	sub2nw,s 0,acc;		;		cjp,~neg .;	;			  | delay until unload
    364  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;		  | enable unload
    365  2b 00 e 0 0 7140 0102  	;			;		;		;
    366  2a 00 e 0 0 7140 0018  	;			;		;		mabr,lab,hi;		  | Y0 * (1.0-X*Y0)
    367  23 00 e 0 0 e386 0018  	mov2nw,s 1,acc;		;		;		;
    368  02 00 3 9 0 e185 0368  	sub2nw,s 0,acc;		;		cjp,~neg .;	;			  | delay until unload
    369  2a 00 e 0 0 7140 0104  	;			;		;		adda,m,hi;		  | enable unload
    36a  2b 00 e 0 0 7140 0104  	;			;		;		;
    36b  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | Y0 + (Y0*(1.0-X*Y0))
    36c  23 00 e 0 0 e386 0118  	mov2nw,s 1,acc;		;		;		;
    36d  02 00 3 9 0 e185 036d  	sub2nw,s 0,acc;		;		cjp,~neg .;	;			  | delay until unload
    36e  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;		  | enable unload
    36f  2b 00 e 0 0 7140 0102  	;			;		;		;
    370  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store Y1
    371  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | return
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)cgi.vp.u 1.2 86/09/12 SMI
                                |	negw d,r[10];		shmem->am;	jmap CGI_LINE;	;
    372  0a 00 e 0 0 949d 0000  CGI_LINE: addw r[29], 28,y; ;		;		;			| 
    373  0a 0f 1 7 0 001c 02bb  	;			am->shmemp;	cjs, go tvec_attr; ;			| Texture addr->scrmemp
    374  0a 00 c 0 0 949d 0003  	addw r[29], 52,y; ;	ldct 3;		;			| 
    375  0a 0f 3 7 0 0034 0379  	;			am->shmemp;	cjp, go cgiv2;	;			| 
                                |	negw d,r[10];		shmem->am;	jmap CGIVEC;	;
    376  0a 0f 1 7 0 d85d 02bc  CGIVEC:	movw r[29],y;	am->shmemp;	cjs,go vec_attr;;
    377  0a 27 e 0 0 7140 0034  	;			 52->am;;		;
    378  0a 0f c 0 0 969d 0003  	addw d,r[29],y;	am->shmemp;	ldct 3;		;			  | shmemp <- addr of vwp params
    379  0a 0e 1 7 0 eb96 0080  cgiv2:	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr; ;			  | move viewport parameters to fpr[32]
    37a  0a 0f c 0 0 c3de 0003  	add2nw 1,r[30];	am->shmemp;	ldct 3;		;			  | shmemp <- (r[30] += 2)
    37b  0a 0e 1 7 0 ed96 0080  nxtcgivec: mov2nw 6,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move vector endpoints to fpr[64]
    37c  2b 0c e 0 0 cd8e 0230  	mov2nw 6,r[14];	am->fpap;	;		lmode rn,ai,pipe,fast;	  | fpap <- addr of endpoints; pipe mode
    37d  2a 08 e 0 0 e396 00a0  	mov2nw 1,y;		am->brreg;	;		floata,la,hi;		  | convert x0 to float; brreg <- 2
    37e  3b 00 4 7 4 c5ce 00a0  	add2nw 2,r[14];	;		push,go;	;		ap+	  | r[14] <- 68, put vwpscld pts at fpr[68]
    37f  2a 00 e 0 0 f8e0 00a0  	movw =vwpsv2,y;		;		;		floata,la,hi;		  | convert y0, x1, and y1
    380  3b 08 8 0 4 04b5 00a0  	;			am->brreg;	rfct;		;		ap+	  | brreg pts to routine to finish vwp scale
    381  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		  | pipeline advance
    382  2b 0d e 0 0 eb86 0122  	mov2nw 5,acc;		am->fpbp;	;		;			  | fpbp <- &VWPXSCL
    383  2a 00 e 0 0 7140 001a  	;			;		;		mabr,lab,a,hi;		  | x0 * VWPXSCL
    384  2b 0d e 0 0 e384 001a  	add2nw 1,acc;		am->fpbp;	;		;
    385  2a 00 e 0 0 7140 001a  	;			;		;		mabr,lab,a,hi;		  | y0 * VWPYSCL
    386  2b 0d e 0 0 e385 001a  	sub2nw 1,acc;		am->fpbp;	;		;
    387  2a 00 e 0 0 7140 001a  	;			;		;		mabr,lab,a,hi;		  | x1 * VWPXSCL
    388  2b 0d e 0 0 e384 001a  	add2nw 1,acc;		am->fpbp;	;		;
    389  2a 00 e 0 0 7140 0018  	;			;		;		mabr,lab,hi;		  | y1 * VWPYSCL
    38a  3b 0d 1 7 0 e185 0018  	sub2nw 0,acc;		am->fpbp;	cjs,go;		;			  | call vwpsv2 to finish vwp scale and send
                                											  | vector to PP; r[14]==68,fpbp<-&VWPXOFF
    38b  02 00 c 0 0 dd6a 0003  	incw,s r[10],r[10];	;		ldct 3;		;			  | reload 2910 R reg,increment loop counter
    38c  0a 0f 3 8 0 c7de 037b  	add2nw 3,r[30];	am->shmemp;	cjp,~zer nxtcgivec;;			  | shmemp<-(r[30] += 8),loop if more vecs
    38d  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;			  | jump to r[0] loop
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)2Dfp.vp.u 1.2 86/09/12 SMI
                                | data pointers for 2-D transform routine
                                | register which directs what vector command is being called
                                |   Floating point register addresses for xf_line_flt_2d & xf_line_int_2d
                                |   	store pt1	stored at fpr[64] (fpdp=64)
                                |   	store pt2	stored at fpr[66] (fpdp=66)
                                |	xform pt1	r[15]=64, r[14] = 68
                                |	xform pt2	r[15]=66, r[14] = 70
                                |   	clip vector	r[15]=68, r[14] = x
                                |	vwp pts 1 & 2	r[15]=68, r[14] = 72	
                                |   	store xf pt2	stored at fpr[76] (this is done before we clip)
                                |   xfln3dinit sets up the texture attributes on the pp, loads the 3d matrix and viewport scaling parameters,
                                |   and loads 1.0 for w2 before returning.  It is called by xflineflt3d, and xflineint3d. 
                                xfln2dinit:
    38e  0a 00 e 0 0 949d 0000  	addw r[29], 28,y; ;		;		;			| DEBUG
    38f  0a 0f 1 7 0 001c 02bb  	;			am->shmemp;	cjs,go tvec_attr; ;			| Texture addr->scrmemp.
    390  0a 0f c 0 0 d849 0005  	movw r[9],y;	am->shmemp;	ldct 5;		;			| 
    391  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr; ;			| 0 matrix to fpr[16]
    392  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am; ;		;			| 
    393  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;			| 0 viewport parameters to fpr[32]
    394  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr; ;			| 
    395  0a 0f c 0 0 d85e 0001  	movw r[30],y;		am->shmemp;	ldct 1;		;			| 
    396  12 17 a 7 2 d8d0 0000  	movw,s d,r[16];	shmem->am;	crtn,go;	;		shp+	| pull first r[16] element & return
                                |	incw r[30],r[30];	;		jmap XF_LINE_FLT_2D;			| r[30] points to first element of r[16]			
                                XF_LINE_FLT_2D: 
    397  0a 00 1 7 0 7140 038e  	;			;		cjs,go xfln2dinit; ;			| 
    398  0a 0e 1 7 0 cd8f 0080  xf1stpt2: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			| r[15]=64, 0 pt1 x,y to here
    399  0a 27 e 0 0 9e9e 0005  	addw d,r[30],r[30];	5->am;		;		;			| r[30] += 5
    39a  0a 00 3 1 0 7140 0027  	;			;		cjp,neg getcmd; ;			| return if was last pt
    39b  02 17 c 0 2 e190 0001  	btstw,s 0,d;		shmem->am;	ldct 1;		;		shp+	| r[16] for second point
    39c  02 00 3 8 0 d8d0 0398  	movw,s d,r[16];	;		cjp,~zer xf1stpt2; ;			| jump if 2nd point is a 0.
    39d  08 00 e 0 e c5cf 0000  	add2nw 2,r[15],r[14];	;		;		;			| r[14]=68, want xf pt1 x,y,z,r[20] here
    39e  0a 0d 1 7 0 e996 046c  	mov2nw 4,y;		am->fpbp;	cjs,go xf2;	;			| matrix ptr in fpap; convert to int & xform 1st point
    39f  0a 00 e 0 0 c5cf 0000  	add2nw 2,r[15];		;		;		;			| r[15] = 68
    3a0  0a 00 e 0 0 c5ce 0000  	add2nw 2,r[14];	;		;		;			| r[14] = 72
    3a1  0a 2d e 0 0 7140 0010  xf2ndpt2: ;			16->fpbp;	;		;			| 0 pt2 x,y,z coords to fpr[66]
    3a2  0a 0e 1 7 0 c3ef 0080  	sub2nw 1,r[15];		am->fpdp;	cjs,go shm_to_fpr; ;			| r[15] = 66, fetch pt2 x,y,z & store here
    3a3  0a 00 1 7 0 c3ee 046c  	sub2nw 1,r[14];	;		cjs,go xf2;	;			| r[14] = 70, convert 2nd pt to int & xform to here
    3a4  0a 2e e 0 0 7140 004c  	;			76->fpdp;	;		;			| store xformed, unclipped pt2 at fpr[76]
    3a5  0a 2c e 0 0 c382 0046  	mov2nw 1,r[2];		70->fpap;	;		;			| xformed pt2 is currently at fpr[70]
    3a6  02 3b e 0 0 c1e2 0000  xfsvpt2: sub2nw,s 0,r[2];	fpregh->fpregh;	;		;			| 
    3a7  03 3b 3 8 8 d84b 03a6  	movw,s r[11],y;	fpregl->fpregl;	cjp,~zer xfsvpt2; ;		adp+	| increment a & d pointers, loop till done
    3a8  02 0c 1 8 0 c3cf 04dd  	add2nw,s 1,r[15];	am->fpap;	cjs,~zer clpvec2; ;			| r[15] = 68 (xf 1st pt.) clip vector if r[11]!=0;
                                											| also if no clip, force cc to ~zer so vec is drawn
    3a9  0a 00 1 8 0 c3ce 04ac  	add2nw 1,r[14];	;		cjs,~zer vwpsndvec2; ;			| r[14] = 72.  if visible, scale to viewport, cnvrt to
                                											| int, & xmit to PP
    3aa  02 27 e 0 0 d850 0005  	movw,s r[16],y;	5->am;		;		;			| test if just sent last vector
    3ab  0a 0f 3 1 0 9e9e 0027  	addw d,r[30],r[30];	am->shmemp;	cjp,neg getcmd;	;			| r[30] += 5 and exit if was last vector
    3ac  0a 17 c 0 2 d8d0 0001  	movw d,r[16];		shmem->am;	ldct 1;		;		shp+	| fetch r[16] for next point
    3ad  02 2c e 0 0 e1f0 004c  	btstw,s 0,r[16];	76->fpap;	;		;			| copy xf pt2 (before clip) to xf pt1 area
    3ae  0a 2e e 0 0 c382 0044  	mov2nw 1,r[2];		68->fpdp;	;		;			| 
    3af  02 00 3 8 0 d850 0398  	movw,s r[16],y;	;		cjp,~zer xf1stpt2; ;			| Will check if last point if jump.
    3b0  02 3b e 0 0 c1e2 0000  	sub2nw,s 0,r[2];	fpregh->fpregh;	;		;			| jump if 2nd point is a movw
    3b1  0b 3b 3 0 8 7140 03a1  xfswap2: ;			fpregl->fpregl;	cjp,zer xf2ndpt2; ;		adp+	| increment a & d pointers
    3b2  02 3b 3 7 0 c1e2 03b1  	sub2nw,s 0,r[2];	fpregh->fpregh;	cjp,go xfswap2; ;			| loop
                                |	incw r[30],r[30];	;		jmap XF_LINE_INT_2D;			| r[30] points to first element of r[16]			
                                XF_LINE_INT_2D: 
    3b3  0a 00 1 7 0 7140 038e  	;			;		cjs,go xfln2dinit; ;			| 
    3b4  0a 0e 1 7 0 cd8f 0080  xf1stpt2i: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			| r[15]=64, 0 pt1 x,y to here
    3b5  0a 27 e 0 0 9e9e 0005  	addw d,r[30],r[30];	5->am;		;		;			| r[30] += 5
    3b6  0a 00 3 1 0 7140 0027  	;			;		cjp,neg getcmd; ;			| return if was last pt
    3b7  02 17 c 0 2 e190 0001  	btstw,s 0,d;		shmem->am;	ldct 1;		;		shp+	| r[16] for second point
    3b8  02 00 3 8 0 d8d0 03b4  	movw,s d,r[16];	;		cjp,~zer xf1stpt2i; ;			| jump if 2nd point is a 0.
    3b9  08 00 e 0 e c5cf 0000  	add2nw 2,r[15],r[14];	;		;		;			| r[14]=68, want xf pt1 x,y,z,r[20] here
    3ba  0a 0d 1 7 0 e996 045d  	mov2nw 4,y;		am->fpbp;	cjs,go xfint2; ;			| matrix ptr in fpap; convert to int & xform 1st point
    3bb  0a 00 e 0 0 c5cf 0000  	add2nw 2,r[15];		;		;		;			| r[15] = 68
    3bc  0a 00 e 0 0 c5ce 0000  	add2nw 2,r[14];	;		;		;			| r[14] = 72
    3bd  0a 2d e 0 0 7140 0010  xf2ndpt2i: ;			16->fpbp;	;		;			| 0 pt2 x,y,z coords to fpr[66]
    3be  0a 0e 1 7 0 c3ef 0080  	sub2nw 1,r[15];		am->fpdp;	cjs,go shm_to_fpr; ;			| r[15] = 66, fetch pt2 x,y,z & store here
    3bf  0a 00 1 7 0 c3ee 045d  	sub2nw 1,r[14];	;		cjs,go xfint2; ;			| r[14] = 70, convert 2nd pt to int & xform to here
    3c0  0a 2e e 0 0 7140 004c  	;			76->fpdp;	;		;			| store xformed, unclipped pt2 at fpr[76]
    3c1  0a 2c e 0 0 c382 0046  	mov2nw 1,r[2];		70->fpap;	;		;			| xformed pt2 is currently at fpr[70]
    3c2  02 3b e 0 0 c1e2 0000  xfsvpt2i: sub2nw,s 0,r[2];	fpregh->fpregh;	;		;			| 
    3c3  03 3b 3 8 8 d84b 03c2  	movw,s r[11],y;	fpregl->fpregl;	cjp,~zer xfsvpt2i; ;		adp+	| increment a & d pointers, loop till done
    3c4  02 0c 1 8 0 c3cf 04dd  	add2nw,s 1,r[15];	am->fpap;	cjs,~zer clpvec2; ;			| r[15] = 68 (xf 1st pt.) clip vector if r[11]!=0;
                                											| also if no clip, force cc to ~zer so vec is drawn
    3c5  0a 00 1 8 0 c3ce 04ac  	add2nw 1,r[14];	;		cjs,~zer vwpsndvec2; ;			| r[14] = 72.  if visible, scale to viewport, cnvrt to
                                											| int, & xmit to PP
    3c6  02 27 e 0 0 d850 0005  	movw,s r[16],y;	5->am;		;		;			| test if just sent last vector
    3c7  0a 0f 3 1 0 9e9e 0027  	addw d,r[30],r[30];	am->shmemp;	cjp,neg getcmd;	;			| r[30] += 5 and exit if was last vector
    3c8  0a 17 c 0 2 d8d0 0001  	movw d,r[16];		shmem->am;	ldct 1;		;		shp+	| fetch r[16] for next point
    3c9  02 2c e 0 0 e1f0 004c  	btstw,s 0,r[16];	76->fpap;	;		;			| copy xf pt2 (before clip) to xf pt1 area
    3ca  0a 2e e 0 0 c382 0044  	mov2nw 1,r[2];		68->fpdp;	;		;			| 
    3cb  02 00 3 8 0 d850 03b4  	movw,s r[16],y;	;		cjp,~zer xf1stpt2i; ;			| Will check if last point if jump.
    3cc  02 3b e 0 0 c1e2 0000  	sub2nw,s 0,r[2];	fpregh->fpregh;	;		;			| jump if 2nd point is a movw
    3cd  0b 3b 3 0 8 7140 03bd  xfswap2i: ;			fpregl->fpregl;	cjp,zer xf2ndpt2i; ;		adp+	| increment a & d pointers
    3ce  02 3b 3 7 0 c1e2 03cd  	sub2nw,s 0,r[2];	fpregh->fpregh;	cjp,go xfswap2i; ;			| loop
                                |	negw d,r[10];		shmem->am;	jmap XFVEC_2D;	;
    3cf  0a 0f 1 7 0 d85d 02bc  XFVEC_2D: movw r[29],y;	am->shmemp;	cjs,go vec_attr;;
    3d0  0a 0f c 0 0 d849 0005  	movw r[9],y;	am->shmemp;	ldct 5;		;
    3d1  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    3d2  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    3d3  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;
    3d4  0a 0e 1 7 0 eb96 0080  xfv2D2:	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr; ;			  | move viewport parameters to fpr[32]
    3d5  0a 0f c 0 0 c3de 0003  	add2nw 1,r[30];	am->shmemp;	ldct 3;		;
    3d6  0a 0e 1 7 0 cd8f 0080  nxtvec2: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr;;			  | move vector endpoints to fpr[64]
    3d7  02 2d e 0 0 d84b 0010  	movw,s r[11],y;	16->fpbp;	;		;			  | r[11]==0? (xf2 doesn't affect cc's)
    3d8  08 00 1 7 e c5cf 046c  	add2nw 2,r[15],r[14];	;		cjs,go xf2;	;			  | want transformed endpoints at fpr[68]
                                											  | transform 1st point
    3d9  0a 2d e 0 0 c3cf 0010  	add2nw 1,r[15];		16->fpbp;	;		;
    3da  0a 00 1 7 0 c3ce 046c  	add2nw 1,r[14];	;		cjs,go xf2;	;			  | transform 2nd point
    3db  02 0c 1 8 0 c3cf 04dd  	add2nw,s 1,r[15];	am->fpap;	cjs,~zer clpvec2;;			  | clip vector if r[11]!=0, also if no
                                											  | clip force cc to ~zer so vec is drawn
    3dc  0a 00 1 8 0 c3ce 04ac  	add2nw 1,r[14];	;		cjs,~zer vwpsndvec2;;			  | if visible, scale to viewport, cnvrt to
                                											  | int, & xmit to PP
    3dd  02 00 c 0 0 dd6a 0003  	incw,s r[10],r[10];	;		ldct 3;		;			  | reload 2910 R reg, incr vector loop ctr
    3de  0a 0f 3 8 0 c7de 03d6  	add2nw 3,r[30];	am->shmemp;	cjp,~zer nxtvec2;;			  | r[30] += 8 and loop if more vectors
    3df  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |   mulptinit2 does necessary initialization for the int & float mulpt routines.
                                mulptinit2: 
    3e0  0a 28 e 0 0 949d 0001  	addw r[29],5,y; 1->brreg; ;		;			  | brreg <- 1
    3e1  0a 0f e 0 0 0005 0000  	;			am->shmemp;	;		;			  | shmemp <- addr of r[9]
    3e2  0a 1f c 0 0 c38e 0005  	mov2nw 1,r[14];	shmem->shmemp;	ldct 5;		;			  | shmemp <- addr of matrix; r[14] <- 2
    3e3  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    3e4  1a 0f c 0 0 c3de 0000  	add2nw 1,r[30];	am->shmemp;	ldct;		;			  | shmemp <- (r[30] += 2), addr of 1st pt
    3e5  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			| 
                                |	negw d,r[10];		shmem->am;	jmap MUL_POINT_FLT_2D;;			  | r[10] <- -npts
                                MUL_POINT_FLT_2D:
    3e6  0a 00 1 7 0 7140 03e0  	;			;		cjs, go mulptinit2; ;			  | do initialization for mulpt2 routines
    3e7  0a 0e 1 7 0 d90f 0080  xfpt2nxt: movw 0,r[15];		am->fpdp;	cjs,go shm_to_fpr;;			  | move pt[i] to fpr[0]
    3e8  0a 0d 1 7 0 e996 046c  	mov2nw 4,y;		am->fpbp;	cjs,go xf2;	;			  | xform pt and store result at fpr[2]
    3e9  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- addr of pt
    3ea  12 2c 4 7 0 dd6a 0002  	incw,s r[10],r[10];	2->fpap;	push,go;	;			  | r[10] += 1; fpap <- addr of xformed pt
    3eb  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move xformed pt to shared memory,
    3ec  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | overwriting original pt
    3ed  1a 27 c 0 0 9e9e 0005  	addw d,r[30],r[30];	5->am;		ldct;		;			  | r[30] += 5, addr of pt[i+1]
    3ee  0a 0a 3 8 2 f900 03e7  	movw 0,y;		am->shmem;	cjp,~zer xfpt2nxt;;		shp+	  | flag[i] <- 0, indicating xform done
                                											  | loop back for next pt;shmemp == &pt[i+1]
    3ef  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                											  | 2-D Matrix Multiply: C = A x B
                                |	negw d,r[10];		shmem->am;	jmap MUL_POINT_INT_2D;;			  | r[10] <- -npts
                                MUL_POINT_INT_2D:
    3f0  0a 00 1 7 0 7140 03e0  	;			;		cjs, go mulptinit2; ;			  | do initialization for mulpt2 routines
    3f1  0a 0e 1 7 0 d90f 0080  xfpt2nxti: movw 0,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			  | move pt[i] to fpr[0]
    3f2  0a 0d 1 7 0 e996 045d  	mov2nw 4,y;		am->fpbp;	cjs,go xfint2;	;			  | xform pt and store result at fpr[2]
    3f3  08 00 1 7 f d96e 044e  	movw r[14],r[15];	;		cjs,go fltoint2; ;			  | convert float res to int, need r[15]
    3f4  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- addr of pt
    3f5  12 2c 4 7 0 dd6a 0002  	incw,s r[10],r[10];	2->fpap;	push,go;	;			  | r[10] += 1; fpap <- addr of xformed pt
    3f6  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move xformed pt to shared memory,
    3f7  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | overwriting original pt
    3f8  1a 27 c 0 0 9e9e 0005  	addw d,r[30],r[30];	5->am;		ldct;		;			  | r[30] += 5, addr of pt[i+1]
    3f9  0a 0a 3 8 2 f900 03f1  	movw 0,y;		am->shmem;	cjp,~zer xfpt2nxti;;		shp+	  | flag[i] <- 0, indicating xform done
                                											  | loop back for next pt;shmemp == &pt[i+1]
    3fa  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |	negw d,r[10];		shmem->am;	jmap PROC_LINE_INT_2D;;
                                PROC_LINE_INT_2D:
    3fb  0a 27 e 0 0 d8c5 0851  	movw d,r[5];		=xfint3->am;	;		;			  | set ptr to fixtofloat routine
    3fc  0a 00 3 7 0 7140 03fe  	;			;		cjp,go cwdvec2;	;			  | and fall through to xf3. otherwise
                                											  | use regular float routine
                                |	negw d,r[10];		shmem->am;	jmap PROC_LINE_FLT_2D;;
                                PROC_LINE_FLT_2D:
    3fd  0a 27 e 0 0 d8c5 0862  	movw d,r[5];		=xf3->am;	;		;			  | set ptr to regular xf3 routine
    3fe  0a 27 e 0 0 869d 0004  cwdvec2: addw d,r[29],acc;	 4->am; ;		;			  | 
    3ff  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
    400  0a 17 c 0 2 d8cb 0001  	movw d,r[11];	shmem->am;	ldct 1;		;		shp+	  | save r[11]
    401  0a 1f 1 7 0 d906 042b  	movw 0,r[6];	shmem->shmemp;	cjs,go expmtrx;	;			  | shmemp <- r[9]
    402  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    403  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;			  | shmemp <- addr of vwp params
    404  0a 0e 1 7 0 eb96 0428  	mov2nw 5,y;		am->fpdp;	cjs,go expvwp;	;			  | move viewport parameters to fpr[32]
    405  0a 0f c 0 0 c3de 0001  	add2nw 1,r[30];	am->shmemp;	ldct 1;		;
                                cwnnxtvec2:
    406  0a 0e 1 7 2 cd8f 0080  	mov2nw 6,r[15];		am->fpdp;	cjs,go shm_to_fpr; ;		shp+	  | move pt1 x,y coords to fpr[64]
    407  0a 0b e 0 0 f900 0000  	movw 0,y;		am->fpregh;	;		;			  | expand pt1 with z=0
    408  0b 0b e 0 6 f900 0000  	movw 0,y;		am->fpregl;	;		;		dp+	  | z->fpr[66]
    409  0a 2b e 0 0 7140 3f80  	;			0x3F80->fpregh;	;		;			  | w1 = 1.0
    40a  0b 0b c 0 6 f900 0001  	movw 0,y;		am->fpregl;	ldct 1;		;		dp+	  | ldct 2 into 2910 counter
    40b  02 00 1 7 0 d84b 0080  	movw,s r[11],y;	;		cjs,go shm_to_fpr; ;			  | move pt2 x,y,z coords to fpr[68]
                                											  | r[11]==0? (xf3 doesn't affect cc's)
    40c  0a 0b e 0 0 f900 0000  	movw 0,y;		am->fpregh;	;		;			  | expand pt2 with z=0
    40d  0b 0b e 0 6 f900 0000  	movw 0,y;		am->fpregl;	;		;		dp+	  | z->fpr[70]
    40e  0a 00 1 7 0 7140 07e3  	;			;		cjs,go cwn3;	;			  | 
    40f  02 00 e 0 0 e1e6 0000  cwnout2: btstw,s 0,r[6];	;		;		;			  | test if invisible
    410  0a 00 3 8 0 7140 0425  	;			;		cjp,~zer cwnnovec2; ;			  | if so get next vector
    411  2b 0c e 0 0 d844 0230  	movw r[4],y;	am->fpap;	;		lmode rn,ai,pipe,fast;	  | fpap <- &x0; pipeline mode
    412  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | convert x0 to integer
    413  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+
    414  2a 00 e 0 0 f8e0 00e0  	movw 76,y;		;		;		fixa,la,hi;		  | y0
    415  2b 0c e 0 0 004c 00e0  	;			am->fpap;	;		;			  | fpap <- &x1
    416  2a 00 e 0 0 f8e0 00e0  	movw 3,y;		;		;		fixa,la,hi;		  | x1
    417  2b 08 e 0 4 0003 00e0  	;			am->brreg;	;		;		ap+	  | brreg <- 3
    418  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | y1
    419  2b 00 e 0 0 7140 00e0  	;			;		;		;			  | 
    41a  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		  | 
    41b  3b 0e 4 7 0 f900 0122  	movw 0,y;		am->fpdp;	push,go;	;			  | fpdp <- 0; 2910 R reg <- 3
    41c  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store x0,y0,x1,y1 starting
    41d  3b 0c 8 0 6 f900 0123  	movw 0,y;		am->fpap;	rfct;		;		dp+	  | fpreg[0]; fpap <- 0
    41e  1a 27 4 7 0 9e9e 0009  	addw d,r[30],r[30];	9->am;		push,go;	;			  | r[30] += 9
    41f  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | overwrite original coords in shmem
    420  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
                                cwnloop2:
    421  0a 0a e 0 2 f900 0000  	movw 0,y;		am->shmem;	;		;		shp+	  | dataready[i] <- 0;shmemp <- nxt vec addr
    422  02 00 c 0 0 dd6a 0001  	incw,s r[10],r[10];	;		ldct 1;		;			  | reload 2910 R reg; incr vec loop cntr
    423  0a 00 3 8 0 dd7e 0406  	incw r[30],r[30];	;		cjp,~zer cwnnxtvec2;;			  | r[30] += 1 and loop if more vectors
    424  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                cwnnovec2:
    425  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- &resultflag[i]
    426  0a 2a e 0 0 9c9e ffff  	addw r[30],9,r[30];	0xFFFF->shmem;	;		;			  | resultflag for this vector <- 0xFFFF
    427  0a 0f 3 7 0 0009 0421  	;			am->shmemp;	cjp,go cwnloop2; ;			  | shmemp <- r[30] <- &dataready[i]
    428  0a 00 1 7 0 7140 0080  expvwp:	;			;		cjs,go shm_to_fpr; ;			  | move 2D viewport in
    429  0a 00 c 0 0 7140 0001  	;			;		ldct 1;		;			  | move 0 into z scale and offset for 3D
    42a  0a 00 3 7 0 7140 0439  	;			;		cjp,go expzero;	;			  | return directly to calling routine
                                expmtrx:
    42b  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr; ;			  | move 2D matrix to fpr[16]
    42c  0a 00 c 0 0 7140 0001  	;			;		ldct 1;		;			  | move 0 into 13 14
    42d  0a 00 1 7 0 7140 0439  	;			;		cjs,go expzero;	;			  | 
    42e  0a 00 c 0 0 7140 0001  	;			;		ldct 1;		;			  | 
    42f  0a 00 1 7 0 7140 0080  	;			;		cjs,go shm_to_fpr; ;			  | move 2D matrix to fpr[20]
    430  0a 00 c 0 0 7140 0005  	;			;		ldct 5;		;			  | move 0 into 23 24
    431  0a 00 1 7 0 7140 0439  	;			;		cjs,go expzero;	;			  |       31 32 33 34
    432  0a 00 c 0 0 7140 0001  	;			;		ldct 1;		;			  | 
    433  0a 00 1 7 0 7140 0080  	;			;		cjs,go shm_to_fpr; ;			  | move 2D matrix to fpr[28]
    434  0a 0b e 0 0 f900 0000  	movw 0,y;		am->fpregh;	;		;			  | 
    435  0b 0b e 0 6 f900 0000  	movw 0,y;		am->fpregl;	;		;		dp+	  | move 0 into 43
    436  0a 2b e 0 0 7140 3f80  	;			0x3f80->fpregh;	;		;			  | move 1 into    44
    437  1b 0b a 7 6 f900 0000  	movw 0,y;		am->fpregl;	crtn,go;	;		dp+	  | 
    438  0b 0b e 0 6 f900 0000  	movw 0,y;		am->fpregl;	;		;		dp+	| 
    439  0a 0b 9 0 0 f900 0438  expzero: movw 0,y;		am->fpregh;	rpct .-1;	;			| 
    43a  1b 0b a 7 6 f900 0000  	movw 0,y;		am->fpregl;	crtn,go;	;		dp+	| 
                                |	rolw 5,d,acc;		shmem->am;	jmap MATMUL_2D;	;		shp+	  | acc <- indexA*32
                                MATMUL_2D:
    43b  0a 17 e 0 2 aa20 0000  	rolw 5,d,r[0];		shmem->am;	;		;		shp+	  | r[0] <- indexB*32
    43c  0a 17 e 0 0 aa21 0000  	rolw 5,d,r[1];		shmem->am;	;		;			  | r[1] <- indexC*32
    43d  0a 27 e 0 0 e281 0040  	addw d,acc,acc;		 64->am;;		;
    43e  0a 0f c 0 0 909d 0005  	addw r[29],acc,y;	am->shmemp;	ldct 5;		;			  | shmemp <- addr of matrix A
    43f  0a 0e 1 7 0 c98f 0080  	mov2nw 4,r[15];		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix A to fpr[16]
    440  0a 27 e 0 0 8680 0040  	addw d,r[0],acc;	 64->am;;		;
    441  0a 0f c 0 0 909d 0005  	addw r[29],acc,y;	am->shmemp;	ldct 5;		;			  | shmemp <- addr of matrix B
    442  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix B to fpr[32]
    443  0a 0d e 0 0 eb96 0000  	mov2nw 5,y;		am->fpbp;	;		;			  | fpbp <- addr of matrix B (in fpr)
    444  0a 00 1 7 0 cd8e 048f  	mov2nw 6,r[14];	;		cjs,go xf2_noxl;;			  | r[14] <- addr of matrix C (fpr[64])
                                											  | r[15] == addr of 1st row of matrix A
                                											  | xf2_noxl produces 1st row of matrix C 
                                											  | xf2_noxl uses no translation terms, so
                                											  | we have the effect of the third element
                                											  | of the A row vector being 0.0
    445  0a 2d e 0 0 c3cf 0020  	add2nw 1,r[15];		32->fpbp;	;		;
    446  0a 00 1 7 0 c3ce 048f  	add2nw 1,r[14];	;		cjs,go xf2_noxl;;			  | produce 2nd row of matrix C
    447  0a 2d e 0 0 c3cf 0020  	add2nw 1,r[15];		32->fpbp;	;		;
    448  0a 00 1 7 0 c3ce 046c  	add2nw 1,r[14];	;		cjs,go xf2;	;			  | produce 3rd row of matrix C
                                											  | xf2 does use the translation terms, so
                                											  | we have the effect of the third element
                                											  | of the A row vector being 1.0
    449  0a 2c e 0 0 8681 0040  	addw d,r[1],acc;	64->fpap;	;		;			  | fpap <- addr of matrix C (in fpr)
    44a  0a 0f 4 7 0 909d 0005  	addw r[29],acc,y;	am->shmemp;	push,go 5;	;			  | shmemp <- addr of matrix C (in shmem)
                                											  | d still has XFORM_FRMOFF
    44b  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move matrix C to shmem
    44c  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
    44d  0a 00 2 0 0 c5de 0027  	add2nw 2,r[30],r[30];	;		jmap getcmd;	;			  | r[30] += 4; jump to r[0] loop
                                |	fltoint2 -- 2D conversion from float to int.  Operates on a single point and converts
                                |   	            the points in place, ie, overwrites the original floating point value.
                                |
                                |	Input Parameters:	r[15] -- Location of point to be converted.
    44e  2b 0c e 0 0 d84f 0230  fltoint2: movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	| 
    44f  2a 0e e 0 0 d84f 00e0  	movw r[15],y;		am->fpdp;	;		fixa,la,hi;		| convert x to int
    450  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    451  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		| convert y to int	
    452  2b 00 e 0 0 7140 00e0  	;			;		;		;			| 
    453  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;			| 
    454  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    455  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;			| 
    456  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    457  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		| 
    458  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    459  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		| overwrite x
    45a  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    45b  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		| overwrite x
    45c  3b 00 a 7 0 7140 0101  	;			;		crtn, go;	;			| 
                                |	xfint2 -- convert point from fix to float and fall through to xf2
                                |
                                |	Important Properties:	Does not use brreg; Does not use 2910 R register (counter)
                                |				Does not change latched 29116 condition code status
                                |
    45d  2b 0c e 0 0 d84f 0230  xfint2:	movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;
    45e  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | x
    45f  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    460  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | y
    461  2b 00 e 0 0 7140 00a0  	;			;		;		;
    462  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    463  2b 00 e 0 0 7140 0120  	;			;		;		;
    464  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    465  2b 00 e 0 0 7140 0120  	;			;		;		;
    466  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    467  2b 0e e 0 0 d84f 0122  	movw r[15],y;		am->fpdp;	;		;
    468  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite x
    469  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    46a  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | overwrite y
    46b  2b 00 e 0 0 7140 0101  	;			;		;		;			  | fall through to xf2
                                |	xf2 -- 2-D floating point transform
                                |
                                |	Input Parameters:	r[15] -- Address of input point
                                |				r[14] -- Address of output point
                                |				matrix -- fpbp should have been loaded
                                |					  with the address of the matrix
                                |					  prior to calling this routine.
                                |					  A 3x2 matrix.  3rd column is
                                |					  assumed to be 0,0,1.
    46c  2b 0c e 0 0 d84f 0230  xf2:	movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;
    46d  2a 0e e 0 0 d84e 0010  	movw r[14],y;		am->fpdp;	;		maba,lab,hi;		  | x*m11
    46e  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    46f  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x*m12
    470  2b 00 e 0 7 7140 0010  	;			;		;		;		abp+
    471  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y*m21
    472  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    473  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y*m22
    474  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    475  2a 00 e 0 0 7140 0124  	;			;		;		adda,la,m,hi;
    476  2b 00 e 0 0 7140 0124  	;			;		;		;
    477  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (x*m11)+m31
    478  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    479  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (x*m12)+m32
    47a  2b 00 e 0 0 7140 011c  	;			;		;		;
    47b  2a 0d e 0 0 d84e 0125  	movw r[14],y;		am->fpbp;	;		adda,la,m,st,hi;		  | store y*m21
    47c  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+
    47d  2a 00 e 0 0 7140 0121  	;			;		;		adda,la,st,hi;		  | store y*m22
    47e  2b 00 e 0 0 7140 0121  	;			;		;		;
    47f  2a 0e e 0 0 d84e 0122  	movw r[14],y;		am->fpdp;	;		adda,la,a,hi;
    480  2b 00 e 0 0 7140 0122  	;			;		;		;
    481  2a 00 e 0 0 7140 011a  	;			;		;		addr,lab,a,hi;		  | ((x*m11)+m31)+(y*m21)
    482  2b 00 e 0 5 7140 011a  	;			;		;		;		bp+
    483  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | ((x*m12)+m32)+(y*m22)
    484  2b 00 e 0 0 7140 0118  	;			;		;		;
    485  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    486  2b 00 e 0 0 7140 0120  	;			;		;		;
    487  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    488  2b 00 e 0 0 7140 0120  	;			;		;		;
    489  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    48a  2b 00 e 0 0 7140 0122  	;			;		;		;
    48b  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store new x
    48c  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    48d  2a 00 e 0 0 7140 0121  	;			;		;		adda,la,st,hi;		  | store new y
    48e  3b 00 a 7 0 7140 0121  	;			;		crtn,go;	;
    48f  2b 0c e 0 0 d84f 0230  xf2_noxl: movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;
    490  2a 0e e 0 0 d84e 0010  	movw r[14],y;		am->fpdp;	;		maba,lab,hi;		  | x*m11
    491  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    492  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x*m12
    493  2b 00 e 0 7 7140 0010  	;			;		;		;		abp+
    494  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y*m21
    495  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    496  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y*m22
    497  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    498  2a 00 e 0 0 7140 0124  	;			;		;		adda,la,m,hi;
    499  2b 00 e 0 0 7140 0124  	;			;		;		;
    49a  2a 00 e 0 0 7140 0125  	;			;		;		adda,la,m,st,hi;		  | store x*m11
    49b  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+
    49c  2a 00 e 0 0 7140 0125  	;			;		;		adda,la,m,st,hi;		  | store x*m12
    49d  2b 0d e 0 0 d84e 0125  	movw r[14],y;		am->fpbp;	;		;
    49e  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (x*m11)+y*m21
    49f  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    4a0  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | (x*m12)+y*m22
    4a1  2b 00 e 0 0 7140 0118  	;			;		;		;
    4a2  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    4a3  2b 00 e 0 0 7140 0120  	;			;		;		;
    4a4  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    4a5  2b 00 e 0 0 7140 0120  	;			;		;		;
    4a6  2a 0e e 0 0 d84e 0122  	movw r[14],y;		am->fpdp;	;		adda,la,a,hi;
    4a7  2b 00 e 0 0 7140 0122  	;			;		;		;
    4a8  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store new x
    4a9  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    4aa  2a 00 e 0 0 7140 0121  	;			;		;		adda,la,st,hi;		  | store new y
    4ab  3b 00 a 7 0 7140 0121  	;			;		crtn,go;	;
                                |	vwpsndvec2 -- scale 2-D vector to viewport, convert floating point
                                |		      coordinates to integer, and send to Painting Processor
                                |		      input vectors are in NDC, i.e. clipped vectors will have
                                |		      -1.0 <= x,y <= +1.0
                                |
                                |	Input Parameters:	fpap -- points to coords to be converted
                                |				r[14] -- points to a place to deposit the converted coords
                                |
    4ac  2b 0d e 0 0 eb86 0230  vwpsndvec2: mov2nw 5,acc;	am->fpbp;	;		lmode rn,ai,pipe,fast;	  | fpbp pts to viewport params
    4ad  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x0 * VWPXSCL
    4ae  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    4af  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y0 * VWPYSCL
    4b0  2b 0d e 0 4 e385 0010  	sub2nw 1,acc;		am->fpbp;	;		;		ap+
    4b1  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x1 * VWPXSCL
    4b2  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    4b3  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y1 * VWPYSCL
    4b4  2b 0d e 0 0 e185 0010  	sub2nw 0,acc;		am->fpbp;	;		;
                                											  | can arrive here from above for 2-D vecs
                                											  | or from vwpsndvec3 for 3-D vecs
    4b5  2a 00 e 0 0 f8e0 0124  vwpsv2:	movw =wrfifo,y;		;		;		adda,la,m,hi;
    4b6  2b 08 e 0 0 007d 0124  	;			am->brreg;	;		;
    4b7  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (x0 * VWPXSCL) + VWPXOFF
    4b8  2b 0d e 0 0 e384 011c  	add2nw 1,acc;		am->fpbp;	;		;
    4b9  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (y0 * VWPYSCL) + VWPYOFF
    4ba  2b 0d e 0 0 e385 011c  	sub2nw 1,acc;		am->fpbp;	;		;
    4bb  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (x1 * VWPXSCL) + VWPXOFF
    4bc  2b 0d e 0 0 e384 011c  	add2nw 1,acc;		am->fpbp;	;		;
    4bd  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | (y1 * VWPYSCL) + VWPYOFF
    4be  3b 06 1 c 0 d811 0118  	movw r[17],acc;	am->fifo1;	cjs,f1f;	;			  | send vector command
    4bf  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    4c0  2b 00 e 0 0 7140 0122  	;			;		;		;
    4c1  2a 00 e 0 0 7140 00ea  	;			;		;		fixr,la,a,hi;		  | convert x0 to int
    4c2  2b 00 e 0 0 7140 00ea  	;			;		;		;
    4c3  2a 00 e 0 0 7140 00ea  	;			;		;		fixr,la,a,hi;		  | convert y0 to int
    4c4  2b 00 e 0 0 7140 00ea  	;			;		;		;
    4c5  2a 00 e 0 0 7140 00ea  	;			;		;		fixr,la,a,hi;		  | convert x1 to int
    4c6  2b 00 e 0 0 7140 00ea  	;			;		;		;
    4c7  2a 00 e 0 0 7140 00e8  	;			;		;		fixr,la,hi;		  | convert y1 to int
    4c8  2b 00 e 0 0 7140 00e8  	;			;		;		;
    4c9  2a 0e e 0 0 d84e 0122  	movw r[14],y;		am->fpdp;	;		adda,la,a,hi;
    4ca  2b 0c e 0 0 d84e 0122  	movw r[14],y;		am->fpap;	;		;
    4cb  2a 00 e 0 0 d8e0 0123  	movw =fifofull,r[0];	;		;		adda,la,a,st,hi;
    4cc  2b 08 e 0 6 04d5 0123  	;			am->brreg;	;		;		dp+
    4cd  2a 00 e 0 0 f8e1 0123  	movw 3,acc;		;		;		adda,la,a,st,hi;
    4ce  3b 36 3 c 6 0003 0123  	;			fpregl->fifo1;	cjp,f1f;	;		dp+	  | x0
    4cf  2a 08 e 0 4 c3c0 0123  	add2nw 1,r[0];		am->brreg;	;		adda,la,a,st,hi;	ap+
    4d0  3b 36 3 c 6 e185 0123  	sub2nw 0,acc;		fpregl->fifo1;	cjp,f1f;	;		dp+	  | y0
    4d1  2a 08 e 0 4 c3c0 0101  	add2nw 1,r[0];		am->brreg;	;		adda,st,hi;	ap+
    4d2  3b 36 3 c 0 e185 0101  	sub2nw 0,acc;		fpregl->fifo1;	cjp,f1f;	;			  | x1
    4d3  0a 00 c 0 4 7140 04db  	;			;		ldct sv2ret;	;		ap+
    4d4  0b 36 7 c 0 7140 04d4  sv2loop1: ;			fpregl->fifo1;	jrp,f1f sv2loop1;;			  | y1
    4d5  2a 00 e 0 0 7140 0123  fifofull: ;			;		;		adda,la,a,st,hi;
    4d6  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    4d7  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;
    4d8  2b 00 e 0 0 7140 0101  	;			;		;		;
    4d9  03 36 3 c 0 f880 04d9  sv2loop2: movw,s acc,y;		fpregl->fifo1;	cjp,f1f sv2loop2;;
    4da  0a 00 3 8 4 e185 04d9  	sub2nw 0,acc;		;		cjp,~zer sv2loop2;;		ap+
    4db  0a 00 1 7 0 d80d 007d  sv2ret:	movw r[13],acc;		;		cjs,go wrfifo;	;			  | now send r[13] and r[12]
    4dc  0a 00 3 7 0 d80c 007d  	movw r[12],acc;		;		cjp,go wrfifo;	;			  | return to calling routine from wrfifo
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)clpvec2.vp.u 1.2 86/09/12 SMI
                                |	clpvec2 -- clip a 2-D vector to a normalized window (-1.0 <= x,y <= 1.0)
                                |
                                |	Input Parameters:	r[15],fpap -- Address of vector to be clipped (N.B.: fpap must be set to r[15] prior to call)
                                |
                                |
                                |	Output:		clipped vector endpoints are written over input points
                                |			return with r[15]==fpap if vector is visible
                                |			Am29116 Z condition flag Z: 0 (2910 branch condition ~zer) => all or part of input vector is visible
                                |						    1 (2910 branch condition  zer) => input vector is not visible
                                |
    4dd  2b 0e e 0 0 f900 0230  clpvec2: movw 0,y;		am->fpdp;	;		lmode rn,ai,pipe,fast;	  | fpreg's 0-15 are scratch memory
    4de  08 2b e 0 4 9deb 3f80  	rolw 14,r[11],r[4];0x3F80->fpregh;;		;			  | fpreg[0] = 1.0
    4df  0b 2b e 0 0 7140 0000  	;			0x0->fpregl;	;		;			  | r[4] is 2-D version of r[11]
    4e0  0a 2d e 0 0 7140 0000  	;			0->fpbp;	;		;			  | i.e. L|R|B|T is bits 3|2|1|0
    4e1  2a 08 e 0 0 e396 0110  	mov2nw 1,y;		am->brreg;	;		adda,lab,hi;		  | wec0_left = 1.0 + x0
    4e2  3b 00 c 0 0 7140 0110  	;			;		ldct;		;			  | Am2910 R reg <- 2 (used below)
    4e3  2a 00 e 0 0 948f 01a0  	addw r[15],2,y;		;		;		rsuba,la,hi;		  | wec0_right = 1.0 - x0
    4e4  2b 0d e 0 4 0002 01a0  	;			am->fpbp;	;		;		ap+	  | fpbp <- &x1 (used at next lab)
    4e5  2a 00 e 0 0 db06 0120  	compw 0,r[6];	;		;		adda,la,hi;		  | wec0_bottom = 1.0 + y0
    4e6  2b 00 e 0 0 fb01 0120  	compw 0,acc;	;		;		;
    4e7  2a 00 e 0 0 f8e0 01a0  	movw =reject2,y;	;		;		rsuba,la,hi;		  | wec0_top = 1.0 - y0
    4e8  2b 08 e 0 4 0522 01a0  	;			am->brreg;	;		;		ap+
    4e9  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		  | wec1_left = 1.0 + x1
    4ea  2b 00 e 0 0 7140 0122  	;			;		;		;
    4eb  2a 00 e 0 0 7140 01a3  	;			;		;		rsuba,la,a,st,hi;	  | wec1_right = 1.0 - x1, store wec0_left
    4ec  2b 31 e 0 8 6e00 01a3  	sl0b d,y;		fpstreg->am;	;		;		adp+
    4ed  2a 00 e 0 0 cc46 0123  	slqw r[6],r[6];	;		;		adda,la,a,st,hi;	  | wec1_bottom = 1.0 + y1, store wec0_right
    4ee  2b 31 e 0 6 6e00 0123  	sl0b d,y;		fpstreg->am;	;		;		dp+
    4ef  2a 00 e 0 0 cc46 01a3  	slqw r[6],r[6];	;		;		rsuba,la,a,st,hi;	  | wec1_top = 1.0 - y1, store wec0_bottom
    4f0  2b 0c e 0 6 d84f 01a3  	movw r[15],y;		am->fpap;	;		;		dp+
    4f1  2a 31 e 0 0 6e00 0193  	sl0b d,y;		fpstreg->am;	;		rsuba,lab,a,st,hi;	  | dx = x1 - x0, store wec0_top
    4f2  2b 00 e 0 a cc46 0193  	slqw r[6],r[6];	;		;		;		abdp+
    4f3  2a 31 e 0 0 6e00 0192  	sl0b d,y;		fpstreg->am;	;		rsuba,lab,a,hi;		  | dy = y1 - y0
    4f4  3b 00 4 f 0 cc46 0192  	slqw r[6],r[6];	;		push,~go;	;
    4f5  2a 31 e 0 0 6e00 0122  	sl0b d,y;		fpstreg->am;	;		adda,la,a,hi;		  | rpt 3 times for acc L,R, & B bits
    4f6  3b 00 8 0 0 ec41 0122  	slqw acc,acc;	;		rfct;		;
    4f7  2a 31 e 0 0 6e00 0123  	sl0b d,y;		fpstreg->am;	;		adda,la,a,st,hi;		  | acc T bit & store dx
    4f8  2b 00 e 0 6 ec41 0123  	slqw acc,acc;	;		;		;		dp+
    4f9  2a 07 e 0 0 90e6 0101  	nandw r[6],acc,y; am->am;	;		adda,st,hi;		  | store dy
    4fa  21 00 e 0 5 9ec4 0101  	andw,s d,r[4],r[5];;		;		;			  | r[5] != 0 iff >= 1 pt outside window
    4fb  0a 07 3 0 0 9126 0523  	norw r[6],acc,y; am->am;	cjp,zer trivaccept2;;			  | trivial accept case
    4fc  02 2c e 0 0 96c4 0000  	andw,s d,r[4],y;	0->fpap;	;		;			  | result != 0 iff 2 pts outside >= 1 plane
    4fd  1a 2e 3 8 0 94c5 0000  	andw,s r[5],0xC,y;	0->fpdp;	cjp,~zer;	;			  | trivial reject case (=reject2 in brreg)
    4fe  02 37 e 0 4 000c 0000  	;			fpregh->am;	;		;		ap+	  | need -wec0_left & -wec0_bottom for
                                											  | intersection calculations below;
                                											  | computed the negatives above to make
                                											  | detection of outside points a simple fp
                                											  | sign bit test; otherwise would have to
                                											  | distinguish +0.0 from truly >0.0
    4ff  0a 0b e 0 8 ff94 0000  	add2nw 15,d,y;		am->fpregh;	;		;		adp+	  | negate wec0_left
    500  0a 37 e 0 0 c782 0000  	mov2nw 3,r[2];	fpregh->am;	;		;			  | store recips computed below at fpreg[8]
    501  0a 00 e 0 6 7140 0000  	;			;		;		;		dp+	  | hardware can't dp+ in previous cycle 
    502  0a 0b 3 8 0 ff94 0504  	add2nw 15,d,y;		am->fpregh;	cjp,~zer xrecip2;;			  | negate wec0_bottom and if line crosses
                                											  | an x plane, compute dx_recip
                                											  | r[5] bits indicate line crossings:
                                											  | L|R|B|T is 3|2|1|0
    503  0a 0c 3 7 0 e596 0507  	mov2nw 2,y;		am->fpap;	cjp,go yrecip2;	;			  | if line didn't cross an x plane and was
                                											  | not trivially accepted, it must cross a
                                											  | y plane
    504  0a 0c 1 7 0 e596 034c  xrecip2: mov2nw 2,y;		am->fpap;	cjs,go recip;	;			  | fpap<-&dx, r[2]<-&dx_recip (fpreg[8])
    505  02 27 e 0 0 96c5 0003  	andw,s d,r[5],y;	0x3->am;	;		;			  | chk for line crossing y planes
    506  0a 00 3 0 0 7140 0508  	;			;		cjp,zer t0t1_2;	;			  | if not, go compute intersections
    507  0a 00 1 7 4 dd62 034c  yrecip2: incw r[2],r[2];	;		cjs,go recip;	;		ap+	  | fpap<-&dy, r[2]<-&dy_recip (fpreg[9])
                                											  | have now computed dx_recip and dy_recip
                                											  | for the intersection calculations if the
                                											  | corresponding t values will be used
    508  2b 0c e 0 0 d904 0230  t0t1_2:	movw 0,r[4];		am->fpap;	;		lmode rn,ai,pipe,fast;	  | t0 = 0.0, param t value for line begin
    509  0a 2d e 0 0 d903 0008  	movw 0,r[3];		8->fpbp;	;		;			  | fpap <- &wec0's, fpbp <- &dx_recip
    50a  2a 00 e 0 0 d8e0 0010  	movw 0x3F80,r[0];	;		;		maba,lab,hi;		  | wec0_left * dx_recip (divide wec by dx)
    50b  2b 00 e 0 4 3f80 0010  	;			;		;		;		ap+	  | r[0] <- high order 1.0
    50c  28 00 e 0 2 d960 0020  	movw r[0],r[2];	;		;		maba,la,hi;		  | wec0_right * dx_recip
    50d  2b 0e e 0 7 d901 0020  	movw 0,r[1];		am->fpdp;	;		;		abp+	  | t1 = 1.0, param t value for line end
                                											  | fpdp<-0,store candidate t's at fpreg[0]
    50e  2a 00 e 0 0 f8e0 0010  	movw =intersect2,y;	;		;		maba,lab,hi;		  | wec0_bottom * dy_recip
    50f  2b 08 e 0 4 0545 0010  	;			am->brreg;	;		;		ap+	  | set up brreg for calls to intersect2
    510  2a 00 e 0 0 db66 0020  	compw r[6],r[6];;		;		maba,la,hi;		  | wec0_top * dy_recip; now r[6] bits
    511  2b 0c e 0 0 f900 0020  	movw 0,y;		am->fpap;	;		;			  | have same polarity as r[5] bits
    512  22 00 e 0 0 99e5 0124  	rolw,s 12,r[5],r[5];;		;		adda,la,m,hi;		  | L|R|B|T now 15|14|13|12, advance pipe
    513  33 00 1 1 0 99e6 0124  	rolw,s 12,r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses L plane
    514  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | R|B|T now 15|14|13, advance pipe
    515  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses R plane
    516  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | B|T now 15|14, advance pipe
    517  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses B plane
    518  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | T now 15, advance pipe
    519  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses T plane
                                											  | now t0 and t1 represent clipped
                                											  | endpoints iff t0 <= t1
    51a  02 0b e 0 0 d844 0000  newpts2: movw,s r[4],y;	am->fpregh;	;		;			  | fpreg[0] <- t0 & test r[4]==0 which
    51b  0b 0b e 0 6 d843 0000  	movw r[3],y;		am->fpregl;	;		;		dp+	  | implies t0==0.0 since fast Weitek mode
    51c  0a 0b e 0 0 d802 0000  	movw r[2],acc;		am->fpregh;	;		;			  | will not produce denormalized results
    51d  0b 0b 3 0 0 d841 0524  	movw r[1],y;		am->fpregl;	cjp,zer t0eq0_2;;			  | fpreg[1]<-t1 & jump if t0==0.0
    51e  02 2d e 0 0 9100 0004  	xorw,s r[0],acc,y;	4->fpbp;	;		;			  | fpbp<-&dx, test r[2] == high order 1.0
                                											  | which means t1 == 1.0, since t1 started
                                											  | at 1.0 and could only decrease
    51f  0b 37 3 0 0 9601 0525  vischk_2: subw d,r[1],y;	fpregl->am;	cjp,zer t1eq1_2;;			  | jump if t1==1.0, else check for t0>t1,
    520  02 37 e 0 0 9622 0000  	subcw,s d,r[2],y;	fpregh->am;	;		;			  | which means line is outside window
    521  0a 00 3 2 0 7140 0525  	;			;		cjp,cry twonewpts_2;;			  | jump on no borrow (t1 - t0 >= 0.0)
                                											  |
    522  12 00 a 7 0 f900 0000  reject2: movw,s 0,y;		;		crtn,go;	;			  | Z bit <- 1 (indicating rejection) & rtn
                                											  |
    523  12 0c a 7 0 d84f 0000  trivaccept2: movw,s r[15],y;	am->fpap;	crtn,go;	;			  | Z bit <- 0 (indicating acceptance),
                                											  | fpap <- r[15], and return
                                											  |
    524  0a 0d 3 7 4 e596 0529  t0eq0_2: mov2nw 2,y;		am->fpbp;	cjp,go t0eq0_2a;;		ap+	  | if t0 == 0.0, then the t0,t1 segment is
                                											  | visible since t1 >= 0.0; also, t1 != 1.0
                                											  | at this point since that would imply
                                											  | trivial acceptance; fpbp<-&dx,fpap<-&t1,
                                											  | & jump into the middle of the code to
                                											  | compute two new endpoints;  we arrange
                                											  | below to compute and store only the 2nd
                                											  | point, thus saving a few cycles
                                											  |
                                t1eq1_2: 										  | if t1 == 1.0, then the t0,t1 segment is
                                											  | visible since t0 <= 1.0; also, t0 != 0.0
                                											  | at this point since that would imply
                                											  | trivial acceptance; we fall into the
                                											  | code to compute two new endpoints, but
                                											  | arrange below to store only the 1st
                                											  | point, thus saving a few cycles
                                											  |
    525  2a 00 e 0 0 7140 0010  twonewpts_2: ;			;		;		maba,lab,hi;		  | t0 * dx
    526  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    527  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | t0 * dy
    528  2b 0d e 0 4 e596 0010  	mov2nw 2,y;		am->fpbp;	;		;		ap+
    529  2a 00 e 0 0 f8e0 0010  t0eq0_2a: movw =t0eq0_2b,y;	;		;		maba,lab,hi;		  | t1 * dx
    52a  2b 08 e 0 5 0541 0010  	;			am->brreg;	;		;		bp+
    52b  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | t1 * dy
    52c  2b 00 e 0 0 7140 0010  	;			;		;		;
    52d  2a 00 e 0 0 7140 0124  	;			;		;		adda,la,m,hi;
    52e  2b 0d e 0 0 d84f 0124  	movw r[15],y;		am->fpbp;	;		;			  | fpbp points to input pts
    52f  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | x0 + (t0 * dx)
    530  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    531  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | y0 + (t0 * dy)
    532  2b 0d e 0 0 d84f 011c  	movw r[15],y;		am->fpbp;	;		;
    533  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | x0 + (t1 * dx)
    534  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    535  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | y0 + (t1 * dy)
    536  2b 0e e 0 0 d84f 0118  	movw r[15],y;		am->fpdp;	;		;			  | will store new pts over old pts
    537  22 00 e 0 0 d844 0122  	movw,s r[4],y;		;		;		adda,la,a,hi;		  | goto t0eq0_2b if t0==0.0, to
    538  3b 00 3 0 0 7140 0122  	;			;		cjp,zer;	;			  | avoid overwriting x0 & y0
    539  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store x0'
    53a  2b 00 e 0 6 9502 0123  	xorw,s r[2],0x3F80,y;	;		;		;		dp+	  | test for t1==1.0
    53b  22 00 e 0 0 3f80 0123  	;			;		;		adda,la,a,st,hi;		  | store y0'
    53c  33 0c a 0 6 d84f 0123  	movw,s r[15],y;		am->fpap;	crtn,zer;	;		dp+	  | if t1==1.0, Z bit<-0,fpap<-r[15] & rtn
    53d  2a 00 e 0 0 7140 0123  t0eq0_2c: ;			;		;		adda,la,a,st,hi;		  | store x1'
    53e  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    53f  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store y1'
    540  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | return with Z bit==0 & fpap==r[15]
                                											  |
    541  2a 00 e 0 6 f8e0 0120  t0eq0_2b: movw =t0eq0_2c,y;	;		;		adda,la,hi;		dp+	  | pipe advance
    542  2b 08 e 0 6 053d 0120  	;			am->brreg;	;		;		dp+	  | increment dp to store x1'
    543  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    544  33 0c 3 7 0 d84f 0122  	movw,s r[15],y;		am->fpap;	cjp,go;		;			  | Z bit<-0,fpap<-r[15], and goto t0eq0_2c
                                											  |
                                											  |
    545  2a 00 e 0 0 7140 0101  intersect2: ;			;		;		adda,st,hi;		  | fpreg[0] <- candidate value
    546  2b 00 e 0 0 ff87 0101  	not2nw 15,acc;		;		;		;			  | acc <- 0x7FFF
    547  02 37 3 9 0 e2c1 054e  	andw,s d,acc,acc;	fpregh->am;	cjp,~neg updt1_2;;			  | update t0 or t1 based upon previously
                                											  | tested bit of r[6]; acc <- high
                                											  | order t & 0x7FFF (to convert -0.0 to
                                											  | +0.0,since t is guaranteed 0.0<=t<=1.0)
    548  0b 37 e 0 0 9603 0000  updt0_2: subw d,r[3],y;	fpregl->am;	;		;			  | compare t with t0 (t0 - t)
    549  02 00 e 0 0 9064 0000  	rsubcw,s r[4],acc,y;	;		;		;
    54a  02 00 3 2 0 ffc5 0554  	bclrw,s 15,r[5];	;		cjp,cry chkthru2;;			  | no borrow means t <= t0
    54b  0a 00 e 0 0 d884 0000  	movw acc,r[4];		;		;		;			  | else t0 <- t
    54c  0a 00 b 0 0 d8c3 051a  	movw d,r[3];		;		cjpp,zer newpts2;;			  | r[5]==0 -> no more intersections
    54d  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | else return to check next plane
    54e  0b 37 e 0 0 9641 0000  updt1_2: rsubw d,r[1],y;	fpregl->am;	;		;			  | compare t with t1 (t - t1)
    54f  02 00 e 0 0 9022 0000  	subcw,s r[2],acc,y;	;		;		;
    550  02 00 3 2 0 ffc5 0554  	bclrw,s 15,r[5];	;		cjp,cry chkthru2;;			  | no borrow means t >= t1
    551  0a 00 e 0 0 d882 0000  	movw acc,r[2];		;		;		;			  | else t1 <- t
    552  0a 00 b 0 0 d8c1 051a  	movw d,r[1];		;		cjpp,zer newpts2;;			  | r[5]==0 -> no more intersections
    553  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | else return to check next plane
    554  1a 00 a 8 0 7140 0000  chkthru2: ;			;		crtn,~zer;	;			  | r[5] != 0 -> more intersections, rtn
    555  0a 00 b 7 0 7140 051a  	;			;		cjpp,go newpts2;;			  | else pop stack and goto newpts2
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)xfpolygon2.vp.u 1.2 86/09/12 SMI
                                |	movw d,r[11];		shmem->am;	jmap XF_PGON_INT_2D;;			  | # of separate boundaries
    556  0a 00 e 0 0 d890 0000  XF_PGON_INT_2D: movw acc, r[16]; ;		;		;			  | flag from command.
    557  0a 27 e 0 0 d8c5 045d  	movw d,r[5];		=xfint2->am;	;		;			| r[5] pts to 2D transform routine
                                											  | xfint2 converts from fix to float
                                											  | before calling the regular xf2 routine
    558  0a 00 3 7 0 7140 055b  	;			;		cjp,go xfpoly2D;;			  | fall into rest of polygon code
                                |	movw d,r[11];		shmem->am;	jmap XFPOLYGON_2D;;			  | # of separate boundaries
    559  0a 00 e 0 0 d890 0000  XFPOLYGON_2D: movw acc, r[16]; ;		;		;			  | flag from command.
    55a  0a 27 e 0 0 d8c5 046c  	movw d,r[5];		=xf2->am;	;		;			  | use the regular xf2 routine
    55b  0a 0f 1 7 0 d85d 02df  xfpoly2D: movw r[29],y;	am->shmemp;	cjs,go polygon_attr_2D; ;		  | 
    55c  0a 0f c 0 0 d849 0005  	movw r[9],y;	am->shmemp;	ldct 5;		;
    55d  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    55e  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    55f  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;
    560  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move viewport parameters to fpr[32]
    561  08 00 e 0 1 dd7e 0000  	incw r[30],r[17];	;		;		;			  | r[17] pts to vector of npts per boundary
                                											  | (after increment below)
    562  0a 27 e 0 0 868b 0002  	addw d,r[11],acc;	2->am;		;		;
    563  0a 00 e 0 0 989e 0000  	addw r[30],acc,r[30];	;		;		;			  | r[30] now points to first vertex
                                										|
                                										| edge structure is:
                                										| fpreg[r[14]+0]: ymin    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[r[14]+1]: ymax    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[r[14]+2]: xmax    32-bit float
                                										| fpreg[r[14]+3]: xmin    32-bit float
                                										| fpreg[r[14]+4]: X       don't care in high word
                                										|		   nxt     11-bit ptr in low word
                                										|
    564  0a 27 e 0 0 d8c9 0172  	movw d,r[9];		370->am;	;		;			  | r[9]<-370
    565  0a 27 e 0 0 d8c8 0080  	movw d,r[8];		128->am;	;		;			  | address of dummy 1st edge
    566  0a 0e e 0 0 c5c8 0000  	add2nw 2,r[8],r[8]; am->fpdp;	;		;			  | fpdp<-&dummy edge r[8]
    567  0b 0b e 0 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	;		;			  | dummy edge r[8]<-ptr to 1st real edge
    568  02 00 e 0 0 c1eb 0000  xf2nxtbnd: sub2nw,s 0,r[11],r[11];;		;		;			  | if ((r[11] -= 1)<0), goto xf2doscan
    569  0a 0f 3 1 0 dd71 05cf  	incw r[17],r[17];	am->shmemp;	cjp,neg xf2doscan;;			  | else get # of vertices for next
    56a  0a 17 e 0 0 d8ca 0000  	movw d,r[10];		shmem->am;	;		;			  | boundary
    56b  0a 00 e 0 0 e599 0000  	rolw 2,d,acc;		;		;		;			  | acc <- r[10]*4
    56c  02 27 e 0 0 960a 0003  	subw,s d,r[10],y;	3->am;		;		;			  | if 0 <= r[10] < 3, not a good boundary
    56d  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp pts to vertices;update r[30] to
    56e  0a 00 3 a 0 989e 0568  	addw r[30],acc,r[30];	;		cjp,~cry xf2nxtbnd;;			  | point to 1st loc after bndry's vertices
    56f  02 27 e 0 0 960a 001a  	subw,s d,r[10],y;	26->am;	;		;			  | if (r[10]>=26),goto xf2lrgpoly
    570  08 08 3 9 0 c1ea 061b  	sub2nw 0,r[10],r[0];	am->brreg;	cjp,~neg xf2lrgpoly; ;			  | brreg <- r[10]-1
                                xf2smlpoly:
    571  0a 27 e 0 0 d8ce 07c6  	movw d,r[14];		1990->am;	;		;			  | r[14] <- address for transformed pts
    572  02 2d e 0 0 d84c 0010  	movw,s r[12],y;	16->fpbp;	;		;			  | fpbp <- address of matrix
                                											  | r[12]==0?(xf2 doesn't affect cc's)
    573  1a 08 4 7 0 d845 0000  	movw r[5],y;		am->brreg;	push,go;	;			  | brreg <- addr of transform routine
                                											  | now loop through r[10] pts & xform them
    574  0a 0e e 0 0 d90f 0000  	movw 0,r[15];		am->fpdp;	;		;			  | put untransformed pt at fpr[0]
    575  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[0] <- x[i]
    576  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+
    577  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[1] <- y[i]
    578  1b 1b 1 7 2 7140 0000  	;			shmem->fpregl;	cjs,go;		;		shp+	  | transform pt and deposit in pt buffer
    579  1a 2d 8 0 0 c3ce 0010  	add2nw 1,r[14],r[14];	16->fpbp;	rfct;		;			  | increment r[14] and loop
    57a  08 08 e 0 0 c1ea 0000  	sub2nw 0,r[10],r[0];	am->brreg;	;		;			  | brreg <- r[10]-1
    57b  0a 0e 3 0 0 f900 059c  	movw 0,y;		am->fpdp;	cjp,zer vwpsmlpoly2;;			  | if clipping disabled, goto vwpsmlpoly2
    57c  08 2b e 0 0 9dec 3f80  	rolw 14,r[12],r[0];0x3F80->fpregh;;		;			  | else do a fast clip test
    57d  0b 2b e 0 0 9cc0 0000  	andw r[0],0xF,r[0];0->fpregl;;			;			  | fpreg[0] <- 1.0
    57e  0a 2c e 0 0 000f 07c6  	;			1990->fpap;	;		;			  | fpap <- address of transformed pts
    57f  08 2d e 0 2 d960 0000  	movw r[0],r[2];0->fpbp;	;		;			  | fpbp <- address of 1.0
                                											  | get 2-D version of r[12],
                                											  | i.e. L|R|B|T is bits 3|2|1|0 with
                                											  | leading zeroes where a "1" means clip
                                											  | against the plane
                                											  | r[2] <- r[0]
                                											  | r[1] <- ~r[0]
    580  28 00 e 0 1 db60 0110  	compw r[0],r[1];;		;		adda,lab,hi;		  | left plane: x[0] + 1.0; test sign below
    581  2b 00 e 0 0 d802 0110  	movw r[2],acc;	;		;		;			  | clip to -1.0 <= x <= 1.0; init acc for
                                											  | first pass through loop below
    582  2a 00 e 0 0 7140 01a0  	;			;		;		rsuba,la,hi;		  | right plane: 1.0 - x[0]; test sign below
    583  2b 00 e 0 4 7140 01a0  	;			;		;		;		ap+
    584  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;		  | bottom plane: y[0] + 1.0;test sign below
    585  2b 00 e 0 0 7140 0120  	;			;		;		;
    586  2a 00 e 0 0 7140 01a0  	;			;		;		rsuba,la,hi;		  |top plane: 1.0 - y[0]; test sign below
    587  3b 00 4 7 4 7140 01a0  	;			;		push,go;	;		ap+	  | loop through r[10] pts (brreg set above)
    588  2a 00 e 0 0 98c2 0122  plyclptst2: andw r[2],acc,r[2];;	;		adda,la,a,hi;		  | accumulate r[2] & r[22] pipe
    589  2b 00 e 0 0 f901 0122  	movw 0,acc;		;		;		;			  | zero acc for next pass through loop
    58a  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		  | x[i] + 1.0; unload x[i-1] + 1.0 and
    58b  2b 31 e 0 0 6e00 0122  	sl0b d,y;		fpstreg->am;	;		;			  | save the sign bit (throw away result)
    58c  2a 00 e 0 0 ec41 01a2  	slqw acc,acc;		;		;		rsuba,la,a,hi;		  | 1.0 - x[i];	unload 1.0 - x[i-1] and
    58d  2b 31 e 0 4 6e00 01a2  	sl0b d,y;		fpstreg->am;	;		;		ap+	  | save the sign bit (throw away result)
    58e  2a 00 e 0 0 ec41 0122  	slqw acc,acc;		;		;		adda,la,a,hi;		  | y[i] + 1.0; unload y[i-1] + 1.0 and
    58f  2b 31 e 0 0 6e00 0122  	sl0b d,y;		fpstreg->am;	;		;			  | save the sign bit (throw away result)
    590  2a 00 e 0 0 ec41 01a2  	slqw acc,acc;		;		;		rsuba,la,a,hi;		  | 1.0 - y[i];	unload 1.0 - y[i-1] and
    591  2b 31 e 0 4 6e00 01a2  	sl0b d,y;		fpstreg->am;	;		;		ap+	  | save the sign bit (throw away result)
    592  0a 00 e 0 0 ec41 0000  	slqw acc,acc;		;		;		;			  | dummy result from adda,la now being ignored
    593  1a 00 8 0 0 9941 0000  	orw r[1],acc,r[1];;		rfct;		;			  | accumulate r[1] & loop until done
    594  0a 00 e 0 0 80c2 0000  	andw r[2],acc,acc;;		;		;			  | accumulate r[2] for last point
    595  02 00 e 0 0 9100 0000  	xorw,s r[0],acc,y;	;		;		;			  | if (r[2] == r[0]), then
                                											  | all pts are inside the clip region,
    596  02 00 3 0 0 da01 059c  	compw,s r[1],acc;	;		cjp,zer vwpsmlpoly2;;			  | so goto vwpsmlpoly2
    597  0a 28 e 0 0 d8e3 0626  	movw 1990,r[3];	=clppoly2->brreg;;		;			  | if (~r[1] != 0), all pts were
    598  0a 00 3 8 0 07c6 0568  	;			;		cjp,~zer xf2nxtbnd;;			  | outside at least 1 clipping plane so
    599  0a 27 e 0 0 d8d2 0615  	movw d,r[18];	=nxtxfpt2->am;	;		;			  | goto xf2nxtbnd; else call clppoly2 with
    59a  1a 27 1 7 0 d8d3 06e7  	movw d,r[19];	=mkedges2->am;	cjs,go;		;			  | r[3] pointing to 1st transformed
    59b  0a 00 3 7 0 7140 0568  	;			;		cjp,go xf2nxtbnd;;			  | point, r[18] pointing to the
                                											  | subroutine nxtxfpt2, and r[19]
                                											  | pointing to the subroutine mkedges2
                                											  | after return, goto xf2nxtbnd
                                vwpsmlpoly2:										  | brreg == r[10]-1 on entry
    59c  0a 27 e 0 0 d8c0 07c6  	movw d,r[0];		1990->am;	;		;			  | r[0] <- 1990 (address of xformed pts)
    59d  0a 0d 1 7 0 eb86 06c7  	mov2nw 5,acc;		am->fpbp;	cjs,go vwpsclpts2;;			  | acc and fpbp point to viewport params
                                											  | scale r[10] pts to the viewport
                                											  | scaling is done in-place
                                xf2smledgs:
    59e  2a 0c e 0 0 dc40 0230  	incw r[0],y;		am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap <- 1990 + 1; use flowthrough mode
    59f  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | y[0]
    5a0  2b 00 e 0 0 7140 00e0  	;			;		;		;
    5a1  0a 00 e 0 0 7140 0000  	;			;		;		;
    5a2  08 08 e 0 0 c3ea 0000  	sub2nw 1,r[10],r[0];	am->brreg;	;		;			  | brreg <- r[10]-2
    5a3  0a 27 e 0 0 d8c3 07c6  	movw d,r[3];	1990->am;	;		;			  | r[3] <- 1990
    5a4  0a 00 e 0 0 7140 0000  	;			;		;		;			  | wait for fixed y[0]
    5a5  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    5a6  2b 0e e 0 0 f900 0102  	movw 0,y;		am->fpdp;	;		;
    5a7  2a 0c e 0 0 f900 0101  	movw 0,y;		am->fpap;	;		adda,st,hi;		  | fpreg[0] <- y[0] (integer)
    5a8  2b 00 e 0 0 c3c3 0101  	add2nw 1,r[3],r[3];;		;		;			  | r[3] <- &x[1]
    5a9  0b 37 e 0 0 d8c4 0000  	movw d,r[4];		fpregl->am;	;		;			  | r[4] <- low word of integer y[0]
    5aa  1a 00 4 7 0 d804 0000  	movw r[4],acc;	;		push,go;	;			  | acc <- y[0]; start loop to build 1st n-1
                                xf2smledgloop:										  | edges; notation: i runs from 1 to n-1
    5ab  0a 0c e 0 0 dc43 0000  	incw r[3],y;	am->fpap;	;		;			  | fpap <- &y[i]
    5ac  28 0e e 0 0 c3c8 00e0  	add2nw 1,r[8],r[0];	am->fpdp;	;		fixa,la,hi;		  | fix y[i]; fpdp <- &edg.xmax
    5ad  2b 0c e 0 0 d843 00e0  	movw r[3],y;	am->fpap;	;		;			  | fpap <- &x[i]
    5ae  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- x[i]
    5af  0b 3b e 0 6 7140 0000  	;			fpregl-> fpregl;;		;		dp+
    5b0  08 0c e 0 0 c3e3 0000  	sub2nw 1,r[3],r[0];	am->fpap;	;		;			  | fpap <- &x[i-1]
    5b1  08 3b e 0 0 d968 0000  	movw r[8],r[0];	fpregh->fpregh;	;		;			  | edg.xmin <- x[i-1]; save r[8] in r[0]
    5b2  0b 3b e 0 6 c5c8 0000  	add2nw 2,r[8],r[8];	fpregl->fpregl;	;		;		dp+	  | r[8] += 4
    5b3  0b 0b e 0 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	;		;			  | edg.nxt <- r[8] <- addr of next edge
    5b4  0a 0e e 0 0 d840 0000  	movw r[0],y;		am->fpdp;	;		;			  | fpdp <- address of this edge
    5b5  2a 0b e 0 6 f880 0102  	movw acc,y;		am->fpregh;	;		adda,a,hi;	dp+	  | edg.ymin <- y[i-1] (16-bit integer)
    5b6  2b 00 e 0 0 c3c3 0102  	add2nw 1,r[3],r[3];;		;		;			  | r[3] <- &x[i+1]
    5b7  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | edg.ymax <- y[i] (32-bit integer)
    5b8  2b 0c e 0 0 dc40 0101  	incw r[0],y;		am->fpap;	;		;			  | fpap <- &edg.ymax
    5b9  03 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregl->am;	;		;			  | check for horizontal edges
    5ba  0b 37 3 0 0 f8c1 05c0  	movw d,acc;		fpregl->am;	cjp,zer xf2horizedg;;			  | acc <- low order 16 bits of int y[i]
    5bb  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | r[9] -= 1
    5bc  0a 0b 3 1 0 f880 05bf  	movw acc,y;		am->fpregh;	cjp,neg xf2edgovflw;;			  | move low 16 bits to high 16 bits where
    5bd  1a 00 8 0 0 7140 0000  	;			;		rfct;		;			  | scan conversion code expects to see it
                                											  | also handle case of too many edges
    5be  0a 00 3 7 0 7140 05c1  	;			;		cjp,go xf2lastedg;;
                                xf2edgovflw:
    5bf  0a 00 e 0 0 db09 0000  	compw 0,r[9];		;		;		;			  | r[9] <- -1 and adjust r[8]
                                xf2horizedg:
    5c0  1a 27 8 0 0 9e08 0005  	subw d,r[8],r[8];	5->am;		rfct;		;			  | ignore horizontal and overflow edges
                                xf2lastedg:
    5c1  02 00 e 0 0 9104 0000  	xorw,s r[4],acc,y;	;		;		;			  | ignore horizontal last edge
    5c2  0a 0e 3 0 0 d848 0568  	movw r[8],y;		am->fpdp;	cjp,zer xf2nxtbnd;;			  | fpdp <- address of nth edge
    5c3  0a 0b e 0 6 f880 0000  	movw acc,y;		am->fpregh;	;		;		dp+	  | edg.ymin <- y[n-1]
    5c4  0a 0b e 0 6 d844 0000  	movw r[4],y;		am->fpregh;	;		;		dp+	  | edg.ymax <- y[0]
    5c5  0a 2c e 0 0 7140 07c6  	;			1990->fpap;	;		;			  | fpap <- &x[0]
    5c6  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- x[0]
    5c7  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    5c8  0a 0c e 0 0 c3e3 0000  	sub2nw 1,r[3],r[3]; am->fpap;	;		;			  | fpap <- &x[n-1]
    5c9  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmin <- x[n-1]
    5ca  0b 3b e 0 6 c5c8 0000  	add2nw 2,r[8],r[8];	fpregl->fpregl;	;		;		dp+	  | r[8] += 4
    5cb  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | r[9] -= 1
    5cc  0b 0b 3 9 0 dd68 0568  	incw r[8],r[8];	am->fpregl;	cjp,~neg xf2nxtbnd;;			  | edg.nxt <- r[8] <- addr of next edge
    5cd  0a 27 e 0 0 9e08 0005  	subw d,r[8],r[8];	5->am;		;		;			  | goto xf2nxtbnd; if (r[9] < 0),
    5ce  0a 00 3 7 0 db09 0568  	compw 0,r[9];		;		cjp,go xf2nxtbnd;;			  | r[9] <- -1 and adjust r[8]
                                xf2doscan:
                                |   if # of edges != 0, call polyscan with r[14] and r[15].
    5cf  02 2f e 0 0 d850 01ff  	movw,s r[16], y;	511->shmemp; ;	;			| Test r[16] to see if textured.
    5d0  0a 17 3 0 0 d8c0 060e  	movw d, r[0];		shmem->am;	cjp, zer xf2polyscan; ;			| What texture is in PP?
    5d1  0a 27 e 0 0 869d 000a  	addw d, r[29], acc;	10->am; ;		;			| Compare PP tex block ptr with our own.
    5d2  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    5d3  02 17 e 0 0 f8c0 0000  	movw,s d, y;		shmem->am;	;		;			| Check for invalid tex block (-1)
    5d4  02 17 3 9 0 9600 05d6  	subw,s d, r[0], y;	shmem->am;	cjp, ~neg xf2tex; ;			| Compare tex pointers.
    5d5  0a 00 3 7 0 d910 060e  	movw 0, r[16];	;		cjp, go xf2polyscan; ;			| 
    5d6  0a 00 3 0 0 7140 05e8  xf2tex:	;			;		cjp, zer xf2texoff; ;			| 
    5d7  0a 27 e 0 0 869d 0007  	addw d, r[29], acc;	7->am; ;		;			| if (reload pp) shmemp = 7
    5d8  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    5d9  1a 17 4 f 0 d8d0 0000  	movw d, r[16];	shmem->am;	push, ~go;	;			| 
    5da  1a 26 d 4 0 7140 001b  	;			 27->fifo1;	loop, f1nf;	;			| 
    5db  08 00 1 7 0 d96d 0322  	movw r[13], r[0];	;		cjs, go stprep;	;			| Save r[13].  stprep incr shmemp.
    5dc  0a 06 3 c 0 d84e 05dc  	movw r[14], y;		am->fifo1;	cjp, f1f .;	;			| 
    5dd  0a 17 e 0 0 d8c1 0000  	movw d, r[1];		shmem->am;	;		;			| TEX2FRAME (stprep incr shmemp)
    5de  0a 2f e 0 0 7140 01ff  	;			511->shmemp; ;	;			| 
    5df  0a 06 3 c 0 d84d 05df  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    5e0  0a 0a e 0 0 d841 0000  	movw r[1], y;		am->shmem;	;		;			| Remember what frame is on PP.
    5e1  08 00 e 0 d d960 0000  	movw r[0], r[13];	;		;		;			| Restore r[13].
    5e2  0a 06 3 c 0 d84f 05e2  	movw r[15], y;		am->fifo1;	cjp, f1f .;	;			| 
    5e3  0a 0f e 0 0 d841 0000  	movw r[1], y;		am->shmemp;	;		;			| Address texture frame.
    5e4  12 00 4 7 0 c1eb 0000  xf2ltex: sub2nw,s 0, r[11], r[11]; ;		push, go;	;			| Copy texture to PP.
    5e5  0a 16 3 c 0 7140 05e5  	;			shmem->fifo1;	cjp, f1f .;	;			| 
    5e6  1a 00 8 0 2 7140 0000  	;			;		rfct;		;		shp+	| 
    5e7  0a 08 3 8 0 d84c 05e4  	movw r[12], y;		am->brreg;	cjp, ~zer xf2ltex; ;			| Copy next row of texture.
    5e8  0a 27 e 0 0 869d 0007  xf2texoff: addw d, r[29], acc; 7->am; ;	;			| 
    5e9  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    5ea  0a 17 e 0 0 d8d0 0000  	movw d, r[16];	shmem->am;	;		;			| 
    5eb  0a 27 e 0 0 869d 0018  	addw d, r[29], acc; 24->am; ;	;			| 
    5ec  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    5ed  02 17 e 0 0 f8c1 0000  	movw,s d, acc;		shmem->am;	;		;			| if (Kind == 0)
    5ee  0a 0e 3 0 0 d90f 060a  	movw 0, r[15];		am->fpdp;	cjp, zer xf2sxsy; ;			| else if (==  1) store pt at fpreg[0]
    5ef  0a 27 e 0 0 869d 000e  	addw d, r[29], acc;	14->am; ;		;			| 
    5f0  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    5f1  0a 08 e 0 0 d845 0000  	movw r[5], y;		am->brreg;	;		;			| 
    5f2  0a 1b e 0 2 c38e 0000  	mov2nw 1, r[14];	shmem->fpregh;	;		;		shp+	| Output point at fpreg[2].
    5f3  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+| 
    5f4  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	| 
    5f5  0b 1b e 0 0 7140 0000  	;			shmem->fpregl;	;		;			| 
    5f6  1a 0d 1 7 0 e996 0000  	mov2nw 4, y;		am->fpbp;	cjs,go;		;			| bp= 16 (address of matrix).
    5f7  0a 28 e 0 0 c380 0000  	mov2nw 1, r[0];		0->brreg;	;		;			| Do in-place viewport xform.
    5f8  0a 0d 1 7 0 eb86 06c7  	mov2nw 5,acc;		am->fpbp;	cjs,go vwpsclpts2; ;			| acc and fpbp point to viewport params
    5f9  2b 0c e 0 0 e396 0230  	mov2nw 1, y;		am->fpap;	;		lmode rn, ai, pipe, fast; |
    5fa  2a 0e e 0 0 f900 00e0  	movw 0, y;		am->fpdp;	;		fixa, la, hi;		| Fix r[21] and r[22].
    5fb  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    5fc  2a 00 e 0 0 7140 00e0  	;			;		;		fixa, la, hi;		| 
    5fd  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    5fe  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    5ff  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    600  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    601  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    602  2a 00 e 0 0 7140 0122  	;			;		;		adda,la, a, hi;		| 
    603  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    604  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 
    605  2b 00 e 0 6 f8e0 0123  	movw =xf2polyscan, y;	;		;		;		dp+	| 
    606  2a 08 e 0 0 060e 0121  	;			am->brreg;	;		adda,la, st, hi;		| 
    607  2b 0c e 0 0 f900 0121  	movw 0, y;		am->fpap;	;		;			| 
    608  0b 37 e 0 4 d8d5 0000  	movw d, r[21];		fpregl->am;	;		;		ap+	| 
    609  1b 37 3 7 0 d8d6 0000  	movw d, r[22];		fpregl->am;	cjp, go;	;			| 
    60a  0a 27 e 0 0 869d 000c  xf2sxsy: addw d, r[29], acc;	 12->am; ;		;			| 
    60b  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    60c  0a 17 e 0 2 d8d5 0000  	movw d, r[21];		shmem->am;	;		;		shp+	| retrieve r[21].
    60d  0a 17 e 0 0 d8d6 0000  	movw d, r[22];		shmem->am;	;		;			| retrieve r[22].
    60e  0a 0e e 0 0 c1e8 0000  xf2polyscan: sub2nw 0,r[8],r[8]; am->fpdp;	;		;			| fpdp <- &edg.nxt for last edge
    60f  03 2b e 0 0 d849 0000  	movw,s r[9],y;	0->fpregl;	;		;			  | load NULL r[8] for last edge
    610  0a 00 3 1 0 9c09 0614  	subw,s r[9],370,r[9];;		cjp,neg xf2noscan;;			  | if # of edges > 370, goto xf2noscan
    611  02 27 e 0 0 0172 0080  	;			128->am;	;		;			  | compute real # of edges
    612  0a 00 3 0 0 d8ce 0614  	movw d,r[14];		;		cjp, zer xf2noscan; ;			| 
    613  08 00 1 7 f d96d 0c5e  	movw r[13],r[15]; ;		cjs, go polyscan; ;			| 
    614  0a 00 2 0 0 7140 0027  xf2noscan: ;			;		jmap getcmd;	;
    615  0a 0e e 0 0 d847 0000  nxtxfpt2: movw r[7],y;	am->fpdp;	;		;			  | fpdp <- address for next pt to clip
    616  0a 0c e 0 0 d843 0000  	movw r[3],y;		am->fpap;	;		;			  | fpap <- address of next transformed pt
    617  02 3b e 0 0 c1ea 0000  	sub2nw,s 0,r[10],r[10];	fpregh->fpregh;	;		;			  | transfer x; r[10]-=1, set cc to
                                											  | reflect result (neg means no more pts)
    618  1b 3b a 1 8 c3c3 0000  	add2nw 1,r[3],r[3];fpregl->fpregl;crtn,neg;	;		adp+	  | r[3] += 2 & return if no more pts
    619  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | transfer y
    61a  1b 3b a 7 0 7140 0000  	;			fpregl->fpregl;	crtn,go;	;			  | return
    61b  0a 27 e 0 0 d8d2 061f  xf2lrgpoly: movw d,r[18];	=nxtcmdpt2->am;	;		;			  | r[18] points to subroutine nxtcmdpt2
    61c  0a 27 e 0 0 d8d3 06e7  	movw d,r[19];	=mkedges2->am;	;		;			  | r[19] points to subroutine mkedges2
    61d  0a 00 1 7 0 7140 0626  	;			;		cjs,go clppoly2;;			  | call clppoly2
    61e  0a 00 3 7 0 7140 0568  	;			;		cjp,go xf2nxtbnd;;			  | loop back to xf2nxtbnd
    61f  02 2d e 0 0 c1ea 0010  nxtcmdpt2: sub2nw,s 0,r[10],r[10]; 16->fpbp;	;		;			  | fpbp pts to matrix; r[10] -= 1, cc
    620  18 2e a 1 e d967 07c6  	movw r[7],r[14];	1990->fpdp;	crtn,neg;	;			  | reflects result; return if no more pts
                                											  | else fpdp<-1990 (addr for new pt)
    621  0a 08 e 0 0 d845 0000  	movw r[5],y;		am->brreg;	;		;			  | brreg pts to appropriate xform routine
    622  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpreg[1990] <- next x; r[14] <- addr
    623  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+  | for xformed pts
    624  0a 1b e 0 2 d8ef 0000  	movw 1990,r[15];	shmem->fpregh;	;		;		shp+	  | fpreg[1990+1] <- next y; r[15] <- 1990
    625  1b 1b 3 7 2 07c6 0000  	;			shmem->fpregl;	cjp,go;		;		shp+	  | jump to xf2 which will return to caller
                                											  | xf2 will xform pt and put result at
                                											  | *r[7]; shmemp now pts to next pt
                                clppoly2:
    626  02 2e e 0 0 d914 0000  	movw,s 0,r[20];	0->fpdp;	;		;			  | r[20] <- FALSE; cc == zer (tested
                                											  | below at nxtpt2)
    627  0a 2b e 0 0 dd15 3f80  	incw 0,r[21];	0x3f80->fpregh;	;		;			  | r[21] <- TRUE; fpreg[0] <- 1.0
    628  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;
    629  0a 2e e 0 0 7140 0028  	;			40->fpdp;;		;
    62a  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 40.firstvtx <- TRUE
    62b  0a 2e e 0 0 7140 0032  	;			50->fpdp;;		;
    62c  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 50.firstvtx <- TRUE
    62d  0a 2e e 0 0 7140 003c  	;			60->fpdp;;		;
    62e  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 60.firstvtx <- TRUE
    62f  0a 2e e 0 0 7140 0046  	;			70->fpdp;;		;
    630  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 70.firstvtx <- TRUE
    631  1a 08 a 8 0 d852 0000  nxtpt2: movw r[18],y;	am->brreg;	crtn,~zer;	;			  | when reach here, cc reflects state of
                                											  | r[20]; return when out of pts; else
                                											  | call routine to get next point with
    632  1a 27 1 7 0 d8c7 0050  	movw d,r[7];	80->am;	cjs,go;		;			  | r[7]==80; returns
    633  02 00 3 1 0 d84c 064e  	movw,s r[12],y;	;		cjp,neg closepoly2;;			  | with cc neg when out of points
    634  0a 00 3 0 0 dd16 064b  	incw 0,r[22];		;		cjp,zer putpts2;;			  | r[22]<-1; if clip disabled, goto putpts2
                                											  | else r[7] points to new pt; r[22]==1
    635  0a 27 e 0 0 d8c6 0064  nxtpt2a: movw d,r[6];	100->am;	;		;			  | r[6]<-100
    636  02 27 e 0 0 ebec 0028  clpleft2: btstw,s 5,r[12]; 40->am;;		;			  | if left clipping enabled, call clppln2
    637  0a 00 3 0 0 d8c4 063b  	movw d,r[4];		;		cjp,zer clptop2;;			  | with r[4]==40
    638  0a 28 e 0 0 7140 0682  	;			=wec_left2->brreg;;		;			  | and brreg==wec_left2
    639  0a 00 1 7 0 d917 0653  	movw 0,r[23];		;		cjs,go clppln2;	;
    63a  08 00 1 7 6 d977 0650  	movw r[23],r[22];		;		cjs,go switchbuf2;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    63b  02 27 e 0 0 e5ec 0032  clptop2: btstw,s 2,r[12];	50->am;;		;			  | if top clipping enabled, call clppln2
    63c  0a 00 3 0 0 d8c4 0640  	movw d,r[4];		;		cjp,zer clpright2;;			  | with r[4]==50
    63d  0a 28 e 0 0 7140 068b  	;			=wec_top2->brreg;;		;			  | and brreg==wec_top2
    63e  0a 00 1 7 0 d917 0653  	movw 0,r[23];		;		cjs,go clppln2;	;
    63f  08 00 1 7 6 d977 0650  	movw r[23],r[22];		;		cjs,go switchbuf2;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    640  02 27 e 0 0 e9ec 003c  clpright2: btstw,s 4,r[12];60->am;;		;			  | if right clipping enabled, call clppln2
    641  0a 00 3 0 0 d8c4 0645  	movw d,r[4];		;		cjp,zer clpbottom2;;			  | with r[4]==60
    642  0a 28 e 0 0 7140 068c  	;			=wec_right2->brreg;;		;			  | and brreg==wec_right2
    643  0a 00 1 7 0 d917 0653  	movw 0,r[23];		;		cjs,go clppln2;	;
    644  08 00 1 7 6 d977 0650  	movw r[23],r[22];		;		cjs,go switchbuf2;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    645  02 27 e 0 0 e7ec 0046  clpbottom2: btstw,s 3,r[12];70->am;;		;			  | if bottom clipping enabled, call clppln2
    646  0a 00 3 0 0 d8c4 064b  	movw d,r[4];		;		cjp,zer putpts2;;			  | with r[4]==70
    647  0a 28 e 0 0 7140 0681  	;			=wec_bottom2->brreg;;		;			  | and brreg==wec_bottom2
    648  0a 00 1 7 0 d917 0653  	movw 0,r[23];		;		cjs,go clppln2;	;
    649  08 00 e 0 6 d977 0000  	movw r[23],r[22];		;		;		;			  | # of output pts is # of pts which are
    64a  08 00 e 0 7 d966 0000  	movw r[6],r[7];;		;		;			  | passed to the pt consuming routine
    64b  0a 08 e 0 0 d853 0000  putpts2: movw r[19],y;	am->brreg;	;		;			  | r[7] points to the pts
    64c  18 00 1 7 f d967 0000  	movw r[7],r[15];	;		cjs,go;		;			  | call the consuming routine
    64d  02 00 3 7 0 d854 0631  	movw,s r[20],y;	;		cjp,go nxtpt2;	;			  | get next input pt; cc reflects state of
                                											  | variable r[20]
    64e  0a 00 c 0 0 dd14 064b  closepoly2: incw 0,r[20];	;		ldct putpts2;	;			  | r[20] <- TRUE; r[22] <- 0
    64f  0a 00 7 8 0 d916 0635  	movw 0,r[22];		;		jrp,~zer nxtpt2a;;			  | if clipping is disabled, goto putpts2;
                                											  | else do one more pass
                                											  | through clipping loop to flush out
                                											  | possible intersection points by passing
                                											  | each plane's saved 1st vertex to it as
                                											  | its last vertex
    650  08 00 e 0 0 d966 0000  switchbuf2: movw r[6],r[0];	;		;		;			  | switch buffer ptrs
    651  08 00 e 0 6 d967 0000  	movw r[7],r[6];;		;		;
    652  18 00 a 7 7 d960 0000  	movw r[0],r[7];	;		crtn,go;	;
    653  08 00 e 0 f d967 0000  clppln2: movw r[7],r[15];	;		;		;			  | use local copy of r[7]
    654  08 00 e 0 e d966 0000  	movw r[6],r[14];	;		;		;			  | use local copy of r[6]
    655  02 00 e 0 0 d856 0000  cpln2loop: movw,s r[22],y;	;		;		;			  | if r[22] == 0, goto chklastpt2
    656  02 00 3 0 0 c1f6 0663  	sub2nw,s 0,r[22];	;		cjp,zer chklastpt2;;			  | if ((r[22] -= 1) < 0), return
    657  1a 0c a 1 0 d844 0000  	movw r[4],y;		am->fpap;	crtn,neg;	;			  | fpap <- r[4]
    658  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;			  | if r[4]->firstvtxflg == FALSE, goto
    659  0a 0c 3 0 0 d84f 0667  	movw r[15],y;		am->fpap;	cjp,zer subseqvtx2;;			  | subseqvtx2; fpap <- r[15]
    65a  0a 0e e 0 0 d844 0000  firstvtx2: movw r[4],y;	am->fpdp;	;		;			  | fpdp <- r[4]
    65b  0a 0b 4 7 6 f900 0001  	movw 0,y;		am->fpregh;	push,go 1;	;		dp+	  | r[4]->firstvtxflg <- FALSE
    65c  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | r[4]->firstvtx <- input pt
    65d  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    65e  0a 0c 4 7 0 d84f 0001  	movw r[15],y;		am->fpap;	push,go 1;	;			  | fpap <- r[15]
    65f  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | r[4]->savdvtx <- input pt
    660  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    661  1a 0c 1 7 0 d84f 0000  	movw r[15],y;		am->fpap;	cjs,go;		;			  | call routine to compute window edge
                                											  | coordinate for this plane and this pt
                                											  | (brreg has address of routine)
                                											  | wec is stored in r[4]->savdwec
    662  0a 00 3 7 0 c3cf 0677  	add2nw 1,r[15],r[15];	;		cjp,go cpln2vischk;;			  | r[15] += 2;go check visibility using wec
    663  02 00 e 0 0 d854 0000  chklastpt2: movw,s r[20],y;	;		;		;			  | if there are more pts, return; else
    664  1a 0c a 0 0 d844 0000  	movw r[4],y;		am->fpap;	crtn,zer;	;			  | if r[4]->firstvtxflg == TRUE, return
    665  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;
    666  18 0c a 8 f dd64 0000  	incw r[4],r[15];	am->fpap;	crtn,~zer;	;			  | else fpap <- r[15] <- &r[4]->firstvtx
                                											  | and fall through to subseqvtx2
    667  1a 2e 1 7 0 7140 0001  subseqvtx2: ;			1->fpdp;	cjs,go;		;			  | fpreg[1] <-  wec for this plane and pt
    668  08 2c e 0 0 c5c4 0001  	add2nw 2,r[4],r[0];	1->fpap;	;		;			  | fpap <- address of input wec
    669  0a 37 e 0 0 f8c1 0000  	movw d,acc;		fpregh->am;	;		;			  | acc <- high word of input wec
    66a  0a 0c e 0 0 dc40 0000  	incw r[0],y;		am->fpap;	;		;			  | fpap <- address of saved wec
    66b  02 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregh->am;	;		;			  | test sign of (input wec) ^ (saved wec)
    66c  0a 00 1 1 0 7140 0695  	;			;		cjs,neg plnintsct2;;			  | if signs differ a polygon edge crosses
                                											  | this plane; call plnintsct2 to compute
                                											  | the intersection and add it to the
                                											  | output buffer
    66d  0a 0c e 0 0 d84f 0000  	movw r[15],y;		am->fpap;	;		;			  | fpap <- address of input pt
    66e  0a 27 e 0 0 8684 0003  	addw d,r[4],acc;	3->am;		;		;			  | acc <- &r[4]->savdvtx
    66f  0a 0e e 0 0 f880 0000  	movw acc,y;		am->fpdp;	;		;			  | fpdp <- &r[4]->savdvtx
    670  0a 3b e 0 0 c3cf 0000  	add2nw 1,r[15],r[15];	fpregh->fpregh;	;		;			  | r[4]->savdvtx <- input pt; r[15] += 2
    671  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    672  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;
    673  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    674  0a 2c e 0 0 7140 0001  	;			1->fpap;	;		;			  | fpap <- address of input wec
    675  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | r[4]->savdwec <- input wec
    676  0b 3b e 0 0 7140 0000  	;			fpregl->fpregl;	;		;
    677  0a 00 e 0 0 8484 0000  cpln2vischk: addw r[4],5,acc;	;		;		;			  | fpap <- acc <- &r[4]->savdwec
    678  0a 0c e 0 0 0005 0000  	;			am->fpap;	;		;
    679  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;
    67a  02 00 3 1 0 d856 0655  	movw,s r[22],y;		;		cjp,neg cpln2loop;;			  | wec < 0 => pt not visible
    67b  0a 0e 3 1 0 d84e 0655  	movw r[14],y;		am->fpdp;	cjp,neg cpln2loop;;			  | (r[22] >= 0) => add pt to output
                                											  | (r[20] == TRUE) && (r[22] < 0) =>
                                											  | this last pt is the same as the first pt
                                											  | so ignore it (only reach here with
                                											  | r[22] < 0 when r[20] == TRUE)
                                cpln2vis:										  | fpdp <- r[14] (above)
    67c  0a 0c e 0 0 e385 0000  	sub2nw 1,acc;		am->fpap;	;		;			  | fpap <- &r[4]->savdvtx
    67d  0a 3b e 0 0 dd77 0000  	incw r[23],r[23];		fpregh->fpregh;	;		;			  | output buffer <- current point
    67e  0b 3b e 0 8 c3ce 0000  	add2nw 1,r[14],r[14];	fpregl->fpregl;	;		;		adp+
    67f  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;
    680  0b 3b 3 7 0 7140 0655  	;			fpregl->fpregl;	cjp,go cpln2loop;;			  | goto cpln2loop
    681  0a 00 e 0 4 7140 0000  wec_bottom2: ;			;		;		;		ap+	  | fpap pts to pt.y for wec_bottom2 or to
    682  2a 0d e 0 0 f900 0230  wec_left2: movw 0,y;		am->fpbp;	;		lmode rn,ai,flow,fast;	  | pt.x for wec_left2;fpbp pts to const 1.0
    683  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | pt.x + 1.0 (left plane wec) OR
    684  2b 00 e 0 0 7140 0110  	;			;		;		;			  | pt.y + 1.0 (bottom plane wec)
    685  0a 00 4 7 0 7140 0002  	;			;		push,go 2;	;
    686  1a 00 8 0 0 7140 0000  	;			;		rfct;		;
    687  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    688  2b 00 e 0 0 7140 0102  	;			;		;		;
    689  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store result and return; result < 0 =>
    68a  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | pt is on invisible side of pln
    68b  0a 00 e 0 4 7140 0000  wec_top2: ;			;		;		;		ap+	  | fpap pts to pt.y for wec_top2 or to pt.x
    68c  2a 0d e 0 0 f900 0230  wec_right2: movw 0,y;		am->fpbp;	;		lmode rn,ai,flow,fast;	  | for wec_right2; fpbp pts to const 1.0
    68d  2a 00 e 0 0 7140 0190  	;			;		;		rsuba,lab,hi;		  | 1.0 - pt.x (right plane wec) OR
    68e  2b 00 e 0 0 7140 0190  	;			;		;		;			  | 1.0 - pt.y (top plane wec)
    68f  0a 00 4 7 0 7140 0002  	;			;		push,go 2;	;
    690  1a 00 8 0 0 7140 0000  	;			;		rfct;		;
    691  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    692  2b 00 e 0 0 7140 0102  	;			;		;		;
    693  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store result and return; result < 0 =>
    694  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | pt is on invisible side of pln
    695  0a 2d e 0 0 9484 0001  plnintsct2: addw r[4],5,y;	1->fpbp;	;		;			  | fbbp pts to wec of new input pt
    696  2a 0c e 0 0 0005 0230  	;			am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap pts to wec of saved pt
    697  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | saved wec - input wec
    698  2b 00 e 0 0 7140 0150  	;			;		;		;
    699  0a 00 4 7 0 7140 0002  	;			;		push,go 2;	;			  | delay for flowthrough mode
    69a  1a 00 8 0 0 7140 0000  	;			;		rfct;		;
    69b  2a 0e e 0 0 e396 0102  	mov2nw 1,y;		am->fpdp;	;		adda,a,hi;		  | fpdp <- 2
    69c  2b 0c e 0 0 e396 0102  	mov2nw 1,y;		am->fpap;	;		;			  | fpap <- 2
    69d  2a 00 e 0 0 d8e2 0101  	movw 3,r[2];		;		;		adda,st,hi;		  | store wec_diff in fpreg[2]
    69e  2b 00 e 0 0 0003 0101  	;			;		;		;			  | r[2] <- 3
    69f  0a 00 1 7 0 7140 034c  	;			;		cjs,go recip;	;			  | fpreg[3] <- reciprocal of difference
    6a0  2b 0d e 0 0 d842 0230  	movw r[2],y;		am->fpbp;	;		lmode rn,ai,pipe,fast;	  | fpbp <- 3; set pipeline mode
    6a1  0a 00 c 0 0 9484 0001  	addw r[4],5,y;	;		ldct 1;		;			  | 2910 R reg <- 1
    6a2  0a 0c e 0 0 0005 0000  	;			am->fpap;	;		;			  | fpap pts to wec of saved pt
    6a3  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | compute t = (wec of saved pt)/wec_diff
    6a4  2b 0c e 0 0 d84f 0010  	movw r[15],y;		am->fpap;	;		;			  | fpap <- address of input pt
    6a5  2a 00 e 0 0 9484 0120  	addw r[4],3,y;	;		;		adda,la,hi;
    6a6  2b 0d e 0 0 0003 0120  	;			am->fpbp;	;		;			  | fpbp <- address of saved pt
    6a7  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dx (input x - saved x)
    6a8  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+
    6a9  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dy (input y - saved y)
    6aa  2b 00 e 0 0 7140 0150  	;			;		;		;
    6ab  2a 00 e 0 0 7140 0124  	;			;		;		adda,la,m,hi;
    6ac  2b 0e e 0 0 e396 0124  	mov2nw 1,y;		am->fpdp;	;		;			  | fpdp <- 2
    6ad  2a 0d e 0 0 e396 0121  	mov2nw 1,y;		am->fpbp;	;		adda,la,st,hi;		  | fpreg[2] <- t; fpbp <- 2
    6ae  2b 00 e 0 0 7140 0121  	;			;		;		;
    6af  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    6b0  2b 00 e 0 0 7140 0122  	;			;		;		;
    6b1  2a 00 e 0 0 7140 001a  	;			;		;		mabr,lab,a,hi;		  | dx * t
    6b2  2b 00 e 0 0 7140 001a  	;			;		;		;
    6b3  2a 00 e 0 0 7140 0018  	;			;		;		mabr,lab,hi;		  | dy * t
    6b4  3b 00 4 f 0 7140 0018  	;			;		push,~go;	;			  | 2910 cntr was set to 1 above
    6b5  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    6b6  3b 00 8 0 0 7140 0120  	;			;		rfct;		;
    6b7  2a 00 e 0 0 9484 0124  	addw r[4],3,y;	;		;		adda,la,m,hi;
    6b8  2b 0d e 0 0 0003 0124  	;			am->fpbp;	;		;			  | fpbp <- address of saved pt
    6b9  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | saved x + (dx * t)
    6ba  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    6bb  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | saved y + (dy * t)
    6bc  2b 00 e 0 0 7140 0118  	;			;		;		;
    6bd  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    6be  2b 00 e 0 0 7140 0120  	;			;		;		;
    6bf  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    6c0  2b 00 e 0 0 7140 0120  	;			;		;		;
    6c1  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    6c2  2b 0e e 0 0 d84e 0122  	movw r[14],y;		am->fpdp;	;		;
    6c3  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | add x coord of intersect pt to output
    6c4  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    6c5  2a 00 e 0 0 dd77 0101  	incw r[23],r[23];		;		;		adda,st,hi;		  | add y coord of intersect pt to output
    6c6  3b 00 a 7 0 c3ce 0101  	add2nw 1,r[14],r[14];	;		crtn,go;	;			  | r[23] += 1; r[14] += 2; return
                                vwpsclpts2:										  | in-place 2-D viewport scale
                                											  | enter with acc,fpbp pointing to viewport
                                											  | params, r[0] pointing to pts to be scaled
                                											  | to viewport, and brreg containing npts-1
    6c7  2b 0c e 0 0 d840 0230  	movw r[0],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	  | fpap <- address of input pts
    6c8  2a 0e e 0 0 d840 0010  	movw r[0],y;		am->fpdp;	;		maba,lab,hi;		  | x[0] * VWPXSCL; fpdp points to input pts
    6c9  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    6ca  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y[0] * VWPYSCL
    6cb  2b 0d e 0 4 e385 0010  	sub2nw 1,acc;		am->fpbp;	;		;		ap+
    6cc  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x[1] * VWPXSCL
    6cd  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    6ce  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y[1] * VWPYSCL
    6cf  2b 0d e 0 4 e385 0010  	sub2nw 1,acc;		am->fpbp;	;		;		ap+
    6d0  2a 00 e 0 0 7140 0014  	;			;		;		maba,lab,m,hi;		  | x[2] * VWPXSCL;
    6d1  3b 0d 4 7 4 e384 0014  	add2nw 1,acc;		am->fpbp;	push,go;	;		ap+	  | loop through all pts (brreg == npts-1)
    6d2  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | y[i] * VWPYSCL; store x[i-2]
    6d3  2b 0d e 0 8 e385 0015  	sub2nw 1,acc;		am->fpbp;	;		;		adp+
    6d4  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | x[i+1] * VWPYSCL; store y[i-2]
    6d5  3b 0d 8 0 8 e384 0015  	add2nw 1,acc;		am->fpbp;	rfct;		;		adp+
    6d6  0a 0d e 0 0 e185 0000  	sub2nw 0,acc;		am->fpbp;	;		;			  | fpbp pts to VWPXOFF
    6d7  0a 0c e 0 0 d840 0000  	movw r[0],y;		am->fpap;	;		;			  | fpap <- address of scaled pts
    6d8  2a 0e e 0 0 d840 0110  	movw r[0],y;		am->fpdp;	;		adda,lab,hi;		  | (x[0] * VWPXSCL) + VWPXOFF;fpdp<-pt addr
    6d9  2b 0d e 0 4 e384 0110  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    6da  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | (y[0] * VWPYSCL) + VWPYOFF
    6db  2b 0d e 0 4 e385 0110  	sub2nw 1,acc;		am->fpbp;	;		;		ap+
    6dc  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | (x[1] * VWPXSCL) + VWPXOFF
    6dd  2b 0d e 0 4 e384 0110  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    6de  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | (y[1] * VWPYSCL) + VWPYOFF
    6df  2b 0d e 0 4 e385 0110  	sub2nw 1,acc;		am->fpbp;	;		;		ap+
    6e0  2a 00 e 0 0 7140 0112  	;			;		;		adda,lab,a,hi;		  | (x[2] * VWPXSCL) + VWPXOFF
    6e1  3b 0d 4 7 4 e384 0112  	add2nw 1,acc;		am->fpbp;	push,go;	;		ap+	  | loop through all pts (brreg == npts-1)
    6e2  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | (y[i] * VWPYSCL) + VWPYOFF; store x[i-2]
    6e3  2b 0d e 0 8 e385 0113  	sub2nw 1,acc;		am->fpbp;	;		;		adp+
    6e4  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | (x[i+1] * VWPYSCL)+VWPXOFF;store y[i-2]
    6e5  3b 0d 8 0 8 e384 0113  	add2nw 1,acc;		am->fpbp;	rfct;		;		adp+
    6e6  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | return
    6e7  02 00 e 0 0 d856 0000  mkedges2: movw,s r[22],y;	;		;		;
    6e8  02 00 3 8 0 d854 06eb  	movw,s r[20],y;	;		cjp,~zer edgpts2;;			  | if (r[22] > 0) goto edgpts2
    6e9  0a 00 3 8 0 7140 071a  	;			;		cjp,~zer lastedg2;;			  | else if no more pts in this boundary
    6ea  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | goto lastedg2; else return
    6eb  08 08 e 0 8 c1f6 0000  edgpts2: sub2nw 0,r[22],r[24];	am->brreg;	;		;			  | brreg <- r[22]-1
    6ec  08 00 e 0 0 d96f 0000  	movw r[15],r[0];		;		;		;			  | r[0] points to input pts
    6ed  0a 0d 1 7 0 eb86 06c7  	mov2nw 5,acc;		am->fpbp;	cjs,go vwpsclpts2;;			  | fpbp,acc <- address of viewport params
                                											  | vwpsclpts2 scales pts in place
    6ee  02 00 e 0 0 d855 0000  	movw,s r[21],y;	;		;		;
    6ef  0a 00 3 0 0 d915 0700  	movw 0,r[21];	;		cjp,zer mkedg2;	;			  | if not 1st pt of boundary, goto mkedg2
                                											  | r[21] <- FALSE
    6f0  2a 0c e 0 0 dc4f 0230  firstpt2: incw r[15],y;		am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap points to 1st pt y; flow mode
    6f1  2a 0e e 0 0 e596 00e0  	mov2nw 2,y;		am->fpdp;	;		fixa,la,hi;		  | convert y to int; fpdp <- 4
    6f2  2b 0c e 0 0 d84f 00e0  	movw r[15],y;		am->fpap;	;		;			  | fpap pts to 1st pt x
    6f3  0a 3b e 0 0 c1f6 0000  	sub2nw 0,r[22],r[22];	fpregh->fpregh;	;		;			  | fpreg[4] <- 1st pt x; r[22] -= 1
    6f4  0b 3b e 0 0 c3cf 0000  	add2nw 1,r[15],r[15];	fpregl->fpregl;	;		;			  | r[15] += 2
    6f5  0a 0e e 0 0 e796 0000  	mov2nw 3,y;		am->fpdp;	;		;			  | fpdp <- 8
    6f6  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | fpreg[8] <- 1st pt x (prev pt storage)
    6f7  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    6f8  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    6f9  2b 00 e 0 0 7140 0102  	;			;		;		;
    6fa  2a 00 e 0 0 f8e0 0101  	movw 9,y;		;		;		adda,st,hi;		  | fpreg[9] <- fixed y
    6fb  2b 0c e 0 0 0009 0101  	;			am->fpap;	;		;			  | fpap <- 9
    6fc  0b 37 e 0 0 f8c1 0000  	movw d,acc;		fpregl->am;	;		;			  | acc <- low 16 bits of int y
    6fd  0a 0b e 0 0 f880 0000  	movw acc,y;		am->fpregh;	;		;			  | low 16 bits to high word of fpreg[9]
    6fe  0a 2e e 0 0 7140 0005  	;			5->fpdp;	;		;			  | (prev pt storage in fpreg[9]); fpdp<-5
    6ff  0a 0b e 0 0 f880 0000  	movw acc,y;		am->fpregh;	;		;			  | fpreg[5,high]<-int y (1st pt storage)
    700  22 00 e 0 0 c1f6 0230  mkedg2:	sub2nw,s 0,r[22],r[22];	;		;		lmode rn,ai,flow,fast;	  | select flow mode; if((r[22]-=1)<0),
    701  0a 0c 3 1 0 dc4f 0719  	incw r[15],y;		am->fpap;	cjp,neg chklastedg2;;			  | goto chklastedg2; fpap <- &y[i]
    702  28 0e e 0 0 c3c8 00e0  	add2nw 1,r[8],r[0];	am->fpdp;	;		fixa,la,hi;		  | fix y[i]; fpdp <- &edg.xmax
    703  2b 0c e 0 0 d84f 00e0  	movw r[15],y;		am->fpap;	;		;			  | fpap <- &x[i]
    704  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- x[i]
    705  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    706  0a 0c e 0 0 e796 0000  	mov2nw 3,y;		am->fpap;	;		;			  | fpap <- &x[i-1] (prev pt)
    707  08 3b e 0 0 d968 0000  	movw r[8],r[0];	fpregh->fpregh;	;		;			  | edg.xmin <- x[i-1]; save r[8] in r[0]
    708  0b 3b e 0 8 c5c8 0000  	add2nw 2,r[8],r[8];	fpregl->fpregl;	;		;		adp+	  | r[8] += 4
    709  0b 0b e 0 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	;		;			  | edg.nxt <- r[8] <- addr of next edge
    70a  0a 0e e 0 0 d840 0000  	movw r[0],y;		am->fpdp;	;		;			  | fpdp <- addr of this edge
    70b  2a 3b e 0 6 7140 0102  	;			fpregh->fpregh;	;		adda,a,hi;	dp+	  | edg.ymin <- y[i-1] (prev y,16-bit int)
    70c  2b 00 e 0 0 c3cf 0102  	add2nw 1,r[15],r[15];	;		;		;			  | r[15] <- &x[i+1]
    70d  2a 37 e 0 0 f8c1 0101  	movw d,acc;		fpregh->am;	;		adda,st,hi;		  | edg.ymax<-y[i](32-bit int);acc<-prev y
    70e  2b 0c e 0 0 dc40 0101  	incw r[0],y;		am->fpap;	;		;			  | fpap <- &edg.ymax
    70f  03 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregl->am;	;		;			  | check for horizontal edges
    710  0b 37 3 0 4 f8c1 0714  	movw d,acc;		fpregl->am;	cjp,zer horizedg2;;		ap+	  | acc <- low order 16 bits of int y[i]
    711  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | if (r[9] -= 1) >= 0, goto savpt2
    712  0a 0b 3 9 0 f880 0715  	movw acc,y;		am->fpregh;	cjp,~neg savpt2;;			  | move low 16 bits to high word where
                                											  | scan conversion code expects to see it
    713  0a 00 e 0 0 db09 0000  edgovflw2: compw 0,r[9];	;		;		;			  | on edge overflow, r[9] <- -1 and
                                											  | adjust r[8]
    714  0a 27 e 0 0 9e08 0005  horizedg2: subw d,r[8],r[8]; 5->am;		;		;			  | ignore horizontal and overflow edges
    715  0a 0e e 0 0 e796 0000  savpt2:	mov2nw 3,y;		am->fpdp;	;		;			  | fpdp <- addr of prev pt (fpreg[8-9])
    716  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | prev pt <- current pt
    717  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+	  | 32-bit float x
    718  0a 0b 3 7 0 f880 0700  	movw acc,y;		am->fpregh;	cjp,go mkedg2;	;			  | 16-bit int y in high word; loop back
    719  02 00 e 0 0 d854 0000  chklastedg2: movw,s r[20],y;;		;		;
    71a  12 00 a 0 0 d855 0000  lastedg2: movw,s r[21],y;	;		crtn,zer;	;			  | return if may be more pts in boundary
    71b  1a 2c a 8 0 7140 0005  	;			5->fpap;	crtn,~zer;	;			  | fpap <- addr of 1st y; return if no pts
    71c  0a 37 e 0 0 d8c0 0000  	movw d,r[0];		fpregh->am;	;		;			  | r[0] <- 1st y (16-bit int)
    71d  0a 2c e 0 0 7140 0009  	;			9->fpap;	;		;			  | fpap <- addr of prev pt y
    71e  02 37 e 0 0 9700 0000  	xorw,s d,r[0],y;		fpregh->am;	;		;			  | check for horizontal last edge
    71f  1a 0e a 0 0 d848 0000  	movw r[8],y;		am->fpdp;	crtn,zer;	;			  | rtn if horiz; fpdp<-addr for last edge
    720  0a 3b e 0 6 7140 0000  	;			fpregh->fpregh;	;		;		dp+	  | edg.ymin <- prev y
    721  0a 0b e 0 6 d840 0000  	movw r[0],y;		am->fpregh;	;		;		dp+	  | edg.ymax <- 1st y
    722  0a 0c e 0 0 e596 0000  	mov2nw 2,y;		am->fpap;	;		;			  | fpap <- addr of 1st pt x
    723  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- 1st x
    724  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    725  0a 0c e 0 0 e796 0000  	mov2nw 3,y;		am->fpap;	;		;			  | fpap <- addr of prev pt x
    726  0a 3b e 0 0 c5c8 0000  	add2nw 2,r[8],r[8];	fpregh->fpregh;	;		;			  | edg,xmin <- prev x; r[8] += 4
    727  03 3b e 0 6 c1e9 0000  	sub2nw,s 0,r[9],r[9]; fpregl->fpregl;;		;		dp+	  | r[9] -= 1
    728  1b 0b a 9 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	crtn,~neg;	;			  | edg.nxt <- r[8] <- addr of next edge
                                											  | if r[9] >= 0, return
    729  0a 00 e 0 0 db09 0000  	compw 0,r[9];		;		;		;			  | else r[9] <- -1
    72a  1a 27 a 7 0 9e08 0005  	subw d,r[8],r[8];	5->am;		crtn,go;	;			  | adjust r[8] and return
                                 |	movw d,r[11];		shmem->am;	jmap PROC_PGON_INT_2D;;			  | # of separate boundaries
                                PROC_PGON_INT_2D:
    72b  0a 27 e 0 0 d8c5 0851   	movw d,r[5];		=xfint3->am;	;		;			  | set ptr to do fixtofloat and fall 
                                 											  | through to use regular xf3 routine
    72c  0a 00 3 7 0 d918 072f   	movw 0,r[24]; ;		cjp,go cwpoly2;	;			  | after set ptr, use float routine
                                 |	movw d,r[11];		shmem->am;	jmap PROC_PGON_FLT_2D;;			  | # of separate boundaries
                                PROC_PGON_FLT_2D:
    72d  0a 27 e 0 0 d8c5 0862   	movw d,r[5];		=xf3->am;	;		;			  | use the regular xf3 routine
    72e  0a 00 e 0 0 d918 0000   	movw 0,r[24];;		;		;
    72f  0a 27 e 0 0 869d 0004  cwpoly2: addw d,r[29],acc;	 4->am; ;		;			  | 
    730  0a 0f e 0 0 f880 0000   	movw acc,y;		am->shmemp;	;		;
    731  0a 17 c 0 2 d8cc 0001   	movw d,r[12];	shmem->am;	ldct 1;		;		shp+	  | save clipplanes
    732  0a 1f 1 7 0 7140 042b   	;			shmem->shmemp;	cjs,go expmtrx; ;			  | shmemp <- r[9]
    733  0a 27 e 0 0 869d 0034   	addw d,r[29],acc;	 52->am;;		;
    734  0a 0f c 0 0 f880 0003   	movw acc,y;		am->shmemp;	ldct 3;		;			  | shmemp <- addr of vwp params
    735  0a 0e 1 7 0 eb96 0428   	mov2nw 5,y;		am->fpdp;	cjs,go expvwp;	;			  | move viewport parameters to fpr[32]
    736  0a 00 1 7 0 ffb8 0c0d   	bsetw 15,r[24]; ;		cjs,go cwp3;	;			  | continue with PROC_PGON_FLT_3D
    737  0a 3a e 0 2 c5d2 0000  cwpout2: add2nw 2,r[18],r[18]; fpregh->shmem; ;		;		shp+	  | x,y to shmem
    738  0b 3a e 0 b 7140 0000  	;			fpregl->shmem; ;		;		shp+,abp+ | r[18] += 4
    739  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  |	
    73a  0b 3a 4 7 b 7140 0002  	;			fpregl->shmem;	push,go 2;	;		shp+,abp+ |
    73b  1a 00 8 0 4 7140 0000  	;			;		rfct;		;		ap+	  | skip z,r[20],i
    73c  02 00 3 7 0 c1ea 0c49  	sub2nw,s 0,r[10],r[10]; ;		cjp,go corendcvertloop3; ;		  | r[10]-=1 and loop back
                                | "@(#)3Dfp.vp.u 1.4 86/09/13"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | data pointers for 3-D routines
                                |   Floating point register addresses for xf_line_flt_3d & xf_line_int_3d
                                |   	store pt1	stored at fpr[64] (fpdp=64)
                                |   	store pt2	stored at fpr[68] (fpdp=68)
                                |	xform pt1	r[15]=64, r[14] = 72
                                |	xform pt2	r[15]=68, r[14] = 76
                                |   	clip vector	r[15]=72, r[14] = x
                                |	vwp pts 1 & 2	r[15]=72, r[14] = 80	
                                |   	store xf pt2	stored at fpr[88] (this is done before we clip)
                                |   xfln3dinit sets up the texture attributes on the pp, loads the 3d matrix and viewport scaling parameters,
                                |   and loads 1.0 for w2 before returning.  It is called by xflineflt3d, and xflineint3d. 
                                xfln3dinit:
    73d  0a 00 e 0 0 949d 0000  	addw r[29], 28,y; ;		;		;			| 
    73e  0a 0f 1 7 0 001c 02bb  	;			am->shmemp;	cjs, go tvec_attr; ;			| Texture addr->scrmemp.
    73f  0a 0f c 0 0 d849 000f  	movw r[9],y;	am->shmemp;	ldct 15;	;			| 
    740  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr; ;			| 0 matrix to fpr[16]
    741  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am; ;		;			| 
    742  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;			| 0 viewport parameters to fpr[32]
    743  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr; ;			| N.B.: only x and y params (not z)
    744  0a 2e e 0 0 7140 0047  	;			71->fpdp;	;		;			| movw w2=1.0 to fpr[71] (only done once)
    745  0a 2b e 0 0 7140 3f80  	;			0x3F80->fpregh;	;		;			| 
    746  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
    747  0a 0f c 0 0 d85e 0002  	movw r[30],y;		am->shmemp;	ldct 2;		;			| 
    748  12 17 a 7 2 d8d0 0000  	movw,s d,r[16];	shmem->am;	crtn, go;	;		shp+	| pull first r[16] element & return.
                                |	incw r[30],r[30];	;		jmap XF_LINE_FLT_3D;			| r[30] points to first element of r[16]			
                                XF_LINE_FLT_3D: 
    749  0a 00 1 7 0 7140 073d  	;			;		cjs,go xfln3dinit; ;			| 
    74a  0a 0e 1 7 0 cd8f 0080  xf1stpt: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			| r[15]=64, 0 pt1 x,y,z to here
    74b  0a 27 e 0 0 9e9e 0007  	addw d,r[30],r[30];	7->am;		;		;			| r[30] += 7
    74c  0a 00 3 1 0 7140 0027  	;			;		cjp,neg getcmd; ;			| return if was last pt
    74d  02 17 c 0 2 e190 0002  	btstw,s 0,d;		shmem->am;	ldct 2;		;		shp+	| r[16] for second point
    74e  02 00 3 8 0 d8d0 074a  	movw,s d,r[16];	;		cjp,~zer xf1stpt; ;			| jump if 2nd point is a 0.
    74f  08 2b e 0 e c7cf 3f80  	add2nw 3,r[15],r[14];	0x3F80->fpregh;	;		;			| r[14]=72, want xf pt1 x,y,z,r[20] here
    750  0b 0b e 0 0 f900 0000  	movw 0,y;		am->fpregl;	;		;			| w1 = 1.0 at fpr[67]
    751  0a 0c 1 7 0 e996 0862  	mov2nw 4,y;		am->fpap;	cjs,go xf3;	;			| matrix ptr in fpap; xform 1st point
    752  0a 00 e 0 0 c7cf 0000  	add2nw 3,r[15];		;		;		;			| r[15] = 72
    753  0a 00 e 0 0 c7ce 0000  	add2nw 3,r[14];	;		;		;			| r[14] = 80
    754  0a 2c e 0 0 7140 0010  xf2ndpt: ;			16->fpap;	;		;			| 0 pt2 x,y,z coords to fpr[68]
    755  0a 0e 1 7 0 c5ef 0080  	sub2nw 2,r[15];		am->fpdp;	cjs,go shm_to_fpr; ;			| r[15] = 68, fetch pt2 x,y,z & store here
    756  0a 00 1 7 0 c5ee 0862  	sub2nw 2,r[14];	;		cjs,go xf3;	;			| r[14] = 76, want xf 2nd pt here
    757  0a 2e e 0 0 7140 0058  	;			88->fpdp;	;		;			| store xformed, unclipped pt2 at fpr[88]
    758  0a 2c e 0 0 c580 004c  	mov2nw 2,r[0];		76->fpap;	;		;			| xformed pt2 is currently at fpr[76]
    759  02 3b e 0 0 c1e0 0000  xfstpt2: sub2nw,s 0,r[0];	fpregh->fpregh;	;		;			| 
    75a  03 3b 3 8 8 d84b 0759  	movw,s r[11],y;	fpregl->fpregl;	cjp,~zer xfstpt2; ;		adp+	| increment a & d pointers, loop till done
    75b  02 0c 1 8 0 c5cf 08d9  	add2nw,s 2,r[15];	am->fpap;	cjs,~zer clpvec3;;			| r[15] = 72 (xf 1st pt.) clip vector if r[11]!=0;
                                											| also if no clip, force cc to ~zer so vec is drawn
    75c  0a 00 1 8 0 c5ce 08ab  	add2nw 2,r[14];	;		cjs,~zer vwpsndvec3_xy;;		| r[14] = 80.  if visible, scale to viewport, cnvrt to
                                											| int, & xmit to PP
    75d  02 27 e 0 0 d850 0007  	movw,s r[16],y;	7->am;		;		;			| test if just sent last vector
    75e  0a 0f 3 1 0 9e9e 0027  	addw d,r[30],r[30];	am->shmemp;	cjp,neg getcmd;	;			| r[30] += 7 and exit if was last vector
    75f  0a 17 c 0 2 d8d0 0002  	movw d,r[16];		shmem->am;	ldct 2;		;		shp+	| fetch r[16] for next point
    760  02 2c e 0 0 e1f0 0058  	btstw,s 0,r[16];	88->fpap;	;		;			| copy xf pt2 to xf pt1 area
    761  0a 2e e 0 0 c580 0048  	mov2nw 2,r[0];		72->fpdp;	;		;			| 
    762  02 00 3 8 0 d850 074a  	movw,s r[16],y;	;		cjp,~zer xf1stpt; ;			| Will check if last point if jump.
    763  02 3b e 0 0 c1e0 0000  	sub2nw,s 0,r[0];	fpregh->fpregh;	;		;			| jump if 2nd point is a movw
    764  0b 3b 3 0 8 7140 0754  xfswap:	;			fpregl->fpregl;	cjp,zer xf2ndpt; ;		adp+	| increment a & d pointers
    765  02 3b 3 7 0 c1e0 0764  	sub2nw,s 0,r[0];	fpregh->fpregh;	cjp,go xfswap;	;			| loop
                                |	incw r[30],r[30];	;		jmap XF_LINE_INT_3D;			| r[30] points to first element of r[16]			
                                XF_LINE_INT_3D: 
    766  0a 00 1 7 0 7140 073d  	;			;		cjs,go xfln3dinit; ;			| 
    767  0a 0e 1 7 0 cd8f 0080  xf1stpti: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			| r[15]=64, 0 pt1 x,y,z to here
    768  0a 27 e 0 0 9e9e 0007  	addw d,r[30],r[30];	7->am;		;		;			| r[30] += 7
    769  0a 00 3 1 0 7140 0027  	;			;		cjp,neg getcmd; ;			| return if was last pt
    76a  02 17 c 0 2 e190 0002  	btstw,s 0,d;		shmem->am;	ldct 2;		;		shp+	| r[16] for second point
    76b  02 00 3 8 0 d8d0 0767  	movw,s d,r[16];	;		cjp,~zer xf1stpti; ;			| jump if 2nd point is a 0.
    76c  08 2b e 0 e c7cf 3f80  	add2nw 3,r[15],r[14];	0x3F80->fpregh;	;		;			| r[14]=72, want xf pt1 x,y,z,r[20] here
    76d  0b 0b e 0 0 f900 0000  	movw 0,y;		am->fpregl;	;		;			| w1 = 1.0 at fpr[67]
    76e  0a 0c 1 7 0 e996 0851  	mov2nw 4,y;		am->fpap;	cjs,go xfint3; ;			| matrix ptr in fpap; convert to int & xform 1st point
    76f  0a 00 e 0 0 c7cf 0000  	add2nw 3,r[15];		;		;		;			| r[15] = 72
    770  0a 00 e 0 0 c7ce 0000  	add2nw 3,r[14];	;		;		;			| r[14] = 80
    771  0a 2c e 0 0 7140 0010  xf2ndpti: ;			16->fpap;	;		;			| 0 pt2 x,y,z coords to fpr[68]
    772  0a 0e 1 7 0 c5ef 0080  	sub2nw 2,r[15];		am->fpdp;	cjs,go shm_to_fpr; ;			| r[15] = 68, fetch pt2 x,y,z & store here
    773  0a 00 1 7 0 c5ee 0851  	sub2nw 2,r[14];	;		cjs,go xfint3; ;			| r[14] = 76, 2nd pt->int & xform to here
    774  0a 2e e 0 0 7140 0058  	;			88->fpdp;	;		;			| store xformed, unclipped pt2 at fpr[88]
    775  0a 2c e 0 0 c580 004c  	mov2nw 2,r[0];		76->fpap;	;		;			| xformed pt2 is currently at fpr[76]
    776  02 3b e 0 0 c1e0 0000  xfstpt2i: sub2nw,s 0,r[0];	fpregh->fpregh;	;		;			| 
    777  03 3b 3 8 8 d84b 0776  	movw,s r[11],y;	fpregl->fpregl;	cjp,~zer xfstpt2i; ;		adp+	| increment a & d pointers, loop till done
    778  02 0c 1 8 0 c5cf 08d9  	add2nw,s 2,r[15];	am->fpap;	cjs,~zer clpvec3;;			| r[15] = 72 (xf 1st pt.) clip vector if r[11]!=0;
                                											| also if no clip, force cc to ~zer so vec is drawn
    779  0a 00 1 8 0 c5ce 08ab  	add2nw 2,r[14];	;		cjs,~zer vwpsndvec3_xy;;		| r[14] = 80.  if visible, scale to viewport, cnvrt to
                                											| int, & xmit to PP
    77a  02 27 e 0 0 d850 0007  	movw,s r[16],y;	7->am;		;		;			| test if just sent last vector
    77b  0a 0f 3 1 0 9e9e 0027  	addw d,r[30],r[30];	am->shmemp;	cjp,neg getcmd;	;			| r[30] += 7 and exit if was last vector
    77c  0a 17 c 0 2 d8d0 0002  	movw d,r[16];		shmem->am;	ldct 2;		;		shp+	| fetch r[16] for next point
    77d  02 2c e 0 0 e1f0 0058  	btstw,s 0,r[16];	88->fpap;	;		;			| copy xf pt2 to xf pt1 area
    77e  0a 2e e 0 0 c580 0048  	mov2nw 2,r[0];		72->fpdp;	;		;			| 
    77f  02 00 3 8 0 d850 0767  	movw,s r[16],y;	;		cjp,~zer xf1stpti; ;			| Will check if last point if jump.
    780  02 3b e 0 0 c1e0 0000  	sub2nw,s 0,r[0];	fpregh->fpregh;	;		;			| jump if 2nd point is a movw
    781  0b 3b 3 0 8 7140 0771  xfswapi: ;			fpregl->fpregl;	cjp,zer xf2ndpti; ;		adp+	| increment a & d pointers
    782  02 3b 3 7 0 c1e0 0781  	sub2nw,s 0,r[0];	fpregh->fpregh;	cjp,go xfswapi; ;			| loop
                                |   xfln3dinit is called by xfvec_3d and corendcvec_3d to perform initialization.
                                xfvec3dinit:
    783  0a 0f 1 7 0 d85d 02bc  	movw r[29],y;	am->shmemp;	cjs,go vec_attr; ;			  | 
    784  0a 0f c 0 0 d849 000f  	movw r[9],y;	am->shmemp;	ldct 15;	;
    785  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    786  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    787  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;			  | move viewport parameters to fpr[32]
    788  0a 0e 3 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjp,go shm_to_fpr; ;			  | only x and y params, will return
                                |	negw d,r[10];		shmem->am;	jmap XFVEC_3D;	;
    789  0a 00 1 7 0 7140 0783  XFVEC_3D: ;			;		cjs,go xfvec3dinit; ;			  | initialization for old format opers.
    78a  0a 0f c 0 0 c3de 0002  	add2nw 1,r[30];	am->shmemp;	ldct 2;		;
    78b  0a 0e 1 7 0 cd8f 0080  nxtvec3: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr;;			  | move pt1 x,y,z coords to fpr[64]
    78c  0a 2b e 0 0 c5de 3f80  	add2nw 2,r[30];	0x3F80->fpregh;	;		;			  | w1 = 1.0, r[30] += 4
    78d  0b 0b c 0 6 f900 0002  	movw 0,y;		am->fpregl;	ldct 2;		;		dp+	  | ldct 2 into 2910 counter
    78e  02 00 1 7 0 d84b 0080  	movw,s r[11],y;	;		cjs,go shm_to_fpr;;			  | move pt2 x,y,z coords to fpr[68]
                                											  | r[11]==0? (xf3 doesn't affect cc's)
    78f  08 2b e 0 e c7cf 3f80  	add2nw 3,r[15],r[14];	0x3F80->fpregh;	;		;			  | want transformed endpoints at fpr[72]
    790  0b 0b e 0 0 f900 0000  	movw 0,y;		am->fpregl;	;		;			  | w2 = 1.0
    791  0a 0c 1 7 0 e996 0862  	mov2nw 4,y;		am->fpap;	cjs,go xf3;	;			  | matrix ptr in fpap; xform 1st point
    792  0a 2c e 0 0 c5cf 0010  	add2nw 2,r[15];		16->fpap;	;		;
    793  0a 00 1 7 0 c5ce 0862  	add2nw 2,r[14];	;		cjs,go xf3;	;			  | transform 2nd point
    794  02 0c 1 8 0 c5cf 08d9  	add2nw,s 2,r[15];	am->fpap;	cjs,~zer clpvec3;;			  | clip vector if r[11]!=0; also if no
                                											  | clip, force cc to ~zer so vec is drawn
    795  0a 00 1 8 0 c5ce 08ab  	add2nw 2,r[14];	;		cjs,~zer vwpsndvec3_xy;;		  | if visible, scale to viewport, cnvrt to
                                											  | int, & xmit to PP
    796  02 00 c 0 0 dd6a 0002  	incw,s r[10],r[10];	;		ldct 2;		;			  | reload 2910 R reg; incr vec loop cntr
    797  0a 0f 3 8 0 c7de 078b  	add2nw 3,r[30];	am->shmemp;	cjp,~zer nxtvec3;;			  | r[30] += 8 and loop if more vectors
    798  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |	negw d,r[10];		shmem->am;	jmap CORENDCVEC_3D;;
                                CORENDCVEC_3D:
    799  0a 00 1 7 0 7140 0783  	;			;		cjs,go xfvec3dinit; ;			  | initialization for old format opers.
    79a  0a 0f c 0 0 c3de 0002  	add2nw 1,r[30];	am->shmemp;	ldct 2;		;
    79b  0a 0e 1 7 0 cd8f 0080  cnxtvec3: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr;;			  | move pt1 x,y,z coords to fpr[64]
    79c  0a 2b e 0 0 c5de 3f80  	add2nw 2,r[30];	0x3F80->fpregh;	;		;			  | w1 = 1.0, r[30] += 4
    79d  0b 0b c 0 6 f900 0002  	movw 0,y;		am->fpregl;	ldct 2;		;		dp+	  | ldct 2 into 2910 counter
    79e  02 00 1 7 0 d84b 0080  	movw,s r[11],y;	;		cjs,go shm_to_fpr;;			  | move pt2 x,y,z coords to fpr[68]
                                											  | r[11]==0? (xf3 doesn't affect cc's)
    79f  08 2b e 0 e c7cf 3f80  	add2nw 3,r[15],r[14];	0x3F80->fpregh;	;		;			  | want transformed endpoints at fpr[72]
    7a0  0b 0b 1 7 0 f900 07a9  	movw 0,y;		am->fpregl;	cjs,go ndcflt3;	;			  | w2 = 1.0; convert xyz's to float
    7a1  0a 0c 1 7 0 e996 0862  	mov2nw 4,y;		am->fpap;	cjs,go xf3;	;			  | matrix ptr in fpap; xform 1st point
    7a2  0a 2c e 0 0 c5cf 0010  	add2nw 2,r[15];		16->fpap;	;		;
    7a3  0a 00 1 7 0 c5ce 0862  	add2nw 2,r[14];	;		cjs,go xf3;	;			  | transform 2nd point
    7a4  02 0c 1 8 0 c5cf 08d9  	add2nw,s 2,r[15];	am->fpap;	cjs,~zer clpvec3;;			  | clip vector if r[11]!=0; also if no
                                											  | clip, force cc to ~zer so vec is drawn
    7a5  0a 00 1 8 0 c5ce 08ab  	add2nw 2,r[14];	;		cjs,~zer vwpsndvec3_xy;;		  | if visible, scale to viewport, cnvrt to
                                											  | int, & xmit to PP
    7a6  02 00 c 0 0 dd6a 0002  	incw,s r[10],r[10];	;		ldct 2;		;			  | reload 2910 R reg; incr vec loop cntr
    7a7  0a 0f 3 8 0 c7de 079b  	add2nw 3,r[30];	am->shmemp;	cjp,~zer cnxtvec3;;			  | r[30] += 8 and loop if more vectors
    7a8  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
    7a9  2b 0c e 0 0 d84f 0230  ndcflt3: movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	  | cnvrt 2 xyz's starting at inptr to float
    7aa  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | x0
    7ab  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    7ac  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | y0
    7ad  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    7ae  2a 00 e 0 0 848f 00a0  	addw r[15],4,acc;	;		;		floata,la,hi;		  | z0
    7af  2b 0c e 0 0 0004 00a0  	;			am->fpap;	;		;
    7b0  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | x1
    7b1  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    7b2  2a 08 e 0 0 e196 00a2  	mov2nw 0,y;		am->brreg;	;		floata,la,a,hi;		  | y1
    7b3  3b 0e 4 7 4 d84f 00a2  	movw r[15],y;		am->fpdp;	push,go;	;		ap+
    7b4  2a 00 e 0 0 7140 00a3  	;			;		;		floata,la,a,st,hi;	  | z1; store x0' & y0'
    7b5  3b 00 8 0 6 7140 00a3  	;			;		rfct;		;		dp+
    7b6  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store z0
    7b7  3b 0e 4 7 0 f880 0123  	movw acc,y;		am->fpdp;	push,go;	;
    7b8  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store x1 and y1
    7b9  3b 00 8 0 6 7140 0123  	;			;		rfct;		;		dp+
    7ba  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store z1
    7bb  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | return
                                |	negw d,r[10];		shmem->am;	jmap PROC_LINE_INT_3D;;
                                PROC_LINE_INT_3D:
    7bc  0a 27 e 0 0 d8c5 0851  	movw d,r[5];		=xfint3->am;	;		;			  | set ptr to fixtofloat routine
    7bd  0a 00 3 7 0 7140 07bf  	;			;		cjp,go cwdvec3;	;			  | and fall through to xf3. otherwise
                                											  | use regular float routine
                                |	negw d,r[10];		shmem->am;	jmap COREWLDVECNDC_3D;;
                                COREWLDVECNDC_3D:
    7be  0a 27 e 0 0 d8c5 0862  	movw d,r[5];		=xf3->am;	;		;			  | set ptr to regular xf3 routine
    7bf  0a 27 e 0 0 869d 0004  cwdvec3: addw d,r[29],acc;	 4->am; ;		;			  | 
    7c0  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
    7c1  0a 17 e 0 2 d8cb 0000  	movw d,r[11];	shmem->am;	;		;		shp+	  | save r[11]
    7c2  0a 1f c 0 0 d906 000f  	movw 0,r[6];	shmem->shmemp;	ldct 15;	;			  | shmemp <- r[9]
    7c3  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    7c4  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    7c5  0a 0f c 0 0 f880 0005  	movw acc,y;		am->shmemp;	ldct 5;		;			  |shmemp <- addr of vwp params
    7c6  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move viewport parameters to fpr[32]
    7c7  0a 0f c 0 0 c3de 0002  	add2nw 1,r[30];	am->shmemp;	ldct 2;		;
                                cwnnxtvec3:
    7c8  0a 0e 1 7 2 cd8f 0080  	mov2nw 6,r[15];		am->fpdp;	cjs,go shm_to_fpr;;		shp+	  | move pt1 x,y,z coords to fpr[64]
    7c9  0a 2b e 0 0 7140 3f80  	;			0x3F80->fpregh;	;		;			  | w1 = 1.0
    7ca  0b 0b c 0 6 f900 0002  	movw 0,y;		am->fpregl;	ldct 2;		;		dp+	  | ldct 2 into 2910 counter
    7cb  02 00 1 7 0 d84b 0080  	movw,s r[11],y;	;		cjs,go shm_to_fpr;;			  | move pt2 x,y,z coords to fpr[68]
                                											  | r[11]==0? (xf3 doesn't affect cc's)
    7cc  0a 00 1 7 0 7140 07e3  	;			;		cjs,go cwn3;	;			  | shared routine to process 3D vector
    7cd  02 00 e 0 0 e1e6 0000  cwnout3: btstw,s 0,r[6];	;		;		;			  | test if invisible
    7ce  0a 00 3 8 0 7140 07f7  	;			;		cjp,~zer cwnnovec3; ;			  | if so next vector
    7cf  2b 0c e 0 0 d844 0230  	movw r[4],y;	am->fpap;	;		lmode rn,ai,pipe,fast;	  | fpap <- &x0; pipeline mode
    7d0  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | convert x0 to integer
    7d1  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+
    7d2  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | y0
    7d3  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+
    7d4  2a 00 e 0 0 f8e0 00e0  	movw 76,y;		;		;		fixa,la,hi;		  | z0
    7d5  2b 0c e 0 0 004c 00e0  	;			am->fpap;	;		;			  | fpap <- &x1
    7d6  2a 00 e 0 0 f8e0 00e0  	movw 5,y;		;		;		fixa,la,hi;		  | x1
    7d7  2b 08 e 0 4 0005 00e0  	;			am->brreg;	;		;		ap+	  | brreg <- 5
    7d8  2a 00 e 0 0 7140 00e2  	;			;		;		fixa,la,a,hi;		  | y1
    7d9  3b 0e 4 7 4 f900 00e2  	movw 0,y;		am->fpdp;	push,go;	;		ap+	  | fpdp <- 0; 2910 R reg <- 5
    7da  2a 00 e 0 0 7140 00e3  	;			;		;		fixa,la,a,st,hi;	  | fix z1; store x0,y0,z0,x1,y1,z1 starting
    7db  3b 0c 8 0 6 f900 00e3  	movw 0,y;		am->fpap;	rfct;		;		dp+	  | fpreg[0]; fpap <- 0
    7dc  1a 27 4 7 0 9e9e 000d  	addw d,r[30],r[30];	13->am;		push,go;	;			  | r[30] += 13
    7dd  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | overwrite original coords in shmem
    7de  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
                                cwnloop3:
    7df  0a 0a e 0 2 f900 0000  	movw 0,y;		am->shmem;	;		;		shp+	  | dataready[i] <- 0;shmemp <- nxt vec addr
    7e0  02 00 c 0 0 dd6a 0002  	incw,s r[10],r[10];	;		ldct 2;		;			  | reload 2910 R reg; incr vec loop cntr
    7e1  0a 00 3 8 0 dd7e 07c8  	incw r[30],r[30];	;		cjp,~zer cwnnxtvec3;;			  | r[30] += 1 and loop if more vectors
    7e2  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
    7e3  0a 08 e 0 0 d845 0000  cwn3:	movw r[5],y;		am->brreg;	;		;			  | 
    7e4  08 2b e 0 e c7cf 3f80  	add2nw 3,r[15],r[14];	0x3F80->fpregh;	;		;			  | want transformed endpoints at fpr[72]
    7e5  0b 0b e 0 0 f900 0000  	movw 0,y;		am->fpregl;	;		;			  | w2 = 1.0
    7e6  1a 0c 1 7 0 e996 0000  	mov2nw 4,y;		am->fpap;	cjs,go;		;			  | matrix ptr in fpap; xform 1st point
    7e7  0a 2c e 0 0 c5cf 0010  	add2nw 2,r[15];		16->fpap;	;		;
    7e8  1a 00 1 7 0 c5ce 0000  	add2nw 2,r[14];	;		cjs,go;		;			  | transform 2nd point
    7e9  02 0c 1 8 0 c5cf 08d9  	add2nw,s 2,r[15];	am->fpap;	cjs,~zer clpvec3;;			  | clip vector if r[11]!=0; also if no
                                											  | clip, force cc to ~zer so vec is vwpscld
    7ea  0a 00 3 0 0 d80b 07f6  	movw r[11],acc;	;		cjp,zer cwnsetreslt;;			  | if invisible, don't scale to viewport
    7eb  02 00 e 0 0 90c7 0000  	andw,s r[7],acc,y;;		;		;			  | set cc to reflect clip status of pt1
    7ec  0a 00 3 0 0 d900 07ee  	movw 0,r[0];		;		cjp,zer .+2;	;			  | r[0]<-0; compute resultflag[i] in r[0]
    7ed  0a 00 e 0 0 e1a0 0000  	bsetw 0,r[0];		;		;		;			  | set bit 0 if pt1 was clipped
    7ee  02 00 e 0 0 90c8 0000  	andw,s r[8],acc,y;;		;		;			  | set cc to reflect clip status of pt2
    7ef  0a 0f 3 0 0 d85e 07f1  	movw r[30],y;		am->shmemp;	cjp,zer .+2;	;			  | shmemp <- &resultflag[i]
    7f0  0a 0a 3 7 2 e3a0 07f2  	bsetw 1,r[0];		am->shmem;	cjp,go .+2;	;		shp+	  | set bit 1 if pt2 clip; resultflag<-r[0]
    7f1  0a 0a e 0 2 d840 0000  	movw r[0],y;		am->shmem;	;		;		shp+	  | resultflag<-r[0] (if pt2 not clipped)
                                											  | clpvec3 returns with fpap==r[15] if pt
                                											  | visible, so fpap==r[15]==72 from above
    7f2  08 0e 4 7 4 c1ef 0003  	sub2nw 0,r[15],r[4]; am->fpdp;	push,go 3;	;			  | fpdp <- r[4] <- 71
    7f3  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | shift x0,y0,z0,w0 up by 1 fpreg location
    7f4  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | so spacing between x0 and x1 is correct
                                											  | for vwpsclpts3 routine (5 locations)
    7f5  0a 08 3 7 0 fd00 0b6b  	incw 0,y;		am->brreg;	cjp,go vwpsclpts3;;			  | call vwpsclpts3 with brreg==1 (npts-1)
                                											  | & r[4]==&x0 to vwpscl pts in place
                                cwnsetreslt:
    7f6  1a 00 a 7 0 c186 0000  	mov2nw 0,r[6];	;		crtn,go;	;			  | set resultflag = 1 for invisible
                                cwnnovec3:
    7f7  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- &resultflag[i]
    7f8  0a 2a e 0 0 9c9e ffff  	addw r[30],13,r[30];	0xFFFF->shmem;	;		;			  | resultflag for this vector <- 0xFFFF
    7f9  0a 0f 3 7 0 000d 07df  	;			am->shmemp;	cjp,go cwnloop3;;			  | shmemp <- r[30] <- &dataready[i]
                                											  | goto cwnloop3
                                |   mulptinit3 does the initialization for mulpt int and flt 3d.
                                mulptinit3:
    7fa  0a 28 e 0 0 949d 0003  	addw r[29],5,y; 3->brreg; ;		;			  | brreg <- 3
    7fb  0a 0f e 0 0 0005 0000  	;			am->shmemp;	;		;			  | shmemp <- addr of r[9]
    7fc  0a 1f c 0 0 c58e 000f  	mov2nw 2,r[14];	shmem->shmemp;	ldct 15;	;			  | shmemp <- addr of matrix; r[14] <- 4
    7fd  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    7fe  1a 0f c 0 0 c3de 0000  	add2nw 1,r[30];	am->shmemp;	ldct;		;			  | shmemp <- (r[30] += 2), addr of 1st pt
    7ff  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | 
                                |	negw d,r[10];		shmem->am;	jmap MUL_POINT_FLT_3D;;			  | r[10] <- -npts
                                MUL_POINT_FLT_3D:
    800  0a 00 1 7 0 7140 07fa  	;			;		cjs,go mulptinit3; ;			  | 
    801  0a 0e 1 7 0 d90f 0080  xfpt3nxt: movw 0,r[15];		am->fpdp;	cjs,go shm_to_fpr;;			  | move pt[i] to fpr[0]
    802  0a 0c 1 7 0 e996 0862  	mov2nw 4,y;		am->fpap;	cjs,go xf3;	;			  | xform pt and store result at fpr[4]
    803  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- addr of pt
    804  12 2c 4 7 0 dd6a 0004  	incw,s r[10],r[10];	4->fpap;	push,go;	;			  | r[10] += 1; fpap <- addr of xformed pt
    805  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move xformed pt to shared memory,
    806  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | overwriting original pt
    807  1a 27 c 0 0 9e9e 0009  	addw d,r[30],r[30];	9->am;		ldct;		;			  | r[30] += 9, addr of pt[i+1]
    808  0a 0a 3 8 2 f900 0801  	movw 0,y;		am->shmem;	cjp,~zer xfpt3nxt;;		shp+	  | flag[i] <- 0, indicating xform done
                                											  | loop back for next pt;shmemp == &pt[i+1]
    809  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |	negw d,r[10];		shmem->am;	jmap MUL_POINT_INT_3D;;			  | r[10] <- -npts
                                MUL_POINT_INT_3D:
    80a  0a 00 1 7 0 7140 07fa  	;			;		cjs,go mulptinit3; ;			  | 
    80b  0a 0e 1 7 0 d90f 0080  xfpt3nxti: movw 0,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			  | move pt[i] to fpr[0]
    80c  0a 0c 1 7 0 e996 083d  	mov2nw 4,y;		am->fpap;	cjs,go xfint3w;	;			  | xform pt & r[20] & store result at fpr[4]
    80d  08 00 1 7 f d96e 082a  	movw r[14],r[15];	;		cjs,go fltoint3; ;			  | convert float res to int, need r[15]
    80e  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- addr of pt
    80f  12 2c 4 7 0 dd6a 0004  	incw,s r[10],r[10];	4->fpap;	push,go;	;			  | r[10] += 1; fpap <- addr of xformed pt
    810  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move xformed pt to shared memory,
    811  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | overwriting original pt
    812  1a 27 c 0 0 9e9e 0009  	addw d,r[30],r[30];	9->am;		ldct;		;			  | r[30] += 9, addr of pt[i+1]
    813  0a 0a 3 8 2 f900 080b  	movw 0,y;		am->shmem;	cjp,~zer xfpt3nxti;;		shp+	  | flag[i] <- 0, indicating xform done
                                											  | loop back for next pt;shmemp == &pt[i+1]
    814  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |	rolw 5,d,acc;		shmem->am;	jmap MATMUL_3D;	;		shp+	  | acc <- indexA*32
                                MATMUL_3D:
    815  0a 17 e 0 2 aa20 0000  	rolw 5,d,r[0];		shmem->am;	;		;		shp+	  | r[0] <- indexB*32
    816  0a 17 e 0 0 aa21 0000  	rolw 5,d,r[1];		shmem->am;	;		;			  | r[1] <- indexC*32
    817  0a 27 e 0 0 e281 0040  	addw d,acc,acc;		 64->am;;		;
    818  0a 0f c 0 0 909d 000f  	addw r[29],acc,y;	am->shmemp;	ldct 15;	;			  | shmemp <- addr of matrix A
    819  0a 0e 1 7 0 c98f 0080  	mov2nw 4,r[15];		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix A to fpr[16]
    81a  0a 27 e 0 0 8680 0040  	addw d,r[0],acc;	 64->am;;		;
    81b  0a 0f c 0 0 909d 000f  	addw r[29],acc,y;	am->shmemp;	ldct 15;	;			  | shmemp <- addr of matrix B
    81c  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix B to fpr[32]
    81d  0a 0c e 0 0 eb96 0000  	mov2nw 5,y;		am->fpap;	;		;			  | fpap <- addr of matrix B (in fpr)
    81e  0a 00 1 7 0 cd8e 0862  	mov2nw 6,r[14];	;		cjs,go xf3;	;			  | r[14] <- addr of matrix C (fpr[64])
                                											  | r[15] == addr of 1st row of matrix A
                                											  | xf3 produces 1st row of matrix C 
    81f  0a 2c e 0 0 c5cf 0020  	add2nw 2,r[15];		32->fpap;	;		;
    820  0a 00 1 7 0 c5ce 0862  	add2nw 2,r[14];	;		cjs,go xf3;	;			  | produce 2nd row of matrix C
    821  0a 2c e 0 0 c5cf 0020  	add2nw 2,r[15];		32->fpap;	;		;
    822  0a 00 1 7 0 c5ce 0862  	add2nw 2,r[14];	;		cjs,go xf3;	;			  | produce 3rd row of matrix C
    823  0a 2c e 0 0 c5cf 0020  	add2nw 2,r[15];		32->fpap;	;		;
    824  0a 00 1 7 0 c5ce 0862  	add2nw 2,r[14];	;		cjs,go xf3;	;			  | produce 4th row of matrix C
    825  0a 2c e 0 0 8681 0040  	addw d,r[1],acc;	64->fpap;	;		;			  | fpap <- addr of matrix C (in fpr)
    826  0a 0f 4 7 0 909d 000f  	addw r[29],acc,y;	am->shmemp;	push,go 15;	;			  | shmemp <- addr of matrix C (in shmem)
                                											  | (d still has XFORM_FRMOFF)
    827  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move matrix C to shmem
    828  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
    829  0a 00 2 0 0 c5de 0027  	add2nw 2,r[30],r[30];	;		jmap getcmd;	;			  | r[30] += 4; jump to r[0] loop
                                |	fltoint3 -- 3D conversion from float to int.  Operates on a single point and converts
                                |   		    the points in place, ie, overwrites the original floating point value.
                                |
                                |	Input Parameters:	r[15] -- Location of point to be converted.
    82a  2b 0c e 0 0 d84f 0230  fltoint3: movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	| 
    82b  2a 0e e 0 0 d84f 00e0  	movw r[15],y;		am->fpdp;	;		fixa,la,hi;		| convert x to int
    82c  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    82d  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		| convert y to int	
    82e  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    82f  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		| convert z to int	
    830  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    831  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		| convert r[20] to int	
    832  2b 00 e 0 0 7140 00e0  	;			;		;		;			| 
    833  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		| 
    834  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    835  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		| overwrite x
    836  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    837  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		| overwrite y
    838  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    839  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		| overwrite z
    83a  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    83b  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		| overwrite r[20]
    83c  3b 00 a 7 0 7140 0101  	;			;		crtn, go;	;			| 
                                |	xfint3w -- convert point from fix to float, including r[20], and jump to xf3.
                                |
                                |	Important Properties:	Does not use brreg; Does not use 2910 R register (counter)
                                |				Does not change latched 29116 condition code status
                                |   	Note: difference with xfint3 is that this converts r[20] also.
                                |
    83d  2b 0c e 0 0 d84f 0230  xfint3w: movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	  | 
    83e  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | x
    83f  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    840  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | y
    841  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    842  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | z
    843  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    844  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | r[20]
    845  2b 00 e 0 0 7140 00a0  	;			;		;		;
    846  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    847  2b 0e e 0 0 d84f 0122  	movw r[15],y;		am->fpdp;	;		;
    848  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite x
    849  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    84a  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite y
    84b  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    84c  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite z
    84d  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+  
    84e  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | overwrite r[20]
    84f  2b 0c e 0 0 e996 0101  	mov2nw 4,y;		am->fpap;	;		;			  | reload fpap and call xf3
    850  0a 00 3 7 0 7140 0862  	;			;		cjp,go xf3;	;			  | 
                                |
                                |	Important Properties:	Does not use brreg; Does not use 2910 R register (counter)
                                |				Does not change latched 29116 condition code status
                                |
    851  2b 0c e 0 0 d84f 0230  xfint3:	movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	  | 
    852  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | x
    853  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    854  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | y
    855  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    856  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | z
    857  2b 00 e 0 0 7140 00a0  	;			;		;		;
    858  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    859  2b 00 e 0 0 7140 0120  	;			;		;		;
    85a  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    85b  2b 0e e 0 0 d84f 0122  	movw r[15],y;		am->fpdp;	;		;
    85c  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite x
    85d  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    85e  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite y
    85f  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    860  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | overwrite z
    861  2b 0c e 0 0 e996 0101  	mov2nw 4,y;		am->fpap;	;		;			  | reload fpap and fall through to xf3
                                |	xf3 -- 3-D floating point transform
                                |
                                |	Input Parameters:	r[15] -- Address of input point
                                |				r[14] -- Address of output point
                                |				matrix -- fpap should have been loaded
                                |					  with the address of the matrix
                                |					  prior to calling this routine.
                                |					  A 4x4 matrix
                                |
                                |	Comments:	Locations at address r[14] are used as temporary storage.
                                |			This routine cannot be used to transform a point in place,
                                |			i.e. r[15] should not be the same as r[14].
                                |
                                |
                                |	Important Properties:	Does not use brreg; Does not use 2910 R register (counter)
                                |				Does not change latched 29116 condition code status
                                |
    862  2b 0d e 0 0 d84f 0230  xf3:	movw r[15],y;		am->fpbp;	;		lmode rn,ai,pipe,fast;
    863  2a 0e e 0 0 d84e 0010  	movw r[14],y;		am->fpdp;	;		maba,lab,hi;		  | m11*x
    864  2b 00 e 0 4 7140 0010  	;			;		;		;		ap+
    865  2a 00 e 0 0 7140 0020  	;			;		;		maba,la,hi;		  | m12*x
    866  2b 00 e 0 4 7140 0020  	;			;		;		;		ap+
    867  2a 00 e 0 0 7140 0020  	;			;		;		maba,la,hi;		  | m13*x
    868  2b 00 e 0 4 7140 0020  	;			;		;		;		ap+
    869  2a 00 e 0 0 7140 0020  	;			;		;		maba,la,hi;		  | m14*x
    86a  2b 00 e 0 7 7140 0020  	;			;		;		;		abp+
    86b  2a 00 e 0 0 7140 0014  	;			;		;		maba,lab,m,hi;		  | m21*y
    86c  2b 00 e 0 4 7140 0014  	;			;		;		;		ap+
    86d  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | m22*y , store m11*x
    86e  2b 00 e 0 8 7140 0025  	;			;		;		;		adp+
    86f  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | m23*y , store m12*x
    870  2b 00 e 0 8 7140 0025  	;			;		;		;		adp+
    871  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | m24*y , store m13*x
    872  2b 00 e 0 8 7140 0025  	;			;		;		;		adp+
    873  2a 0d e 0 0 d84e 0125  	movw r[14],y;		am->fpbp;	;		adda,la,m,st,hi;		  | store m14*x
    874  2b 0e e 0 0 d84e 0125  	movw r[14],y;		am->fpdp;	;		;
    875  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m21*y + m11*x
    876  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    877  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m22*y + m12*x
    878  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    879  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m23*y + m13*x
    87a  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    87b  2a 00 e 0 0 948f 0118  	addw r[15],2,y;		;		;		addr,lab,hi;		  | m24*y + m14*x
    87c  2b 0d e 0 0 0002 0118  	;			am->fpbp;	;		;
    87d  2a 00 e 0 0 7140 0012  	;			;		;		maba,lab,a,hi;		  | m31*z
    87e  2b 00 e 0 4 7140 0012  	;			;		;		;		ap+
    87f  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m32*z , store m21*y + m11*x
    880  2b 00 e 0 8 7140 0023  	;			;		;		;		adp+
    881  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m33*z , store m22*y + m12*x
    882  2b 00 e 0 8 7140 0023  	;			;		;		;		adp+
    883  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m34*z , store m23*y + m13*x
    884  2b 00 e 0 8 7140 0023  	;			;		;		;		adp+
    885  2a 0d e 0 0 d84e 0125  	movw r[14],y;		am->fpbp;	;		adda,la,m,st,hi;		  | store m24*y + m14*x
    886  2b 0e e 0 0 d84e 0125  	movw r[14],y;		am->fpdp;	;		;
    887  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m31*z + (m21*y + m11*x)
    888  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    889  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m32*z + (m22*y + m12*x)
    88a  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    88b  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m33*z + (m23*y + m13*x)
    88c  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    88d  2a 00 e 0 0 948f 0118  	addw r[15],3,y;		;		;		addr,lab,hi;		  | m34*z + (m24*y + m14*x)
    88e  2b 0d e 0 0 0003 0118  	;			am->fpbp;	;		;
    88f  2a 00 e 0 0 7140 0012  	;			;		;		maba,lab,a,hi;		  | m41*r[20]
    890  2b 00 e 0 4 7140 0012  	;			;		;		;		ap+
    891  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m42*r[20] , store m31*z + (m21*y + m11*x)
    892  2b 00 e 0 8 7140 0023  	;			;		;		;		adp+
    893  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m43*r[20] , store m32*z + (m22*y + m12*x)
    894  2b 00 e 0 8 7140 0023  	;			;		;		;		adp+
    895  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m44*r[20] , store m33*z + (m23*y + m13*x)
    896  2b 00 e 0 6 7140 0023  	;			;		;		;		dp+
    897  2a 0d e 0 0 d84e 0125  	movw r[14],y;		am->fpbp;	;		adda,la,m,st,hi;		  | store m34*z + (m24*y + m14*x)
    898  2b 0e e 0 0 d84e 0125  	movw r[14],y;		am->fpdp;	;		;
    899  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m41*r[20] + (m31*z + m21*y + m11*x)
    89a  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    89b  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m42*r[20] + (m32*z + m22*y + m12*x)
    89c  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    89d  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m43*r[20] + (m33*z + m23*y + m13*x)
    89e  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    89f  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | m44*r[20] + (m34*z + m24*y + m14*x)
    8a0  2b 00 e 0 0 7140 0118  	;			;		;		;
    8a1  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    8a2  2b 00 e 0 0 7140 0122  	;			;		;		;
    8a3  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | x' = m41*w + m31*z + m21*y + m11*x
    8a4  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    8a5  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | y' = m42*w + m32*z + m22*y + m12*x
    8a6  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    8a7  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | z' = m43*w + m33*z + m23*y + m13*x
    8a8  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    8a9  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | r[20]' = m44*w + m34*z + m24*y + m14*x
    8aa  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;
                                |	vwpsndvec3_xy -- scale 3-D vector (x0,y0,z0,w0 x1,y1,z1,w1) to viewport,
                                |			 convert floating point coordinates to integer, and
                                |			 send to Painting Processor
                                |			 produces only scaled x and y
                                |			 input vectors are in NDC, i.e. clipped vectors will have
                                |			 -1.0 <= x/r[20],y/r[20] <= 1.0
                                |
                                |	Input Parameters:	r[15] -- address of first input point x,y,z,r[20]
                                |				r[14] -- address for scaled x,y
                                |
                                |
                                vwpsndvec3_xy:
    8ab  08 27 e 0 2 d96e 0003  	movw r[14],r[2];	3->am;		;		;			  | use fpr[r[14],r[14]+1] for reciprocals
    8ac  0a 0c 1 7 0 968f 08ce  	addw d,r[15],y;		am->fpap;	cjs,go paratest; ;			  | test for parallel proj: r[20] == 1
    8ad  0a 27 e 0 0 dd62 0007  	incw r[2],r[2];	7->am;		;		;
    8ae  0a 0c 1 7 0 968f 034c  vwrecp2: addw d,r[15],y;	am->fpap;	cjs,go recip;	;			| compute reciprocal of w1
    8af  2b 0c e 0 0 d84f 0230  	movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	| 
    8b0  0a 0d e 0 0 d84e 0000  	movw r[14],y;		am->fpbp;	;		;
    8b1  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x0 * 1/w0
    8b2  2b 00 e 0 4 7140 0010  	;			;		;		;		ap+
    8b3  2a 00 e 0 0 948f 0020  	addw r[15],4,y;		;		;		maba,la,hi;		  | y0 * 1/w0
    8b4  2b 0c e 0 5 0004 0020  	;			am->fpap;	;		;		bp+
    8b5  2a 00 e 0 0 f8e0 0010  	movw =vwpsv2,y;		;		;		maba,lab,hi;		  | x1 * 1/w1
    8b6  2b 08 e 0 4 04b5 0010  	;			am->brreg;	;		;		ap+
    8b7  2a 00 e 0 0 7140 0020  	;			;		;		maba,la,hi;		  | y1 * 1/w1
    8b8  2b 00 e 0 0 7140 0020  	;			;		;		;
    8b9  2a 0d e 0 0 eb86 0124  	mov2nw 5,acc;		am->fpbp;	;		adda,la,m,hi;		  | fpbp pts to viewport params
    8ba  2b 00 e 0 0 7140 0124  	;			;		;		;
    8bb  2a 00 e 0 0 7140 001c  	;			;		;		mabr,lab,m,hi;		  | x0 * VWPXSCL
    8bc  2b 0d e 0 0 e384 001c  	add2nw 1,acc;		am->fpbp;	;		;
    8bd  2a 00 e 0 0 7140 001c  	;			;		;		mabr,lab,m,hi;		  | y0 * VWPYSCL
    8be  2b 0d e 0 0 e385 001c  	sub2nw 1,acc;		am->fpbp;	;		;
    8bf  2a 00 e 0 0 7140 001c  	;			;		;		mabr,lab,m,hi;		  | x1 * VWPXSCL
    8c0  2b 0d e 0 0 e384 001c  	add2nw 1,acc;		am->fpbp;	;		;
    8c1  2a 00 e 0 0 7140 0018  	;			;		;		mabr,lab,hi;		  | y1 * VWPYSCL
    8c2  3b 0d 3 7 0 e185 0018  	sub2nw 0,acc;		am->fpbp;	cjp,go;		;			  | fpbp<-&Vwpxoff; jump to vwpsv2 to
                                											  | finish scaling, conversion, & xmit to PP
    8c3  2b 0d e 0 0 eb86 0230  vwparll: mov2nw 5,acc;		am->fpbp;	;		lmode rn,ai,pipe,fast;	| fpbp pts to viewport params
    8c4  0a 00 e 0 0 f8e0 0000  	movw =vwpsv2,y;		;		;		;			| 
    8c5  2a 08 e 0 0 04b5 0010  	;			am->brreg;	;		maba,lab,hi;		| x0 * VWPXSCL
    8c6  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+	| 
    8c7  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y0 * VWPYSCL
    8c8  2b 0d e 0 4 e385 0010  	sub2nw 1,acc;		am->fpbp;	;		;		ap+	| 
    8c9  08 0c e 0 0 c5cf 0000  	add2nw 2,r[15],r[0];	am->fpap;	;		;			| 
    8ca  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x1 * VWPXSCL
    8cb  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+	| 
    8cc  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y1 * VWPYSCL
    8cd  3b 0d 3 7 0 e185 0010  	sub2nw 0,acc;		am->fpbp;	cjp, go;	;			| fpbp<-&Vwpxoff; jump to vwpsv2 to
                                											| finish scaling, conversion, & xmit to PP
                                paratest:
    8ce  0a 27 e 0 0 f8c1 3f80  	movw d,acc;		0x3f80->am;	;		;			  | test for fp 1.0
    8cf  02 37 e 0 0 e200 0000  	subw,s d,acc,y;		fpregh->am;	;		;			| compare msw
    8d0  03 37 3 8 0 f8c0 034c  	movw,s d,y;		fpregl->am;	cjp,~zer recip;	;			| compare lsw, if either fail jp recip
    8d1  0a 0e 3 8 0 d842 034c  	movw r[2],y;		am->fpdp;	cjp,~zer recip;	;			  | otherwise no need for divide
    8d2  08 0c e 0 0 c1ee 0000  	sub2nw 0,r[14],r[0];	am->fpap;	;		;			| w2 is at (r[14]-1)
    8d3  02 37 e 0 0 e200 0000  	subw,s d,acc,y;		fpregh->am;	;		;			| compare msw (fp 1 is in acc)
    8d4  03 37 3 8 0 f8c0 08d6  	movw,s d,y;		fpregl->am;	cjp,~zer parecip; ;			| jump if w2 is also 1
    8d5  0a 0c b 0 0 d84f 08c3  	movw r[15],y;		am->fpap;	cjpp,zer vwparll; ;			| jump to vwp scale if w2==1 also
    8d6  0a 0c e 0 0 c5e0 0000  parecip: sub2nw 2,r[0];		am->fpap;	;		;			| 'a' ptr set to w1
    8d7  0a 3b e 0 0 dd62 0000  	incw r[2],r[2];	fpregh->fpregh;	;		;			| need to set w1==1 for multiply
    8d8  0b 3b b 7 0 7140 08ae  	;			fpregl->fpregl;	cjpp,go vwrecp2; ;			| return to find recip for pt2
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)clpvec3.vp.u 1.2 86/09/12 SMI
                                |	clpvec3 -- clip a 3-D vector to a normalized window (-1.0 <= x/r[20],y/r[20] <= 1.0, 0.0 <= z/r[20] <= 1.0)
                                |		   operates in homogeneous coordinates and clips to the region of positive r[20] only
                                |
                                |	Input Parameters:	r[15],fpap -- Address of vector to be clipped (N.B.: fpap must be set to r[15] prior to call)
                                |
                                |
                                |	Output:		clipped vector endpoints are written over input points
                                |			return with r[15]==fpap if vector is visible
                                |			Am29116 Z condition flag Z: 0 (2910 branch condition ~zer) => all or part of input vector is visible
                                |						    1 (2910 branch condition  zer) => input vector is not visible
                                |
    8d9  29 00 e 0 0 c3cf 0230  clpvec3: add2nw 1,r[15],r[0];	;		;		lmode rn,ai,pipe,fast;    | fpreg's 0-15 are scratch memory
    8da  0a 0d e 0 0 dd60 0000  	incw r[0],r[0];		am->fpbp;	;		;			  | fpbp <- &w0
    8db  2a 0e e 0 0 e786 0110  	mov2nw 3,acc;		am->fpdp;	;		adda,lab,hi;		  | wec0_left = w0 + x0; fpdp <- 8
    8dc  2b 0b e 0 0 f900 0110  	movw 0,y;		am->fpregl;	;		;			  | fpr[8] <- 0.0
    8dd  2a 0b e 0 0 f900 01a0  	movw 0,y;		am->fpregh;	;		rsuba,la,hi;		  | wec0_right = w0 - x0
    8de  2b 00 e 0 4 e185 01a0  	sub2nw 0,acc;		;		;		;		ap+	  | acc <- 7 (used below)
    8df  2a 00 e 0 0 f8e0 0120  	movw =trivaccept3,y;	;		;		adda,la,hi;		  | wec0_bottom = w0 + y0
    8e0  2b 08 e 0 0 093b 0120  	;			am->brreg;	;		;			  | set up brreg for possible branch later
    8e1  2a 00 e 0 0 d908 01a0  	movw 0,r[8];	;		;		rsuba,la,hi;		  | wec0_top = w0 - y0; r[8]<-0, for
    8e2  2b 0d e 0 4 e796 01a0  	mov2nw 3,y;		am->fpbp;	;		;		ap+	  | COREWLDVECNDC_3D r[0]; fpbp <- 8
    8e3  2a 0e e 0 0 f900 0112  	movw 0,y;		am->fpdp;	;		adda,lab,a,hi;		  | wec0_hither = 0.0 + z0; fpdp <- 0
    8e4  2b 0d e 0 0 d840 0112  	movw r[0],y;		am->fpbp;	;		;			  | fpbp <- &w0
    8e5  2a 00 e 0 0 db06 0193  	compw 0,r[6];	;		;		rsuba,lab,a,st,hi;	  | wec0_yon = w0 - z0; r[6] = 0xFFFF
    8e6  2b 31 e 0 8 6e00 0193  	sl0b d,y;		fpstreg->am;	;		;		adp+	  | get L bit of r[6]
    8e7  28 0d e 0 1 988f 0101  	addw r[15],acc,r[1];	am->fpbp;	;		adda,st,hi;		  | can't set both a & b ptrs fast enough
    8e8  2b 00 e 0 8 cc46 0101  	slqw r[6],r[6];	;		;		;		adp+	  | to keep pipe going; fpbp<-&w1,fpap<-&x1
    8e9  2a 31 e 0 0 6e00 0112  	sl0b d,y;		fpstreg->am;	;		adda,lab,a,hi;		  | wec1_left = w1 + x1
    8ea  2b 00 e 0 0 cc46 0112  	slqw r[6],r[6];	;		;		;			  | R bit of r[6]
    8eb  2a 00 e 0 0 fb01 01a3  	compw 0,acc;	;		;		rsuba,la,a,st,hi;	  | wec1_right = w1 - x1; acc = 0xFFFF
    8ec  2b 31 e 0 8 6e00 01a3  	sl0b d,y;		fpstreg->am;	;		;		adp+	  | B bit of r[6]
    8ed  2a 00 e 0 0 cc46 0123  	slqw r[6],r[6];	;		;		adda,la,a,st,hi;	  | wec1_bottom = w1 + y1
    8ee  2b 31 e 0 6 6e00 0123  	sl0b d,y;		fpstreg->am;	;		;		dp+	  | T bit of r[6]
    8ef  2a 00 e 0 0 cc46 01a3  	slqw r[6],r[6];	;		;		rsuba,la,a,st,hi;	  | wec1_top = w1 - y1
    8f0  2b 0d e 0 8 c782 01a3  	mov2nw 3,r[2];		am->fpbp;	;		;		adp+	  | fpbp <- 8
    8f1  2a 31 e 0 0 6e00 0113  	sl0b d,y;		fpstreg->am;	;		adda,lab,a,st,hi;	  | wec1_hither = 0.0 + z1
    8f2  2b 00 e 0 6 cc46 0113  	slqw r[6],r[6];	;		;		;		dp+	  | H bit of r[6]
    8f3  2a 31 e 0 0 6e00 0101  	sl0b d,y;		fpstreg->am;	;		adda,st,hi;		  | have to hiccup pipe to avoid losing last
    8f4  2b 0d e 0 6 d841 0101  	movw r[1],y;		am->fpbp;	;		;		dp+	  | r[6] bit; fpbp <- &w1
    8f5  2a 00 e 0 0 cc46 0192  	slqw r[6],r[6];	;		;		rsuba,lab,a,hi;		  | wec1_yon = w1 - z1; Y bit of r[6]
    8f6  2b 31 e 0 0 6e00 0192  	sl0b d,y;		fpstreg->am;	;		;			  | L bit of acc
    8f7  2a 00 e 0 0 ec41 0101  	slqw acc,acc;	;		;		adda,st,hi;		  | hiccup pipe to reload a and b ptrs
    8f8  2b 0c e 0 6 f900 0101  	movw 0,y;		am->fpap;	;		;		dp+	  | fpap <- 0, address of wec0's
    8f9  0a 0d e 0 0 c3e2 0000  	sub2nw 1,r[2];		am->fpbp;	;		;			  | fpbp <- 6, address of wec1's
    8fa  2a 31 e 0 0 6e00 0152  	sl0b d,y;		fpstreg->am;	;		suba,lab,a,hi;		  | wec0_left - wec1_left
    8fb  2b 00 e 0 7 ec41 0152  	slqw acc,acc;	;		;		;		abp+	  | R bit of acc
    8fc  28 00 e 0 7 db66 0153  	compw r[6],r[7];;		;		suba,lab,a,st,hi;	  | wec0_right - wec1_right
    8fd  2b 31 e 0 a 6e00 0153  	sl0b d,y;		fpstreg->am;	;		;		abdp+	  | B bit of acc
                                											  | r[7]<-~r[6](COREWLDVECNDC_3D)
    8fe  2a 00 e 0 0 ec41 0153  	slqw acc,acc;	;		;		suba,lab,a,st,hi;	  | wec0_bottom - wec1_bottom
    8ff  2b 31 e 0 a 6e00 0153  	sl0b d,y;		fpstreg->am;	;		;		abdp+	  | T bit of acc
    900  2a 00 e 0 0 ec41 0153  	slqw acc,acc;	;		;		suba,lab,a,st,hi;	  | wec0_top - wec1_top
    901  2b 31 e 0 a 6e00 0153  	sl0b d,y;		fpstreg->am;	;		;		abdp+	  | H bit of acc
    902  2a 00 e 0 0 ec41 0153  	slqw acc,acc;	;		;		suba,lab,a,st,hi;	  | wec0_hither - wec1_hither
    903  2b 0e e 0 7 c1c2 0153  	add2nw 0,r[2];		am->fpdp;	;		;		abp+	  | fpdp <- 7, store wec diffs there
    904  2a 31 e 0 0 6e00 0153  	sl0b d,y;		fpstreg->am;	;		suba,lab,a,st,hi;	  | wec0_yon - wec1_yon;store wec left diff
    905  2b 00 e 0 6 ec41 0153  	slqw acc,acc;	;		;		;		dp+	  | Y bit of acc
    906  2a 07 e 0 0 90e6 0123  	nandw r[6],acc,y; am->am;	;		adda,la,a,st,hi;		  | store wec right diff
    907  23 00 e 0 6 96cb 0123  	andw,s d,r[11],y;	;		;		;		dp+	  | result != 0 iff >= 1 pt outside window
    908  38 00 3 0 5 9ecb 0123  	andw d,r[11],r[5];;		cjp,zer;	adda,la,a,st,hi;		  | jump if trivial accept; 2-reg op ok here
    909  2b 00 e 0 6 f8e0 0123  	movw =reject3,y;	;		;		;		dp+	  | store wec bottom diff
    90a  2a 08 e 0 0 093a 0123  	;			am->brreg;	;		adda,la,a,st,hi;		  | store wec top diff
    90b  2b 07 e 0 6 9126 0123  	norw r[6],acc,y; am->am;	;		;		dp+
    90c  22 00 e 0 0 96cb 0123  	andw,s d,r[11],y;	;		;		adda,la,a,st,hi;		  | result != 0 iff 2 pts outside >= 1 plane
    90d  3b 0c 3 8 6 d842 0123  	movw r[2],y;		am->fpap;	cjp,~zer;	;		dp+	  | jump if trivial reject;store hither diff
    90e  2a 00 e 0 0 c1e2 0101  	sub2nw 0,r[2],r[2];	;		;		adda,st,hi;		  | fpap<-7; r[2]<-6; store wec yon diff
    90f  23 00 e 0 0 ebe5 0101  	btstw,s 5,r[5];	;		;		;
    910  0a 00 1 8 0 da88 034c  	compw acc,r[8];;		cjs,~zer recip;	;			  | compute left recip if intersect
                                											  | r[8]<-~acc(COREWLDVECNDC_3D)
    911  02 00 e 0 0 e9e5 0000  	btstw,s 4,r[5];	;		;		;
    912  0a 00 1 8 4 dd62 034c  	incw r[2],r[2];	;		cjs,~zer recip;	;		ap+	  | compute right recip if intersect
    913  02 00 e 0 0 e7e5 0000  	btstw,s 3,r[5];	;		;		;
    914  0a 00 1 8 4 dd62 034c  	incw r[2],r[2];	;		cjs,~zer recip;	;		ap+	  | compute bottom recip if intersect
    915  02 00 e 0 0 e5e5 0000  	btstw,s 2,r[5];	;		;		;
    916  0a 00 1 8 4 dd62 034c  	incw r[2],r[2];	;		cjs,~zer recip;	;		ap+	  | compute top recip if intersect
    917  02 00 e 0 0 e3e5 0000  	btstw,s 1,r[5];	;		;		;
    918  0a 00 1 8 4 dd62 034c  	incw r[2],r[2];	;		cjs,~zer recip;	;		ap+	  | compute hither recip if intersect
    919  02 00 e 0 0 e1e5 0000  	btstw,s 0,r[5];	;		;		;
    91a  0a 00 1 8 4 dd62 034c  	incw r[2],r[2];	;		cjs,~zer recip;	;		ap+	  | compute yon recip if intersect
                                											  | r[5] bits indicate line crossings:
                                											  | L|R|B|T|H|Y is 5|4|3|2|1|0
                                											  | have now computed recips for the
                                											  | intersection calculations below if the
                                											  | corresponding t values will be used
                                											  | The calculations of candidate values of
                                											  | t below are of the form :
                                											  |	t = wec0_x / (wec0_x - wec1_x)
                                											  | where x is left, right, bottom, top,
                                											  | hither, or yon.
    91b  2b 0c e 0 0 d904 0230  t0t1_3:	movw 0,r[4];		am->fpap;	;		lmode rn,ai,pipe,fast;	  | t0 = 0.0, param t value for line begin
    91c  0a 2d e 0 0 d903 0006  	movw 0,r[3];		6->fpbp;	;		;			  | fpap <- &wec0's, fpbp <- &diff_recip's
    91d  2a 00 e 0 0 d8e0 0010  	movw 0x3F80,r[0];	;		;		maba,lab,hi;		  | wec0_left * recip_left
    91e  2b 00 e 0 7 3f80 0010  	;			;		;		;		abp+	  | r[0] <- high order 1.0
    91f  28 00 e 0 2 d960 0010  	movw r[0],r[2];	;		;		maba,lab,hi;		  | wec0_right * recip_right
    920  2b 0e e 0 7 d901 0010  	movw 0,r[1];		am->fpdp;	;		;		abp+	  | t1 = 1.0, param t value for line end
                                											  | fpdp<-0,store candidate t's at fpreg[0]
    921  2a 00 e 0 0 f8e0 0010  	movw =intersect3,y;	;		;		maba,lab,hi;		  | wec0_bottom * recip_bottom
    922  2b 08 e 0 7 0983 0010  	;			am->brreg;	;		;		abp+	  | set up brreg for calls to intersect3
    923  2a 00 e 0 0 db66 0010  	compw r[6],r[6];;		;		maba,lab,hi;		  | wec0_top * recip_top; now r[6] bits
    924  2b 00 e 0 7 7140 0010  	;			;		;		;		abp+	  | have same polarity as r[5] bits
    925  22 00 e 0 0 95e5 0014  	rolw,s 10,r[5],r[5];;		;		maba,lab,m,hi;		  | wec0_hither * recip_hither
    926  33 00 1 1 5 95e6 0014  	rolw,s 10,r[6],r[6];;		cjs,neg;	;		bp+	  | call intersect2 if line crosses L plane
                                											  | L|R|B|T|H|Y now 15|14|13|12|11|10
    927  0a 2c e 0 0 7140 0005  	;			5->fpap;	;		;			  | reset fpap for final t value
    928  22 00 e 0 0 cc05 0014  	sl0w,s r[5],r[5];;		;		maba,lab,m,hi;		  | wec0_yon * recip_yon
    929  33 00 1 1 0 cc06 0014  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses R plane
                                											  | R|B|T|H|Y now 15|14|13|12|11
    92a  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | B|T|H|Y now 15|14|13|12, advance pipe
    92b  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses B plane
    92c  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | T|H|Y now 15|14|13, advance pipe
    92d  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses T plane
    92e  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | H|Y now 15|14, advance pipe
    92f  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses H plane
    930  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | Y now 15, advance pipe
    931  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses Y plane
                                											  | now t0 and t1 represent clipped
                                											  | endpoints iff t0 <= t1
    932  02 0b e 0 0 d844 0000  newpts3: movw,s r[4],y;	am->fpregh;	;		;			  | fpreg[0] <- t0 & test r[4]==0 which
    933  0b 0b e 0 6 d843 0000  	movw r[3],y;		am->fpregl;	;		;		dp+	  | implies t0==0.0 since fast Weitek mode
    934  0a 0b e 0 0 d802 0000  	movw r[2],acc;		am->fpregh;	;		;			  | will not produce denormalized results
    935  0b 0b 3 0 0 d841 093c  	movw r[1],y;		am->fpregl;	cjp,zer t0eq0_3;;			  | fpreg[1]<-t1 & jump if t0==0.0
    936  02 2c e 0 0 9100 0000  	xorw,s r[0],acc,y;	0->fpap;	;		;			  | fpap<-&t0; test r[2] == high order 1.0
                                											  | which means t1 == 1.0, since t1 started
                                											  | at 1.0 and could only decrease
    937  0b 37 3 0 0 9601 093e  vischk_3: subw d,r[1],y;	fpregl->am;	cjp,zer t1eq1_3;;			  | jump if t1==1.0, else check for t0>t1,
    938  02 37 e 0 0 9622 0000  	subcw,s d,r[2],y;	fpregh->am;	;		;			  | which means line is outside window
    939  0a 00 3 2 0 d900 093f  	movw 0,r[0];		;		cjp,cry twonewpts_3;;			  | jump on no borrow (t1 - t0 >= 0.0)
                                											  | r[0]<-&t0 (used below); cc indicating
                                											  | cry causes both pts to be computed below
    93a  12 00 a 7 0 f900 0000  reject3: movw,s 0,y;		;		crtn,go;	;			  | Z bit <- 1 (indicating rejection) & rtn
                                											  |
    93b  12 0c a 7 0 d84f 0000  trivaccept3: movw,s r[15],y;	am->fpap;	crtn,go;	;			  | Z bit <- 0 (indicating acceptance),
                                											  | fpap <- r[15], and return
                                											  |
    93c  02 28 e 0 0 dd00 0976  t0eq0_3: incw,s 0,r[0];		=t0eq0_3a->brreg;;		;			  | if t0 == 0.0, then the t0,t1 segment is
    93d  0a 00 3 7 0 7140 093f  	;			;		cjp,go twonewpts_3;;			  | visible since t1 >= 0.0; also, t1 != 1.0
                                											  | at this point since that would imply
                                											  | trivial acceptance; force cc to indicate
                                											  | ~cry -- we use this to arrange
                                											  | below to compute and store only one
                                											  | point; brreg has a branch address to
                                											  | compute the t1 point; r[0]<-&t1
                                											  |
    93e  02 28 e 0 0 d900 0975  t1eq1_3: movw,s 0,r[0];		=t1eq1_3a->brreg;;		;			  | if t1 == 1.0, then the t0,t1 segment is
                                											  | visible since t0 <= 1.0; also, t0 != 0.0
                                											  | at this point since that would imply
                                											  | trivial acceptance; force cc to indicate
                                											  | ~cry -- we use this to arrange
                                											  | below to compute and store only one
                                											  | point; brreg has a branch address to
                                											  | compute the t0 point; r[0]<-&t0
                                											  |
                                											  | when we arrive here cc indicates whether
                                											  | we have to compute 1 or 2 pts
                                											  | cry => need to compute 2 pts
                                											  | ~cry => need to compute 1 pt
                                											  |
    93f  0a 0d e 0 0 d80f 0000  twonewpts_3: movw r[15],acc;	am->fpbp;	;		;			  | fpbp <- &x0
    940  0a 0c e 0 0 e584 0000  	add2nw 2,acc;		am->fpap;	;		;			  | fpap <- &x1
    941  2a 0e e 0 0 e396 0150  	mov2nw 1,y;		am->fpdp;	;		suba,lab,hi;		  | dx = x1 - x0
    942  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+	  | fpdp <- 2 -- put deltas at fpreg[2-5]
    943  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dy = y1 - y0
    944  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+
    945  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dz = z1 - z0
    946  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+
    947  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dw = w1 - w0
    948  2b 00 e 0 0 7140 0150  	;			;		;		;
    949  2a 0d e 0 0 d840 0122  	movw r[0],y;		am->fpbp;	;		adda,la,a,hi;		  | fpbp<-&t0 or &t1, as previously set up
    94a  2b 00 e 0 0 7140 0122  	;			;		;		;			  | advance pipe
    94b  2a 00 e 0 0 7140 001b  	;			;		;		mabr,lab,a,st,hi;	  | t? * dx; store dx
    94c  2b 00 e 0 6 7140 001b  	;			;		;		;		dp+
    94d  2a 00 e 0 0 7140 002b  	;			;		;		mabr,la,a,st,hi;	  | t? * dy; store dy
    94e  2b 00 e 0 6 7140 002b  	;			;		;		;		dp+
    94f  2a 00 e 0 0 7140 002b  	;			;		;		mabr,la,a,st,hi;	  | t? * dz; store dz
    950  2b 00 e 0 6 7140 002b  	;			;		;		;		dp+
    951  2a 00 e 0 0 7140 0029  	;			;		;		mabr,la,st,hi;		  | t? * dw; store dw
    952  3b 0c 3 a 9 e396 0029  	mov2nw 1,y;		am->fpap;	cjp,~cry;	;		bdp+	  | jump to compute only 1 pt; brreg
                                											  | previously set to t0eq0_3a or t1eq1_3a
                                											  | else fpap<-&dx, fpbp<-&t1,
                                											  | fpdp<-6 -- store t0*d's at fpreg[6-9]
                                											  | only reach here if computing 2 points
    953  2a 00 e 0 0 7140 0014  	;			;		;		maba,lab,m,hi;		  | t1 * dx
    954  2b 00 e 0 4 7140 0014  	;			;		;		;		ap+
    955  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | t1 * dy; store (t0 * dx)
    956  2b 00 e 0 8 7140 0025  	;			;		;		;		adp+
    957  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | t1 * dz; store (t0 * dy)
    958  2b 00 e 0 8 f8e0 0025  	movw 6,y;		;		;		;		adp+
    959  2a 0d e 0 0 0006 0025  	;			am->fpbp;	;		maba,la,m,st,hi;	  | t1 * dw; store (t0 * dz); fpbp<-&(t0*dx)
    95a  2b 0c e 0 6 d84f 0025  	movw r[15],y;		am->fpap;	;		;		dp+	  | fpap<-&x0;store t1*d's at fpreg[10-13]
    95b  2a 00 e 0 0 7140 0115  	;			;		;		adda,lab,m,st,hi;	  | x0' = x0 + (t0*dx); store (t0 * dw)
    95c  2b 00 e 0 a 7140 0115  	;			;		;		;		abdp+
    95d  2a 00 e 0 0 7140 0115  	;			;		;		adda,lab,m,st,hi;	  | y0' = y0 + (t0*dy); store (t1 * dx)
    95e  2b 00 e 0 a 7140 0115  	;			;		;		;		abdp+
    95f  2a 00 e 0 0 7140 0115  	;			;		;		adda,lab,m,st,hi;	  | z0' = z0 + (t0*dz); store (t1 * dy)
    960  2b 00 e 0 a 7140 0115  	;			;		;		;		abdp+
    961  2a 00 e 0 0 7140 0115  	;			;		;		adda,lab,m,st,hi;	  | w0' = w0 + (t0*dw); store (t1 * dz)
    962  2b 0c e 0 9 d84f 0115  	movw r[15],y;		am->fpap;	;		;		bdp+	  | fpap<-&x0; fpbp<-&(t1*dx)
    963  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | x1' = x0 + (t1*dx); store (t1 * dw)
    964  2b 0e e 0 7 d84f 0113  	movw r[15],y;		am->fpdp;	;		;		abp+	  | fpdp<-&x0
    965  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | y1' = y0 + (t1*dy); store x0'
    966  2b 00 e 0 a 7140 0113  	;			;		;		;		abdp+
    967  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | z1' = z0 + (t1*dz); store y0'
    968  2b 00 e 0 a 7140 0113  	;			;		;		;		abdp+
    969  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | w1' = w0 + (t1*dw); store z0'
    96a  2b 00 e 0 6 7140 0113  	;			;		;		;		dp+
    96b  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store w0'
    96c  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
                                											  | can reach here to store pt1' from above
                                											  | when computing 2 pts or from below when
                                											  | computing only pt1'; also can reach here
                                											  | from below to store pt0' when computing
                                											  | only that pt
    96d  2a 00 e 0 0 7140 0123  storept_3: ;			;		;		adda,la,a,st,hi;		  | store x1' (or x0')
    96e  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    96f  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store y1' (or y0')
    970  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    971  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store z1' (or z0')
    972  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    973  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store w1' (or w0')
    974  33 0c a 7 0 d84f 0101  	movw,s r[15],y;		am->fpap;	crtn,go;	;			  | return with Z bit==0 & fpap==r[15]
                                											  |
    975  0a 0e 3 7 0 d84f 0977  t1eq1_3a: movw r[15],y;		am->fpdp;	cjp,go onenewpt_3;;			  | fpdp<-&x0 so we will store x0'
                                											  |
    976  0a 0e e 0 0 f880 0000  t0eq0_3a: movw acc,y;		am->fpdp;	;		;			  | fpdp<-&x1 so we will store x1'
                                											  | arrive here to compute only 1 pt; pipe
                                											  | contains either t0*d's or t1*d's
    977  2a 0d e 0 0 d84f 0124  onenewpt_3: movw r[15],y;	am->fpbp;	;		adda,la,m,hi;		  | fpbp<-&x0; advance pipeline
    978  2b 00 e 0 0 7140 0124  	;			;		;		;
    979  2a 00 e 0 0 f8e0 011c  	movw =storept_3,y;	;		;		addr,lab,m,hi;		  | x?' = x0 + (t?*dx)
    97a  2b 08 e 0 5 096d 011c  	;			am->brreg;	;		;		bp+	  | brreg<-storept_3 for subsequent branch
    97b  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | y?' = y0 + (t?*dy)
    97c  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    97d  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | z?' = z0 + (t?*dz)
    97e  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    97f  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | r[20]?' = w0 + (t?*dw)
    980  2b 00 e 0 0 7140 0118  	;			;		;		;
    981  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		  | advance pipeline
    982  3b 00 3 7 0 7140 0122  	;			;		cjp,go;		;			  | goto storept_3
                                											  |
                                											  |
    983  2a 0c e 0 0 f900 0101  intersect3: movw 0,y;		am->fpap;	;		adda,st,hi;		  | fpreg[0] <- candidate value; fpap<-0
    984  2b 00 e 0 0 ff87 0101  	not2nw 15,acc;		;		;		;			  | acc <- 0x7FFF
    985  02 37 3 9 0 e2c1 098c  	andw,s d,acc,acc;	fpregh->am;	cjp,~neg updt1_3;;			  | update t0 or t1 based upon previously
                                											  | tested bit of r[6]; acc <- high
                                											  | order t & 0x7FFF (to convert -0.0 to
                                											  | +0.0,since t is guaranteed 0.0<=t<=1.0)
    986  0b 37 e 0 0 9603 0000  updt0_3: subw d,r[3],y;	fpregl->am;	;		;			  | compare t with t0 (t0 - t)
    987  02 00 e 0 0 9064 0000  	rsubcw,s r[4],acc,y;	;		;		;
    988  02 00 3 2 0 ffc5 0992  	bclrw,s 15,r[5];	;		cjp,cry chkthru3;;			  | no borrow means t <= t0
    989  0a 00 e 0 0 d884 0000  	movw acc,r[4];		;		;		;			  | else t0 <- t
    98a  0a 00 b 0 0 d8c3 0932  	movw d,r[3];		;		cjpp,zer newpts3;;			  | r[5]==0 -> no more intersections
    98b  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | else return to check next plane
    98c  0b 37 e 0 0 9641 0000  updt1_3: rsubw d,r[1],y;	fpregl->am;	;		;			  | compare t with t1 (t - t1)
    98d  02 00 e 0 0 9022 0000  	subcw,s r[2],acc,y;	;		;		;
    98e  02 00 3 2 0 ffc5 0992  	bclrw,s 15,r[5];	;		cjp,cry chkthru3;;			  | no borrow means t >= t1
    98f  0a 00 e 0 0 d882 0000  	movw acc,r[2];		;		;		;			  | else t1 <- t
    990  0a 00 b 0 0 d8c1 0932  	movw d,r[1];		;		cjpp,zer newpts3;;			  | r[5]==0 -> no more intersections
    991  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | else return to check next plane
    992  1a 00 a 8 0 7140 0000  chkthru3: ;			;		crtn,~zer;	;			  | r[5] != 0 -> more intersections, rtn
    993  0a 00 b 7 0 7140 0932  	;			;		cjpp,go newpts3;;			  | else pop stack and goto newpts3
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)xfpolygon3.vp.u 1.2 86/09/12 SMI
                                |	movw d,r[11];		shmem->am;	jmap CORENDCPOLY_3D;;			  | # of separate boundaries
                                CORENDCPOLY_3D:
    994  0a 27 e 0 0 d8c5 0851  	movw d,r[5];		=xfint3->am;	;		;			  | r[5] pts to 3D transform routine
                                											  | xfint3 converts from fix to float
                                											  | before calling the regular xf3 routine
    995  0a 00 3 7 0 7140 0997  	;			;		cjp,go xfpoly3D;;			  | fall into rest of polygon code
                                |	movw d,r[11];		shmem->am;	jmap XFPOLYGON_3D;;			  | # of separate boundaries
                                XFPOLYGON_3D:
    996  0a 27 e 0 0 d8c5 0862  	movw d,r[5];		=xf3->am;	;		;			  | use the regular xf3 routine
    997  0a 0f 1 7 0 d85d 02cf  xfpoly3D: movw r[29],y;	am->shmemp;	cjs,go polygon_attr_3D;;		  | option bits passed to polygon_attr_3D
    998  0a 0f c 0 0 d849 000f  	movw r[9],y;	am->shmemp;	ldct 15;	;			  | in acc -- constant:0, Gouraud:1
    999  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    99a  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    99b  0a 0f c 0 0 f880 0005  	movw acc,y;		am->shmemp;	ldct 5;		;
    99c  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move viewport parameters to fpr[32]
                                										|
                                										| edge structure is:
                                										| fpreg[r[14]+0]: ymin    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[r[14]+1]: ymax    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[r[14]+2]: xmax    32-bit float
                                										| fpreg[r[14]+3]: zmax    32-bit float
                                										| fpreg[r[14]+4]: imax    32-bit float
                                										| fpreg[r[14]+5]: xmin    32-bit float
                                										| fpreg[r[14]+6]: zmin    32-bit float
                                										| fpreg[r[14]+7]: imin    32-bit float
                                										| fpreg[r[14]+8]: X       don't care in high word
                                										|		   nxt     11-bit ptr in low word
                                										|
                                	| Initialization for edge table variables when the edge-building routines
                                	|  are the consuming routines for the points output by the polygon clipper
    99d  0a 27 e 0 0 d8c9 00b4  	movw d,r[9];		180->am;	;		;			  | r[9]<-180
    99e  0a 27 e 0 0 d8c8 00e6  	movw d,r[8];		230->am;	;		;			  | address of dummy 1st edge
    99f  0a 0e e 0 0 c7c8 0000  	add2nw 3,r[8],r[8]; am->fpdp;	;		;			  | fpdp<-&dummy edge r[8]
    9a0  0b 0b e 0 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	;		;			  | dummy edge r[8]<-ptr to 1st real edge
    9a1  0a 27 e 0 0 d8d3 0bac  	movw d,r[19];	=mkedges3->am;	;		;			  | r[19] <- mkedges3, ptr to point-
                                											  | consuming routine
                                	| Start of reading input polygon and xform-clip-vwpscale pipeline
                                procpoly3:
    9a2  08 00 e 0 1 dd7e 0000  	incw r[30],r[17];	;		;		;			  | r[17] pts to vector of npts per boundary
                                											  | (after increment below)
    9a3  0a 27 e 0 0 868b 0002  	addw d,r[11],acc;	2->am;		;		;
    9a4  0a 00 e 0 0 989e 0000  	addw r[30],acc,r[30];	;		;		;			  | r[30] now points to first vertex
    9a5  02 00 e 0 0 c1eb 0000  xf3nxtbnd: sub2nw,s 0,r[11],r[11];;		;		;			  | if ((r[11] -= 1)<0), goto xf3nxtstep
    9a6  0a 0f 3 1 0 dd71 0a98  	incw r[17],r[17];	am->shmemp;	cjp,neg xf3nxtstep;;			  | else get # of vertices for next
    9a7  0a 17 e 0 0 d8ca 0000  	movw d,r[10];		shmem->am;	;		;			  | boundary
    9a8  02 2e e 0 0 fff8 0003  	btstw,s 15,r[24]; 3->fpdp;	;		;			  | test for 2D or 3D input routine
    9a9  0a 00 3 8 0 858a 09ae  	rolw 2,r[10],acc;	;		cjp,~zer xf32nxbnd; ;			  | if 2D, acc == r[10]*4
    9aa  02 00 e 0 0 e1f8 0000  	btstw,s 0,r[24]; ;		;		;			  | set cc to reflect shading type &
    9ab  0a 00 3 8 0 e39d 09ae  	rolw 1,acc,acc;		;		cjp,~zer .+3;	;			  | fpdp <- 3 (used below); acc <- r[10]*8
    9ac  0a 00 e 0 0 800a 0000  	subw r[10],acc,acc;	;		;		;			  | if Gouraud shading, acc == r[10]*8
    9ad  0a 00 e 0 0 800a 0000  	subw r[10],acc,acc;	;		;		;			  | if constant shading, acc <- r[10]*6
    9ae  02 27 e 0 0 960a 0003  xf32nxbnd: subw,s d,r[10],y;	3->am;		;		;			  | if 0 <= r[10] < 3, not a good boundary
    9af  08 0f e 0 0 d97e 0000  	movw r[30],r[16];	am->shmemp;	;		;			  | shmemp pts to vertices;update r[30] to
    9b0  0a 00 3 a 0 989e 09a5  	addw r[30],acc,r[30];	;		cjp,~cry xf3nxtbnd;;			  | point to 1st loc after bndry's vertices
    9b1  02 27 e 0 0 960a 001a  	subw,s d,r[10],y;	26->am;	;		;			  | if (r[10]>=26),goto xf3lrgpoly
    9b2  08 08 3 9 0 c1ea 0aa2  	sub2nw 0,r[10],r[0];	am->brreg;	cjp,~neg xf3lrgpoly;;			  | brreg <- r[10]-1; r[16] has shmem addr
                                											  | of 1st vertex of this boundary -- this
                                											  | is used if we jump to xf3lrgpoly
                                xf3smlpoly:
    9b3  0a 27 e 0 0 d8ce 077b  	movw d,r[14];		1915->am;	;		;			  | r[14] <- address for transformed pts
    9b4  0a 2c e 0 0 d8e0 0010  	movw 1889,r[0];	16->fpap;	;		;			  | fpap <- address of matrix; r[0] <- addr
    9b5  0a 2b e 0 0 0761 3f80  	;			0x3f80->fpregh;	;		;			  | to temporarily hold vertex intensities
    9b6  03 2b e 0 0 fff8 0000  	btstw,s 15,r[24]; 0->fpregl ;	;		;			  | test for 2D or 3D input routine
    9b7  02 00 3 8 0 e1f8 0a8d  	btstw,s 0,r[24]; ;		cjp,~zer xf32smlp; ;			  | fpr[3] <- 1.0 (fpdp was set above)
                                											  | set cc to reflect constant or Gouraud
                                											  | shading (xf3 doesn't affect cc's)
    9b8  1a 08 4 7 0 d845 0000  	movw r[5],y;		am->brreg;	push,go;	;			  | brreg <- addr of transform routine
                                											  | now loop through r[10] pts & xform them
    9b9  0a 0e e 0 0 d90f 0000  	movw 0,r[15];		am->fpdp;	;		;			  | put untransformed pt at fpr[0]
    9ba  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[0] <- x[i]
    9bb  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+
    9bc  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[1] <- y[i]
    9bd  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+
    9be  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[2] <- z[i]
    9bf  1b 1b 1 7 2 7140 0000  	;			shmem->fpregl;	cjs,go;		;		shp+	  | transform pt and deposit in pt buffer
    9c0  0a 0c 3 8 0 e996 09c3  	mov2nw 4,y;		am->fpap;	cjp,~zer .+3;	;			  | reload matrix ptr; if constant shading,
    9c1  1a 27 8 0 0 9e8e 0005  	addw d,r[14],r[14];	5->am;		rfct;		;			  | increment r[14] and loop
    9c2  02 00 3 7 0 d84c 09d1  	movw,s r[12],y;	;		cjp,go xf3smlclp;;			  | if constant shading, goto xf3smlclp
                                											  | when loop is complete
                                											  | also set cc to reflect clipping state
    9c3  0a 0e e 0 0 dd60 0000  	incw r[0],r[0];		am->fpdp;	;		;			  | if Gouraud shading, fpdp<-1890 loc for
    9c4  0a 17 e 0 2 9c8e 0000  	addw r[14],5,r[14];	shmem->am;	;		;		shp+	  | ith vertex intensity; convert int[i]
    9c5  0b 1b e 0 2 0005 0000  	;			shmem->fpregl;	;		;		shp+	  | fixed point representation from unsigned
    9c6  1a 0b 8 0 0 ef95 0000  	sub2nw 7,d,y;		am->fpregh;	rfct;		;			  | (8-bit integer, 16-bit fraction) to
                                											  | signed (7-bit integer, 16-bit fraction)
                                											  | by subtracting 2^^7 from integer since
                                											  | Weitek float and fix ops only handle
                                											  | 24-bit twos-complement integers
                                											  | r[14] += 5, and loop
    9c7  2b 08 e 0 0 e396 0230  	mov2nw 1,y;		am->brreg;	;		lmode rn,ai,pipe,fast;	  | brreg <- 2; set Weitek pipeline mode
    9c8  0a 2c e 0 0 7140 0762  	;			1890->fpap;	;		;			  | fpap <- addr of vertex intensities
    9c9  2a 00 e 0 0 d8f0 00a0  	movw 1919,r[16];	;		;		floata,la,hi;		  | convert intensities to float
    9ca  3b 0e 4 7 4 077f 00a0  	;			am->fpdp;	push,go;	;		ap+	  | fpdp<-1915+4,addr for 1st cnvrtd intns
    9cb  2a 00 e 0 0 f8e1 00a0  	movw 5,acc;		;		;		floata,la,hi;		  | repeat these 2 instructions 3 times
    9cc  3b 00 8 0 4 0005 00a0  	;			;		rfct;		;		ap+	  | acc <- 5
    9cd  28 08 e 0 0 c1ea 00a2  	sub2nw 0,r[10],r[0];	am->brreg;	;		floata,la,a,hi;		  | brreg <- r[10]-1
    9ce  3b 00 4 7 4 7140 00a2  	;			;		push,go;	;		ap+	  | pipe full,enable unload of 1st intensity
    9cf  22 00 e 0 0 d84c 00a3  	movw,s r[12],y;	;		;		floata,la,a,st,hi;	  | store int[i], start converting int[i+5]
    9d0  3b 0e 8 0 4 9890 00a3  	addw r[16],acc,r[16];	am->fpdp;	rfct;		;		ap+	  | fpdp+=5;set cc to reflect clipping state
    9d1  0a 0e 3 0 0 f900 09f5  xf3smlclp: movw 0,y;		am->fpdp;	cjp,zer fastpoly3;;			  | if clipping disabled, goto fastpoly3
    9d2  0a 2c e 0 0 9ccc 077b  	andw r[12],0x3F,r[12]; 1915->fpap;;	;			  | else do a fast clip test; fpdp <- 0
    9d3  0a 2d e 0 0 003f 077e  	;			1918->fpbp;	;		;			  | fpap<-&x0;fpbp<-&w0;r[12] format:
                                											  | L|R|B|T|H|Y is bits 5|4|3|2|1|0 with
                                											  | leading zeroes where a "1" means clip
                                											  | against the plane
                                											  | Note that lmode is still rn,ai,pipe,fast
                                											  | either from xf3 or from float cnvrt loop
    9d4  28 00 e 0 2 d96c 0110  	movw r[12],r[2];;		;		adda,lab,hi;		  | left plane: w0 + x0; test sign below
    9d5  29 00 e 0 1 db6c 0110  	compw r[12],r[1];;		;		;			  | r[2] <- r[12]
                                											  | r[1] <- ~r[12]
    9d6  2a 0b e 0 0 f900 01a0  	movw 0,y;		am->fpregh;	;		rsuba,la,hi;		  | right plane: w0 - x0; test sign below
    9d7  2b 0b e 0 4 f900 01a0  	movw 0,y;		am->fpregl;	;		;		ap+	  | fpr[0] <- 0.0
    9d8  28 08 e 0 0 c1ea 0120  	sub2nw 0,r[10],r[0];	am->brreg;	;		adda,la,hi;		  | bottom plane: w0 + y0; test sign below
    9d9  2b 00 e 0 0 d8e0 0120  	movw 1918,r[0];	;		;		;			  | r[0] <- &w0 (1915+3); brreg <- r[10]-1
    9da  2a 00 e 0 0 077e 01a0  	;			;		;		rsuba,la,hi;		  | top plane: w0 - y0; test sign below
    9db  3b 0d 4 7 4 f900 01a0  	movw 0,y;		am->fpbp;	push,go;	;		ap+	  | fpbp pts to 0.0
                                											  | loop through r[10] pts (brreg set above)
    9dc  2a 00 e 0 0 f901 0112  plyclptst3: movw 0,acc;		;		;		adda,lab,a,hi;		  | hither plane: 0.0 + z[i];test sign below
    9dd  2b 0d e 0 0 d840 0112  	movw r[0],y;		am->fpbp;	;		;			  | zero acc; fpbp <- &r[20][i]
    9de  2a 00 e 0 0 c5c0 0192  	add2nw 2,r[0];		;		;		rsuba,lab,a,hi;		  | yon plane: r[20][i] - z[i]; test sign below
    9df  2b 31 e 0 4 6e00 0192  	sl0b d,y;		fpstreg->am;	;		;		ap+	  | r[0] += 4; save sign bit of r[20][i]+x[i]
    9e0  2a 00 e 0 4 ec41 0122  	slqw acc,acc;		;		;		adda,la,a,hi;	ap+	  | advance pipeline
    9e1  2b 0d e 0 4 dd60 0122  	incw r[0],r[0];		am->fpbp;	;		;		ap+	  | fpap <- &x[i+1]; fpbp <- r[0] <- &r[20][i+1]
    9e2  2a 31 e 0 0 6e00 0112  	sl0b d,y;		fpstreg->am;	;		adda,lab,a,hi;		  | r[20][i+1]+x[i+1];save sign bit of r[20][i]-x[i]
    9e3  2b 00 e 0 0 ec41 0112  	slqw acc,acc;		;		;		;
    9e4  2a 31 e 0 0 6e00 01a2  	sl0b d,y;		fpstreg->am;	;		rsuba,la,a,hi;		  | r[20][i+1]-x[i+1];save sign bit of r[20][i]+y[i]
    9e5  2b 00 e 0 4 ec41 01a2  	slqw acc,acc;		;		;		;		ap+
    9e6  2a 31 e 0 0 6e00 0122  	sl0b d,y;		fpstreg->am;	;		adda,la,a,hi;		  | r[20][i+1]+y[i+1];save sign bit of r[20][i]-y[i]
    9e7  2b 00 e 0 0 ec41 0122  	slqw acc,acc;		;		;		;
    9e8  2a 31 e 0 0 6e00 01a0  	sl0b d,y;		fpstreg->am;	;		rsuba,la,hi;		  | r[20][i+1]-y[i+1];save sign bit of 0.0+z[i]
    9e9  2b 00 e 0 4 ec41 01a0  	slqw acc,acc;		;		;		;		ap+
    9ea  0a 31 e 0 0 6e00 0000  	sl0b d,y;		fpstreg->am;	;		;			  | save sign bit of r[20][i]-z[i]
    9eb  0a 2d e 0 0 ec41 0000  	slqw acc,acc;		0->fpbp;	;		;			  | fpbp pts to 0.0
    9ec  0a 00 e 0 0 9941 0000  	orw r[1],acc,r[1];;		;		;			  | accumulate r[1]
    9ed  1a 00 8 0 0 98c2 0000  	andw r[2],acc,r[2];;	rfct;		;			  | accumulate r[2] & loop until done
    9ee  0a 00 e 0 0 d802 0000  	movw r[2],acc;	;		;		;			  | acc <- r[2]
    9ef  02 00 e 0 0 910c 0000  	xorw,s r[12],acc,y;;		;		;			  | if (r[2] == r[12]), then
                                											  | all pts are inside the clip region,
    9f0  02 00 3 0 0 da01 09f5  	compw,s r[1],acc;	;		cjp,zer fastpoly3;;			  | so goto fastpoly3
    9f1  0a 28 e 0 0 d8e3 0acc  	movw 1915,r[3];	=clppoly3->brreg;;		;			  | if (~r[1] != 0), all pts were
    9f2  0a 00 3 8 0 077b 09a5  	;			;		cjp,~zer xf3nxtbnd;;			  | outside at least 1 clipping plane so
    9f3  1a 27 1 7 0 d8d2 0a9a  	movw d,r[18];	=nxtxfpt3->am;	cjs,go;		;			  | goto xf3nxtbnd; else call clppoly3 with
                                											  | r[3] pointing to 1st transformed
    9f4  0a 00 3 7 0 7140 09a5  	;			;		cjp,go xf3nxtbnd;;			  | point and r[18] pointing to the
                                											  | subroutine nxtxfpt3
                                											  | after return, goto xf3nxtbnd
    9f5  02 27 e 0 0 9713 0bac  fastpoly3: xorw,s d,r[19],y; =mkedges3->am;;		;			  | if r[19] != mkedges3, goto
    9f6  0a 00 3 8 0 7140 0bf7  	;			;		cjp,~zer procfastbnd3;;			  | procfastbnd3; else fall through to
                                											  | the code below which is an accelerator
                                											  | for the case of small polygons which
                                											  | do not require clipping, when the edge-
                                											  | building routines are output routines
                                vwpsmlpoly3:
    9f7  0a 27 e 0 0 d8c4 077b  	movw d,r[4];	1915->am;	;		;			  | r[4]<-1915(address of xformed pts)
    9f8  08 08 1 7 0 c1ea 0b6b  	sub2nw 0,r[10],r[0];	am->brreg;	cjs,go vwpsclpts3;;			  | vwpsclpts3 assumes vwp params at fpr[32]
                                											  | scale r[10] pts to the viewport
                                											  | scaling is done in-place
                                											  | pass r[10]-1 in brreg
                                xf3smledgs:
    9f9  2a 0c e 0 0 dc44 0230  	incw r[4],y;	am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap <- 1915 + 1; use flowthrough mode
    9fa  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | y[0]
    9fb  2b 00 e 0 0 7140 00e0  	;			;		;		;
    9fc  0a 00 e 0 0 7140 0000  	;			;		;		;
    9fd  08 08 e 0 0 c3ea 0000  	sub2nw 1,r[10],r[0];	am->brreg;	;		;			  | brreg <- r[10]-2
    9fe  0a 27 e 0 0 d8c3 077b  	movw d,r[3];	1915->am;	;		;			  | r[3] <- 1915
    9ff  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			  | d<-5; wait for fixed y[0]
    a00  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    a01  2b 0e e 0 0 f900 0102  	movw 0,y;		am->fpdp;	;		;
    a02  2a 0c e 0 0 f900 0101  	movw 0,y;		am->fpap;	;		adda,st,hi;		  | fpreg[0] <- y[0] (integer)
    a03  2b 00 e 0 0 9e83 0101  	addw d,r[3],r[3];;		;		;			  | r[3] <- &x[1]
    a04  0b 37 e 0 0 d8c4 0000  	movw d,r[4];		fpregl->am;	;		;			  | r[4] <- low word of integer y[0]
    a05  1a 27 4 7 0 d804 0005  	movw r[4],acc;	5->am;		push,go;	;			  | acc<-y[0]; d<-5; start loop to build 1st
                                xf3smledgloop:										  | n-1 edges;notation: i runs from 1 to n-1
    a06  0a 0c e 0 0 dc43 0000  	incw r[3],y;	am->fpap;	;		;			  | fpap <- &y[i]
    a07  28 0e e 0 0 c3c8 00e0  	add2nw 1,r[8],r[0];	am->fpdp;	;		fixa,la,hi;		  | fix y[i]; fpdp <- &edg.xmax
    a08  2b 0c e 0 0 d843 00e0  	movw r[3],y;	am->fpap;	;		;			  | fpap <- &x[i]
    a09  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- x[i]
    a0a  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a0b  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a0c  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.zmax <- z[i]
    a0d  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a0e  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a0f  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.imax <- intensity[i]
    a10  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    a11  0a 0c e 0 0 9603 0000  	subw d,r[3],y;	am->fpap;	;		;			  | fpap <- &x[i-1]
    a12  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmin <- x[i-1]
    a13  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a14  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a15  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.zmin <- z[i-1]
    a16  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a17  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a18  08 3b e 0 0 d968 0000  	movw r[8],r[0];	fpregh->fpregh;	;		;			  | edg.imin <- intensity[i-1]; r[0]<-r[8]
    a19  0b 3b e 0 6 c7c8 0000  	add2nw 3,r[8],r[8];	fpregl->fpregl;	;		;		dp+	  | r[8] += 8
    a1a  0b 0b e 0 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	;		;			  | edg.nxt <- r[8] <- addr of next edge
    a1b  0a 0e e 0 0 d840 0000  	movw r[0],y;		am->fpdp;	;		;			  | fpdp <- address of this edge
    a1c  2a 0b e 0 6 f880 0102  	movw acc,y;		am->fpregh;	;		adda,a,hi;	dp+	  | edg.ymin <- y[i-1] (16-bit integer)
    a1d  2b 00 e 0 0 9e83 0102  	addw d,r[3],r[3];;		;		;			  | r[3] <- &x[i+1]
    a1e  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | edg.ymax <- y[i] (32-bit integer)
    a1f  2b 0c e 0 0 dc40 0101  	incw r[0],y;		am->fpap;	;		;			  | fpap <- &edg.ymax
    a20  03 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregl->am;	;		;			  | check for horizontal edges
    a21  0b 37 3 0 0 f8c1 0a27  	movw d,acc;		fpregl->am;	cjp,zer xf3horizedg;;			  | acc <- low order 16 bits of int y[i]
    a22  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | r[9] -= 1
    a23  0a 0b 3 1 0 f880 0a26  	movw acc,y;		am->fpregh;	cjp,neg xf3edgovflw;;			  | move low 16 bits to high 16 bits where
                                											  | scan conversion code expects to see it
                                											  | also handle case of too many edges
    a24  1a 27 8 0 0 7140 0005  	;			5->am;		rfct;		;			  | d <- 5; loop back until last edge
    a25  0a 00 3 7 0 7140 0a28  	;			;		cjp,go xf3lastedg;;
                                xf3edgovflw:
    a26  0a 00 e 0 0 db09 0000  	compw 0,r[9];		;		;		;			  | r[9] <- -1 and adjust r[8]
                                xf3horizedg:
    a27  18 27 8 0 8 d960 0005  	movw r[0],r[8];	5->am;		rfct;		;			  | ignore horizontal and overflow edges
                                											  | r[8] -= 9
                                											  | d<-5; loop back until last edge
                                xf3lastedg:
    a28  02 2c e 0 0 9104 077b  	xorw,s r[4],acc,y;	1915->fpap;	;		;			  | ignore horizontal last edge; fpap<-&x[0]
    a29  0a 0e 3 0 0 d848 09a5  	movw r[8],y;		am->fpdp;	cjp,zer xf3nxtbnd;;			  | fpdp <- address of nth edge
    a2a  0a 0b e 0 6 f880 0000  	movw acc,y;		am->fpregh;	;		;		dp+	  | edg.ymin <- y[n-1]
    a2b  0a 0b e 0 6 d844 0000  	movw r[4],y;		am->fpregh;	;		;		dp+	  | edg.ymax <- y[0]
    a2c  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- x[0]
    a2d  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a2e  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a2f  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.zmax <- z[0]
    a30  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a31  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a32  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.imax <- intensity[0]
    a33  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    a34  0a 0c e 0 0 9603 0000  	subw d,r[3],y;	 am->fpap;	;		;			  | fpap <- &x[n-1]
    a35  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmin <- x[n-1]
    a36  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a37  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a38  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.zmin <- z[n-1]
    a39  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a3a  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a3b  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.imin <- intensity[n-1]
    a3c  0b 3b e 0 6 c7c8 0000  	add2nw 3,r[8],r[8];	fpregl->fpregl;	;		;		dp+	  | r[8] += 8
    a3d  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | r[9] -= 1
    a3e  0b 0b 3 9 0 dd68 09a5  	incw r[8],r[8];	am->fpregl;	cjp,~neg xf3nxtbnd;;			  | edg.nxt <- r[8] <- addr of next edge
    a3f  0a 27 e 0 0 9e08 0009  	subw d,r[8],r[8];	9->am;		;		;			  | goto xf3nxtbnd; if (r[9] < 0),
    a40  0a 00 3 7 0 db09 09a5  	compw 0,r[9];		;		cjp,go xf3nxtbnd;;			  | r[9] <- -1 and adjust r[8]
                                											  | completion code for r[19]==mkedges3
                                											  | code from jump vector to get here:
                                |	sub2nw 0,r[8],r[8];	am->fpdp;	cjp,go xf3doscan;;			  | fpdp <- &edg.nxt for last edge
                                xf3doscan: 
    a41  02 00 e 0 0 f3f8 0000  	btstw,s 9, r[24]; ;		;		;			| 
    a42  02 00 3 8 0 f5f8 0a44  	btstw,s 10, r[24]; ;		cjp, ~zer .+2;	;			| 
    a43  0a 00 3 0 0 7140 0a85  	;			;		cjp, zer xf3polyscan; ;			| Go scan if no texturing.
    a44  0a 2f e 0 0 7140 01ff  	;			511->shmemp; ;	;			| What texture is in PP?
    a45  0a 17 e 0 0 d8c0 0000  	movw d, r[0];		shmem->am;	;		;			| 
    a46  0a 27 e 0 0 869d 000a  	addw d, r[29], acc;	10->am; ;		;			| Compare PP texture block ptr with our own.
    a47  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    a48  02 17 e 0 0 f8c0 0000  	movw,s d, y;		shmem->am;	;		;			| Check for invalid tex block (-1)
    a49  02 17 3 9 0 9600 0a4c  	subw,s d, r[0], y;	shmem->am;	cjp, ~neg xf3tex; ;			| Compare tex pointers.
    a4a  0a 27 e 0 0 9ed8 f9ff  	andw d, r[24], r[24]; 0xf9ff->am; ;	;			| mask out bits 9 and 10. (comp 0x600)
    a4b  0a 00 3 7 0 7140 0a85  	;			;		cjp, go xf3polyscan; ;			| 
    a4c  0a 00 3 0 0 7140 0a5d  xf3tex:	;			;		cjp, zer xf3texoff; ;			| 
    a4d  0a 27 e 0 0 869d 0007  	addw d, r[29], acc;	7->am; ;		;			| if (reload pp) shmemp = 7
    a4e  1a 0f 4 f 0 f880 0000  	movw acc, y;		am->shmemp;	push, ~go;	;			| 
    a4f  1a 26 d 4 0 7140 001b  	;			 27->fifo1;	loop, f1nf;	;			| 
    a50  08 00 1 7 0 d96d 0322  	movw r[13], r[0];	;		cjs, go stprep;	;			| Save r[13].  stprep incr shmemp.
    a51  0a 06 3 c 0 d84e 0a51  	movw r[14], y;		am->fifo1;	cjp, f1f .;	;			| 
    a52  0a 17 e 0 0 d8c1 0000  	movw d, r[1];		shmem->am;	;		;			| TEX2FRAME (stprep incr shmemp)
    a53  0a 2f e 0 0 7140 01ff  	;			511->shmemp; ;	;			| 
    a54  0a 06 3 c 0 d84d 0a54  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    a55  0a 0a e 0 0 d841 0000  	movw r[1], y;		am->shmem;	;		;			| Remember what frame is on PP.
    a56  08 00 e 0 d d960 0000  	movw r[0], r[13];	;		;		;			| Restore r[13].
    a57  0a 06 3 c 0 d84f 0a57  	movw r[15], y;		am->fifo1;	cjp, f1f .;	;			| 
    a58  0a 0f e 0 0 d841 0000  	movw r[1], y;		am->shmemp;	;		;			| Address texture frame.
    a59  12 00 4 7 0 c1eb 0000  xf3ltex: sub2nw,s 0, r[11], r[11]; ;		push, go;	;			| Copy texture to PP.
    a5a  0a 16 3 c 0 7140 0a5a  	;			shmem->fifo1;	cjp, f1f .;	;			| 
    a5b  1a 00 8 0 2 7140 0000  	;			;		rfct;		;		shp+	| 
    a5c  0a 08 3 8 0 d84c 0a59  	movw r[12], y;		am->brreg;	cjp, ~zer xf3ltex; ;			| Copy next row of texture.
    a5d  0a 27 e 0 0 869d 0018  xf3texoff: addw d, r[29], acc; 24->am; ;	;			| 
    a5e  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    a5f  02 17 e 0 0 f8c1 0000  	movw,s d, acc;		shmem->am;	;		;			| if (Kind == 0)
    a60  0a 00 3 0 0 7140 0a81  	;			;		cjp, zer xf3sxsy; ;			| else (Kind ==  2) Addr of xform subr.
    a61  0a 2e e 0 0 7140 0003  	;			3->fpdp;	;		;			| 
    a62  0a 2b e 0 0 7140 3f80  	;			0x3f80->fpregh;	;		;			| 4th coord of pt is 1.0 (homog.)
    a63  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
    a64  0a 0e e 0 0 d90f 0000  	movw 0, r[15];		am->fpdp;	;		;			| 
    a65  0a 2c e 0 0 7140 0010  	;			16->fpap;	;		;			| Address of matrix for transform.
    a66  0a 27 e 0 0 869d 0012  	addw d, r[29], acc;	18->am; ;		;			| 
    a67  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    a68  0a 1b e 0 2 c58e 0000  	mov2nw 2, r[14];	shmem->fpregh;	;		;		shp+	| store 3 coords at 0 (r[15]). r[14]= 4.
    a69  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+| 
    a6a  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	| 
    a6b  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+| 
    a6c  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	| 
    a6d  0b 1b 1 7 0 7140 0862  	;			shmem->fpregl;	cjs, go xf3;	;			| Transform point.
    a6e  0a 28 e 0 0 c584 0000  	mov2nw 2, r[4];	0->brreg;	;		;			| Pt. Addr->r[4], num vertices->brreg.
    a6f  0a 00 1 7 0 7140 0b6b  	;			;		cjs, go vwpsclpts3; ;			| Do in-place viewport scale.
    a70  2b 0c e 0 0 e596 0230  	mov2nw 2, y;		am->fpap;	;		lmode rn, ai, pipe, fast; | 
    a71  2a 0e e 0 0 f900 00e0  	movw 0, y;		am->fpdp;	;		fixa, la, hi;		| Fix r[21] and r[22]. Ignore z coordinate.
    a72  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    a73  2a 00 e 0 0 7140 00e0  	;			;		;		fixa, la, hi;		| 
    a74  2b 00 e 0 0 7140 00e0  	;			;		;		;			| 
    a75  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    a76  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    a77  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    a78  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    a79  2a 00 e 0 0 7140 0122  	;			;		;		adda,la, a, hi;		| 
    a7a  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    a7b  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 
    a7c  2b 00 e 0 6 f8e0 0123  	movw =xf3polyscan, y;	;		;		;		dp+	| 
    a7d  2a 08 e 0 0 0a85 0121  	;			am->brreg;	;		adda,la, st, hi;		| 
    a7e  2b 0c e 0 0 f900 0121  	movw 0, y;		am->fpap;	;		;			| 
    a7f  0b 37 e 0 4 d8d5 0000  	movw d, r[21];		fpregl->am;	;		;		ap+	| 
    a80  1b 37 3 7 0 d8d6 0000  	movw d, r[22];		fpregl->am;	cjp, go;	;			| goto xf3polyscan.
    a81  0a 27 e 0 0 869d 000c  xf3sxsy: addw d, r[29], acc;	 12->am; ;		;			| 
    a82  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| retrieve r[21] and r[22].
    a83  0a 17 e 0 2 d8d5 0000  	movw d, r[21];		shmem->am;	;		;		shp+	| 
    a84  0a 17 e 0 0 d8d6 0000  	movw d, r[22];		shmem->am;	;		;			| 
    a85  0a 0e e 0 0 d848 0000  xf3polyscan: movw r[8], y;	am->fpdp;	;		;			| Reload dp.
    a86  03 2b e 0 0 d849 0000  	movw,s r[9],y;	0->fpregl;	;		;			  | load NULL r[8] for last edge
    a87  0a 00 3 1 0 9c09 0a8c  	subw,s r[9],180,r[9];;		cjp,neg xf3noscan;;			  | if # of edges > 180, goto xf3noscan
    a88  02 00 e 0 0 00b4 0000  	;			;		;		;			  | compute real # of edges
    a89  0a 27 e 0 0 d8ce 00e6  	movw d,r[14];		230->am;	;		;			  | if # of edges != 0, call polyscan3 with
    a8a  08 00 e 0 f d96d 0000  	movw r[13],r[15];;		;		;			  | r[14], r[15], and r[16]
    a8b  08 00 1 8 0 d978 0dcd  	movw r[24],r[16];;	cjs,~zer polyscan3;;
    a8c  0a 00 2 0 0 7140 0027  xf3noscan: ;			;		jmap getcmd;	;
    a8d  1a 08 4 7 0 d845 0000  xf32smlp: movw r[5],y;	am->brreg;	push,go;	;			  | brreg <- addr of transform routine
                                											  | now loop through r[10] pts & xform them
    a8e  0a 0e e 0 0 d90f 0000  	movw 0,r[15];		am->fpdp;	;		;			  | put untransformed pt at fpr[0]
    a8f  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[0] <- x[i]
    a90  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+
    a91  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[1] <- y[i]
    a92  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+  | 
    a93  0a 2b e 0 0 7140 0000  	;			0->fpregh;	;		;			  | fpr[2] <- z==0
    a94  1b 2b 1 7 0 7140 0000  	;			0->fpregl;	cjs,go;		;			  | transform pt and deposit in pt buffer
    a95  0a 0c e 0 0 e996 0000  	mov2nw 4,y;		am->fpap;	;		;			  | reload matrix ptr for constant shading
    a96  1a 27 8 0 0 9e8e 0005  	addw d,r[14],r[14];	5->am;		rfct;		;			  | increment r[14] and loop
    a97  02 00 3 7 0 d84c 09d1  	movw,s r[12],y;	;		cjp,go xf3smlclp;;			  | if constant shading, goto xf3smlclp
                                xf3nxtstep:
    a98  08 08 e 0 0 c1f3 0000  	sub2nw 0,r[19],r[16]; am->brreg;	;		;			  | next step after xform-clp-consumepts is
    a99  1a 00 3 7 0 7140 0000  	;			;		cjp,go;		;			  | determined from jump vector at
                                											  | r[19]-1
    a9a  0a 0e e 0 0 d847 0000  nxtxfpt3: movw r[7],y;	am->fpdp;	;		;			  | fpdp <- address for next pt to clip
    a9b  0a 0c e 0 0 d843 0000  	movw r[3],y;		am->fpap;	;		;			  | fpap <- address of next transformed pt
    a9c  02 3b e 0 0 c1ea 0000  	sub2nw,s 0,r[10],r[10];	fpregh->fpregh;	;		;			  | transfer x; r[10]-=1, set cc to
                                											  | reflect result (neg means no more pts)
    a9d  1b 3b a 1 8 7140 0000  	;			fpregl->fpregl;	crtn,neg;	;		adp+	  | return if no more pts
    a9e  0a 3b 4 7 0 7140 0002  	;			fpregh->fpregh;	push,go 2;	;			  | transfer y
    a9f  0b 3b e 0 8 f8e1 0000  	movw 5,acc;		fpregl->fpregl;	;		;		adp+
    aa0  1a 3b 8 0 0 0005 0000  	;			fpregh->fpregh;	rfct;		;			  | transfer z, r[20], and intensity
    aa1  1b 3b a 7 0 9883 0000  	addw r[3],acc,r[3]; fpregl->fpregl; crtn,go;	;			  | r[3] += 5; return (cc is ~neg)
                                xf3lrgpoly:
    aa2  02 00 e 0 0 fff8 0000  	btstw,s 15,r[24]; ;		;		;			  | test 2D or 3D input routine
    aa3  0a 00 3 8 0 d810 0aa8  	movw r[16],acc;		;		cjp,~zer xf32l;	;			  | if 2D assume constant shading
    aa4  02 2e e 0 0 e1f8 077e  	btstw,s 0,r[24]; 1918->fpdp; ;		;			  | test constant or Gouraud shading
    aa5  0a 00 3 0 0 7140 0aaa  	;			;		cjp,zer xf3lc;	;			  | 
                                											  | Gouraud shading
    aa6  0a 27 e 0 0 d8d2 0abe  xf3lg:	movw d,r[18];	=nxtcmdpt3g->am;;		;			  | r[18] points to subroutine nxtcmdpt3g
    aa7  0a 00 3 7 0 d883 0aab  	movw acc,r[3];	;		cjp,go xf3l;	;			  | r[3] <- shmem addr of boundary pts
    aa8  0a 27 e 0 0 d8d2 0ab5  xf32l:	movw d,r[18];	=nxtcmdpt23->am; ;		;			  | 2D input routine
    aa9  0a 00 3 7 0 7140 0aab  	;			;		cjp,go xf3l;	;			  | r[18] points to subroutine nxtcmdpt23
                                											  | constant shading
    aaa  0a 27 e 0 0 d8d2 0aae  xf3lc:	movw d,r[18];	=nxtcmdpt3c->am;;		;			  | r[18] points to subroutine nxtcmdpt3c
    aab  0a 2b e 0 0 7140 3f80  xf3l:	;			0x3F80->fpregh;	;		;			  | fpreg[1915+3]<-1.0(used by nxtcmdpt3's)
    aac  0b 0b 1 7 0 f900 0acc  	movw 0,y;		am->fpregl;	cjs,go clppoly3;;			  | call clppoly3
    aad  0a 00 3 7 0 7140 09a5  	;			;		cjp,go xf3nxtbnd;;			  | loop back to xf3nxtbnd
    aae  02 2c e 0 0 c1ea 0010  nxtcmdpt3c: sub2nw,s 0,r[10],r[10]; 16->fpap;	;		;			  | fpap pts to matrix; r[10] -= 1, cc
    aaf  18 2e a 1 e d967 077b  	movw r[7],r[14];	1915->fpdp;	crtn,neg;	;			  | reflects result; return if no more pts
                                											  | else fpdp<-1915 (addr for new pt)
    ab0  0a 08 e 0 0 d845 0000  	movw r[5],y;		am->brreg;	;		;			  | brreg pts to appropriate xform routine
    ab1  0a 1b 4 7 2 7140 0001  	;			shmem->fpregh;	push,go 1;	;		shp+	  | fpreg[1915] <- next x; r[14] <- addr
    ab2  0b 1b e 0 c d8ef 0000  	movw 1915,r[15];	shmem->fpregl;	;		;		shp+,dp+  | for xformed pt; transfer y and z
    ab3  1a 1b 8 0 2 077b 0000  	;			shmem->fpregh;	rfct;		;		shp+	  | transfer y and z; r[15] <- 1915
    ab4  1b 1b 3 7 2 7140 0000  	;			shmem->fpregl;	cjp,go;		;		shp+	  | jump to xform routine which returns to
                                											  | caller after xfrming pt & putting result
                                											  | at *r[7] (fpreg[1915+3] == 1.0)
                                											  | shmemp now pts to next pt
    ab5  02 2c e 0 0 c1ea 0010  nxtcmdpt23: sub2nw,s 0,r[10],r[10]; 16->fpap;	;		;			  | fpap pts to matrix; r[10] -= 1, cc
    ab6  18 2e a 1 e d967 077b  	movw r[7],r[14];	1915->fpdp;	crtn,neg;	;			  | reflects result; return if no more pts
                                											  | else fpdp<-1915 (addr for new pt)
    ab7  0a 08 e 0 0 d845 0000  	movw r[5],y;		am->brreg;	;		;			  | brreg pts to appropriate xform routine
    ab8  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpreg[1915] <- next x; r[14] <- addr
    ab9  0b 1b e 0 c d8ef 0000  	movw 1915,r[15];	shmem->fpregl;	;		;		shp+,dp+  | for xformed pt; transfer y
    aba  0a 1b e 0 2 077b 0000  	;			shmem->fpregh;	;		;		shp+	  | transfer y; r[15] <- 1915
    abb  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+  |
    abc  0a 2b e 0 0 7140 0000  	;			0->fpregh;	;		;			  | z == 0
    abd  1b 2b 3 7 0 7140 0000  	;			0->fpregl;	cjp,go;		;			  | jump to xform routine which returns to
                                											  | caller after xfrming pt & putting result
                                											  | at *r[7] (fpreg[1915+3] == 1.0)
                                											  | shmemp now pts to next pt
    abe  02 2e e 0 0 c1ea 077b  nxtcmdpt3g: sub2nw,s 0,r[10],r[10]; 1915->fpdp;;		;			  | fpdp<-1915(addr for new pt);r[10] -= 1,
    abf  18 2c a 1 0 c5c3 077b  	add2nw 2,r[3],r[0];	1915->fpap;	crtn,neg;	;			  | cc reflects result;return if no more pts
    ac0  0a 0f e 0 0 c3c0 0000  	add2nw 1,r[0],r[0];	am->shmemp;	;		;			  | fpap<-1915;shmemp <- r[0] <- shmem addr
    ac1  0a 17 e 0 2 7140 0000  	;			shmem->am;	;		;		shp+	  | of vertex intensity; convert intensity
    ac2  2a 0b e 0 0 ef95 0230  	sub2nw 7,d,y;		am->fpregh;	;		lmode rn,ai,flow,fast;	  | fixed point representation from unsigned
    ac3  0b 1b c 0 0 7140 0002  	;			shmem->fpregl;	ldct 2;		;			  | (8-bit integer, 16-bit fraction) to
                                											  | signed (7-bit integer, 16-bit fraction)
                                											  | by subtracting 2^^7 from integer since
                                											  | Weitek float and fix ops only handle
                                											  | 24-bit twos-complement integers
                                											  | flow mode; 2910 R reg<-2
    ac4  2a 0f e 0 0 d843 00a0  	movw r[3],y;	am->shmemp;	;		floata,la,hi;		  | convert intensity to float; shmemp <- &x
    ac5  39 00 4 f 3 c3c0 00a0  	add2nw 1,r[0],r[3];	;		push,~go;	;			  | r[3] += 8 (addr of next pt in shmem)
    ac6  0a 1b e 0 2 d8ef 0000  	movw 1915,r[15];	shmem->fpregh;	;		;		shp+	  | transfer x, y, and z to fpreg[1915]
    ac7  1b 1b 8 0 c 077b 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+  | r[15]<-1915
    ac8  2a 08 e 0 0 d845 0102  	movw r[5],y;		am->brreg;	;		adda,a,hi;		  | enable unload of converted intensity
    ac9  29 0e e 0 0 c5c7 0102  	add2nw 2,r[7],r[0];	am->fpdp;	;		;			  | brreg<-r[5]; fpdp<-addr for intensity
    aca  2a 0c e 0 0 e996 0101  	mov2nw 4,y;		am->fpap;	;		adda,st,hi;		  | *(r[7]+4) <-  converted intensity
    acb  39 00 3 7 e d967 0101  	movw r[7],r[14];	;		cjp,go;		;			  | fpap pts to matrix
                                											  | r[14] <- addr for xformed pt
                                											  | jump to xform routine which returns to
                                											  | caller after xfrming pt & putting result
                                											  | at *r[7] (fpreg[1915+3] == 1.0)
                                clppoly3:
    acc  02 2e e 0 0 d914 0028  	movw,s 0,r[20];	40->fpdp;;		;			  | r[20] <- FALSE; cc == zer (tested
                                											  | below at nxtpt3)
    acd  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 40.firstvtx <- TRUE
    ace  0a 2e e 0 0 dd15 0037  	incw 0,r[21];	55->fpdp;;		;			  | r[21] <- TRUE
    acf  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 55.firstvtx <- TRUE
    ad0  0a 2e e 0 0 7140 0046  	;			70->fpdp;;		;
    ad1  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 70.firstvtx <- TRUE
    ad2  0a 2e e 0 0 7140 0055  	;			85->fpdp;;		;
    ad3  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 85.firstvtx <- TRUE
    ad4  0a 2e e 0 0 7140 0064  	;			100->fpdp;;		;
    ad5  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 100.firstvtx <- TRUE
    ad6  0a 2e e 0 0 7140 0073  	;			115->fpdp;;		;
    ad7  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 115.firstvtx <- TRUE
    ad8  1a 08 a 8 0 d852 0000  nxtpt3: movw r[18],y;	am->brreg;	crtn,~zer;	;			  | when reach here, cc reflects state of
                                											  | r[20]; return when out of pts; else
                                											  | call routine to get next point with
    ad9  1a 27 1 7 0 d8c7 0082  	movw d,r[7];	130->am;	cjs,go;		;			  | r[7]==130; returns
    ada  02 00 3 1 0 d84c 0aff  	movw,s r[12],y;	;		cjp,neg closepoly3;;			  | with cc neg when out of points
    adb  0a 00 3 0 0 dd16 0afc  	incw 0,r[22];		;		cjp,zer putpts3;;			  | r[22]<-1; if clip disabled, goto putpts3
                                											  | else r[7] points to new pt; r[22]==1
    adc  0a 27 e 0 0 d8c6 00b4  nxtpt3a: movw d,r[6];	180->am;	;		;			  | r[6]<-180
    add  02 27 e 0 0 ebec 0028  clpleft3: btstw,s 5,r[12]; 40->am;;		;			  | if left clipping enabled, call clppln3
    ade  0a 00 3 0 0 d8c4 0ae2  	movw d,r[4];		;		cjp,zer clptop3;;			  | with r[4]==40
    adf  0a 28 e 0 0 7140 0b32  	;			=wec_left3->brreg;;		;			  | and brreg==wec_left3
    ae0  0a 00 1 7 0 d917 0b04  	movw 0,r[23];		;		cjs,go clppln3;	;
    ae1  08 00 1 7 6 d977 0b01  	movw r[23],r[22];		;		cjs,go switchbuf3;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    ae2  02 27 e 0 0 e5ec 0037  clptop3: btstw,s 2,r[12];	55->am;;		;			  | if top clipping enabled, call clppln3
    ae3  0a 00 3 0 0 d8c4 0ae7  	movw d,r[4];		;		cjp,zer clphither3;;			  | with r[4]==55
    ae4  0a 28 e 0 0 7140 0b37  	;			=wec_top3->brreg;;		;			  | and brreg==wec_top3
    ae5  0a 00 1 7 0 d917 0b04  	movw 0,r[23];		;		cjs,go clppln3;	;
    ae6  08 00 1 7 6 d977 0b01  	movw r[23],r[22];		;		cjs,go switchbuf3;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    ae7  02 27 e 0 0 e3ec 0046  clphither3: btstw,s 1,r[12]; 70->am;;		;			  | if hither clipping enabled, call clppln3
    ae8  0a 00 3 0 0 d8c4 0aec  	movw d,r[4];		;		cjp,zer clpright3;;			  | with r[4]==70
    ae9  0a 28 e 0 0 7140 0b42  	;			=wec_hither3->brreg;;		;			  | and brreg==wec_hither3
    aea  0a 00 1 7 0 d917 0b04  	movw 0,r[23];		;		cjs,go clppln3;	;
    aeb  08 00 1 7 6 d977 0b01  	movw r[23],r[22];		;		cjs,go switchbuf3;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    aec  02 27 e 0 0 e9ec 0055  clpright3: btstw,s 4,r[12]; 85->am;;		;			  | if right clipping enabled, call clppln3
    aed  0a 00 3 0 0 d8c4 0af1  	movw d,r[4];		;		cjp,zer clpbottom3;;			  | with r[4]==85
    aee  0a 28 e 0 0 7140 0b38  	;			=wec_right3->brreg;;		;			  | and brreg==wec_right3
    aef  0a 00 1 7 0 d917 0b04  	movw 0,r[23];		;		cjs,go clppln3;	;
    af0  08 00 1 7 6 d977 0b01  	movw r[23],r[22];		;		cjs,go switchbuf3;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    af1  02 27 e 0 0 e7ec 0064  clpbottom3: btstw,s 3,r[12]; 100->am;;		;			  | if bottom clipping enabled, call clppln3
    af2  0a 00 3 0 0 d8c4 0af6  	movw d,r[4];		;		cjp,zer clpyon3;;			  | with r[4]==100
    af3  0a 28 e 0 0 7140 0b31  	;			=wec_bottom3->brreg;;		;			  | and brreg==wec_bottom3
    af4  0a 00 1 7 0 d917 0b04  	movw 0,r[23];		;		cjs,go clppln3;	;
    af5  08 00 1 7 6 d977 0b01  	movw r[23],r[22];		;		cjs,go switchbuf3;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    af6  02 27 e 0 0 e1ec 0073  clpyon3: btstw,s 0,r[12]; 115->am;;		;			  | if yon clipping enabled, call clppln3
    af7  0a 00 3 0 0 d8c4 0afc  	movw d,r[4];		;		cjp,zer putpts3;;			  | with r[4]==115
    af8  0a 28 e 0 0 7140 0b36  	;			=wec_yon3->brreg;;		;			  | and brreg==wec_yon3
    af9  0a 00 1 7 0 d917 0b04  	movw 0,r[23];		;		cjs,go clppln3;	;
    afa  08 00 e 0 6 d977 0000  	movw r[23],r[22];		;		;		;			  | # of output pts is # of pts which are
    afb  08 00 e 0 7 d966 0000  	movw r[6],r[7];;		;		;			  | passed to the pt consuming routine
    afc  0a 08 e 0 0 d853 0000  putpts3: movw r[19],y;	am->brreg;	;		;			  | r[7] points to the pts
    afd  18 00 1 7 f d967 0000  	movw r[7],r[15];	;		cjs,go;		;			  | call the consuming routine
    afe  02 00 3 7 0 d854 0ad8  	movw,s r[20],y;	;		cjp,go nxtpt3;	;			  | get next input pt; cc reflects state of
                                											  | variable r[20]
    aff  0a 00 c 0 0 dd14 0afc  closepoly3: incw 0,r[20];	;		ldct putpts3;	;			  | r[20] <- TRUE; r[22] <- 0
    b00  0a 00 7 8 0 d916 0adc  	movw 0,r[22];		;		jrp,~zer nxtpt3a;;			  | if clipping is disabled, goto putpts3;
                                											  | else do one more pass
                                											  | through clipping loop to flush out
                                											  | possible intersection points by passing
                                											  | each plane's saved 1st vertex to it as
                                											  | its last vertex
    b01  08 00 e 0 0 d966 0000  switchbuf3: movw r[6],r[0];	;		;		;			  | switch buffer ptrs
    b02  08 00 e 0 6 d967 0000  	movw r[7],r[6];;		;		;
    b03  18 00 a 7 7 d960 0000  	movw r[0],r[7];	;		crtn,go;	;
    b04  08 00 e 0 f d967 0000  clppln3: movw r[7],r[15];	;		;		;			  | use local copy of r[7]
    b05  08 00 e 0 e d966 0000  	movw r[6],r[14];	;		;		;			  | use local copy of r[6]
    b06  02 00 e 0 0 d856 0000  cpln3loop: movw,s r[22],y;	;		;		;			  | if r[22] == 0, goto chklastpt3
    b07  02 00 3 0 0 c1f6 0b14  	sub2nw,s 0,r[22];	;		cjp,zer chklastpt3;;			  | if ((r[22] -= 1) < 0), return
    b08  1a 0c a 1 0 d844 0000  	movw r[4],y;		am->fpap;	crtn,neg;	;			  | fpap <- r[4]
    b09  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;			  | if r[4]->firstvtxflg == FALSE, goto
    b0a  0a 0c 3 0 0 d84f 0b18  	movw r[15],y;		am->fpap;	cjp,zer subseqvtx3;;			  | subseqvtx3; fpap <- r[15]
    b0b  0a 0e e 0 0 d844 0000  firstvtx3: movw r[4],y;	am->fpdp;	;		;			  | fpdp <- r[4]
    b0c  0a 0b 4 7 6 f900 0004  	movw 0,y;		am->fpregh;	push,go 4;	;		dp+	  | r[4]->firstvtxflg <- FALSE
    b0d  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | r[4]->firstvtx <- input pt
    b0e  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    b0f  0a 0c 4 7 0 d84f 0004  	movw r[15],y;		am->fpap;	push,go 4;	;			  | fpap <- r[15]
    b10  0a 3b e 0 0 f8e1 0000  	movw 5,acc;		fpregh->fpregh;	;		;			  | r[4]->savdvtx <- input pt
    b11  1b 3b 8 0 8 0005 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | acc <- 5
    b12  1a 0c 1 7 0 d84f 0000  	movw r[15],y;		am->fpap;	cjs,go;		;			  | call routine to compute window edge
                                											  | coordinate for this plane and this pt
                                											  | fpap <- r[15]
                                											  | (brreg has address of routine)
                                											  | wec is stored in r[4]->savdwec
    b13  0a 00 3 7 0 988f 0b26  	addw r[15],acc,r[15];	;		cjp,go cpln3vischk;;			  | r[15] += 5;go check visibility using wec
    b14  02 00 e 0 0 d854 0000  chklastpt3: movw,s r[20],y;	;		;		;			  | if there are more pts, return; else
    b15  1a 0c a 0 0 d844 0000  	movw r[4],y;		am->fpap;	crtn,zer;	;			  | if r[4]->firstvtxflg == TRUE, return
    b16  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;
    b17  18 0c a 8 f dd64 0000  	incw r[4],r[15];	am->fpap;	crtn,~zer;	;			  | else fpap <- r[15] <- &r[4]->firstvtx
                                											  | and fall through to subseqvtx3
    b18  18 2e 1 7 0 c7c4 0008  subseqvtx3: add2nw 3,r[4],r[0];8->fpdp;	cjs,go;		;			  | fpreg[8] <-  wec for this plane and pt
    b19  0a 2c e 0 0 c3c0 0008  	add2nw 1,r[0],r[0];	8->fpap;	;		;			  | fpap <- address of input wec
    b1a  0a 37 e 0 0 f8c1 0000  	movw d,acc;		fpregh->am;	;		;			  | acc <- high word of input wec
    b1b  0a 0c e 0 0 dc40 0000  	incw r[0],y;		am->fpap;	;		;			  | fpap <- address of saved wec
    b1c  02 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregh->am;	;		;			  | test sign of (input wec) ^ (saved wec)
    b1d  0a 00 1 1 0 7140 0b45  	;			;		cjs,neg plnintsct3;;			  | if signs differ a polygon edge crosses
                                											  | this plane; call plnintsct3 to compute
                                											  | the intersection and add it to the
                                											  | output buffer
    b1e  0a 0c e 0 0 d84f 0000  	movw r[15],y;		am->fpap;	;		;			  | fpap <- address of input pt
    b1f  0a 27 e 0 0 8684 0006  	addw d,r[4],acc;	6->am;		;		;			  | acc <- &r[4]->savdvtx
    b20  0a 0e 4 7 0 f880 0004  	movw acc,y;		am->fpdp;	push,go 4;	;			  | fpdp <- &r[4]->savdvtx
    b21  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | r[4]->savdvtx <- input pt
    b22  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    b23  0a 2c e 0 0 7140 0008  	;			8->fpap;	;		;			  | fpap <- address of input wec
    b24  0a 3b e 0 0 9c8f 0000  	addw r[15],5,r[15];	fpregh->fpregh;	;		;			  | r[4]->savdwec <- input wec
    b25  0b 3b e 0 0 0005 0000  	;			fpregl->fpregl;	;		;			  | r[15] += 5
    b26  0a 00 e 0 0 9484 0000  cpln3vischk: addw r[4],11,y;	;		;		;
    b27  0a 0c e 0 0 000b 0000  	;			am->fpap;	;		;			  | fpap <- &r[4]->savdwec
    b28  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;
    b29  02 00 3 1 0 d856 0b06  	movw,s r[22],y;		;		cjp,neg cpln3loop;;			  | wec < 0 => pt not visible
    b2a  0a 0e 3 1 0 d84e 0b06  	movw r[14],y;		am->fpdp;	cjp,neg cpln3loop;;			  | (r[22] >= 0) => add pt to output
                                											  | (r[20] == TRUE) && (r[22] < 0) =>
                                											  | this last pt is the same as the first pt
                                											  | so ignore it (only reach here with
                                											  | r[22] < 0 when r[20] == TRUE)
                                cpln3vis:										  | fpdp <- r[14] (above)
    b2b  0a 27 e 0 0 9484 0005  	addw r[4],6,y;	5->am;		;		;			  | d <- 5
    b2c  0a 0c e 0 0 0006 0000  	;			am->fpap;	;		;			  | fpap <- &r[4]->savdvtx
    b2d  0a 3b 4 7 0 dd77 0003  	incw r[23],r[23];		fpregh->fpregh;	push,go 3;	;			  | r[23] += 1
    b2e  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+	  | output buffer <- current point
    b2f  1a 3b 8 0 0 7140 0000  	;			fpregh->fpregh;	rfct;		;
    b30  0b 3b 3 7 0 9e8e 0b06  	addw d,r[14],r[14];	fpregl->fpregl;	cjp,go cpln3loop;;			  | r[14] += 5; goto cpln3loop
    b31  0a 00 e 0 4 7140 0000  wec_bottom3: ;			;		;		;		ap+	  | fpap pts to pt.y for wec_bottom3 OR
    b32  2a 00 e 0 0 948f 0230  wec_left3: addw r[15],3,y;	;		;		lmode rn,ai,flow,fast;	  | to pt.x for wec_left3
    b33  0a 0d c 0 0 0003 0b3c  	;			am->fpbp;	ldct wec_wait3;	;			  | fpbp <- &pt.r[20]
    b34  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | pt.r[20] + pt.x (left plane wec) OR
    b35  3b 00 7 f 0 7140 0110  	;			;		jrp,~go;	;			  | pt.r[20] + pt.y (bottom plane wec)
                                											  | jump to wec_wait3
    b36  0a 00 e 0 4 7140 0000  wec_yon3: ;			;		;		;		ap+	  | fpap pts to pt.z for wec_yon3 OR
    b37  0a 00 e 0 4 7140 0000  wec_top3: ;			;		;		;		ap+	  | to pt.y for wec_top3 OR
    b38  2a 00 e 0 0 948f 0230  wec_right3: addw r[15],3,y;	;		;		lmode rn,ai,flow,fast;	  | to pt.x for wec_right3
    b39  0a 0d e 0 0 0003 0000  	;			am->fpbp;	;		;			  | fpbp <- &pt.r[20]
    b3a  2a 00 e 0 0 7140 0190  	;			;		;		rsuba,lab,hi;		  | pt.r[20] - pt.x (right plane wec) OR
    b3b  2b 00 e 0 0 7140 0190  	;			;		;		;			  | pt.r[20] - pt.y (top plane wec) OR
                                											  | pt.r[20] - pt.z (yon plane wec)
    b3c  0a 00 4 7 0 7140 0002  wec_wait3: ;			;		push,go 2;	;
    b3d  1a 00 8 0 0 7140 0000  	;			;		rfct;		;
    b3e  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    b3f  2b 00 e 0 0 7140 0102  	;			;		;		;
    b40  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store result and return; result < 0 =>
    b41  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | pt is on invisible side of pln
    b42  08 0c e 0 1 c3cf 0000  wec_hither3: add2nw 1,r[15],r[1]; am->fpap;	;		;			  | fpap <- &pt.z
    b43  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | store pt.z (hither plane wec); z < 0 =>
    b44  1b 3b a 7 0 7140 0000  	;			fpregl->fpregl;	crtn,go;	;			  | pt is on invisible side of pln; return
    b45  0a 2d e 0 0 9484 0008  plnintsct3: addw r[4],11,y;	8->fpbp;	;		;			  | fpbp pts to wec of new input pt
    b46  2a 0c e 0 0 000b 0230  	;			am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap pts to wec of saved pt
    b47  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | saved wec - input wec
    b48  2b 00 e 0 0 7140 0150  	;			;		;		;
    b49  0a 00 4 7 0 7140 0002  	;			;		push,go 2;	;			  | delay for flowthrough mode
    b4a  1a 2e 8 0 0 7140 0009  	;			9->fpdp;	rfct;		;			  | fpdp <- 9
    b4b  2a 00 e 0 0 f8e0 0102  	movw 9,y;		;		;		adda,a,hi;
    b4c  2b 0c e 0 0 0009 0102  	;			am->fpap;	;		;			  | fpap <- 9
    b4d  2a 00 e 0 0 d8e2 0101  	movw 10,r[2];	;		;		adda,st,hi;		  | store wec_diff in fpreg[9]
    b4e  2b 00 e 0 0 000a 0101  	;			;		;		;			  | r[2] <- 10
    b4f  0a 00 1 7 0 7140 034c  	;			;		cjs,go recip;	;			  | fpreg[10] <- reciprocal of difference
    b50  2b 0d e 0 0 d842 0230  	movw r[2],y;		am->fpbp;	;		lmode rn,ai,pipe,fast;	  | fpbp <- 10; set pipeline mode
    b51  0a 00 c 0 0 9484 0001  	addw r[4],11,y;	;		ldct 1;		;			  | 2910 R reg <- 1
    b52  0a 0c e 0 0 000b 0000  	;			am->fpap;	;		;			  | fpap pts to wec of saved pt
    b53  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | compute t = (wec of saved pt)/wec_diff
    b54  2b 0c e 0 0 d84f 0010  	movw r[15],y;		am->fpap;	;		;			  | fpap <- address of input pt
    b55  2a 00 e 0 0 9484 0120  	addw r[4],6,y;	;		;		adda,la,hi;
    b56  3b 0d 4 f 0 0006 0120  	;			am->fpbp;	push,~go;	;			  | fpbp <- address of saved pt
    b57  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dx (input x - saved x) and
    b58  3b 00 8 0 7 7140 0150  	;			;		rfct;		;		abp+	  | dy (input y - saved y)
    b59  2a 00 e 0 0 f8e1 0154  	movw 9,acc;		;		;		suba,lab,m,hi;		  | dz (input z - saved z)
    b5a  2b 0e e 0 7 0009 0154  	;			am->fpdp;	;		;		abp+	  | fpdp <- 9
    b5b  2a 00 e 0 0 f8e0 0151  	movw 6,y;		;		;		suba,lab,st,hi;		  | fpreg[9] <- t; dw (input r[20] - saved r[20])
    b5c  2b 07 e 0 7 0006 0151  	;			am->am;		;		;		abp+	  | d <- 6
    b5d  2a 00 e 0 0 c580 0152  	mov2nw 2,r[0];		;		;		suba,lab,a,hi;		  | di (input i - saved i)
    b5e  3b 0d 4 f 0 f880 0152  	movw acc,y;		am->fpbp;	push,~go;	;			  | fpbp <- 9
    b5f  22 00 e 0 0 c1e0 001a  	sub2nw,s 0,r[0],r[0];	;		;		mabr,lab,a,hi;		  | dx * t; dy * t; dz * t; dw * t
    b60  3b 00 d 0 0 7140 001a  	;			;		loop,zer;	;
    b61  2a 00 e 0 0 c580 001c  	mov2nw 2,r[0];		;		;		mabr,lab,m,hi;		  | di * t
    b62  3b 0d 4 f 0 9684 001c  	addw d,r[4],y;	am->fpbp;	push,~go;	;			  | fpbp <- address of saved pt
    b63  22 00 e 0 0 c1e0 011c  	sub2nw,s 0,r[0],r[0];	;		;		addr,lab,m,hi;		  | saved x + dx*t; saved y + dy*t
    b64  3b 00 d 0 5 7140 011c  	;			;		loop,zer;	;		bp+	  | saved z + dz*t; saved r[20] + dw*t
    b65  2a 00 e 0 0 c580 011a  	mov2nw 2,r[0];		;		;		addr,lab,a,hi;		  | saved i + di*t
    b66  3b 0e 4 f 0 d84e 011a  	movw r[14],y;		am->fpdp;	push,~go;	;			  | fpdp <- r[14]
    b67  22 00 e 0 0 c1e0 0123  	sub2nw,s 0,r[0],r[0];	;		;		adda,la,a,st,hi;		  | store intersection x,y,z,r[20] at *r[14]
    b68  3b 00 d 0 6 dd6e 0123  	incw r[14],r[14];	;		loop,zer;	;		dp+	  | r[14] += 4
    b69  2a 00 e 0 0 dd6e 0101  	incw r[14],r[14];	;		;		adda,st,hi;		  | store intersection i at *(r[14]+4)
    b6a  3b 00 a 7 0 dd77 0101  	incw r[23],r[23];		;		crtn,go;	;			  | r[14] += 1; r[23] += 1; return
                                vwpsclpts3:										  | in-place 3-D viewport scale
                                											  | assumes vwp params are at fpr[32],
                                											  | r[4] points to pts to be scaled,
                                											  | and brreg contains npts-1
                                											  | call with max of 1915-1890 (25) pts if
                                											  | there are pts in 1915, else max of
                                											  | 2048-1890 (158) pts, so 1890 doesn't
                                											  | overflow fpreg's
    b6b  0a 27 e 0 0 d8c2 0762  	movw d,r[2];		1890->am;	;		;			  | r[2]<-1890, addr for r[20] reciprocals
    b6c  0a 00 e 0 0 d804 0000  	movw r[4],acc;	;		;		;			  | r[16] <- r[4]
    b6d  1a 27 4 7 0 d890 0003  	movw acc,r[16];		3->am;		push,go;	;			  | d <- 3; loop through npts
    b6e  0a 0c 1 7 0 9e90 034c  	addw d,r[16],r[16];	am->fpap;	cjs,go recip;	;			  | fpap <- &r[20][i];compute reciprocal of r[20][i]
    b6f  1a 27 8 0 0 dd62 0005  	incw r[2],r[2];	5->am;		rfct;		;			  | r[2] <- &1890[i+1] and loop back
    b70  29 0c e 0 0 d964 0230  	movw r[4],r[0];	am->fpap;	;		lmode rn,ai,pipe,fast;	  | fpap <- r[0] <- &x[0]; pipeline mode
    b71  0a 2d e 0 0 7140 0762  	;			1890->fpbp;	;		;			  | fpbp <- &wrecip[0]
    b72  2a 00 e 0 0 f8e1 0010  	movw 5,acc;		;		;		maba,lab,hi;		  | x0 * 1/w0
    b73  2b 00 e 0 4 0005 0010  	;			;		;		;		ap+	  | acc <- 5
    b74  2a 07 e 0 0 d840 0020  	movw r[0],y;		am->am;		;		maba,la,hi;		  | y0 * 1/w0
    b75  2b 0e e 0 4 d8d0 0020  	movw d,r[16];		am->fpdp;	;		;		ap+	  | fpdp <- r[16] <- &x[0]
    b76  2a 00 e 0 0 7140 0020  	;			;		;		maba,la,hi;		  | z0 * 1/w0
    b77  2b 0c e 0 5 9880 0020  	addw r[0],acc,r[0];	am->fpap;	;		;		bp+	  | fpap<-&x[1]; fpbp<-&wrecip[1]
    b78  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x1 * 1/w1
    b79  2b 00 e 0 4 7140 0010  	;			;		;		;		ap+
    b7a  2a 00 e 0 0 7140 0024  	;			;		;		maba,la,m,hi;		  | y1 * 1/w1
    b7b  3b 00 4 7 4 7140 0024  	;			;		push,go;	;		ap+	  | loop through all pts (brreg == npts-1)
    b7c  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | z[i] * 1/r[20][i]; store x[i-1]*1/r[20][i-1]
    b7d  2b 0c e 0 9 9880 0025  	addw r[0],acc,r[0];	am->fpap;	;		;		bdp+	  | fpap<-&x[i+1]; fpbp<-&wrecip[i+1]
    b7e  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | x[i+1] * 1/r[20][i+1]; store y[i-1]*1/r[20][i-1]
    b7f  2b 00 e 0 8 7140 0015  	;			;		;		;		adp+
    b80  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | y[i+1] * 1/r[20][i+1]; store z[i-1]*1/r[20][i-1]
    b81  3b 0e 8 0 4 9890 0015  	addw r[16],acc,r[16];	am->fpdp;	rfct;		;		ap+
    b82  0a 0d e 0 0 cb90 0000  	mov2nw 5,r[16];		am->fpbp;	;		;			  | fpbp <- r[16] <- &VWPXSCL
    b83  08 0c e 0 0 d964 0000  	movw r[4],r[0];	am->fpap;	;		;			  | fpap <- r[0] <- &x[0]
    b84  2a 0e e 0 0 d840 0010  	movw r[0],y;		am->fpdp;	;		maba,lab,hi;		  | x[0] * VWPXSCL; fpdp points to input pts
    b85  2b 0d e 0 4 c3d0 0010  	add2nw 1,r[16];		am->fpbp;	;		;		ap+
    b86  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y[0] * VWPYSCL
    b87  2b 0d e 0 4 c3d0 0010  	add2nw 1,r[16];		am->fpbp;	;		;		ap+
    b88  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | z[0] * VWPZSCL
    b89  2b 0d e 0 0 c5f0 0010  	sub2nw 2,r[16];		am->fpbp;	;		;
    b8a  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;			  | pipeline advance since can't change
    b8b  2b 0c e 0 0 9880 0120  	addw r[0],acc,r[0];	am->fpap;	;		;			  | both fpap and fpbp fast enough
    b8c  2a 00 e 0 0 7140 0014  	;			;		;		maba,lab,m,hi;		  | x[1] * VWPXSCL
    b8d  3b 0d 4 7 4 c3d0 0014  	add2nw 1,r[16];		am->fpbp;	push,go;	;		ap+	  | loop through all pts
    b8e  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | y[i] * VWPYSCL; store x[i-1]*VWPXSCL
    b8f  2b 0d e 0 8 c3d0 0015  	add2nw 1,r[16];		am->fpbp;	;		;		adp+
    b90  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | z[i] * VWPZSCL; store y[i-1]*VWPYSCL
    b91  2b 0d e 0 6 c5f0 0015  	sub2nw 2,r[16];		am->fpbp;	;		;		dp+
    b92  2a 00 e 0 0 7140 0121  	;			;		;		adda,la,st,hi;		  | pipeline advance; store z[i-1]*VWPZSCL
    b93  2b 0c e 0 6 9880 0121  	addw r[0],acc,r[0];	am->fpap;	;		;		dp+
    b94  2a 00 e 0 6 7140 0014  	;			;		;		maba,lab,m,hi;	dp+	  | x[i+1] * VWPXSCL
    b95  3b 0d 8 0 8 c3d0 0014  	add2nw 1,r[16];		am->fpbp;	rfct;		;		adp+	  | fpdp <- &x[i]; loop back
    b96  0a 0d e 0 0 c1f0 0000  	sub2nw 0,r[16];		am->fpbp;	;		;			  | fpbp <- r[16] <- &VWPXOFF
    b97  08 0c e 0 0 d964 0000  	movw r[4],r[0];	am->fpap;	;		;			  | fpap <- r[0] <- &x[0]
    b98  2a 0e e 0 0 d840 0110  	movw r[0],y;		am->fpdp;	;		adda,lab,hi;		  | x[0] + VWPXOFF; fpdp points to input pts
    b99  2b 0d e 0 4 c3d0 0110  	add2nw 1,r[16];		am->fpbp;	;		;		ap+
    b9a  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | y[0] + VWPYOFF
    b9b  2b 0d e 0 4 c3d0 0110  	add2nw 1,r[16];		am->fpbp;	;		;		ap+
    b9c  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | z[0] + VWPZOFF
    b9d  2b 0d e 0 0 c5f0 0110  	sub2nw 2,r[16];		am->fpbp;	;		;
    b9e  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;			  | pipeline advance since can't change
    b9f  2b 0c e 0 0 9880 0120  	addw r[0],acc,r[0];	am->fpap;	;		;			  | both fpap and fpbp fast enough
    ba0  2a 00 e 0 0 7140 0112  	;			;		;		adda,lab,a,hi;		  | x[1] + VWPXOFF
    ba1  3b 0d 4 7 4 c3d0 0112  	add2nw 1,r[16];		am->fpbp;	push,go;	;		ap+	  | loop through all pts
    ba2  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | y[i] + VWPYOFF; store x[i-1]+VWPXOFF
    ba3  2b 0d e 0 8 c3d0 0113  	add2nw 1,r[16];		am->fpbp;	;		;		adp+
    ba4  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | z[i] + VWPZOFF; store y[i-1]+VWPYOFF
    ba5  2b 0d e 0 6 c5f0 0113  	sub2nw 2,r[16];		am->fpbp;	;		;		dp+
    ba6  2a 00 e 0 0 7140 0121  	;			;		;		adda,la,st,hi;		  | pipeline advance; store z[i-1]+VWPZOFF
    ba7  2b 0c e 0 6 9880 0121  	addw r[0],acc,r[0];	am->fpap;	;		;		dp+
    ba8  2a 00 e 0 6 7140 0112  	;			;		;		adda,lab,a,hi;	dp+	  | x[i+1] + VWPXOFF
    ba9  3b 0d 8 0 8 c3d0 0112  	add2nw 1,r[16];		am->fpbp;	rfct;		;		adp+	  | fpdp <- &x[i]; loop back
    baa  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | return
                                											  | completion jump vector when r[19]
                                											  | points to mkedges3; after putting all
                                											  | pts through xform-clip-scale-mkedg,
                                											  | jump here to complete processing
    bab  0a 0e 3 7 0 c1e8 0a41  	sub2nw 0,r[8],r[8];	am->fpdp;	cjp,go xf3doscan;;			  | fpdp <- &edg.nxt for last edge and
                                											  | goto xf3doscan
    bac  02 00 e 0 0 d856 0000  mkedges3: movw,s r[22],y;	;		;		;
    bad  02 00 3 8 0 d854 0bb0  	movw,s r[20],y;	;		cjp,~zer edgpts3;;			  | if (r[22] > 0) goto edgpts3
    bae  0a 00 3 8 0 7140 0be6  	;			;		cjp,~zer lastedg3;;			  | else if no more pts in this boundary
    baf  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | goto lastedg3; else return
    bb0  08 08 e 0 0 c1f6 0000  edgpts3: sub2nw 0,r[22],r[16];	am->brreg;	;		;			  | brreg <- r[22]-1
    bb1  08 00 1 7 4 d96f 0b6b  	movw r[15],r[4];	;		cjs,go vwpsclpts3;;			  | r[4] points to input pts
                                											  | vwpsclpts3 assumes vwp params at fpr[32]
                                											  | vwpsclpts3 scales pts in place
    bb2  02 00 e 0 0 d855 0000  	movw,s r[21],y;	;		;		;
    bb3  0a 00 3 0 0 d915 0bc9  	movw 0,r[21];	;		cjp,zer mkedg3;	;			  | if not 1st pt of boundary, goto mkedg3
                                											  | r[21] <- FALSE
    bb4  2a 0c e 0 0 d84f 0230  firstpt3: movw r[15],y;		am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap points to 1st pt y; flow mode
    bb5  0a 0e e 0 0 f900 0000  	movw 0,y;		am->fpdp;	;		;			  | fpdp <- 0
    bb6  0a 3b e 0 0 c1f6 0000  	sub2nw 0,r[22],r[22];	fpregh->fpregh;	;		;			  | fpreg[0] <- 1st pt x; r[22] -= 1
    bb7  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    bb8  2a 00 e 0 0 9c8f 00e0  	addw r[15],5,r[15];	;		;		fixa,la,hi;		  | convert y to int
    bb9  2b 00 e 0 4 0005 00e0  	;			;		;		;		ap+	  | r[15] += 5
    bba  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | fpreg[1] <- 1st pt z
    bbb  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    bbc  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    bbd  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | fpreg[2] <- 1st pt i
    bbe  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    bbf  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    bc0  2b 00 e 0 0 7140 0102  	;			;		;		;
    bc1  2a 00 e 0 0 f8e0 0101  	movw 3,y;		;		;		adda,st,hi;		  | fpreg[3] <- fixed 1st pt y
    bc2  2b 0c e 0 0 0003 0101  	;			am->fpap;	;		;			  | fpap <- 3
    bc3  0b 37 e 0 0 f8c1 0000  	movw d,acc;		fpregl->am;	;		;			  | acc <- low 16 bits of int y
    bc4  0a 0b e 0 6 f880 0000  	movw acc,y;		am->fpregh;	;		;		dp+	  | low 16 bits to high word of fpreg[3]
    bc5  0a 0c 4 7 0 f900 0002  	movw 0,y;		am->fpap;	push,go 2;	;			  | fpap <- 0 (addr of 1st pt storage)
    bc6  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | prev pt <- 1st pt x,z,i
    bc7  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    bc8  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | fpreg[7,high] <- int y (prev pt storage)
    bc9  22 00 e 0 0 c1f6 0230  mkedg3:	sub2nw,s 0,r[22],r[22];	;		;		lmode rn,ai,flow,fast;	  | select flow mode; if((r[22]-=1)<0),
    bca  0a 0c 3 1 0 dc4f 0be5  	incw r[15],y;		am->fpap;	cjp,neg chklastedg3;;			  | goto chklastedg3; fpap <- &y[i]
    bcb  28 0e e 0 0 c3c8 00e0  	add2nw 1,r[8],r[0];	am->fpdp;	;		fixa,la,hi;		  | fix y[i]; fpdp <- &edg.xmax
    bcc  2b 0c e 0 0 d84f 00e0  	movw r[15],y;		am->fpap;	;		;			  | fpap <- &x[i]
    bcd  08 3b e 0 0 d968 0000  	movw r[8],r[0];	fpregh->fpregh;	;		;			  | edg.xmax <- x[i]; r[0] <- r[8]
    bce  0b 3b 4 7 8 7140 0001  	;			fpregl->fpregl;	push,go 1;	;		adp+
    bcf  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    bd0  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.zmax <- z[i]; edg.imax <- i[i]
    bd1  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    bd2  0a 0c 4 7 0 e596 0002  	mov2nw 2,y;		am->fpap;	push,go 2;	;			  | fpap <- &x[i-1] (prev pt)
    bd3  0a 3b e 0 0 f8e1 0000  	movw 9,acc;		fpregh->fpregh;	;		;			  | edg.xmin <- x[i-1]; edg.zmin <- z[i-1]
    bd4  1b 3b 8 0 8 0009 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | edg.imin <- i[i-1]; acc <- 9
    bd5  0b 0b e 0 0 9888 0000  	addw r[8],acc,r[8];	am->fpregl;	;		;			  | edg.nxt <- r[8] <- addr of next edge
    bd6  0a 0e e 0 0 d840 0000  	movw r[0],y;		am->fpdp;	;		;			  | fpdp <- addr of this edge
    bd7  2a 3b e 0 6 9c8f 0102  	addw r[15],5,r[15];	fpregh->fpregh;	;		adda,a,hi;	dp+	  | edg.ymin <- y[i-1] (prev y,16-bit int)
    bd8  2b 00 e 0 0 0005 0102  	;			;		;		;			  | r[15] <- &x[i+1]
    bd9  2a 37 e 0 0 f8c1 0101  	movw d,acc;		fpregh->am;	;		adda,st,hi;		  | edg.ymax<-y[i](32-bit int);acc<-prev y
    bda  2b 0c e 0 0 dc40 0101  	incw r[0],y;		am->fpap;	;		;			  | fpap <- &edg.ymax
    bdb  03 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregl->am;	;		;			  | check for horizontal edges
    bdc  0b 37 3 0 4 f8c1 0be0  	movw d,acc;		fpregl->am;	cjp,zer horizedg3;;		ap+	  | acc <- low order 16 bits of int y[i]
    bdd  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | if (r[9] -= 1) >= 0, goto savpt3
    bde  0a 0b 3 9 0 f880 0be1  	movw acc,y;		am->fpregh;	cjp,~neg savpt3;;			  | move low 16 bits to high word where
                                											  | scan conversion code expects to see it
    bdf  0a 00 e 0 0 db09 0000  edgovflw3: compw 0,r[9];	;		;		;			  | on edge overflow, r[9] <- -1 and
                                											  | adjust r[8]
    be0  0a 27 e 0 0 9e08 0009  horizedg3: subw d,r[8],r[8]; 9->am;		;		;			  | ignore horizontal and overflow edges
    be1  0a 0e 4 7 0 e596 0002  savpt3:	mov2nw 2,y;		am->fpdp;	push,go 2;	;			  | fpdp <- addr of prev pt (fpreg[4-7])
    be2  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | prev pt <- current pt
    be3  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | 32-bit float x,z,i
    be4  0a 0b 3 7 0 f880 0bc9  	movw acc,y;		am->fpregh;	cjp,go mkedg3;	;			  | 16-bit int y in high word; loop back
    be5  02 00 e 0 0 d854 0000  chklastedg3: movw,s r[20],y;;		;		;
    be6  12 00 a 0 0 d855 0000  lastedg3: movw,s r[21],y;	;		crtn,zer;	;			  | return if may be more pts in boundary
    be7  1a 2c a 8 0 7140 0003  	;			3->fpap;	crtn,~zer;	;			  | fpap <- addr of 1st y; return if no pts
    be8  0a 37 e 0 0 d8c0 0000  	movw d,r[0];		fpregh->am;	;		;			  | r[0] <- 1st y (16-bit int)
    be9  0a 2c e 0 0 7140 0007  	;			7->fpap;	;		;			  | fpap <- addr of prev pt y
    bea  02 37 e 0 0 9700 0000  	xorw,s d,r[0],y;		fpregh->am;	;		;			  | check for horizontal last edge
    beb  1a 0e a 0 0 d848 0000  	movw r[8],y;		am->fpdp;	crtn,zer;	;			  | rtn if horiz; fpdp<-addr for last edge
    bec  0a 3b e 0 6 c7c8 0000  	add2nw 3,r[8],r[8];	fpregh->fpregh;	;		;		dp+	  | edg.ymin <- prev y; r[8] += 8
    bed  0a 0b e 0 6 d840 0000  	movw r[0],y;		am->fpregh;	;		;		dp+	  | edg.ymax <- 1st y
    bee  0a 0c 4 7 0 f900 0002  	movw 0,y;		am->fpap;	push,go 2;	;			  | fpap <- addr of 1st pt x
    bef  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- 1st x; edg.zmax <- 1st z
    bf0  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | edg.imax <- 1st i
    bf1  02 00 4 7 4 c1e9 0002  	sub2nw,s 0,r[9],r[9];;		push,go 2;	;		ap+	  | fpap <- addr of prev pt x; r[9] -= 1
    bf2  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmin <- prev x; edg.zmin <- prev z
    bf3  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | edg.imin <- prev i
    bf4  1b 0b a 9 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	crtn,~neg;	;			  | edg.nxt <- r[8] <- addr of next edge
                                											  | if r[9] >= 0, return
    bf5  0a 00 e 0 0 db09 0000  	compw 0,r[9];		;		;		;			  | else r[9] <- -1
    bf6  1a 27 a 7 0 9e08 0009  	subw d,r[8],r[8];	9->am;		crtn,go;	;			  | adjust r[8] and return
                                procfastbnd3:
    bf7  0a 00 e 0 0 d914 0000  	movw 0,r[20];	;		;		;			  | r[20] <- FALSE
    bf8  0a 00 e 0 0 dd15 0000  	incw 0,r[21];	;		;		;			  | r[21] <- TRUE
    bf9  0a 00 e 0 0 d80a 0000  	movw r[10],acc;		;		;		;
    bfa  0a 00 e 0 0 d896 0000  	movw acc,r[22];		;		;		;			  | r[22] <- r[10], # of pts
    bfb  0a 08 e 0 0 d853 0000  	movw r[19],y;	am->brreg;	;		;			  | brreg <- addr of pt-consuming routine
    bfc  1a 27 1 7 0 d8cf 077b  	movw d,r[15];		1915->am;	cjs,go;		;			  | r[15]<-1915,addr of xfrmd,clptested pts
                                											  | and call r[19]
    bfd  0a 00 e 0 0 dd14 0000  	incw 0,r[20];	;		;		;			  | r[20] <- TRUE
    bfe  0a 08 e 0 0 d853 0000  	movw r[19],y;	am->brreg;	;		;			  | brreg <- addr of pt-consuming routine
    bff  1a 00 1 7 0 d916 0000  	movw 0,r[22];		;		cjs,go;		;			  | r[22] <- 0, call pt-consuming routine
    c00  0a 00 3 7 0 7140 09a5  	;			;		cjp,go xf3nxtbnd;;			  | loop back to xf3nxtbnd
                                |	movw d,r[11];		shmem->am;	jmap PROC_PGON_INT_3D;;			  | # of separate boundaries
                                PROC_PGON_INT_3D:
    c01  0a 27 e 0 0 d8c5 0851  	movw d,r[5];		=xfint3->am;	;		;			  | set ptr to do fixtofloat and fall 
                                											  | through to use regular xf3 routine
    c02  0a 00 3 7 0 d898 0c05  	movw acc,r[24]; ;		cjp,go cwpoly3;	;			  | after set ptr, use float routine
                                |	movw d,r[11];		shmem->am;	jmap COREWLDPOLYNDC_3D;;		  | # of separate boundaries
                                COREWLDPOLYNDC_3D:
    c03  0a 27 e 0 0 d8c5 0862  	movw d,r[5];		=xf3->am;	;		;			  | use the regular xf3 routine
    c04  0a 00 e 0 0 d898 0000  	movw acc,r[24];;		;		;
    c05  0a 27 e 0 0 869d 0004  cwpoly3: addw d,r[29],acc;	 4->am; ;		;			  | 
    c06  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
    c07  0a 17 e 0 2 d8cc 0000  	movw d,r[12];	shmem->am;	;		;		shp+	  | save clipplanes
    c08  0a 1f c 0 0 ffd8 000f  	bclrw 15,r[24]; shmem->shmemp;	ldct 15;	;			  | shmemp <- r[9], clear 2D flag
    c09  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    c0a  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    c0b  0a 0f c 0 0 f880 0005  	movw acc,y;		am->shmemp;	ldct 5;		;			  |shmemp <- addr of vwp params
    c0c  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move viewport parameters to fpr[32]
                                	| Initialization for NDC output polygon variables when corendcproc3 is
                                	| the consuming routine for the points output by the polygon clipper
    c0d  0a 27 e 0 0 d8c8 00e6  cwp3:	movw d,r[8];		230->am;	;		;			  | address of beginning of output list
    c0e  0a 0e e 0 0 d848 0000  	movw r[8],y;		am->fpdp;	;		;			  | fpreg[230] is nbndsout
    c0f  0a 2b e 0 0 dd68 0000  	incw r[8],r[8];	0->fpregh;	;		;			  | nbndsout <- 0; r[8] keeps track of
                                											  | next available location in NDC list
    c10  0a 27 e 0 0 d8d3 0c13  	movw d,r[19];	=corendcproc3->am;;		;			  | r[19] <- corendcproc3, ptr to
                                											  | point-consuming routine
    c11  0a 00 3 7 0 7140 09a2  	;			;		cjp,go procpoly3;;			  | goto procpoly3 to put input polygon thru
                                											  | the xform-clip-consumepoint pipeline
                                											  | completion jump vector when r[19]
                                											  | points to corendcproc3; after putting
                                											  | all pts through xform-clip-ndcproc,
                                											  | jump here to complete processing
    c12  08 0f 3 7 1 d97e 0c3b  	movw r[30],r[17];	am->shmemp;	cjp,go corendcfinish3;;			  | shmemp <- &MAXLOCS
                                											  |
                                corendcproc3:
    c13  02 00 e 0 0 d856 0000  	movw,s r[22],y;		;		;		;
    c14  02 00 3 8 0 d854 0c17  	movw,s r[20],y;	;		cjp,~zer ndcpts3;;			  | if (r[22] > 0) goto ndcpts3
    c15  0a 00 3 8 0 7140 0c26  	;			;		cjp,~zer lastndc3;;			  | else if no more pts in this boundary
    c16  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | goto lastndc3; else return
                                ndcpts3:
    c17  02 00 e 0 0 d855 0000  	movw,s r[21],y;	;		;		;
    c18  0a 00 3 0 0 d915 0c1c  	movw 0,r[21];	;		cjp,zer ndcp3;	;			  | if not 1st pt of boundary, goto ndcp3
                                											  | r[21] <- FALSE
    c19  0a 00 e 0 0 d909 0000  firstndc3: movw 0,r[9];	;		;		;			  | r[9] <- 0
    c1a  08 00 e 0 c d968 0000  	movw r[8],r[12];	;		;		;			  | r[12] <- r[8]
    c1b  0a 00 e 0 0 dd68 0000  	incw r[8],r[8];	;		;		;			  | r[8] += 1
    c1c  08 08 e 0 0 c1f6 0000  ndcp3:	sub2nw 0,r[22],r[16];	am->brreg;	;		;			  | brreg <- r[22]-1
    c1d  0a 0e e 0 0 d848 0000  	movw r[8],y;		am->fpdp;	;		;			  | fpdp <- addr for next output pt
    c1e  1a 0c 4 7 0 d84f 0000  	movw r[15],y;		am->fpap;	push,go;	;			  | fpap <- addr of xfrm-clp input pts
                                											  | for each input point
    c1f  0a 27 e 0 0 fec1 0005  	negw d,acc;		5->am;		;		;
    c20  02 3b e 0 0 fc81 0000  	incw,s acc,acc;		fpregh->fpregh;	;		;			  | copy input to output
    c21  0b 3b 3 8 8 7140 0c20  	;			fpregl->fpregl;	cjp,~zer .-1;	;		adp+	  | x,y,z,r[20],i
    c22  02 27 e 0 0 9608 0758  	subw,s d,r[8],y;	1880->am;	;		;			  | if r[8] >= 1880, goto ndctoobig3
    c23  0a 00 b 9 0 dd69 0c39  	incw r[9],r[9];;		cjpp,~neg ndctoobig3;;			  | else r[9] += 1
    c24  12 27 8 0 0 9e88 0005  	addw,s d,r[8],r[8];	5->am;		rfct;		;			  | r[8] += 5, and loop back until done
    c25  02 00 e 0 0 d854 0000  	movw,s r[20],y;	;		;		;
    c26  12 2c a 0 0 d855 00e6  lastndc3: movw,s r[21],y;	230->fpap;	crtn,zer;	;			  | return if may be more pts in boundary
                                											  | fpap <- &nbndsout
    c27  12 37 a 8 0 f8c1 0000  	movw,s d,acc;		fpregh->am;	crtn,~zer;	;			  | return if r[21]
    c28  1a 2e a 1 0 7140 00e6  	;			230->fpdp;	crtn,neg;	;			  | return if nbndsout < 0 (overflow)
                                											  | fpdp <- &nbndsout
    c29  0a 0b e 0 0 fc81 0000  	incw acc,acc;		am->fpregh;	;		;			  | nbndsout += 1
    c2a  0a 0e e 0 0 d84c 0000  	movw r[12],y;	am->fpdp;	;		;			  | fpdp <- &boundary data for this boundary
    c2b  0a 0b e 0 0 d849 0000  	movw r[9],y;	am->fpregh;	;		;			  | store # of pts in this boundary
    c2c  08 08 e 0 0 c1e9 0000  	sub2nw 0,r[9],r[0]; am->brreg;	;		;			  | brreg <- r[9]-1
    c2d  08 00 1 7 4 dd6c 0b6b  	incw r[12],r[4];;		cjs,go vwpsclpts3;;			  | r[4] points to output pts
                                											  | vwpsclpts3 assumes vwp params at fpr[32]
                                											  | vwpsclpts3 scales pts in place
    c2e  0a 00 e 0 0 8589 0000  	rolw 2,r[9],acc;	;		;		;
    c2f  0a 00 e 0 0 8089 0000  	addw r[9],acc,acc;	;		;		;
    c30  2b 08 e 0 0 e185 0230  	sub2nw 0,acc;		am->brreg;	;		lmode rn,ai,pipe,fast;	  | brreg <- 5*r[9] - 1; pipeline mode
    c31  0a 0c 4 7 0 dc4c 0003  	incw r[12],y;	am->fpap;	push,go 3;	;			  | fpap <- &x[0]; 2910 R reg <- 3
    c32  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | convert x[0],y[0],z[0],r[20][0] to integer
    c33  3b 00 8 0 4 7140 00e0  	;			;		rfct;		;		ap+
    c34  2a 0e e 0 0 dc4c 00e2  	incw r[12],y;	am->fpdp;	;		fixa,la,a,hi;		  | i[0]; fpdp <- &x[0]
    c35  3b 00 4 7 4 7140 00e2  	;			;		push,go;	;		ap+
    c36  2a 00 e 0 0 7140 00e3  	;			;		;		fixa,la,a,st,hi;	  | loop through 5*r[9] values,
    c37  3b 00 8 0 8 7140 00e3  	;			;		rfct;		;		adp+	  | converting to integer and storing back
    c38  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | return
                                ndctoobig3:
    c39  0a 2e e 0 0 dce8 00e6  	incw 230,r[8];	230->fpdp;	;		;			  | list has overflowed, so record this fact
    c3a  1a 2b a 7 0 00e6 ffff  	;			0xFFFF->fpregh;	crtn,go;	;			  | nbndsout<- -1;r[8]<-230+1;return
                                |	movw r[30],r[17];	am->shmemp;	cjp,go corendcfinish3;;			  | shmemp <- r[17] <- &MAXLOCS
                                corendcfinish3:
    c3b  0a 17 e 0 0 d8c0 0000  	movw d,r[0];		shmem->am;	;		;			  | tmp0 <- MAXLOCS
    c3c  0a 0f e 0 0 c3d1 0000  	add2nw 1,r[17],r[17];	am->shmemp;	;		;			  | shmemp <- r[17] <- &nbndsout
    c3d  0a 27 e 0 0 8608 00e6  	subw d,r[8],acc;	230->am;	;		;			  | acc <- (r[8] - 230)
    c3e  0a 00 e 0 0 ec01 0000  	sl0w acc,acc;		;		;		;			  | acc *= 2
    c3f  02 00 e 0 0 9040 0000  	rsubw,s r[0],acc,y;	;		;		;			  | if (2*(r[8] - 230) > MAXLOCS), set
    c40  0a 00 3 1 0 db0b 0c43  	compw 0,r[11];		;		cjp,neg .+3;	;			  | r[11] <- 0xFFFF (more stringent test
    c41  08 2c e 0 2 dd71 00e6  	incw r[17],r[18];	230->fpap;	;		;			  | could be done); else, fpap <- &nbndsclip
    c42  0a 37 e 0 4 d8cb 0000  	movw d,r[11];		fpregh->am;	;		;		ap+	  | r[11] <- nbndsclip
    c43  02 0a e 0 2 d84b 0000  	movw,s r[11],y;		am->shmem;	;		;		shp+	  | nbndsout <- r[11]; if neg or 0, goto
    c44  0a 00 3 1 0 9e92 0c5b  	addw d,r[18],r[18];	;		cjp,neg corendcthru3;;			  | corendcthru3; r[18]<-r[17]+1+r[11](d)
                                corendcbndsloop3:
    c45  0a 0f 3 0 0 dd71 0c5b  	incw r[17],r[17];	am->shmemp;	cjp,zer corendcthru3;;			  | shmemp <- (r[17]+=1), addr for r[10][i]
    c46  02 37 e 0 0 d8ca 0000  	movw,s d,r[10];		fpregh->am;	;		;			  | r[10] <- r[10][i]
    c47  0a 3a e 0 4 7140 0000  	;			fpregh->shmem;	;		;		ap+	  | *r[17] <- r[10][i]
    c48  0a 0f e 0 0 d852 0000  	movw r[18],y;		am->shmemp;	;		;			  | shmemp <- r[18], addr for vertices
                                corendcvertloop3:
    c49  0a 00 3 0 0 7140 0c5a  	;			;		cjp,zer corendcnxtbnd3;;
    c4a  02 00 e 0 0 fff8 0000  	btstw,s 15,r[24]; ;		;		;			  | test 2D or 3D output routine
    c4b  0a 00 3 8 0 7140 0737  	;			;		cjp,~zer cwpout2; ;			  | go to 2D output routime
    c4c  02 00 4 7 0 e1f8 0002  	btstw,s 0,r[24];;		push,go 2;	;			  | cc reflects constant or Gouraud shading
    c4d  0a 3a e 0 2 dd72 0000  	incw r[18],r[18];	fpregh->shmem;	;		;		shp+	  | x,y,z to shmem
    c4e  1b 3a 8 0 b dd72 0000  	incw r[18],r[18];	fpregl->shmem;	rfct;		;		shp+,abp+ | r[18] += 6
    c4f  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+	  | skip r[20]
    c50  0a 37 e 0 0 d8c0 0000  	movw d,r[0];		fpregh->am;	;		;			  | high intensity
    c51  0b 37 3 0 4 d8c1 0c59  	movw d,r[1];		fpregl->am;	cjp,zer .+8;	;		ap+	  | if intensity not needed, don't send it
    c52  02 27 e 0 0 9700 007f  	xorw,s d,r[0],y;		0x7f->am;	;		;			  | otherwise, check for Weitek float to
    c53  02 00 3 8 0 dc41 0c56  	incw,s r[1],y;		;		cjp,~zer corendcnoadj;;			  | int conversion bug in which an intensity
    c54  0a 00 3 8 0 7140 0c56  	;			;		cjp,~zer corendcnoadj;;			  | between 127 + (65535/65536) and
    c55  0a 0a 3 7 2 d840 0c57  	movw r[0],y;		am->shmem;	cjp,go .+2;	;		shp+	  | 127 + (65535.5/65536), corresponding to
                                											  | an offset (by -2^23) float value between
                                											  | -1.0 and -0.5, is converted to the value
                                											  | 0x007FFFFF rather than 0xFFFFFFFF (after
                                											  | float->int and before adding 2^23);
                                											  | after adding back 0x00800000 (2^23),
                                											  | the value would be 0xFFFFFF (255 +
                                											  | (65535/65536)) rather than 0x007FFFFF
                                											  | (127 + (65535/65536));
                                											  | if this case has arisen, ensure that
                                											  | the intensity is changed to 0x007FFFFF
                                corendcnoadj:
    c56  0a 0a e 0 2 cfc0 0000  	add2nw 7,r[0],r[0];	am->shmem;	;		;		shp+	  | send intensity reconverted to
    c57  0a 0a e 0 2 d841 0000  	movw r[1],y;		am->shmem;	;		;		shp+	  | unsigned 8-bit integer, 16-bit fraction
    c58  0a 00 e 0 0 c3d2 0000  	add2nw 1,r[18],r[18];;		;		;			  | r[18] += 2
    c59  02 00 3 7 0 c1ea 0c49  	sub2nw,s 0,r[10],r[10]; ;		cjp,go corendcvertloop3; ;		  | r[10]-=1 and loop back
                                corendcnxtbnd3:
    c5a  02 00 3 7 0 c1eb 0c45  	sub2nw,s 0,r[11],r[11];	;		cjp,go corendcbndsloop3;;		  | r[11]-=1 and loop back
                                corendcthru3:
    c5b  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmem <- &data ready flag
    c5c  0a 2a e 0 0 dd7e 0000  	incw r[30],r[30];	0->shmem;	;		;			  | data ready flag <- 0; r[30]+=1
    c5d  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                | "@(#)polyscan.vp.u 1.2 86/09/12 SMI"
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |   Polygon scan conversion.  Polygon may have multiple holes.
                                |   Based on pr_polygon2.c which is derived from Foley and Van Dam pg. 459.
                                |   includes polyscan3.vp.u at end (which see).
                                |   Input:
                                |   	r[15]	colorop	PIX_OP | PIX_COLOR (color)
                                |   	r[14]	pet	pointer to edge table in FP register memory.  First edge is a dummy.
                                |   Edges are received in the form of EdgeIn and are converted internally to the Edge structure (structures are same size).
                                |   typedef struct EdgeIn {	(Edge for polygon fill)
                                |	int ymn, ymx;		(16 bit integers, value in the hi 16 bits)
                                |	float dx, xmn;		(dx is xmax initially.)
                                |	Edge *nxt;		(int in low 16 bits.)
                                |   } EdgeIn;
                                |   typedef struct Edge {	(Edge for polygon fill) (16 bit integers, values in the hi and lo 16 bits respectively)
                                |	short error, ymn;	(bresenham error accumulator, ymn.).
                                |	short errx, erry;	(incrementers).
                                |	short dx, xmn;
                                |	short ymx, dxerry;	(ymx, dx * erry).
                                |	Edge *nxt;		(int in low 16 bits.)
                                |   } Edge;
    c5e  0a 2e e 0 0 7140 0002  polyscan: ;			2->fpdp;	;		;			| save pointer to edge table.
    c5f  0b 0b e 0 0 d84e 0000  	movw r[14], y;		am->fpregl;	;		;			| 
    c60  0a 27 e 0 0 7140 0004  	;			4->am;	;		;			| r[20]= et [0].r[18].  Skip dummy first edge
    c61  0a 0c e 0 0 968e 0000  	addw d, r[14], y;		am->fpap;	;		;			| 
                                |   Initialize the edge values:  For all edges ymin must be lowest.
    c62  03 37 e 0 0 d8d4 0000  psinit:	movw,s d, r[20];		fpregl->am;	;		;			| while (r[20])
    c63  0b 3c 3 0 0 7140 0cdf  	;			fpregl->fpap;	cjp, zer pssort; ;			| for all edges, ymin must be < r[9].
    c64  0a 0e e 0 0 d854 0000  	movw r[20], y;		am->fpdp;	;		;			| adp 0 0 with respect to r[20].
    c65  0a 37 e 0 8 d8ca 0000  	movw d, r[10];		fpregh->am;	;		;		adp+	| adp 1 1
    c66  00 37 e 0 8 9e4a 0000  	rsubw,s d, r[10], r[8];	fpregh->am;	;		;			| 
    c67  0a 00 3 9 8 d8c9 0c72  	movw d, r[9];		;		cjp, ~neg psnoswap; ;		adp+	| adp 2 2.  if (r[9] < r[10]) ...
    c68  0a 00 e 0 0 df68 0000  	negw r[8], r[8];	;		;		;			| 
    c69  08 00 e 0 4 d96a 0000  	movw r[10], r[4];		;		;		;			| r[4] y's
    c6a  08 00 e 0 a d969 0000  	movw r[9], r[10];		;		;		;			| 
    c6b  08 00 e 0 9 d964 0000  	movw r[4], r[9];		;		;		;			| 
    c6c  0a 37 e 0 0 d8cb 0000  	movw d, r[11];		fpregh->am;	;		;			| r[4] x's
    c6d  0b 37 e 0 4 d8c4 0000  	movw d, r[4];		fpregl->am;	;		;		ap+	| adp 3 2
    c6e  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			| 
    c6f  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+	| adp 3 3
    c70  0a 0b e 0 0 d84b 0000  	movw r[11], y;		am->fpregh;	;		;			| 
    c71  0b 0b e 0 0 d844 0000  	movw r[4], y;		am->fpregl;	;		;			| 
    c72  0a 0e e 0 0 f900 0000  psnoswap: movw 0, y;	am->fpdp;	;		;			| Stash r[8] in fpregs.
    c73  0b 0b e 0 0 d848 0000  	movw r[8], y;		am->fpregl;	;		;			| 
    c74  0a 2b e 0 0 7140 0000  	;			0->fpregh;	;		;			| 
    c75  29 0c e 0 7 c3d4 0230  	add2nw 1, r[20], r[23];	am->fpap;	;		lmode rn, ai, pipe, fast;| 
    c76  0a 0d e 0 0 dc57 0000  	incw r[23], y;		am->fpbp;	;		;			| 
    c77  2a 00 e 0 0 7140 0150  	;			;		;		suba, lab, hi;		| r[7]= r[11] - r[12], prepare to float r[8]
    c78  2b 00 e 0 4 7140 0150  	;			;		;		;		ap+	| 
    c79  2a 00 e 0 0 7140 00e2  	;			;		;		fixa, la, a, hi;	| fix r[12]
    c7a  2b 0c e 0 0 f900 00e2  	movw 0, y;	am->fpap;	;		;			| 
    c7b  2a 00 e 0 0 7140 00a2  	;			;		;		floata, la, a, hi;	| float r[8]
    c7c  2b 00 e 0 0 7140 00a2  	;			;		;		;			| 
    c7d  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    c7e  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    c7f  2a 00 e 0 0 7140 0122  	;			;		;		adda,la, a, hi;		| 
    c80  2b 0e e 0 0 d857 0122  	movw r[23], y;		am->fpdp;	;		;			| 
    c81  2a 00 e 0 0 7140 00eb  	;			;		;		fixr, la, a, st, hi;	| fix r[7].  store r[7] float in r[11].
    c82  2b 00 e 0 6 7140 00eb  	;			;		;		;		dp+	| 
    c83  2a 0c e 0 0 dc57 0123  	incw r[23], y;		am->fpap;	;		adda,la, a, st, hi;		| store r[12] fix in fpreg
    c84  2b 0e e 0 0 f900 0123  	movw 0, y;	am->fpdp;	;		;			| 
    c85  2a 00 e 0 0 7140 0121  	;			;		;		adda,la, st, hi;		| store r[8] float.  get r[12] from fpreg.
    c86  2b 37 e 0 0 d8cc 0121  	movw d, r[12];		fpregl->am;	;		;			| 
    c87  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    c88  2b 00 e 0 0 f8e0 0120  	movw =recip, y;		;		;		;			| 
    c89  2a 08 e 0 0 034c 0122  	;			am->brreg;	;		adda,la, a, hi;		| 
    c8a  2b 0e e 0 0 dc54 0122  	incw r[20], y;		am->fpdp;	;		;			| 
    c8b  2a 00 e 0 0 dd02 0121  	incw 0, r[2];	;		;		adda,la, st, hi;		| store fixed r[7] in what was r[9]
    c8c  3b 0c 1 7 0 f900 0121  	movw 0, y;		am->fpap;	cjs, go;	;			| Calculate reciprocal.
    c8d  2a 0c e 0 0 fd00 0270  	incw 0, y;	am->fpap;	;		lmode rz, ai, flow, fast;| recip may have changed mode.
    c8e  08 0d c 0 7 c3d4 0003  	add2nw 1, r[20], r[23];	am->fpbp;	ldct 3;		;			| 
                                |   r[7] / r[8] == -((-r[7]) / r[8]) for octants 2 and 3.
    c8f  2a 00 e 0 0 7140 0010  	;			;		;		maba, lab, hi;		| r[11]= r[7] / r[8]. (mul by recip.)
    c90  3b 00 4 f 0 7140 0010  	;			;		push, ~go;	;			| 
    c91  1a 28 8 0 0 7140 0003  	;			3->brreg;	rfct;		;			| 
    c92  2a 00 e 0 0 7140 0104  	;			;		;		adda, m, hi;		| 
    c93  2b 00 e 0 0 7140 0104  	;			;		;		;			| 
    c94  2a 00 e 0 0 7140 00e8  	;			;		;		fixr, la, hi;		| fix r[11].
    c95  3b 00 4 7 0 7140 00e8  	;			;		push, go;	;			| 
    c96  1a 00 8 0 0 7140 0000  	;			;		rfct;		;			| 
    c97  2a 00 e 0 0 7140 0102  	;			;		;		adda, a, hi;		| 
    c98  2b 0e e 0 0 dc57 0102  	incw r[23], y;		am->fpdp;	;		;			| store r[11] fix in old r[12] location.
    c99  2a 00 e 0 0 d808 0101  	movw r[8], acc;		;		;		adda, st, hi;		| set acc for mult.
    c9a  2b 0c e 0 0 dc57 0101  	incw r[23], y;		am->fpap;	;		;			| 
    c9b  0b 37 e 0 0 d8cb 0000  	movw d, r[11];		fpregl->am;	;		;			| 
    c9c  0a 00 1 7 0 d8c2 0fce  	movw d, r[2];		;		cjs, go multiply; ;			| compute r[11]*r[8].  MAKE FLOAT (FIX) MUL
    c9d  08 00 e 0 5 d960 0000  	movw r[0], r[5];	;		;		;			| 
    c9e  0a 0c e 0 0 dc54 0000  	incw r[20], y;		am->fpap;	;		;			| 
    c9f  03 37 e 0 0 d8c7 0000  	movw,s d, r[7];		fpregl->am;	;		;			| if (r[7] >= 0)....
    ca0  02 00 3 1 0 9608 0cb2  	subw,s d, r[8], y;	;		cjp, neg psi23;	;			| if (r[8] < r[7])....
    ca1  08 00 3 9 3 cc8b 0caf  	sr0w r[11], r[3];	;		cjp, ~neg psi1;	;			| r[11]/2
    ca2  08 00 e 0 2 d963 0000  psi0:	movw r[3], r[2];	;		;		;			| OCTANT 0.  set r[2] for mult.
    ca3  0a 00 1 7 0 d808 0fce  	movw r[8], acc;		;		cjs, go multiply; ;			| 
    ca4  0a 00 e 0 0 d807 0000  	movw r[7], acc;		;		;		;			| 
    ca5  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| r[7] >> 1
    ca6  00 00 e 0 6 9840 0000  	rsubw,s r[0], acc, r[6]; ;		;		;			| r[6]= -(r[7] >> 1) + (r[11]/2) * r[8].
    ca7  0a 00 3 1 0 d808 0ca9  	movw r[8], acc;		;		cjp, neg psi0jog; ;			| if (r[6] <= 0)....
    ca8  0a 00 3 8 0 7140 0cab  	;			;		cjp, ~zer psi0njog; ;			| 
    ca9  0a 00 e 0 0 9886 0000  psi0jog: addw r[6], acc, r[6]; ;		;		;			| r[6] += r[8]
    caa  0a 00 e 0 0 dd6c 0000  	incw r[12], r[12];		;		;		;			| r[12]++
    cab  0a 00 e 0 0 d807 0000  psi0njog: movw r[7], acc;	;		;		;			| 
    cac  0a 00 e 0 0 9846 0000  	rsubw r[6], acc, r[6]; ;		;		;			| r[6] -= r[7]
    cad  08 07 e 0 3 cc8b 0000  	sr0w r[11], r[3];	am->am;		;		;			| 
    cae  0a 00 3 7 0 9e8c 0cd4  	addw d, r[12], r[12];	;		cjp, go psinxt;	;			| r[12] += r[11]/2
    caf  0a 00 e 0 0 d808 0000  psi1:	movw r[8], acc;		;		;		;			| OCTANT 1.
    cb0  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| r[8] >> 1.
    cb1  0a 00 3 7 0 de86 0cd4  	negw acc, r[6];	;		cjp, go psinxt;	;			| r[6] = - (r[8] >> 1)
                                |   OCTANTS 2 and 3.
    cb2  0a 00 e 0 0 fec1 0000  psi23:	negw d, acc;		;		;		;			| -r[7]
    cb3  02 00 e 0 0 9048 0000  	rsubw,s r[8], acc, y;	;		;		;			| 
    cb4  0a 00 3 9 0 de0b 0ccc  	negw r[11], acc;		;		cjp, ~neg psi2;	;			| OCTANT 3.  (-r[11])
    cb5  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| (-r[11]) / 2.  set for multiplication.
    cb6  0a 00 e 0 0 d882 0000  	movw acc, r[2];		;		;		;			| 
    cb7  0a 00 1 7 0 d808 0fce  	movw r[8], acc;		;		cjs, go multiply; ;			| ((-r[11]) / 2) * r[8]
    cb8  0a 00 e 0 0 de07 0000  	negw r[7], acc;		;		;		;			| -r[7]
    cb9  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| (-r[7]) >> 1
    cba  00 00 e 0 6 9840 0000  	rsubw,s r[0], acc, r[6]; ;		;		;			| r[6]= -((-r[7]) >> 1) + ((-r[11])/2) * r[8]
    cbb  0a 00 3 1 0 d808 0cbd  	movw r[8], acc;		;		cjp, neg psi3jog; ;			| 
    cbc  0a 00 3 8 0 7140 0cbf  	;			;		cjp, ~zer psi3njog; ;			| 
    cbd  0a 00 e 0 0 9886 0000  psi3jog: addw r[6], acc, r[6]; ;		;		;			| r[6] += r[8]
    cbe  0a 00 e 0 0 c1ec 0000  	sub2nw 0, r[12], r[12];	;		;		;			| r[12]--
    cbf  0a 00 e 0 0 d807 0000  psi3njog: movw r[7], acc;	;		;		;			| 
    cc0  0a 00 e 0 0 9886 0000  	addw r[6], acc, r[6];	;		;		;			| r[6] += r[7]
    cc1  0a 00 e 0 0 de0b 0000  	negw r[11], acc;		;		;		;			| 
    cc2  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| r[11] / 2
    cc3  0a 00 e 0 0 fe81 0000  	negw acc, acc;		;		;		;			| >> 2 is not symmetric about zero.
    cc4  0a 00 e 0 0 fc81 0000  	incw acc, acc;		;		;		;			| r[11] / 2 + 1
    cc5  0a 00 e 0 0 988c 0000  	addw r[12], acc, r[12];	;		;		;			| r[12] += r[11] / 2 + 1
    cc6  0a 00 e 0 0 d806 0000  	movw r[6], acc;	;		;		;			| 
    cc7  0a 00 e 0 0 8045 0000  	rsubw r[5], acc, acc;	;		;		;			| r[11] * r[8] - r[6]
    cc8  08 00 e 0 6 9887 0000  	addw r[7], acc, r[6];	;		;		;			| r[6]= r[7] + r[11] * r[8] - r[6]
    cc9  00 00 e 0 0 e1e8 0000  	btstw,s 0, r[8], r[0];	;		;		;			| if (r[8] & 1) ....
    cca  0a 00 3 0 0 7140 0cd4  	;			;		cjp, zer psinxt; ;			| 
    ccb  0a 00 3 7 0 dd66 0cd4  	incw r[6], r[6];	;		cjp, go psinxt;	;			| 
    ccc  0a 00 e 0 0 d808 0000  psi2:	movw r[8], acc;		;		;		;			| OCTANT 2.
    ccd  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| r[8] >> 1
    cce  0a 00 e 0 0 de86 0000  	negw acc, r[6];	;		;		;			| r[6]= -(r[8] >> 1)
    ccf  0a 00 e 0 0 de08 0000  	negw r[8], acc;		;		;		;			| -r[8]
    cd0  02 00 e 0 0 9006 0000  	subw,s r[6], acc, y;	;		;		;			| if (r[6] <= -r[8])
    cd1  0a 00 3 1 0 d808 0cd4  	movw r[8], acc;		;		cjp, neg psinxt; ;			| 
    cd2  0a 00 e 0 0 c1ec 0000  	sub2nw 0, r[12], r[12];	;		;		;			| r[12]--
    cd3  0a 00 3 7 0 9886 0cd4  	addw r[6], acc, r[6];	;		cjp, go psinxt;	;			| r[6] += r[8]
    cd4  0a 0e e 0 0 d854 0000  psinxt:	movw r[20], y;		am->fpdp;	;		;			| 
    cd5  0a 0b e 0 0 d846 0000  	movw r[6], y;		am->fpregh;	;		;			| 
    cd6  0b 0b e 0 6 d84a 0000  	movw r[10], y;		am->fpregl;	;		;		dp+	| 
    cd7  0a 0b e 0 0 d847 0000  	movw r[7], y;		am->fpregh;	;		;			| 
    cd8  0b 0b e 0 6 d848 0000  	movw r[8], y;		am->fpregl;	;		;		dp+	| 
    cd9  0a 0b e 0 0 d84b 0000  	movw r[11], y;		am->fpregh;	;		;			| 
    cda  0b 0b e 0 6 d84c 0000  	movw r[12], y;		am->fpregl;	;		;		dp+	| 
    cdb  0a 0b e 0 0 d849 0000  	movw r[9], y;		am->fpregh;	;		;			| 
    cdc  0b 0b e 0 6 d845 0000  	movw r[5], y;		am->fpregl;	;		;		dp+	| 
    cdd  08 27 e 0 7 9e94 0004  	addw d, r[20], r[23];	4->am;	;		;			| 
    cde  0a 0c 3 7 0 d857 0c62  	movw r[23], y;		am->fpap;	cjp, go psinit; ;			| 
                                |   Sort edge table on r[10] and on r[12] secondarily.
                                |   Bubble sort (?) for now.
                                |   From here on acc stores 4.
    cdf  0a 2c e 0 0 d904 0002  pssort:	movw 0, r[4];		2->fpap;	;		;			| Assume non-empty edge table.  do {
    ce0  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    ce1  0a 27 e 0 0 f8c1 0004  	movw d, acc;		4->am;	;		;			| 
    ce2  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[20]= r[14]->r[18]
    ce3  0b 37 e 0 0 d8d4 0000  	movw d, r[20];		fpregl->am;	;		;			| 
    ce4  0a 0c e 0 0 9094 0000  pssort0: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    ce5  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    ce6  0a 0c 3 0 0 d854 0cfe  	movw r[20], y;		am->fpap;	cjp, zer psdowhile; ;			| 
    ce7  0b 37 e 0 0 d8ca 0000  	movw d, r[10];		fpregl->am;	;		;			| if (r[20]->r[10] > r[20]->r[18]->r[10]) {
    ce8  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| &r[20]->r[18]
    ce9  0b 37 e 0 0 d8d1 0000  	movw d, r[17];		fpregl->am;	;		;			| r[17]= r[20]->r[18]
    cea  0b 3c e 0 0 7140 0000  	;			fpregl->fpap;	;		;			| &r[20]->next->r[10]
    ceb  03 37 e 0 0 964a 0000  	rsubw,s d, r[10], y;	fpregl->am;	;		;			| r[20]->r[10] > r[20]->r[18]->r[10]
    cec  08 0c 3 9 7 c3d4 0cf5  	add2nw 1, r[20], r[23];	am->fpap;	cjp, ~neg pssortx; ;			| r[20]->r[12]
    ced  0a 0c e 0 0 9091 0000  psswaps: addw r[17], acc, y;	am->fpap;	;		;			| r[20]->r[18]= r[20]->r[18]->r[18]
    cee  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| 
    cef  0b 3b e 0 0 7140 0000  	;			fpregl->fpregl;	;		;			| 
    cf0  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[17]->r[18]= r[14]->r[18]
    cf1  0a 0e e 0 0 9091 0000  	addw r[17], acc, y;	am->fpdp;	;		;			| 
    cf2  0b 3b e 0 0 dd04 0000  	incw 0, r[4];		fpregl->fpregl;	;		;			| r[4]= 1
    cf3  0a 0e e 0 0 908e 0000  	addw r[14], acc, y;	am->fpdp;	;		;			| r[14]->r[18]= r[17]
    cf4  0b 0b 3 7 0 d851 0cfa  	movw r[17], y;		am->fpregl;	cjp, go pssort1; ;			| 
    cf5  0b 37 3 8 0 d8cc 0cfa  pssortx: movw d, r[12];		fpregl->am;	cjp, ~zer pssort1; ;			| r[20]->r[12]
    cf6  08 0c e 0 7 c3d1 0000  	add2nw 1, r[17], r[23];	am->fpap;	;		;			| r[20]->r[18]->r[12]
    cf7  03 37 e 0 0 960c 0000  	subw,s d, r[12], y;	fpregl->am;	;		;			| if (r[20]->r[12] > r[20]->r[18]->r[12]) {
    cf8  0a 00 3 0 0 7140 0cfa  	;			;		cjp, zer pssort1; ;			| 
    cf9  0a 00 3 9 0 7140 0ced  	;			;		cjp, ~neg psswaps; ;			| r[4] }
    cfa  0a 0c e 0 0 908e 0000  pssort1: addw r[14], acc, y;	am->fpap;	;		;			| r[14]= r[14]->r[18]
    cfb  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    cfc  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[20]= r[14]->r[18]
    cfd  03 37 3 7 0 d8d4 0ce4  	movw,s d, r[20];		fpregl->am;	cjp, go pssort0; ;			| 
    cfe  02 00 e 0 0 d844 0000  psdowhile: movw,s r[4], y;	;		;		;			| } while (r[4])
    cff  0a 00 3 8 0 7140 0cdf  	;			;		cjp, ~zer pssort; ;			| 
                                |   Ready to draw segments.
    d00  02 00 e 0 0 d850 0000  psrdy:	movw,s r[16], y;	;		;		;			| 
                                |	;			;		cjp, go psrdy1;	;			| DEBUG.  Fits with pixrect.vp.u ppshinit.
    d01  0a 00 3 0 0 7140 0d18  	;			;		cjp, zer psrdy1; ;			| 
                                |   psinipp: ;			19->am;		;		;			| 
    d02  0a 27 e 0 0 7140 0015  psinipp: ;			21->am;	;		;			| DEBUG
    d03  0a 06 3 c 0 f8c0 0d03  	movw d, y;		am->fifo1;	cjp, f1f .;	;			| Send plhinit command (#19) to pp.
    d04  08 00 e 0 0 cc8f 0000  	sr0w r[15], r[0];	;		;		;			| 
    d05  0a 27 e 0 0 9ec0 000f  	andw d, r[0], r[0];	0xf->am;	;		;			| 
                                | PIXOP_NEEDS_DST (op << 1)= (op^(op << 1)) & 0xa
    d06  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| 
    d07  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
    d08  0a 00 e 0 0 8100 0000  	xorw r[0], acc, acc;	;		;		;			| 
    d09  02 27 e 0 0 e281 000a  	addw,s d, acc, acc;	0xa->am;	;		;			| 
    d0a  0a 00 3 0 0 7140 0d0d  	;			;		cjp, zer psnodst; ;			| 
    d0b  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| SWWPIX
    d0c  0a 00 3 7 0 7140 0d0e  	;			;		cjp, go psropreg; ;			| 
    d0d  0a 27 e 0 0 7140 0001  psnodst: ;			1->am;		;		;			| SRWPIX
    d0e  0a 06 3 c 0 f8c0 0d0e  psropreg: movw d, y;		am->fifo1;	cjp, f1f .;	;			| RopMode
    d0f  0a 06 3 c 0 d840 0d0f  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| Op
    d10  0a 06 3 c 0 f900 0d10  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Patt
    d11  0a 06 3 c 0 f900 0d11  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Mask2
    d12  0a 06 3 c 0 f900 0d12  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Mask1
    d13  0a 06 3 c 0 f900 0d13  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| r[14]
    d14  0a 06 3 c 0 f900 0d14  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| OpCnt
    d15  0a 06 3 c 0 f900 0d15  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Shift
    d16  0a 06 3 c 0 f900 0d16  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| PrimeSrc2
    d17  0a 27 e 0 0 f8c1 0004  	movw d, acc;		4->am;	;		;			| 
    d18  0a 2c e 0 0 7140 0002  psrdy1:	;			2->fpap;	;		;			| r[14]= et[0].r[18]
    d19  0b 37 e 0 0 7140 0000  	;			fpregl->am;	;		;			| 
    d1a  0a 0c e 0 0 e280 0000  	addw d, acc, y;		am->fpap;	;		;			| 
    d1b  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    d1c  0a 27 e 0 0 d8d1 07d0  	movw d, r[17];		2000->am;	;		;			| r[17]= aet
    d1d  0a 0c e 0 0 d84e 0000  	movw r[14], y;		am->fpap;	;		;			| r[13]= r[14]->r[10]
    d1e  0b 37 e 0 0 d8cd 0000  	movw d, r[13];		fpregl->am;	;		;			| 
    d1f  0a 0e e 0 0 9091 0000  	addw r[17], acc, y;	am->fpdp;	;		;			| r[17]->r[18]= 0
    d20  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
                                |   Repeat until aet and et are empty.
                                |   Get current edges out of edge table (et) and put in active edge table.
    d21  08 28 e 0 4 d971 0d36  psdo:	movw r[17], r[20];		=pspaint->brreg; ;		;			| r[20]= r[17]
    d22  02 0c e 0 0 d84e 0000  pswhily: movw,s r[14], y;		am->fpap;	;		;			| while (r[14] && (r[14]->r[10] <= r[13])) {
    d23  13 37 3 0 0 960d 0000  	subw,s d, r[13], y;	fpregl->am;	cjp, zer;	;			| (r[14]->r[10] <= r[13])
    d24  18 0c 3 1 0 c3ce 0000  	add2nw 1, r[14], r[0];	am->fpap;	cjp, neg;	;			| save r[14]->r[12]
    d25  0b 37 e 0 0 d8cc 0000  	movw d, r[12];		fpregl->am;	;		;			| 
    d26  0a 0c e 0 0 9094 0000  pswhilx: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18] && (
    d27  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| test r[20]->r[18] for 0
    d28  0a 00 3 0 0 7140 0d2d  	;			;		cjp, zer psetaet; ;			| 
    d29  08 0c e 0 7 c3d2 0000  	add2nw 1, r[18], r[23];	am->fpap;	;		;			| r[20]->r[18]->r[12]
    d2a  03 37 e 0 0 964c 0000  	rsubw,s d, r[12], y;	fpregl->am;	;		;			| while( &&(r[20]->r[18]->r[12](a) < r[14]->r[12](b)))
    d2b  0a 00 3 9 0 7140 0d2d  	;			;		cjp, ~neg psetaet; ;			| 
    d2c  08 00 3 7 4 d972 0d26  	movw r[18], r[20];		;		cjp, go pswhilx; ;			| { r[20]= r[20]->r[18] }
    d2d  08 00 e 0 3 d972 0000  psetaet: movw r[18], r[19];		;		;		;			| r[19]= r[20]->r[18]
    d2e  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| r[20]->r[18]= r[14]
    d2f  0b 0b e 0 0 d84e 0000  	movw r[14], y;		am->fpregl;	;		;			| 
    d30  0a 07 e 0 0 d84e 0000  	movw r[14], y;		am->am;		;		;			| 
    d31  0a 00 e 0 0 d8d2 0000  	movw d, r[18];		;		;		;			| 
    d32  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[14]= r[14]->r[18]
    d33  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    d34  0a 0e e 0 0 9092 0000  	addw r[18], acc, y;	am->fpdp;	;		;			| r[20]->r[18]->r[18]= r[19]
    d35  0b 0b 3 7 0 d853 0d22  	movw r[19], y;		am->fpregl;	cjp, go pswhily; ;			| }
                                |   Paint the current scanline segments.  We are guaranteed that the edges come in pairs.
    d36  0a 0c e 0 0 9091 0000  pspaint: addw r[17], acc, y;	am->fpap;	;		;			| r[20]= r[17]->r[18]
    d37  03 37 e 0 0 d8d4 0000  	movw,s d, r[20];		fpregl->am;	;		;			| 
    d38  0a 0c 3 0 0 9094 0d69  pswhp1:	addw r[20], acc, y;	am->fpap;	cjp, zer psremactive; ;			| while (r[20]) {  There are more edges
    d39  0b 37 c 0 0 d8d3 0003  	movw d, r[19];		fpregl->am;	ldct 3;		;			| 
                                |   First pixel x1= trunc (x + .4999 + r[11]/2)
    d3a  02 28 e 0 0 d850 0d3e  	movw,s r[16], y;	=psppcmd->brreg; ;		;			| 
    d3b  10 27 3 0 7 e1f0 0016  	btstw,s 0, r[16], r[23]; 22->am; cjp, zer;	;			| PPFill2DSeg (plgfill)
    d3c  1a 27 3 8 0 7140 001c  	;			28->am;	cjp, ~zer;	;			| 
    d3d  0a 27 e 0 0 7140 001d  	;			29->am;	;		;			| 
    d3e  0a 06 3 c 0 f8c0 0d3e  psppcmd:movw d, y;		am->fifo1;	cjp, f1f .;	;			| 
                                |   Args to plgfill:  r[13], x1, x2, color, op
                                |   Args to plgtex1:  r[13], x1, x2, color, color0, op, r[21], r[22]
                                |   Args to plgtex8:  r[13], x1, x2, op, r[21], r[22]
    d3f  0a 06 3 c 0 d84d 0d3f  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    d40  08 0c e 0 7 c3d4 0000  	add2nw 1, r[20], r[23];	am->fpap;	;		;			| r[20]->r[12]
    d41  0b 37 e 0 0 d8cc 0000  	movw d, r[12];		fpregl->am;	;		;			| 
    d42  0b 36 3 c 0 7140 0d42  	;			fpregl->fifo1;	cjp, f1f .;	;			| 
    d43  08 0c e 0 7 c3d3 0000  	add2nw 1, r[19], r[23];	am->fpap;	;		;			| r[19]->r[12]
    d44  0b 36 3 c 0 7140 0d44  	;			fpregl->fifo1;	cjp, f1f .;	;			| 
    d45  02 00 e 0 0 d850 0000  	movw,s r[16], y;	;		;		;			| 
    d46  00 00 3 0 7 e1f0 0d60  	btstw,s 0, r[16], r[23]; ;		cjp, zer pstex0; ;			| 
    d47  0a 00 3 0 0 7140 0d57  	;			;		cjp, zer pstex8; ;			| 
                                |   pstex1:
    d48  08 00 e 0 0 97ef 0000  	rolw 11, r[15], r[0];	;		;		;			| Color in op
    d49  02 27 e 0 0 9ec0 07ff  	andw,s d, r[0], r[0];	0x7ff->am;	;		;			| if (color == 0) color= all ones.
    d4a  0a 00 3 8 0 7140 0d4c  	;			;		cjp, ~zer .+2;	;			| 
    d4b  0a 27 e 0 0 d8c0 ffff  	movw d, r[0];		0xffff->am;	;		;			| 
    d4c  0a 06 3 c 0 d840 0d4c  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    d4d  0a 06 3 c 0 f900 0d4d  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Color0
    d4e  08 27 e 0 0 9ecf 001f  	andw d, r[15], r[0];	0x1f->am;	;		;			| Op
    d4f  0a 06 3 c 0 d840 0d4f  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    d50  02 07 e 0 0 d84c 0000  	movw,s r[12], y;		am->am;		;		;			| 
    d51  08 00 e 0 7 9e95 0000  	addw d, r[21], r[23];	;		;		;			| 
    d52  0a 06 3 c 0 d857 0d52  	movw r[23], y;		am->fifo1;	cjp, f1f .;	;			| r[21]
    d53  0a 07 e 0 0 d84d 0000  	movw r[13], y;		am->am;		;		;			| 
    d54  08 00 e 0 7 9e96 0000  	addw d, r[22], r[23];	;		;		;			| 
    d55  0a 06 3 c 0 d857 0d55  	movw r[23], y;		am->fifo1;	cjp, f1f .;	;			| r[22]
    d56  0a 00 3 7 0 7140 0d65  	;			;		cjp, go psnxtseg; ;			| 
    d57  08 27 e 0 0 9ecf 001f  pstex8:	andw d, r[15], r[0];	0x1f->am;	;		;			| Op
    d58  0a 06 3 c 0 d840 0d58  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    d59  02 07 e 0 0 d84c 0000  	movw,s r[12], y;		am->am;		;		;			| 
    d5a  08 00 e 0 7 9e95 0000  	addw d, r[21], r[23];	;		;		;			| 
    d5b  0a 06 3 c 0 d857 0d5b  	movw r[23], y;		am->fifo1;	cjp, f1f .;	;			| r[21]
    d5c  0a 07 e 0 0 d84d 0000  	movw r[13], y;		am->am;		;		;			| 
    d5d  08 00 e 0 7 9e96 0000  	addw d, r[22], r[23];	;		;		;			| 
    d5e  0a 06 3 c 0 d857 0d5e  	movw r[23], y;		am->fifo1;	cjp, f1f .;	;			| r[22]
    d5f  0a 00 3 7 0 7140 0d65  	;			;		cjp, go psnxtseg; ;			| 
    d60  08 00 e 0 0 97ef 0000  pstex0:	rolw 11, r[15], r[0];	;		;		;			| Color in op
    d61  0a 27 e 0 0 9ec0 07ff  	andw d, r[0], r[0];	0x7ff->am;	;		;			| 
    d62  0a 06 3 c 0 d840 0d62  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    d63  08 27 e 0 0 9ecf 001f  	andw d, r[15], r[0];	0x1f->am;	;		;			| Op
    d64  0a 06 3 c 0 d840 0d64  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    d65  0a 0c e 0 0 9093 0000  psnxtseg:addw r[19], acc, y;	am->fpap;	;		;			| r[20]= r[19]->r[18]
    d66  03 37 e 0 0 d8d4 0000  	movw,s d, r[20];		fpregl->am;	;		;			| 
    d67  0a 0c 3 0 0 9094 0d69  	addw r[20], acc, y;	am->fpap;	cjp, zer psremactive; ;			| if (r[20]) r[19]= r[20]->r[18].  NB while (r[20])
    d68  0b 37 3 7 0 d8d3 0d38  	movw d, r[19];		fpregl->am;	cjp, go pswhp1;	;			| 
                                |   Remove active edges whose ymax <= r[13]
    d69  0a 00 e 0 0 dd6d 0000  psremactive: incw r[13], r[13];	;		;		;			| r[13]++.  Step to next scanline
    d6a  08 00 e 0 4 d971 0000  	movw r[17], r[20];		;		;		;			| r[20]= r[17]
    d6b  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    d6c  03 37 e 0 0 d8d2 0000  psremwh: movw,s d, r[18];		fpregl->am;	;		;			| 
    d6d  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| 
    d6e  0a 0c 3 0 0 9692 0d75  	addw d, r[18], y;		am->fpap;	cjp, zer psupx;	;			| if (r[20]->r[18]->r[9] <= r[13])
    d6f  02 37 e 0 0 960d 0000  	subw,s d, r[13], y;	fpregh->am;	;		;			| 
    d70  0a 0c 3 1 0 9092 0d73  	addw r[18], acc, y;	am->fpap;	cjp, neg psstep; ;			| r[20]->r[18]= r[20]->r[18]->r[18]
    d71  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| 
    d72  0b 3b 3 7 0 7140 0d6c  	;			fpregl->fpregl;	cjp, go psremwh; ;			| 
    d73  08 00 e 0 4 d972 0000  psstep:	movw r[18], r[20];		;		;		;			| else r[20]= r[20]->r[18]
    d74  0a 0c 3 7 0 9094 0d6c  	addw r[20], acc, y;	am->fpap;	cjp, go psremwh; ;			| 
                                |   Update x values in aet
    d75  08 00 e 0 4 d971 0000  psupx:	movw r[17], r[20];		;		;		;			| r[20]= r[17]
    d76  0a 0c e 0 0 9094 0000  psupxwhile: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    d77  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    d78  08 00 3 0 4 d972 0da7  	movw r[18], r[20];		;		cjp, zer psresort; ;			| r[20]= r[20]->r[18]
    d79  0a 0c e 0 0 dc54 0000  	incw r[20], y;		am->fpap;	;		;			| 
    d7a  02 37 e 0 0 d8c7 0000  	movw,s d, r[7];		fpregh->am;	;		;			| if (r[7] >= 0) ....
    d7b  0b 37 3 1 0 d8c8 0d90  	movw d, r[8];		fpregl->am;	cjp, neg psupx23; ;			| 
    d7c  02 00 e 0 4 9647 0000  psupx01: rsubw,s d, r[7], y;	;		;		;		ap+	| if (r[8] < r[7]) ....
    d7d  0b 37 3 9 0 d8cc 0d8a  	movw d, r[12];		fpregl->am;	cjp, ~neg psupx1; ;			| 
    d7e  0a 37 e 0 0 9e8c 0000  psupx0:	addw d, r[12], r[12];	fpregh->am;	;		;			| OCTANT 0.  r[12] += r[11]
    d7f  0a 0c e 0 0 d854 0000  	movw r[20], y;		am->fpap;	;		;			| 
    d80  0a 37 e 0 0 d8c6 0000  	movw d, r[6];		fpregh->am;	;		;			| 
    d81  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| 
    d82  0a 0c e 0 0 9694 0000  	addw d, r[20], y;		am->fpap;	;		;			| 
    d83  03 37 e 0 0 9e86 0000  	addw,s d, r[6], r[6];	fpregl->am;	;		;			| r[6] += r[11] * r[8].  if (r[6] <= 0)....
    d84  0a 07 e 0 0 d847 0000  	movw r[7], y;		am->am;		;		;			| 
    d85  0a 00 3 1 0 9e06 0d87  	subw d, r[6], r[6];	;		cjp, neg psupx0if; ;			| r[6] -= r[7].
    d86  0a 00 3 8 0 7140 0da3  	;			;		cjp, ~zer psupxdo; ;			| Save r[12] & r[6], and loopback.
    d87  0a 07 e 0 0 d848 0000  psupx0if: movw r[8], y;		am->am;		;		;			| 
    d88  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| r[6] += r[8].
    d89  0a 00 3 7 0 dd6c 0da3  psupx0xmn: incw r[12], r[12];	;		cjp, go psupxdo; ;			| r[12]++.
    d8a  0a 0c e 0 0 d854 0000  psupx1:	movw r[20], y;		am->fpap;	;		;			| OCTANT 1
    d8b  00 37 e 0 6 9e87 0000  	addw,s d, r[7], r[6];	fpregh->am;	;		;			| r[6] += r[7]
    d8c  0a 00 3 1 0 7140 0da3  	;			;		cjp, neg psupxdo; ;			| 
    d8d  0a 07 3 0 0 d848 0da3  	movw r[8], y;		am->am;		cjp, zer psupxdo; ;			| 
    d8e  0a 00 e 0 0 9e06 0000  	subw d, r[6], r[6];	;		;		;			| r[6] -= r[8]
    d8f  0a 00 3 7 0 dd6c 0da3  	incw r[12], r[12];		;		cjp, go psupxdo; ;			| 
    d90  08 00 e 0 0 df67 0000  psupx23: negw r[7], r[0];	;		;		;			| 
    d91  02 00 e 0 4 9640 0000  	rsubw,s d, r[0], y;	;		;		;		ap+	| if (r[8] < -r[7])
    d92  0b 37 3 9 0 d8cc 0d9c  	movw d, r[12];		fpregl->am;	cjp, ~neg psupx2; ;			| 
    d93  0a 37 e 0 0 9e8c 0000  psupx3:	addw d, r[12], r[12];	fpregh->am;	;		;			| OCTANT 3.  r[12] += r[11]
    d94  0a 0c e 0 0 d854 0000  	movw r[20], y;		am->fpap;	;		;			| 
    d95  00 37 e 0 6 9e47 0000  	rsubw,s d, r[7], r[6];	fpregh->am;	;		;			| r[6] -= r[7]
    d96  08 0c 3 1 7 c3d4 0d9a  	add2nw 1, r[20], r[23];	am->fpap;	cjp, neg psupx3a; ;			| prepare to access r[11] * r[8] (r[20] +3)
    d97  0a 07 3 0 0 d848 0d9a  	movw r[8], y;		am->am;		cjp, zer psupx3a; ;			| if (r[6] > 0) ...
    d98  0a 00 e 0 0 9e06 0000  	subw d, r[6], r[6];	;		;		;			| 
    d99  0a 00 e 0 0 c1ec 0000  	sub2nw 0, r[12], r[12];	;		;		;			| 
    d9a  0a 00 e 0 4 7140 0000  psupx3a: ;			;		;		;		ap+	| 
    d9b  0b 37 3 7 0 9e86 0da3  	addw d, r[6], r[6];	fpregl->am;	cjp, go psupxdo; ;			| r[6] += r[11] * r[8]
    d9c  0a 0c e 0 0 d854 0000  psupx2:	movw r[20], y;		am->fpap;	;		;			| OCTANT 2.
    d9d  08 37 e 0 6 9e87 0000  	addw d, r[7], r[6];	fpregh->am;	;		;			| r[6] += r[7]
    d9e  0a 07 e 0 0 de48 0000  	negw r[8], y;		am->am;		;		;			| 
    d9f  02 00 e 0 0 9646 0000  	rsubw,s d, r[6], y;	;		;		;			| 
    da0  0a 07 3 1 0 d848 0da3  	movw r[8], y;		am->am;		cjp, neg psupxdo; ;			| 
    da1  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| 
    da2  0a 00 3 7 0 c1ec 0da3  	sub2nw 0, r[12], r[12];	;		cjp, go psupxdo; ;			| 
    da3  0a 0e e 0 0 d854 0000  psupxdo: movw r[20], y;		am->fpdp;	;		;			| Save r[12] & r[6], and loopback.
    da4  0a 0b e 0 0 d846 0000  	movw r[6], y;		am->fpregh;	;		;			| 
    da5  08 0e e 0 7 c3d4 0000  	add2nw 1, r[20], r[23];	am->fpdp;	;		;			| 
    da6  0b 0b 3 7 0 d84c 0d76  	movw r[12], y;		am->fpregl;	cjp, go psupxwhile; ;			| 
                                |   Resort on > r[12] because previous step may have crossed edges.
    da7  08 00 e 0 4 d971 0000  psresort: movw r[17], r[20];	;		;		;			| r[20]= r[17]
    da8  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| if (r[20]->r[18])
    da9  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    daa  0a 00 3 0 0 7140 0dc8  	;			;		cjp, zer pswhend; ;			| 
    dab  08 00 e 0 4 d971 0000  psrsdo:	movw r[17], r[20];		;		;		;			| do { r[20]= r[17]
    dac  08 00 e 0 3 d972 0000  	movw r[18], r[19];		;		;		;			| r[19]= r[20]->r[18]
    dad  0a 00 e 0 0 d904 0000  	movw 0, r[4];		;		;		;			| r[4]= 0
    dae  0a 0c e 0 0 9093 0000  pswhp2nxt: addw r[19], acc, y;	am->fpap;	;		;			| while (r[19]->r[18])
    daf  03 37 e 0 0 d8c0 0000  	movw,s d, r[0];		fpregl->am;	;		;			| 
    db0  0a 00 3 0 0 7140 0dc6  	;			;		cjp, zer psdoswap; ;			| if (r[19]->r[12] > r[19]->r[18]->r[12])
    db1  08 0c e 0 1 c3c0 0000  	add2nw 1, r[0], r[1];	am->fpap;	;		;			| r[19]->r[18]->r[12]
    db2  0b 37 e 0 0 d8cc 0000  	movw d, r[12];		fpregl->am;	;		;			| 
    db3  08 0c e 0 7 c3d3 0000  	add2nw 1, r[19], r[23];	am->fpap;	;		;			| 
    db4  03 37 e 0 0 964c 0000  	rsubw,s d, r[12], y;	fpregl->am;	;		;			| 
    db5  0a 00 3 0 0 7140 0dc2  	;			;		cjp, zer psrselse; ;			| 
    db6  0a 00 3 1 0 7140 0dc2  	;			;		cjp, neg psrselse; ;			| 
    db7  0a 0e e 0 0 9094 0000  psrsthen: addw r[20], acc, y;	am->fpdp;	;		;			| r[20]->r[18]= r[19]->r[18]
    db8  0b 0b e 0 0 d840 0000  	movw r[0], y;		am->fpregl;	;		;			| 
    db9  0a 0e e 0 0 9093 0000  	addw r[19], acc, y;	am->fpdp;	;		;			| r[19]->r[18]= r[19]->r[18]->r[18]
    dba  0a 0c e 0 0 9080 0000  	addw r[0], acc, y;	am->fpap;	;		;			| 
    dbb  0b 3b e 0 0 7140 0000  	;			fpregl->fpregl;	;		;			| 
    dbc  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| r[20]->r[18]->r[18]= r[19]
    dbd  0b 37 e 0 0 d8d2 0000  	movw d, r[18];		fpregl->am;	;		;			| 
    dbe  0a 0e e 0 0 9092 0000  	addw r[18], acc, y;	am->fpdp;	;		;			| 
    dbf  0b 0b e 0 0 d853 0000  	movw r[19], y;		am->fpregl;	;		;			| 
    dc0  08 00 e 0 4 d972 0000  	movw r[18], r[20];		;		;		;			| r[20]= r[20]->r[18]
    dc1  0a 00 3 7 0 dd04 0dae  	incw 0, r[4];		;		cjp, go pswhp2nxt; ;			| r[4]= 1
    dc2  0a 0c e 0 0 9094 0000  psrselse: addw r[20], acc, y;	am->fpap;	;		;			| r[20]= r[20]->r[18]
    dc3  0b 37 e 0 0 d8d4 0000  	movw d, r[20];		fpregl->am;	;		;			| 
    dc4  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| r[19]= r[20]->r[18]
    dc5  0b 37 3 7 0 d8d3 0dae  	movw d, r[19];		fpregl->am;	cjp, go pswhp2nxt; ;			| 
    dc6  02 00 e 0 0 d844 0000  psdoswap: movw,s r[4], y;	;		;		;			| } while (r[4])
    dc7  0a 00 3 8 0 7140 0dab  	;			;		cjp, ~zer psrsdo; ;			| 
    dc8  0a 0c e 0 0 9091 0000  pswhend: addw r[17], acc, y;	am->fpap;	;		;			| } while (r[17]->r[18] || r[14])
    dc9  03 37 e 0 0 f8c0 0000  	movw,s d, y;		fpregl->am;	;		;			| r[17]->r[18]
    dca  02 00 3 8 0 d84e 0d21  	movw,s r[14], y;		;		cjp, ~zer psdo;	;			| 
    dcb  0a 00 3 8 0 7140 0d21  	;			;		cjp, ~zer psdo;	;			| 
    dcc  1a 00 a 7 0 7140 0000  	;			;		crtn, go;	;			| 
                                | "@(#)polyscan3.vp.u 1.2 86/09/12 SMI"
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |   3D Polygon scan conversion.  See also polyscan.vp.u
                                |   Polygon scan conversion.  Polygon may have multiple holes.
                                |   Based on pr_polygon2.c which is derived from Foley and Van Dam pg. 459.
                                |   Pixel vertices are offset by (-.5, 0)
                                |   Input:
                                |   	r[15]	colorop	PIX_OP | PIX_COLOR (color)
                                |   	r[14]	pet	pointer to edge table in FP register memory.  First edge is a dummy.  Will be around 0x80.
                                |   typedef struct EdgeZC {	(Edge for polyhedral shading)
                                |	int ymn, ymx;	(16 bit integers, value in the hi 16 bits)
                                |	float dx, dz, dc;	(These start off life as max values.  z is 0 to 2**16 - 1, c is -2**23 to 2**23 - 1.)
                                |   		(color was 24 bits (0 to 2**24 - 1) but xfpolygon3.vp.u subtracted 2**23 from it).
                                |	float xmn, zmn, cmn;	
                                |	Edge *nxt;	(int in low 16 bits.)
                                |   } EdgeZC;
    dcd  0a 2e e 0 0 7140 0010  polyscan3: ;			0x10->fpdp;	;		;			| 
    dce  0a 2b e 0 0 7140 3f00  	;			0x3f00->fpregh;	;		;			| 0.5
    dcf  0b 2b e 0 6 7140 0000  	;			0->fpregl;	;		;		dp+	| 
    dd0  0a 2b e 0 0 7140 c700  	;			0xc700->fpregh;	;		;			| ShiftZ value of -32768.0
    dd1  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
    dd2  0a 2b e 0 0 7140 4380  	;			0x4380->fpregh;	;		;			| Multiply z by 256 (shift up 8 bits).
    dd3  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
    dd4  0a 2e e 0 0 7140 0002  	;			2->fpdp;	;		;			| save pointer to edge table.
    dd5  0b 0b e 0 0 d84e 0000  	movw r[14], y;		am->fpregl;	;		;			| 
    dd6  0a 27 e 0 0 7140 0008  	;			8->am;	;		;			| r[20]= et [0].r[18].  Skip dummy first edge
    dd7  0a 0c e 0 0 968e 0000  	addw d, r[14], y;		am->fpap;	;		;			| 
    dd8  0a 27 e 0 0 d8c6 7f80  	movw d, r[6];		0x7f80->am;	;		;			| 
    dd9  0a 27 e 0 0 d8c5 807f  	movw d, r[5];	0x807f->am;	;		;			| 
                                |   Initialize the edge values:  For all edges ymin must be lowest.
    dda  23 37 e 0 0 d8d4 0270  p3iedge: movw,s d, r[20];		fpregl->am;	;		lmode rz, ai, pipe, fast;| while (r[20])
    ddb  02 00 3 0 0 f1f0 0e6c  	btstw,s 8, r[16];	;		cjp, zer p3sort; ;			| for all edges, ymin must be < r[8].
    ddc  0a 00 3 0 0 7140 0de8  	;			;		cjp, zer p3noz; ;			| 
    ddd  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| Shift first z up 7 bits (7 + 16 == 23).
    dde  0a 0c e 0 0 9694 0000  	addw d, r[20], y;		am->fpap;	;		;			| 
    ddf  0a 0e e 0 0 9694 0000  	addw d, r[20], y;		am->fpdp;	;		;			| 
    de0  0a 37 e 0 0 d8c0 0000  	movw d, r[0];		fpregh->am;	;		;			| 
    de1  0a 27 e 0 0 f8c1 0380  	movw d, acc;		0x380->am;	;		;			| 
    de2  0a 0b e 0 0 9080 0000  	addw r[0], acc, y;	am->fpregh;	;		;			| 
    de3  0a 27 e 0 0 7140 0006  	;			6->am;		;		;			| Shift second z up 7 bits (7 + 16 == 23).
    de4  0a 0c e 0 0 9694 0000  	addw d, r[20], y;		am->fpap;	;		;			| 
    de5  0a 0e e 0 0 9694 0000  	addw d, r[20], y;		am->fpdp;	;		;			| 
    de6  0a 37 e 0 0 d8c0 0000  	movw d, r[0];		fpregh->am;	;		;			| 
    de7  0a 0b e 0 0 9080 0000  	addw r[0], acc, y;	am->fpregh;	;		;			| Done shifting z.
    de8  0a 0c e 0 0 d854 0000  p3noz:	movw r[20], y;		am->fpap;	;		;			| 
    de9  0a 37 e 0 4 d8c9 0000  	movw d, r[9];		fpregh->am;	;		;		ap+	| r[20]->r[9]
    dea  0a 37 e 0 0 d8c8 0000  	movw d, r[8];		fpregh->am;	;		;			| 
    deb  20 37 e 0 7 9e09 0230  	subw,s d, r[9], r[7];	fpregh->am;	;		lmode rn, ai, flow, fast;| r[9] - r[8]
    dec  0a 2e e 0 0 7140 0000  	;			0->fpdp;	;		;			| 
    ded  0a 0b 3 9 0 f900 0e29  	movw 0, y;		am->fpregh;	cjp, ~neg p3swap; ;			| 
    dee  0b 0b c 0 0 de47 0003  	negw r[7], y;		am->fpregl;	ldct 3;		;			| 
    def  0a 2c e 0 0 7140 0000  	;			0->fpap;	;		;			| 
    df0  2a 00 e 0 0 f8e0 00a0  	movw =recip, y;		;		;		floata, la, hi;		| 
    df1  3b 08 4 f 0 034c 00a0  	;			am->brreg;	push, ~go;	;			| 
    df2  1a 00 8 0 0 7140 0000  	;			;		rfct;		;			| 
    df3  2a 00 e 0 0 7140 0102  	;			;		;		adda, a, hi;		| 
    df4  2b 00 e 0 0 7140 0102  	;			;		;		;			| 
    df5  2a 00 e 0 0 7140 0101  	;			;		;		adda, st, hi;		| 
    df6  2b 00 e 0 0 7140 0101  	;			;		;		;			| move from one register set to another.
    df7  1a 27 1 7 0 d8c2 0001  	movw d, r[2];		1->am;	cjs, go;	;			| load dp arg (r[2]) for recip of r[7].
    df8  29 0c e 0 b c3d4 0270  	add2nw 1, r[20], r[27];	am->fpap;	;		lmode rz, ai, pipe, fast;| Reset mode after return from recip
    df9  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| 
    dfa  08 0d e 0 b 9e94 0000  	addw d, r[20], r[27];	am->fpbp;	;		;			| 
    dfb  2a 00 e 0 0 7140 0150  	;			;		;		suba, lab, hi;		| r[20]->xmx - r[20]->r[12]
    dfc  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+	| 
    dfd  2a 00 e 0 0 7140 0150  	;			;		;		suba, lab, hi;		| r[20]->zmx - r[20]->zmn
    dfe  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+	| 
    dff  2a 00 e 0 0 7140 0150  	;			;		;		suba, lab, hi;		| r[20]->cmx - r[20]->cmn
    e00  2b 00 e 0 0 7140 0150  	;			;		;		;			| 
    e01  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    e02  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    e03  2a 0d e 0 0 fd00 0122  	incw 0, y;		am->fpbp;	;		adda,la, a, hi;		| 1->fpbp
    e04  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    e05  2a 00 e 0 0 7140 001a  	;			;		;		mabr, lab, a, hi;	| * 1 / r[7].
    e06  2b 00 e 0 0 7140 001a  	;			;		;		;			| 
    e07  2a 00 e 0 0 7140 001a  	;			;		;		mabr, lab, a, hi;	| * 1 / r[7].
    e08  2b 00 e 0 0 7140 001a  	;			;		;		;			| 
    e09  2a 00 e 0 0 7140 0018  	;			;		;		mabr, lab, hi;		| * 1 / r[7].
    e0a  2b 00 e 0 0 7140 0018  	;			;		;		;			| 
    e0b  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    e0c  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    e0d  28 0e e 0 b c3d4 0124  	add2nw 1, r[20], r[27];	am->fpdp;	;		adda,la, m, hi;		| 
    e0e  2b 00 e 0 0 7140 0124  	;			;		;		;			| 
    e0f  2a 00 e 0 0 7140 0125  	;			;		;		adda,la, m, st, hi;		| Store r[11].
    e10  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+	| 
    e11  2a 00 e 0 0 7140 0125  	;			;		;		adda,la, m, st, hi;		| Store r[23].
    e12  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+	| 
    e13  28 0c e 0 b c3d4 0121  	add2nw 1, r[20], r[27];	am->fpap;	;		adda,la, st, hi;		| Store r[25].
    e14  29 0d e 0 b c5d4 0121  	add2nw 2, r[20], r[27];	am->fpbp;	;		;			| 
    e15  02 37 e 0 0 d8c0 0000  	movw,s d, r[0];		fpregh->am;	;		;			| if (r[11] < 0)
                                |	add2nw 1, r[20], r[27];	am->fpdp;	cjp, ~neg p3dxok; ;			| 
    e16  08 0e 3 7 b c3d4 0e18  	add2nw 1, r[20], r[27];	am->fpdp;	cjp, go p3dxok; ;			| 
    e17  0a 0b e 0 0 ffc0 0000  	bclrw 15, r[0], r[0];	am->fpregh;	;		;			| 
    e18  2a 00 e 0 0 cf80 0270  p3dxok:	mov2nw 7, r[0];		;		;		lmode rz, ai, flow, fast;| Wait to use fpregh.
    e19  02 37 e 0 0 86c6 0000  	andw,s d, r[6], acc;	fpregh->am;	;		;			| 
    e1a  0a 00 3 0 5 8000 0e1c  	subw r[0], acc, acc;	;		cjp, zer p3xmn;	;		bp+	| r[11] / 2
    e1b  0a 0b e 0 0 a105 0000  	romw 0, d, acc, r[5]; am->fpregh;	;		;			| 
    e1c  0a 28 e 0 6 7140 0003  p3xmn:	;			3->brreg;	;		;		dp+	| Wait for fpreg memory cycle.
    e1d  2a 00 e 0 6 7140 0110  	;			;		;		adda, lab, hi;	dp+	| pxmn += r[11] / 2
    e1e  3b 00 4 7 6 7140 0110  	;			;		push, go;	;		dp+	| 
    e1f  1a 00 8 0 0 7140 0000  	;			;		rfct;		;			| 
    e20  2a 00 e 0 0 7140 0102  	;			;		;		adda, a, hi;		| 
    e21  2b 00 e 0 0 f8e0 0102  	movw =p3xmn1, y;	;		;		;			| 
    e22  2a 08 e 0 0 0e27 0101  	;			am->brreg;	;		adda, st, hi;		| Store pxmn.
    e23  39 0e 3 0 b c3d4 0101  	add2nw 1, r[20], r[27];	am->fpdp;	cjp, zer;	;			| 
    e24  0a 37 e 0 0 86c6 0000  	andw d, r[6], acc;	fpregh->am;	;		;			| 
    e25  0a 00 e 0 0 8080 0000  	addw r[0], acc, acc;	;		;		;			| Restore r[11] * 2
    e26  0a 0b e 0 0 a105 0000  	romw 0, d, acc, r[5]; am->fpregh;	;		;			| 
    e27  08 27 e 0 b 9e94 0008  p3xmn1:	addw d, r[20], r[27];	8->am;	;		;			| 
    e28  0a 0c 3 7 0 d85b 0dda  	movw r[27], y;		am->fpap;	cjp, go p3iedge; ;			| 
                                |   if (r[20]->r[9] > r[20]->r[8]) i.e. neg:  r[7] = r[20]->r[8] - r[20]->r[9]
    e29  0b 0b c 0 0 d847 0003  p3swap:	movw r[7], y;		am->fpregl;	ldct 3;		;			| 
    e2a  0a 2c e 0 0 7140 0000  	;			0->fpap;	;		;			| 
    e2b  0a 0e e 0 0 d854 0000  	movw r[20], y;		am->fpdp;	;		;			| 
    e2c  2a 0b e 0 0 d848 00a0  	movw r[8], y;		am->fpregh;	;		floata, la, hi;		| Swap r[9] and r[8].
    e2d  3b 00 4 f 6 7140 00a0  	;			;		push, ~go;	;		dp+	| 
    e2e  1a 28 8 0 0 7140 034c  	;			=recip->brreg;	rfct;		;			| 
    e2f  2a 0b e 0 0 d849 0102  	movw r[9], y;		am->fpregh;	;		adda, a, hi;		| 
    e30  2b 0e e 0 0 f900 0102  	movw 0, y;		am->fpdp;	;		;			| 
    e31  2a 0c e 0 0 f900 0101  	movw 0, y;		am->fpap;	;		adda, st, hi;		| 
    e32  2b 00 e 0 0 7140 0101  	;			;		;		;			| 
    e33  1a 27 1 7 0 d8c2 0001  	movw d, r[2];		1->am;	cjs, go;	;			| load dp arg (r[2]) for recip of r[7].
    e34  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| 
    e35  2b 0d e 0 0 9694 0270  	addw d, r[20], y;		am->fpbp;	;		lmode rz, ai, pipe, fast;| 
    e36  08 0c e 0 b c3d4 0000  	add2nw 1, r[20], r[27];	am->fpap;	;		;			| 
    e37  2a 37 e 0 0 d8cb 0190  	movw d, r[11];		fpregh->am;	;		rsuba, lab, hi;		| r[20]->r[12] - r[20]->r[11]
    e38  2b 37 e 0 7 d8ca 0190  	movw d, r[10];		fpregl->am;	;		;		abp+	| Save r[20]->r[11] for implicit r[3]
    e39  2a 37 e 0 0 d8d7 0190  	movw d, r[23];		fpregh->am;	;		rsuba, lab, hi;		| r[20]->zmn - r[20]->r[23]
    e3a  2b 37 e 0 7 d8d8 0190  	movw d, r[24];		fpregl->am;	;		;		abp+	| Save r[20]->r[23] for implicit r[3]
    e3b  2a 37 e 0 0 d8d9 0190  	movw d, r[25];		fpregh->am;	;		rsuba, lab, hi;		| r[20]->cmn - r[20]->r[25]
    e3c  2b 37 e 0 0 d8da 0190  	movw d, r[26];		fpregl->am;	;		;			| Save r[20]->r[25] for implicit r[3]
    e3d  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    e3e  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    e3f  2a 0d e 0 0 fd00 0122  	incw 0, y;		am->fpbp;	;		adda,la, a, hi;		| 1->fpbp
    e40  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    e41  2a 00 e 0 0 7140 001a  	;			;		;		mabr, lab, a, hi;	| * 1 / r[7].
    e42  2b 00 e 0 0 7140 001a  	;			;		;		;			| 
    e43  2a 00 e 0 0 7140 001a  	;			;		;		mabr, lab, a, hi;	| * 1 / r[7].
    e44  2b 00 e 0 0 7140 001a  	;			;		;		;			| 
    e45  2a 00 e 0 0 7140 0018  	;			;		;		mabr, lab, hi;		| * 1 / r[7].
    e46  2b 00 e 0 0 7140 0018  	;			;		;		;			| 
    e47  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    e48  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    e49  2a 00 e 0 0 7140 0124  	;			;		;		adda,la, m, hi;		| 
    e4a  29 0e e 0 b c3d4 0124  	add2nw 1, r[20], r[27];	am->fpdp;	;		;			| 
    e4b  2a 00 e 0 0 7140 0125  	;			;		;		adda,la, m, st, hi;		| store r[11].
    e4c  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+	| 
    e4d  2a 00 e 0 0 7140 0125  	;			;		;		adda,la, m, st, hi;		| store r[23].
    e4e  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+	| 
    e4f  28 0c e 0 b c3d4 0121  	add2nw 1, r[20], r[27];	am->fpap;	;		adda,la, st, hi;		| store r[25].
    e50  29 0d e 0 b c5d4 0121  	add2nw 2, r[20], r[27];	am->fpbp;	;		;			| 
    e51  02 37 e 0 0 d8c0 0000  	movw,s d, r[0];		fpregh->am;	;		;			| 
                                |	add2nw 1, r[20], r[27];	am->fpdp;	cjp, ~neg p3dxok1; ;			| 
    e52  08 0e 3 7 b c3d4 0e54  	add2nw 1, r[20], r[27];	am->fpdp;	cjp, go p3dxok1; ;			| 
    e53  0a 0b e 0 0 ffc0 0000  	bclrw 15, r[0], r[0];	am->fpregh;	;		;			| 
    e54  2a 00 e 0 0 cf80 0270  p3dxok1: mov2nw 7, r[0];	;		;		lmode rz, ai, flow, fast;| 
    e55  02 37 e 0 0 86c6 0000  	andw,s d, r[6], acc;	fpregh->am;	;		;			| 
    e56  0a 00 3 0 5 8000 0e58  	subw r[0], acc, acc;	;		cjp, zer p3xmn2; ;		bp+	| r[11] / 2
    e57  0a 0b e 0 0 a105 0000  	romw 0, d, acc, r[5]; am->fpregh;	;		;			| 
    e58  0a 28 e 0 0 9494 0003  p3xmn2:	addw r[20], 5, y;		3->brreg;	;		;			| 
    e59  0a 0e e 0 0 0005 0000  	;			am->fpdp;	;		;			| 
    e5a  0a 0b e 0 0 d84b 0000  	movw r[11], y;		am->fpregh;	;		;			| saveddx + (r[11] / 2)
    e5b  0b 0b e 0 6 d84a 0000  	movw r[10], y;		am->fpregl;	;		;		dp+	| 
    e5c  0a 0b e 0 0 d857 0000  	movw r[23], y;		am->fpregh;	;		;			| saveddx + (r[11] / 2)
    e5d  0b 0b e 0 6 d858 0000  	movw r[24], y;		am->fpregl;	;		;		dp+	| 
    e5e  0a 0b e 0 0 d859 0000  	movw r[25], y;		am->fpregh;	;		;			| saveddx + (r[11] / 2)
    e5f  0b 0b e 0 0 d85a 0000  	movw r[26], y;		am->fpregl;	;		;			| 
    e60  28 0e e 0 b c5d4 0110  	add2nw 2, r[20], r[27];	am->fpdp;	;		adda, lab, hi;		| pxmn += r[11] / 2
    e61  3b 00 4 7 6 7140 0110  	;			;		push, go;	;		dp+	| 
    e62  1a 27 8 0 0 7140 0003  	;			3->am;		rfct;		;			| 
    e63  2a 00 e 0 0 7140 0102  	;			;		;		adda, a, hi;		| 
    e64  2b 00 e 0 0 f8e0 0102  	movw =p3xmn3, y;	;		;		;			| 
    e65  2a 08 e 0 0 0e6a 0101  	;			am->brreg;	;		adda, st, hi;		| Store pxmn.
    e66  39 0e 3 0 b c3d4 0101  	add2nw 1, r[20], r[27];	am->fpdp;	cjp, zer;	;			| 
    e67  0a 37 e 0 0 86c6 0000  	andw d, r[6], acc;	fpregh->am;	;		;			| 
    e68  0a 00 e 0 0 8080 0000  	addw r[0], acc, acc;	;		;		;			| Restore r[11] * 2
    e69  0a 0b e 0 0 a105 0000  	romw 0, d, acc, r[5]; am->fpregh;	;		;			| 
    e6a  08 27 e 0 b 9e94 0008  p3xmn3:	addw d, r[20], r[27];	8->am;	;		;			| 
    e6b  0a 0c 3 7 0 d85b 0dda  	movw r[27], y;		am->fpap;	cjp, go p3iedge; ;			| 
                                |   Sort edge table on r[9] and on r[12] secondarily.
                                |   Bubble sort (?) for now.
                                |   From here on acc stores 8.
    e6c  0a 2c e 0 0 d903 0002  p3sort:	movw 0, r[3];		2->fpap;	;		;			| Assume non-empty edge table.  do {
    e6d  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    e6e  0a 27 e 0 0 f8c1 0008  	movw d, acc;		8->am;	;		;			| 
    e6f  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[20]= r[14]->r[18]
    e70  0b 37 e 0 0 d8d4 0000  	movw d, r[20];		fpregl->am;	;		;			| 
    e71  0a 0c e 0 0 9094 0000  p3sort0: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    e72  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    e73  0a 0c 3 0 0 d854 0e97  	movw r[20], y;		am->fpap;	cjp, zer p3dowhile; ;			| 
    e74  0a 37 e 0 0 d8c9 0000  	movw d, r[9];		fpregh->am;	;		;			| if (r[20]->r[9] > r[20]->r[18]->r[9]) {
    e75  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| &r[20]->r[18]
    e76  0b 37 e 0 0 d8d1 0000  	movw d, r[17];		fpregl->am;	;		;			| r[17]= r[20]->r[18]
    e77  0b 3c e 0 0 7140 0000  	;			fpregl->fpap;	;		;			| &r[20]->next->r[9]
    e78  02 37 e 0 0 9649 0000  	rsubw,s d, r[9], y;	fpregh->am;	;		;			| r[20]->r[9] > r[20]->r[18]->r[9]
    e79  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| 
    e7a  0a 0c 3 9 0 9694 0e83  	addw d, r[20], y;		am->fpap;	cjp, ~neg p3sortx; ;			| r[20]->r[12]
    e7b  0a 0c e 0 0 9091 0000  p3swaps: addw r[17], acc, y;	am->fpap;	;		;			| r[20]->r[18]= r[20]->r[18]->r[18]
    e7c  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| 
    e7d  0b 3b e 0 0 7140 0000  	;			fpregl->fpregl;	;		;			| 
    e7e  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[17]->r[18]= r[14]->r[18]
    e7f  0a 0e e 0 0 9091 0000  	addw r[17], acc, y;	am->fpdp;	;		;			| 
    e80  0b 3b e 0 0 dd03 0000  	incw 0, r[3];		fpregl->fpregl;	;		;			| r[3]= 1
    e81  0a 0e e 0 0 908e 0000  	addw r[14], acc, y;	am->fpdp;	;		;			| r[14]->r[18]= r[17]
    e82  0b 0b 3 7 0 d851 0e93  	movw r[17], y;		am->fpregl;	cjp, go p3sort1; ;			| 
    e83  0a 37 3 8 0 d8cc 0e93  p3sortx: movw d, r[12];		fpregh->am;	cjp, ~zer p3sort1; ;			| r[20]->r[12]
    e84  0b 37 e 0 0 d8ca 0000  	movw d, r[10];		fpregl->am;	;		;			| 
    e85  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| 
    e86  0a 0c e 0 0 9691 0000  	addw d, r[17], y;	am->fpap;	;		;			| r[20]->r[18]->r[12]
    e87  02 37 e 0 0 970c 0000  	xorw,s d, r[12], y;	fpregh->am;	;		;			| if (r[20]->r[12] > r[20]->r[18]->r[12]) {
    e88  02 37 3 9 0 f8c0 0e8b  	movw,s d, y;		fpregh->am;	cjp, ~neg p3same2; ;			| Start by comparing signs.
    e89  0a 00 3 1 0 7140 0e7b  	;			;		cjp, neg p3swaps; ;			| If different then sign of b is (a>b)
    e8a  0a 00 3 9 0 7140 0e93  	;			;		cjp, ~neg p3sort1; ;			| 
    e8b  0b 37 3 9 0 960a 0e90  p3same2: subw d, r[10], y;	fpregl->am;	cjp, ~neg p3samepos2; ;			| 
    e8c  02 37 e 0 0 962c 0000  	subcw,s d, r[12], y;	fpregh->am;	;		;			| 
    e8d  0a 00 3 0 0 7140 0e93  	;			;		cjp, zer p3sort1; ;			| 
    e8e  0a 00 3 a 0 7140 0e7b  	;			;		cjp, ~cry p3swaps; ;			| 
    e8f  0a 00 3 2 0 7140 0e93  	;			;		cjp, cry p3sort1; ;			| 
    e90  02 37 e 0 0 962c 0000  p3samepos2: subcw,s d, r[12], y; fpregh->am;	;		;			| 
    e91  0a 00 3 0 0 7140 0e93  	;			;		cjp, zer p3sort1; ;			| 
    e92  0a 00 3 2 0 7140 0e7b  	;			;		cjp, cry p3swaps; ;			| 
    e93  0a 0c e 0 0 908e 0000  p3sort1: addw r[14], acc, y;	am->fpap;	;		;			| r[14]= r[14]->r[18]
    e94  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    e95  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[20]= r[14]->r[18]
    e96  03 37 3 7 0 d8d4 0e71  	movw,s d, r[20];		fpregl->am;	cjp, go p3sort0; ;			| 
    e97  02 00 e 0 0 d843 0000  p3dowhile: movw,s r[3], y;	;		;		;			| } while (r[3])
    e98  0a 00 3 8 0 7140 0e6c  	;			;		cjp, ~zer p3sort; ;			| 
                                |   Ready to draw segments.
    e99  02 00 e 0 0 d850 0000  	movw,s r[16], y;	;		;		;			| 
    e9a  0a 00 3 0 0 7140 0eb1  	;			;		cjp, zer p3rdydraw; ;			| 
    e9b  0a 27 e 0 0 7140 0013  p3inipp: ;			19->am;		;		;			| 
    e9c  0a 06 3 c 0 f8c0 0e9c  	movw d, y;		am->fifo1;	cjp, f1f .;	;			| Send plhinit command (#19) to pp.
    e9d  08 00 e 0 0 cc8f 0000  	sr0w r[15], r[0];	;		;		;			| 
    e9e  0a 27 e 0 0 9ec0 000f  	andw d, r[0], r[0];	0xf->am;	;		;			| 
                                | PIXOP_NEEDS_DST (op << 1)= (op^(op << 1)) & 0xa
    e9f  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| 
    ea0  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
    ea1  0a 00 e 0 0 8100 0000  	xorw r[0], acc, acc;	;		;		;			| 
    ea2  02 27 e 0 0 e281 000a  	addw,s d, acc, acc;	0xa->am;	;		;			| 
    ea3  0a 00 3 0 0 7140 0ea6  	;			;		cjp, zer p3nodst; ;			| 
    ea4  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| SWWPIX
    ea5  0a 00 3 7 0 7140 0ea7  	;			;		cjp, go p3ropreg; ;			| 
    ea6  0a 27 e 0 0 7140 0001  p3nodst: ;			1->am;		;		;			| SRWPIX
    ea7  0a 06 3 c 0 f8c0 0ea7  p3ropreg: movw d, y;		am->fifo1;	cjp, f1f .;	;			| RopMode
    ea8  0a 06 3 c 0 d840 0ea8  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| Op
    ea9  0a 06 3 c 0 f900 0ea9  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Patt
    eaa  0a 06 3 c 0 f900 0eaa  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Mask2
    eab  0a 06 3 c 0 f900 0eab  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Mask1
    eac  0a 06 3 c 0 f900 0eac  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| r[14]
    ead  0a 06 3 c 0 f900 0ead  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| OpCnt
    eae  0a 06 3 c 0 f900 0eae  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Shift
    eaf  0a 06 3 c 0 f900 0eaf  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| PrimeSrc2
    eb0  0a 27 e 0 0 f8c1 0008  	movw d, acc;		8->am;	;		;			| 
    eb1  0a 2c e 0 0 7140 0002  p3rdydraw: ;			2->fpap;	;		;			| r[14]= et[0].r[18]
    eb2  0b 37 e 0 0 7140 0000  	;			fpregl->am;	;		;			| 
    eb3  0a 0c e 0 0 e280 0000  	addw d, acc, y;		am->fpap;	;		;			| 
    eb4  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    eb5  0a 27 e 0 0 d8d1 07d0  	movw d, r[17];		2000->am;	;		;			| r[17]= aet
    eb6  0a 0c e 0 0 d84e 0000  	movw r[14], y;		am->fpap;	;		;			| r[13]= r[14]->r[9] + 0x8000
    eb7  0a 37 e 0 0 d8cd 0000  	movw d, r[13];		fpregh->am;	;		;			| 
    eb8  0a 0e e 0 0 9091 0000  	addw r[17], acc, y;	am->fpdp;	;		;			| r[17]->r[18]= 0
    eb9  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
                                |   Repeat until aet and et are empty.
                                |   Get current edges out of edge table (et) and put in active edge table.
    eba  08 28 e 0 4 d971 0edc  p3do:	movw r[17], r[20];		=p3paint->brreg; ;		;			| r[20]= r[17]
    ebb  02 0c e 0 0 d84e 0000  p3whily: movw,s r[14], y;		am->fpap;	;		;			| while (r[14] && (r[14]->r[9] <= r[13])) {
    ebc  12 37 3 0 0 960d 0000  	subw,s d, r[13], y;	fpregh->am;	cjp, zer;	;			| (r[14]->r[9] <= r[13])
    ebd  1a 27 3 1 0 7140 0005  	;			5->am;		cjp, neg;	;			| save r[14]->r[12]
    ebe  0a 0c e 0 0 968e 0000  	addw d, r[14], y;		am->fpap;	;		;			| 
    ebf  0a 37 e 0 0 d8cc 0000  	movw d, r[12];		fpregh->am;	;		;			| 
    ec0  0b 37 e 0 0 d8ca 0000  	movw d, r[10];		fpregl->am;	;		;			| 
    ec1  0a 0c e 0 0 9094 0000  p3whilx: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18] && (
    ec2  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| test r[20]->r[18] for 0
    ec3  0a 00 3 0 0 7140 0ed3  	;			;		cjp, zer p3etaet; ;			| 
    ec4  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| 
    ec5  0a 0c e 0 0 9692 0000  	addw d, r[18], y;		am->fpap;	;		;			| r[20]->r[18]->r[12]
    ec6  02 37 e 0 0 970c 0000  	xorw,s d, r[12], y;	fpregh->am;	;		;			| while( && (r[20]->r[18]->r[12](a) < r[14]->r[12](b)))
    ec7  02 37 3 9 0 f8c0 0eca  	movw,s d, y;		fpregh->am;	cjp, ~neg p3same; ;			| Start by comparing signs.
    ec8  0a 00 3 9 0 7140 0ed3  	;			;		cjp, ~neg p3etaet; ;			| If different then sign of a is (a<b)
    ec9  0a 00 3 1 0 7140 0ed2  	;			;		cjp, neg p3whilx0; ;			| 
    eca  0b 37 3 9 0 964a 0ecf  p3same:	rsubw d, r[10], y;	fpregl->am;	cjp, ~neg p3samepos; ;			| Do a-b
    ecb  02 37 e 0 0 966c 0000  	rsubcw,s d, r[12], y;	fpregh->am;	;		;			| a and b same sign, but negative.
    ecc  0a 00 3 0 0 7140 0ed3  	;			;		cjp, zer p3etaet; ;			| 
    ecd  0a 00 3 a 0 7140 0ed3  	;			;		cjp, ~cry p3etaet; ;			| 
    ece  0a 00 3 2 0 7140 0ed2  	;			;		cjp, cry p3whilx0; ;			| 
    ecf  02 37 e 0 0 966c 0000  p3samepos: rsubcw,s d, r[12], y; fpregh->am;	;		;			| 
    ed0  0a 00 3 0 0 7140 0ed3  	;			;		cjp, zer p3etaet; ;			| 
    ed1  0a 00 3 2 0 7140 0ed3  	;			;		cjp, cry p3etaet; ;			| 
    ed2  08 00 3 7 4 d972 0ec1  p3whilx0: movw r[18], r[20];		;		cjp, go p3whilx; ;			| { r[20]= r[20]->r[18] }
    ed3  08 00 e 0 3 d972 0000  p3etaet: movw r[18], r[19];		;		;		;			| r[19]= r[20]->r[18]
    ed4  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| r[20]->r[18]= r[14]
    ed5  0b 0b e 0 0 d84e 0000  	movw r[14], y;		am->fpregl;	;		;			| 
    ed6  0a 07 e 0 0 d84e 0000  	movw r[14], y;		am->am;		;		;			| 
    ed7  0a 00 e 0 0 d8d2 0000  	movw d, r[18];		;		;		;			| 
    ed8  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[14]= r[14]->r[18]
    ed9  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    eda  0a 0e e 0 0 9092 0000  	addw r[18], acc, y;	am->fpdp;	;		;			| r[20]->r[18]->r[18]= r[19]
    edb  0b 0b 3 7 0 d853 0ebb  	movw r[19], y;		am->fpregl;	cjp, go p3whily; ;			| }
                                |   Paint the current scanline segments.  We are guaranteed that the edges come in pairs.
                                |   p3paint: addw r[17], acc, y;	am->fpap;	;		;			| r[20]= r[17]->r[18]
    edc  0a 0c e 0 0 9091 0000  p3paint: addw r[17], acc, y;	am->fpap;	;		;			| r[20]= r[17]->r[18]
    edd  03 37 e 0 0 d8d4 0000  	movw,s d, r[20];		fpregl->am;	;		;			| 
    ede  0a 0c 3 0 0 9094 0f79  p3whp1:	addw r[20], acc, y;	am->fpap;	cjp, zer p3remactive; ;			| while (r[20]) {  There are more edges
    edf  0b 37 e 0 0 d8d3 0000  	movw d, r[19];		fpregl->am;	;		;			| 
    ee0  02 28 e 0 0 f1f0 0ee6  	btstw,s 8, r[16];	=p3ppnohse->brreg; ;		;			| 
    ee1  12 28 3 0 0 e1f0 0eea  	btstw,s 0, r[16];	=p3ppcmd->brreg; cjp, zer;	;			| 
    ee2  12 27 3 8 0 f3f0 0019  	btstw,s 9, r[16];	 25->am;	cjp, ~zer;	;			| 3D shaded.
    ee3  12 27 3 8 0 f5f0 001c  	btstw,s 10, r[16];	28->am;	cjp, ~zer;	;			| 3D 1-bit texture
    ee4  1a 27 3 8 0 7140 001d  	;			29->am;	cjp, ~zer;	;			| 3D 8-bit texture
    ee5  1a 27 3 7 0 7140 0019  	;			 25->am;	cjp, go;	;			| 3D solid.
    ee6  12 27 3 8 0 f3f0 0018  p3ppnohse: btstw,s 9, r[16];  24->am;	cjp, ~zer;	;			| 2D shaded
    ee7  12 27 3 8 0 f5f0 001c  	btstw,s 10, r[16];	28->am;	cjp, ~zer;	;			| 2D 1-bit texture
    ee8  1a 27 3 8 0 7140 001d  	;			29->am;	cjp, ~zer;	;			| 2D 8-bit texture
    ee9  0a 27 e 0 0 7140 0016  	;			22->am;	;		;			| 2D solid
                                |   Args to plhsh:    r[13], x1, x2, op, zhi, dzhi, r[24], chi, dchi, r[26] (Solid: dchi = r[26] = 0)
                                |   Args to plgsh:    r[13], x1, x2, op, chi, dchi, r[26]
                                |   Args to plgtex1:  r[13], x1, x2, color, color0, op, r[21], r[22]
                                |   Args to plgtex8:  r[13], x1, x2, op, r[21], r[22]
                                |   Args to plgfill:  r[13], x1, x2, color, op
    eea  0a 06 3 c 0 f8c0 0eea  p3ppcmd: movw d, y;		am->fifo1;	cjp, f1f .;	;			| Send command to fifo
    eeb  0a 06 3 c 0 d84d 0eeb  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    eec  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| Offset from r[20].
    eed  0a 2d e 0 0 7140 0010  	;			0x10->fpbp;	;		;			| 
                                |   First pixel x1= trunc (x + .4999 + r[11]/2)
    eee  2b 0c e 0 0 9694 0270  	addw d, r[20], y;		am->fpap;	;		lmode rz, ai, pipe, fast;| x1= r[20]->r[12]
    eef  0a 00 e 0 0 7140 0000  	;			;		;		;			| 
    ef0  2a 00 e 0 0 7140 0110  	;			;		;		adda, lab, hi;		| x1 + 0.5
    ef1  2b 0c e 0 0 9693 0110  	addw d, r[19], y;		am->fpap;	;		;			| 
    ef2  2a 00 e 0 0 7140 0110  	;			;		;		adda, lab, hi;		| x2 + 0.5
    ef3  2b 00 e 0 0 7140 0110  	;			;		;		;			| 
    ef4  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    ef5  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    ef6  2a 0c e 0 0 9694 0120  	addw d, r[20], y;		am->fpap;	;		adda,la, hi;			| 
    ef7  2b 0d e 0 0 9693 0120  	addw d, r[19], y;		am->fpbp;	;		;			| 
    ef8  2a 00 e 0 0 7140 0192  	;			;		;		rsuba, lab, a, hi;	| x2 - x1
    ef9  2b 00 e 0 0 7140 0192  	;			;		;		;			| 
    efa  2a 00 e 0 0 7140 00ea  	;			;		;		fixr, la, a, hi;	| x1
    efb  2b 00 e 0 0 7140 00ea  	;			;		;		;			| 
    efc  2a 00 e 0 0 7140 00e8  	;			;		;		fixr, la, hi;		| x2
    efd  2b 00 e 0 7 7140 00e8  	;			;		;		;		abp+	| 
    efe  2a 00 e 0 0 7140 0190  	;			;		;		rsuba, lab, hi;		| z2 - z1
    eff  2b 00 e 0 0 7140 0190  	;			;		;		;			| 
    f00  2a 00 e 0 0 7140 00e2  	;			;		;		fixa, la, a, hi;	| z1
    f01  2b 0e e 0 7 f900 00e2  	movw 0, y;		am->fpdp;	;		;		abp+	| 
    f02  2a 00 e 0 0 7140 0193  	;			;		;		rsuba, lab, a, st, hi;	| 0:  Store x2 - x1.  c2 - c1
    f03  2b 00 e 0 6 7140 0193  	;			;		;		;		dp+	| 
    f04  2a 00 e 0 0 7140 00e3  	;			;		;		fixa, la, a, st, hi;	| 1:  (int) x1.  Fix c1
    f05  2b 00 e 0 6 7140 00e3  	;			;		;		;		dp+	| 
    f06  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 2:  (int) x2
    f07  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f08  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 3:  z2 - z1
    f09  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f0a  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 4:  (int) z1
    f0b  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f0c  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 5:  c2 - c1
    f0d  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f0e  2a 0c e 0 0 fd00 0123  	incw 0, y;		am->fpap;	;		adda,la, a, st, hi;		| 6:  (int) c1
    f0f  2b 00 e 0 0 7140 0123  	;			;		;		;			| 
    f10  0b 37 e 0 0 dccc 0000  	incw d, r[12];		fpregl->am;	;		;			| Save r[12] for use by r[21] at p3texoff
    f11  0a 06 3 c 0 d84c 0f11  	movw r[12], y;		am->fifo1;	cjp, f1f .;	;			| x1
    f12  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+	| 
    f13  0b 37 e 0 0 dcc0 0000  	incw d, r[0];		fpregl->am;	;		;			| 
    f14  0a 06 3 c 0 d840 0f14  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| x2
    f15  02 00 e 0 0 d850 0000  	movw,s r[16], y;	;		;		;			| 
    f16  02 00 3 0 0 e1f0 0f1b  	btstw,s 0, r[16];	;		cjp, zer p3colorop; ;			| 
    f17  02 00 3 8 0 f5f0 0f21  	btstw,s 10, r[16];	;		cjp, ~zer p3notsld2d; ;			| 
    f18  02 00 3 8 0 f3f0 0f21  	btstw,s 9, r[16];	;		cjp, ~zer p3notsld2d; ;			| 
    f19  0a 00 3 8 0 7140 0f1b  	;			;		cjp, ~zer p3colorop; ;			| 
    f1a  0a 00 3 7 0 7140 0f21  	;			;		cjp, go p3notsld2d; ;			| 
    f1b  08 00 e 0 0 97ef 0000  p3colorop: rolw 11, r[15], r[0]; ;		;		;			| Color from op for Solid 2D and tex 1.
    f1c  0a 27 e 0 0 9ec0 07ff  	andw d, r[0], r[0];	0x7ff->am;	;		;			| 
    f1d  0a 06 3 c 0 d840 0f1d  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    f1e  02 00 e 0 0 f3f0 0000  	btstw,s 9, r[16];	;		;		;			| 
    f1f  0a 00 3 0 0 7140 0f21  	;			;		cjp, zer p3notsld2d; ;			| 
    f20  0a 06 3 c 0 f900 0f20  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| color0.
    f21  08 27 e 0 0 9ecf 001f  p3notsld2d: andw d, r[15], r[0]; 0x1f->am;	;		;			| 
    f22  0a 06 3 c 0 d840 0f22  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| Op
    f23  02 00 e 0 0 d850 0000  	movw,s r[16], y;	;		;		;			| 
    f24  02 00 3 0 0 f3f0 0f2e  	btstw,s 9, r[16];	;		cjp, zer p3nexte; ;			| Finished Solid 2D segment. Go set fpap.
    f25  02 00 3 8 0 f5f0 0f28  	btstw,s 10, r[16];	;		cjp, ~zer p3texoff; ;			| 
    f26  0a 00 3 8 0 7140 0f28  	;			;		cjp, ~zer p3texoff; ;			| 
    f27  0a 00 3 7 0 7140 0f2f  	;			;		cjp, go p3notex; ;			| 
    f28  0a 07 e 0 0 d84c 0000  p3texoff: movw r[12], y;		am->am;		;		;			| 
    f29  08 00 e 0 b 9e95 0000  	addw d, r[21], r[27];	;		;		;			| 
    f2a  0a 06 3 c 0 d85b 0f2a  	movw r[27], y;		am->fifo1;	cjp, f1f .;	;			| 
    f2b  0a 07 e 0 0 d84d 0000  	movw r[13], y;		am->am;		;		;			| 
    f2c  08 00 e 0 b 9e96 0000  	addw d, r[22], r[27];	;		;		;			| 
    f2d  0a 06 3 c 0 d85b 0f2d  	movw r[27], y;		am->fifo1;	cjp, f1f .;	;			| 
    f2e  0a 0c 3 7 0 9093 0f76  p3nexte: addw r[19], acc, y;	am->fpap;	cjp, go p3nxtedge; ;			| Finished textured 2D segment. Set fpap.
    f2f  0a 2c e 0 0 7140 0004  p3notex: ;			4->fpap;	;		;			| 2D Shaded, 3D HSE or shaded.
    f30  02 00 e 0 0 f1f0 0000  	btstw,s 8, r[16];	;		;		;			| 
    f31  0a 00 3 0 0 7140 0f3a  	;			;		cjp, zer p3recip; ;			| 
    f32  0a 37 e 0 0 b020 0000  	rolw 8, d, r[0];	fpregh->am;	;		;			| Shift z up from 23 bits to 32 bits.
    f33  0b 37 e 0 0 b120 0000  	romw 8, d, r[0], 0xff;	fpregl->am;	;		;			| 
    f34  0a 00 e 0 0 00ff 0000  	;			;		;		;			| 
    f35  0b 37 e 0 0 b021 0000  	rolw 8, d, r[1];	fpregl->am;	;		;			| 
    f36  0a 27 e 0 0 9ec1 ff00  	andw d, r[1], r[1];	0xff00->am;	;		;			| 
    f37  0a 27 e 0 0 9e81 7fff  	addw d, r[1], r[1];	0x7fff->am;	;		;			| add 0.5
    f38  0a 27 e 0 0 9ea0 0000  	addcw d, r[0], r[0];	0->am;		;		;			| 
    f39  0a 06 3 c 0 d840 0f39  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| zhi
                                |	movw r[1], y;		am->fifo1;	cjp, f1f .;	;			| zlo
    f3a  0a 2c e 0 0 7140 0000  p3recip: ;			0->fpap;	;		;			| 
    f3b  0a 2e e 0 0 dd02 0000  	incw 0, r[2];		0->fpdp;	;		;			| Store recip in fpreg [1]
    f3c  0a 00 1 7 0 7140 034c  	;			;		cjs, go recip;	;			| 
    f3d  0a 27 e 0 0 f8c1 0008  	movw d, acc;		8->am;	;		;			| Restore accumulator value.
    f3e  0a 2d e 0 0 7140 0003  	;			3->fpbp;	;		;			| 
    f3f  2b 0c e 0 0 fd00 0270  	incw 0, y;		am->fpap;	;		lmode rz, ai, pipe, fast;| 
    f40  0a 0e e 0 0 fd00 0000  	incw 0, y;		am->fpdp;	;		;			| 
    f41  2a 00 e 0 0 f8e0 0010  	movw 5, y;		;		;		maba, lab, hi;		| (z2 - z1) * 1 / (x2 - x1)
    f42  2b 0d e 0 0 0005 0010  	;			am->fpbp;	;		;			| 
    f43  2a 00 e 0 0 7140 0010  	;			;		;		maba, lab, hi;		| (c2 - c1) * 1 / (x2 - x1)
    f44  2b 00 e 0 0 7140 0010  	;			;		;		;			| 
    f45  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    f46  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    f47  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    f48  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    f49  2a 0e e 0 0 f900 0124  	movw 0, y;		am->fpdp;	;		adda,la, m, hi;		| 
    f4a  2b 00 e 0 0 7140 0124  	;			;		;		;			| 
    f4b  2a 00 e 0 0 7140 00ec  	;			;		;		fixr, la, m, hi;	| 
    f4c  2b 00 e 0 0 7140 00ec  	;			;		;		;			| 
    f4d  2a 00 e 0 0 7140 00e8  	;			;		;		fixr, la, hi;		| 
    f4e  2b 00 e 0 0 7140 00e8  	;			;		;		;			| 
    f4f  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    f50  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    f51  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    f52  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    f53  2a 00 e 0 0 7140 0122  	;			;		;		adda,la, a, hi;		| 
    f54  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    f55  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| r[23]
    f56  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f57  2a 00 e 0 0 7140 0121  	;			;		;		adda,la, st, hi;		| r[25]
    f58  2b 0c e 0 0 f900 0121  	movw 0, y;		am->fpap;	;		;			| 
    f59  02 00 e 0 0 f1f0 0000  	btstw,s 8, r[16];	;		;		;			| 
    f5a  0a 37 3 0 0 b020 0f61  	rolw 8, d, r[0];	fpregh->am;	cjp, zer p3color; ;			| Shift r[23] up from 23 bits to 32 bits.
    f5b  0b 37 e 0 0 b120 0000  	romw 8, d, r[0], 0xff;	fpregl->am;	;		;			| 
    f5c  0a 00 e 0 0 00ff 0000  	;			;		;		;			| 
    f5d  0a 06 3 c 0 d840 0f5d  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| dzhi
    f5e  0b 37 e 0 0 b021 0000  	rolw 8, d, r[1];	fpregl->am;	;		;			| 
    f5f  0a 27 e 0 0 9ec1 ff00  	andw d, r[1], r[1];	0xff00->am;	;		;			| 
    f60  0a 06 3 c 0 d841 0f60  	movw r[1], y;		am->fifo1;	cjp, f1f .;	;			| r[24]
    f61  02 2c e 0 0 e1f0 0006  p3color: btstw,s 0, r[16];	6->fpap;	;		;			| c= fpreg [5].
    f62  0a 00 3 8 0 7140 0f69  	;			;		cjp, ~zer p3shade; ;			| 
                                |   Reached only if r[16] == 0x100.
    f63  08 27 e 0 0 97ef 07ff  	rolw 11, r[15], r[0]; 0x7ff->am;	;		;			| 
    f64  0a 06 3 c 0 96c0 0f64  	andw d, r[0], y;	am->fifo1;	cjp, f1f .;	;			| Color hi is taken from op. (shift rt. 5).
    f65  0a 06 3 c 0 f900 0f65  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Color low.
    f66  0a 06 3 c 0 f900 0f66  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| dchi
    f67  0a 06 3 c 0 f900 0f67  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| r[26]
    f68  0a 0c 3 7 0 9093 0f76  	addw r[19], acc, y;	am->fpap;	cjp, go p3nxtedge; ;			| r[20]= r[19]->r[18]
                                |   Shadestyles 0x101 and 1.
    f69  0b 37 e 0 0 d8c1 0000  p3shade: movw d, r[1];	fpregl->am;	;		;			| 
    f6a  0a 37 e 0 0 d8c0 0000  	movw d, r[0];		fpregh->am;	;		;			| 
    f6b  0a 00 e 0 0 cfc0 0000  	add2nw 7, r[0];	;		;		;			| add 2**23 to color. (undoes xfpolygon3.vp)
    f6c  0a 27 e 0 0 9e81 7fff  	addw d, r[1], r[1];	0x7fff->am;	;		;			| add 0.5
    f6d  0a 27 e 0 0 9ea0 0000  	addcw d, r[0], r[0]; 0->am;		;		;			| 
    f6e  0a 06 3 c 0 d840 0f6e  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| c1.  color hi.
    f6f  0a 06 3 c 0 d841 0f6f  	movw r[1], y;		am->fifo1;	cjp, f1f .;	;			| color lo.
    f70  0a 2c e 0 0 7140 0001  	;			1->fpap;	;		;			| 
    f71  0b 37 e 0 0 d8c1 0000  	movw d, r[1];		fpregl->am;	;		;			| 
    f72  0a 37 e 0 0 d8c0 0000  	movw d, r[0];		fpregh->am;	;		;			| 
    f73  0a 06 3 c 0 d840 0f73  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| dchi
    f74  0a 06 3 c 0 d841 0f74  	movw r[1], y;		am->fifo1;	cjp, f1f .;	;			| r[26].
    f75  0a 0c e 0 0 9093 0000  	addw r[19], acc, y;	am->fpap;	;		;			| r[20]= r[19]->r[18]
    f76  03 37 e 0 0 d8d4 0000  p3nxtedge: movw,s d, r[20];	fpregl->am;	;		;			| Must have fpap= r[19] + acc = r[19]->r[18]
    f77  0a 0c 3 0 0 9094 0f79  	addw r[20], acc, y;	am->fpap;	cjp, zer p3remactive; ;			| if (r[20]) r[19]= r[20]->r[18].  NB while (r[20])
    f78  0b 37 3 7 0 d8d3 0ede  	movw d, r[19];		fpregl->am;	cjp, go p3whp1;	;			| 
                                |   Remove active edges whose ymax <= r[13]
    f79  0a 00 e 0 0 dd6d 0000  p3remactive: incw r[13], r[13];	;		;		;			| r[13]++.  Step to next scanline
    f7a  08 00 e 0 4 d971 0000  	movw r[17], r[20];		;		;		;			| r[20]= r[17]
    f7b  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    f7c  03 37 e 0 0 d8d2 0000  p3remwh: movw,s d, r[18];		fpregl->am;	;		;			| 
    f7d  0a 0c 3 0 0 dc52 0f84  	incw r[18], y;		am->fpap;	cjp, zer p3upx;	;			| if (r[20]->r[18] <= r[13])
    f7e  02 37 e 0 0 960d 0000  	subw,s d, r[13], y;	fpregh->am;	;		;			| 
    f7f  0a 0c 3 1 0 9092 0f82  	addw r[18], acc, y;	am->fpap;	cjp, neg p3step; ;			| r[20]->r[18]= r[20]->r[18]->r[18]
    f80  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| 
    f81  0b 3b 3 7 0 7140 0f7c  	;			fpregl->fpregl;	cjp, go p3remwh; ;			| 
    f82  08 00 e 0 4 d972 0000  p3step:	movw r[18], r[20];		;		;		;			| else r[20]= r[20]->r[18]
    f83  0a 0c 3 7 0 9094 0f7c  	addw r[20], acc, y;	am->fpap;	cjp, go p3remwh; ;			| 
                                |   Update x values in aet
    f84  08 28 e 0 4 d971 0f9c  p3upx:	movw r[17], r[20];		=p3resort->brreg; ;		;			| r[20]= r[17]
    f85  0a 0c e 0 0 9094 0000  p3whupx: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    f86  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    f87  18 27 3 0 4 d972 0005  	movw r[18], r[20];		5->am;		cjp, zer;	;			| r[20]= r[20]->r[18]
    f88  08 0c e 0 b c3d4 0000  	add2nw 1, r[20], r[27];	am->fpap;	;		;			| r[20]->r[12] += r[20]->r[11]
    f89  08 0d e 0 b 9e94 0000  	addw d, r[20], r[27];	am->fpbp;	;		;			| r[12].
    f8a  2a 0e e 0 0 d85b 0110  	movw r[27], y;		am->fpdp;	;		adda, lab, hi;		| r[20]->r[12] += r[20]->r[11]
    f8b  2b 00 e 0 7 7140 0110  	;			;		;		;		abp+	| 
    f8c  2a 00 e 0 0 7140 0110  	;			;		;		adda, lab, hi;		| r[20]->zmn += r[20]->r[23]
    f8d  2b 00 e 0 7 7140 0110  	;			;		;		;		abp+	| 
    f8e  2a 00 e 0 0 7140 0110  	;			;		;		adda, lab, hi;		| r[20]->cmn += r[20]->r[25]
    f8f  2b 00 e 0 7 7140 0110  	;			;		;		;		abp+	|
    f90  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    f91  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    f92  2a 00 e 0 0 7140 0122  	;			;		;		adda,la, a, hi;		| 
    f93  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    f94  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| r[20]->r[12]
    f95  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f96  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| r[20]->zmn
    f97  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f98  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| r[20]->cmn
    f99  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f9a  0a 28 e 0 0 7140 0f85  	;			=p3whupx->brreg; ;		;			| 
    f9b  1a 28 3 7 0 7140 0f9c  	;			=p3resort->brreg; cjp, go;	;			| 
                                |   Resort on > r[12] because previous step may have crossed edges.
    f9c  08 00 e 0 4 d971 0000  p3resort: movw r[17], r[20];	;		;		;			| r[20]= r[17]
    f9d  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| if (r[20]->r[18])
    f9e  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    f9f  0a 00 3 0 0 7140 0fc9  	;			;		cjp, zer p3whend; ;			| 
    fa0  08 00 e 0 4 d971 0000  p3rsdo:	movw r[17], r[20];		;		;		;			| do { r[20]= r[17]
    fa1  08 00 e 0 3 d972 0000  	movw r[18], r[19];		;		;		;			| r[19]= r[20]->r[18]
    fa2  0a 00 e 0 0 d903 0000  	movw 0, r[3];		;		;		;			| r[3]= 0
    fa3  0a 0c e 0 0 9093 0000  p3whp2nxt: addw r[19], acc, y;	am->fpap;	;		;			| while (r[19]->r[18])
    fa4  03 37 e 0 0 d8c0 0000  	movw,s d, r[0];		fpregl->am;	;		;			| 
    fa5  0a 00 3 0 0 7140 0fc7  	;			;		cjp, zer p3doswap; ;			| 
    fa6  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| if (r[19]->r[12] > r[19]->r[18]->r[12])
    fa7  0a 0c e 0 0 9680 0000  	addw d, r[0], y;	am->fpap;	;		;			| r[19]->r[18]->r[12]
    fa8  0a 37 e 0 0 d8cc 0000  	movw d, r[12];		fpregh->am;	;		;			| 
    fa9  0b 37 e 0 0 d8ca 0000  	movw d, r[10];		fpregl->am;	;		;			| 
    faa  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| r[19]->r[12]
    fab  0a 0c e 0 0 9693 0000  	addw d, r[19], y;		am->fpap;	;		;			| 
    fac  02 37 e 0 0 970c 0000  	xorw,s d, r[12], y;	fpregh->am;	;		;			| if: start by comparing signs.
    fad  02 00 3 9 0 d84c 0fb0  	movw,s r[12], y;	;		cjp, ~neg p3same1; ;			| 
    fae  0a 00 3 1 0 7140 0fb8  	;			;		cjp, neg p3rsthen; ;			| If different then sign of b is (a>b)
    faf  0a 00 3 9 0 7140 0fc3  	;			;		cjp, ~neg p3rselse; ;			| 
    fb0  0b 37 3 9 0 964a 0fb5  p3same1: rsubw d, r[10], y;	fpregl->am;	cjp, ~neg p3samepos1; ;			| Do a-b
    fb1  02 37 e 0 0 966c 0000  	rsubcw,s d, r[12], y;	fpregh->am;	;		;			| a and b same sign, but negative.
    fb2  0a 00 3 0 0 7140 0fc3  	;			;		cjp, zer p3rselse; ;			| 
    fb3  0a 00 3 a 0 7140 0fb8  	;			;		cjp, ~cry p3rsthen; ;			| 
    fb4  0a 00 3 2 0 7140 0fc3  	;			;		cjp, cry p3rselse; ;			| 
    fb5  02 37 e 0 0 966c 0000  p3samepos1: rsubcw,s d, r[12], y; fpregh->am;	;		;			| 
    fb6  0a 00 3 0 0 7140 0fc3  	;			;		cjp, zer p3rselse; ;			| 
    fb7  0a 00 3 a 0 7140 0fc3  	;			;		cjp, ~cry p3rselse; ;			| 
    fb8  0a 0e e 0 0 9094 0000  p3rsthen: addw r[20], acc, y;	am->fpdp;	;		;			| r[20]->r[18]= r[19]->r[18]
    fb9  0b 0b e 0 0 d840 0000  	movw r[0], y;		am->fpregl;	;		;			| 
    fba  0a 0e e 0 0 9093 0000  	addw r[19], acc, y;	am->fpdp;	;		;			| r[19]->r[18]= r[19]->r[18]->r[18]
    fbb  0a 0c e 0 0 9080 0000  	addw r[0], acc, y;	am->fpap;	;		;			| 
    fbc  0b 3b e 0 0 7140 0000  	;			fpregl->fpregl;	;		;			| 
    fbd  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| r[20]->r[18]->r[18]= r[19]
    fbe  0b 37 e 0 0 d8d2 0000  	movw d, r[18];		fpregl->am;	;		;			| 
    fbf  0a 0e e 0 0 9092 0000  	addw r[18], acc, y;	am->fpdp;	;		;			| 
    fc0  0b 0b e 0 0 d853 0000  	movw r[19], y;		am->fpregl;	;		;			| 
    fc1  08 00 e 0 4 d972 0000  	movw r[18], r[20];		;		;		;			| r[20]= r[20]->r[18]
    fc2  0a 00 3 7 0 dd03 0fa3  	incw 0, r[3];		;		cjp, go p3whp2nxt; ;			| r[3]= 1
    fc3  0a 0c e 0 0 9094 0000  p3rselse: addw r[20], acc, y;	am->fpap;	;		;			| r[20]= r[20]->r[18]
    fc4  0b 37 e 0 0 d8d4 0000  	movw d, r[20];		fpregl->am;	;		;			| 
    fc5  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| r[19]= r[20]->r[18]
    fc6  0b 37 3 7 0 d8d3 0fa3  	movw d, r[19];		fpregl->am;	cjp, go p3whp2nxt; ;			| 
    fc7  02 00 e 0 0 d843 0000  p3doswap: movw,s r[3], y;	;		;		;			| } while (r[3])
    fc8  0a 00 3 8 0 7140 0fa0  	;			;		cjp, ~zer p3rsdo; ;			| 
    fc9  0a 0c e 0 0 9091 0000  p3whend: addw r[17], acc, y;	am->fpap;	;		;			| } while (r[17]->r[18] || r[14])
    fca  03 37 e 0 0 f8c0 0000  	movw,s d, y;		fpregl->am;	;		;			| r[17]->r[18]
    fcb  02 00 3 8 0 d84e 0eba  	movw,s r[14], y;		;		cjp, ~zer p3do;	;			| 
    fcc  0a 00 3 8 0 7140 0eba  	;			;		cjp, ~zer p3do;	;			| 
    fcd  1a 00 a 7 0 7140 0000  	;			;		crtn, go;	;			| 
                                | "@(#)multiply.vp.u 1.2 86/09/12 SMI"
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |   Multiplier routine.
                                |   Multiplier arrives in r[2].  It should have fewer one bits than
                                |   multiplicand which arrives in acc.  The result is computed and
                                |   in r[0,1] with the low order bits in r[0].  The algorithm is a
                                |   simple shift-add.  It was chosen because the majority of
                                |   multipliers will not have many bits.
    fce  02 00 e 0 0 9102 0000  multiply: xorw,s r[2], acc, y; ;	;		;			| 
    fcf  0a 00 3 9 0 d904 0fd1  	movw 0, r[4];		;		cjp, ~neg mul;	;			| 
    fd0  0a 00 e 0 0 dd04 0000  	incw 0, r[4];		;		;		;			| 
    fd1  0a 00 e 0 0 d900 0000  mul:	movw 0, r[0];		;		;		;			| Clear.
    fd2  02 28 e 0 0 d842 0fd9  	movw,s r[2], y;	=mul2->brreg;	;		;			| 
    fd3  0a 00 3 9 0 d901 0fd5  	movw 0, r[1];		;		cjp, ~neg mul1;	;			| 
    fd4  0a 00 e 0 0 df62 0000  	negw r[2], r[2]; ;		;		;			| 
    fd5  12 00 a 0 0 f880 0000  mul1:	movw,s acc, y;	;		crtn, zer;	;			| 
    fd6  18 27 3 9 3 d462 0010  	priw r[2], 0, r[3]; 16->am;	cjp, ~neg;	;			| Find highest bit and test r[2].
    fd7  0a 00 e 0 0 7140 0000  	;			;		;		;			| NOP ASSEMBLER BUG WORKAROUND
    fd8  0a 00 e 0 0 fe81 0000  	negw acc, acc;	;		;		;			| 
    fd9  1a 08 a 0 0 9e43 0000  mul2:	rsubw d, r[3], r[3];	am->brreg;	crtn, zer;	;			| Generate number of times for loop.
    fda  12 00 4 7 0 9fe2 0000  	rolw,s 15, r[2], r[2]; ;	push, go;	;			| Shift r[2]. Set carry 0.
                                | Ld cntr.  Push mulloop on stack.
    fdb  0a 00 3 9 0 7140 0fdd  	;			;		cjp, ~neg mulshift; ;			| If bit 15 zero skip addition.
    fdc  02 00 e 0 0 9881 0000  	addw,s r[1], acc, r[1]; ;	;		;			| Add Multiplicand to result.
    fdd  0a 00 e 0 0 cce1 0000  mulshift: srcw r[1], r[1];	;		;		;			| Shift result.
    fde  0a 00 e 0 0 ccc0 0000  	srqw r[0], r[0];	;		;		;			| 
    fdf  12 00 8 0 0 9fe2 0000  	rolw,s 15, r[2], r[2]; ;	rfct;		;			| Shift r[2]. Set carry 0.
    fe0  0a 03 e 0 0 dc43 0000  	incw r[3], y;		am->nreg;	;		;			| 
    fe1  0a 00 e 0 0 d903 0000  	movw 0, r[3];		;		;		;			| 
    fe2  0e 00 e 0 0 e1a3 0000  	bsetw n, r[3];		;		;		;			| 
    fe3  0a 07 e 0 0 c1e3 0000  	sub2nw 0, r[3], r[3];	am->am;		;		;			| 
    fe4  0e 00 e 0 0 81e1 0000  	rolw n, r[1], r[1];	;		;		;			| Rotate right 1 bit.
    fe5  0a 00 e 0 0 d801 0000  	movw r[1], acc;	;		;		;			| 
    fe6  0a 00 e 0 0 9ec1 0000  	andw d, r[1], r[1];	;		;		;			| r[3] is in d.
    fe7  0a 07 e 0 0 d840 0000  	movw r[0], y;		am->am;		;		;			| Save r[0] in d.
    fe8  0e 00 e 0 0 a103 0000  	romw n, d, acc, r[3];	;		;		;			| 
    fe9  02 00 e 0 0 d844 0000  	movw,s r[4], y;		;		;		;			| 
    fea  1a 00 a 0 0 d880 0000  	movw acc, r[0];	;		crtn, zer;	;			| 
    feb  02 00 e 0 0 df60 0000  	negw,s r[0], r[0];	;		;		;			| 
    fec  1a 00 a a 0 db61 0000  	compw r[1], r[1];	;		crtn, ~cry;	;			| 
    fed  1a 00 a 7 0 dd61 0000  	incw r[1], r[1];	;		crtn, go;	;			| 
                                | "@(#)gbuffer.vp.u 1.2 86/09/12"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                |	movw r[29],y;	am->shmemp;	jmap SETZBUF;	;
    fee  0a 17 1 7 0 d8d0 0009  SETZBUF: movw d,r[16];		shmem->am;	cjs,go gb_board_inq;;			  | r[16] <- r[28] for this frame
                                											  | check whether gbuffer is present
    fef  02 00 3 1 0 9110 0ff1  	xorw,s r[16],acc,y;	;		cjp,neg nozbuf;	;			  | if not, goto nozbuf; else if gbuffer is
    ff0  08 0f 3 0 0 d1dd 0ff3  	add2nw 8,r[29],r[16];am->shmemp;	cjp,zer zbuf;	;			  | associated with this frame buffer, goto
                                											  | zbuf; shmemp <- addr of clipping list
    ff1  0a 27 e 0 0 9e9e 0006  nozbuf:	addw d,r[30],r[30];	6->am;		;		;			  | SETZBUF r[0] is invalid; r[30] += 6
    ff2  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;			  | jump to r[0] loop
    ff3  0a 28 e 0 0 f8e1 007d  zbuf:	movw 10,acc;	=wrfifo->brreg;	;		;			  | send 10 command to PP
    ff4  1a 06 1 c 0 000a 0000  	;			am->fifo1;	cjs,f1f;	;
    ff5  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | acc <- # of rectangles & send to PP
    ff6  02 00 4 7 0 e185 0003  setzb1:sub2nw,s 0,acc;		;		push,go 3;	;			  | 4 values in one rectangle.
    ff7  0a 16 3 c 0 7140 0ff7  	;			shmem->fifo1;	cjp,f1f .;	;
    ff8  1a 00 8 0 2 7140 0000  	;			;		rfct;		;		shp+
    ff9  0a 00 3 8 0 7140 0ff6  	;			;		cjp, ~zer setzb1;;
    ffa  1a 27 1 7 0 f8c1 0010  	movw d,acc;		16->am;	cjs,go;		;			  | send 16 command to PP
    ffb  0a 0f 4 7 0 dc5e 0004  	incw r[30],y;		am->shmemp;	push,go 4;	;			  | shmemp <- addr of command args
    ffc  0a 16 3 c 0 7140 0ffc  	;			shmem->fifo1;	cjp,f1f .;	;			  | send 5 args to PP: 16-bit value, screen
    ffd  1a 27 8 0 2 7140 0006  	;			6->am;		rfct;		;		shp+	  | X, screen Y, width, height
    ffe  0a 00 2 0 0 9e9e 0027  	addw d,r[30],r[30];	;		jmap getcmd;	;			  | r[30] += 6; jump to r[0] loop
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)statpixrect.vp.u 1.1 86/09/12 SMI
                                | These routines were moved over to the painting processor's memory bank, due to space considerations on the viewing
                                | processor.  
                                org 0x1000
                                debug off
                                |   Pixinit does alot of the initialization that is common between pr_line, polyline and vec.
   1000  0a 28 e 0 0 f8e1 109c  pixinit: movw  8,acc;	=wrfifo_pp->brreg; ;		;			| 
   1001  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs,f1f;	;
   1002  1a 27 1 7 0 86c0 00ff  	andw d,r[0],acc;		0xFF->am;	cjs,go;		;
   1003  1a 27 1 7 0 f8c1 000a  	movw d,acc;		10->am;	cjs,go;		;
   1004  08 0f e 0 0 c5de 0000  	add2nw 2,r[30],r[16];	am->shmemp;	;		;			| want shmemp to point to rect
   1005  0a 06 3 c 0 fd00 1005  	incw 0, y;		am->fifo1;	cjp,f1f .;	;			| 1 clipping rectangle.
   1006  0a 16 3 c 0 7140 1006  	;			shmem->fifo1;	cjp,f1f .;	;
   1007  0a 17 e 0 2 d8c1 0000  	movw d,r[1];		shmem->am;	;		;		shp+
   1008  0a 16 3 c 0 7140 1008  	;			shmem->fifo1;	cjp,f1f .;	;			| 
   1009  0a 17 c 0 2 d8c2 0001  	movw d,r[2];		shmem->am;	ldct 1;		;		shp+	| 
   100a  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+
   100b  1a 17 3 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjp,go;		;		shp+	| will return from here (cjp)
                                |	;			;		jmap prvec_pp; ;			| 
   100c  0a 00 1 7 0 7140 1000  prvec_pp: ;			;		cjs,go pixinit;	;			| 
   100d  1a 27 1 7 0 f8c1 0009  	movw d,acc;		9->am;		cjs,go;		;
   100e  1a 17 1 7 2 8681 0000  prvec1:	addw d,r[1],acc;	shmem->am;	cjs,go;		;		shp+
   100f  1a 17 1 7 2 8682 0000  	addw d,r[2],acc;	shmem->am;	cjs,go;		;		shp+
   1010  0a 00 9 0 0 7140 100e  	;			;		rpct prvec1;	;
   1011  0a 27 e 0 0 869e 0002  	addw d,r[30],acc;	2->am;		;		;
   1012  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
   1013  0a 16 3 c 0 7140 1013  	;			shmem->fifo1;	cjp,f1f .;	;
   1014  0a 27 e 0 2 9e9e 000c  	addw d,r[30],r[30];	12->am;		;		;		shp+
   1015  0a 16 3 c 0 7140 1015  	;			shmem->fifo1;	cjp,f1f .;	;
   1016  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |	;			;		jmap pr_line_pp; ;			| 
                                pr_line_pp: 
   1017  0a 00 1 7 0 7140 1000  	;			;		cjs,go pixinit;	;			| 
   1018  1a 27 1 7 0 f8c1 001a  	movw d,acc;		26->am;	cjs,go;		;			| pr_line pp command
   1019  1a 17 1 7 2 8681 0000  prtvec1:addw d,r[1],acc;	shmem->am;	cjs,go;		;		shp+
   101a  1a 17 1 7 2 8682 0000  	addw d,r[2],acc;	shmem->am;	cjs,go;		;		shp+
   101b  0a 00 9 0 0 7140 1019  	;			;		rpct prtvec1;	;			| 
   101c  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	| width->fifo1
   101d  0a 17 e 0 2 db00 0000  	compw 0,r[0];	shmem->am;	;		;		shp+	| first pattern segment from shmem
   101e  02 06 3 c 0 f8c0 101e  prtpat:	movw,s d,y;		am->fifo1;	cjp,f1f .;	;			| first segment->fifo1
   101f  0a 17 3 0 2 dd60 1029  	incw r[0],r[0];	shmem->am;	cjp,zer prtsol;	;		shp+	| jump if 5 vector (1st seg 0).
   1020  02 06 3 c 0 f8c0 1020  prtpatlp: movw,s d,y;		am->fifo1;	cjp,f1f .;	;			| continue writing segments
   1021  0a 17 3 8 2 dd60 1020  	incw r[0],r[0];	shmem->am;	cjp,~zer prtpatlp; ;		shp+	| loop until pattern ends.
   1022  1a 00 1 7 0 f8c1 0000  	movw d,acc;		;		cjs,go;		;			| starting offset->fifo1
   1023  1a 17 1 7 0 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;			| options->fifo1
   1024  08 0f e 0 0 c3de 0000  prtbyt:	add2nw 1,r[30],r[16];	am->shmemp;	;		;			| shmemp points to op (r[30]+2)
   1025  0a 16 3 c 0 7140 1025  	;			shmem->fifo1;	cjp,f1f .;	;			| op->fifo1
   1026  0a 07 e 0 2 c9c0 0000  	add2nw 4,r[0];	am->am;		;		;		shp+	| r[3]+r[0]+1->r[30]
   1027  0a 16 3 c 0 7140 1027  	;			shmem->fifo1;	cjp,f1f .;	;			| color->fifo1
   1028  0a 00 2 0 0 9e9e 0027  	addw d,r[30],r[30];	;		jmap getcmd;	;			| 
   1029  0a 06 3 c 0 eb96 1029  prtsol:	mov2nw 5,y;		am->fifo1;	cjp, f1f .;	;			| options(solidvec)->fifo1
   102a  0a 00 3 7 0 c3e0 1024  	sub2nw 1,r[0];	;		cjp, go prtbyt;	;			| 5,r[30]+=14(nb = -2)
                                |	;			;		jmap pr_polyline_pp; ;			| 
                                pr_polyline_pp:
   102b  0a 00 1 7 0 7140 1000  	;			;		cjs,go pixinit;	;			| 
   102c  1a 27 1 7 0 f8c1 001e  	movw d,acc;		30->am; cjs,go;	;			| polyline pp command->fifo1
   102d  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	| r[7]->fifo1
   102e  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	| r[8]->fifo1
   102f  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	| width->fifo1
   1030  0a 17 e 0 2 dd03 0000  	incw 0,r[3];		shmem->am;	;		;		shp+	| first pattern segment from shmem
   1031  02 06 3 c 0 f8c0 1031  	movw,s d,y;		am->fifo1;	cjp,f1f .;	;			| first segment->fifo1
   1032  0a 17 3 0 2 d8c4 1052  	movw d,r[4];		shmem->am;	cjp,zer prpsol;	;		shp+	| jump if 5 (just pulled options)
   1033  02 06 3 c 0 f8c0 1033  prppatlp: movw,s d,y;		am->fifo1;	cjp,f1f .;	;			| first segment->fifo1
   1034  0a 17 3 8 2 dd63 1033  	incw r[3],r[3];	shmem->am;	cjp,~zer prppatlp; ;		shp+	| increment count, pull next seg
   1035  0a 06 3 c 0 f8c0 1035  prpoff:	movw d,y;		am->fifo1;	cjp,f1f .;	;			| starting offset->fifo1
   1036  02 17 e 0 2 d8c4 0000  	movw,s d,r[4];		shmem->am;	;		;		shp+	| options->r[4]
   1037  0a 06 3 c 0 eb91 1037  	bclrw 5,d,y;	am->fifo1;	cjp,f1f .;	;			| options->fifo1 (clear 5 bit)
   1038  08 0f e 0 0 c3de 0000  	add2nw 1,r[30],r[16];	am->shmemp;	;		;			| load shmemp with op address
   1039  0a 16 3 c 0 7140 1039  prpbyt:	;			shmem->fifo1;	cjp,f1f .;	;			| op->fifo1
   103a  0a 27 e 0 2 8683 000d  	addw d,r[3],acc;	13->am;		;		;		shp+	| add pattern length + # bytes sent.
   103b  0a 16 3 c 0 7140 103b  	;			shmem->fifo1;	cjp,f1f .;	;			| color->fifo1
   103c  0a 0f e 0 0 989e 0000  	addw r[30],acc,r[30];	am->shmemp;	;		;			| sum->r[30] & shmemp to fetch nbytes
   103d  0a 17 e 0 2 d8c3 0000  	movw d,r[3];		shmem->am;	;		;		shp+	| npts->r[3] & d-latch
   103e  0a 06 3 c 0 f8c0 103e  	movw d,y;		am->fifo1;	cjp,f1f .;	;			| npts->fifo1 
   103f  02 00 e 0 0 f3e4 0000  	btstw,s 9,r[4];	;		;		;			| test if 9 exists
   1040  0a 08 3 8 0 c1e3 1048  	sub2nw 0,r[3],r[3];	am->brreg;	cjp,~zer prpmv;	;			| npts-1->brreg, npts->r[3], cjp 9
   1041  1a 00 c 0 0 dd63 0000  	incw r[3],r[3];		;		ldct;		;			| npts->r[3]
   1042  0a 17 e 0 2 8681 0000  prpptlp: addw d,r[1],acc;	shmem->am;	;		;		shp+	| x+offset->acc
   1043  0a 06 3 c 0 f880 1043  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			| x->fifo1
   1044  0a 17 e 0 2 8682 0000  	addw d,r[2],acc;	shmem->am;	;		;		shp+	| y+offset->acc
   1045  0a 06 3 c 0 f880 1045  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			| y->fifo1
   1046  0a 00 9 0 0 7140 1042  	;			;		rpct prpptlp;	;			| loop until zero
   1047  0a 07 3 7 0 cc23 1051  	sl1w r[3],r[3];		am->am;		cjp,go prpend;	;			| npts*2+1->d-latch (1->fetching npts)
   1048  1a 00 c 0 0 dd63 0000  prpmv:	incw r[3],r[3];		;		ldct;		;			| npts-1->brreg, npts->r[3]
   1049  0a 17 e 0 2 8681 0000  prpmvlp: addw d,r[1],acc;	shmem->am;	;		;		shp+	| x+offset->acc
   104a  0a 06 3 c 0 f880 104a  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			| x->fifo1
   104b  0a 17 e 0 2 8682 0000  	addw d,r[2],acc;	shmem->am;	;		;		shp+	| y+offset->acc
   104c  0a 06 3 c 0 f880 104c  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			| y->fifo1
   104d  0a 16 3 c 0 7140 104d  	;			shmem->fifo1;	cjp,f1f .;	;			| 9->fifo1
   104e  0a 00 9 0 2 d803 1049  	movw r[3],acc;		;		rpct prpmvlp;	;		shp+	| loop until zero
   104f  0a 00 e 0 0 cc23 0000  	sl1w r[3],r[3];		;		;		;			| npts*2+1->r[3] (1->fetching npts)
   1050  0a 07 e 0 0 8083 0000  	addw r[3],acc,acc;	am->am;		;		;			| npts*3+1->d-latch
   1051  0a 00 2 0 0 9e9e 0027  prpend:	addw d,r[30],r[30];	;		jmap getcmd;	;			| update r[30] for next fetch
   1052  0a 06 3 c 0 d903 1052  prpsol:	movw 0,r[3];		am->fifo1;	cjp,f1f .;	;			| dummy stoff->fifo1
   1053  0a 06 3 c 0 eba4 1053  	bsetw 5,r[4];	am->fifo1;	cjp,f1f .;	;			| options->fifo1 (5 bit set)
   1054  08 0f 3 7 0 c3de 1039  	add2nw 1,r[30],r[16];	am->shmemp;	cjp,go prpbyt;	;			| 
                                |	movw 0, r[16];	;		jmap PRPOLYSOL1_PP; ;			| Solid => no texture.
                                PRPOLYSOL1_PP:
   1055  0a 28 e 0 0 f8e1 109c  	movw  8,acc;	=wrfifo_pp->brreg; ;		;			| put wrfifo_pp address in brreg and
   1056  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs,f1f;	;			  | send  8 r[0] to PP
   1057  1a 27 1 7 0 86c0 00ff  	andw d,r[0],acc;		0xFF->am;	cjs,go;		;			  | send bit plane mask to PP
   1058  0a 17 e 0 2 d8cf 0000  	movw d,r[15];		shmem->am;	;		;		shp+	  | save color and op for later
   1059  1a 27 1 7 0 f8c1 000a  	movw d,acc;		10->am;	cjs,go;		;			  | now send clipping list
   105a  0a 06 3 c 0 fd00 105a  	incw 0, y;		am->fifo1;	cjp,f1f .;	;			  | 1 clipping rectangle.
   105b  0a 17 e 0 2 d8c7 0000  	movw d,r[7];		shmem->am;	;		;		shp+	  | save dst pixrect x offset and send to PP
   105c  0a 06 3 c 0 d847 105c  	movw r[7],y;		am->fifo1;	cjp,f1f .;	;
   105d  0a 17 c 0 2 d8c8 0001  	movw d,r[8];		shmem->am;	ldct 1;		;		shp+	| save dst pixrect y offset and send to PP
   105e  0a 06 3 c 0 d848 105e  	movw r[8],y;		am->fifo1;	cjp,f1f .;	;
   105f  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | send dst pixrect x size
   1060  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | send dst pixrect y size
   1061  02 00 e 0 0 d850 0000  	movw,s r[16], y;	;		;		;			| 
   1062  0a 17 3 0 2 9e87 1064  	addw d,r[7],r[7];	shmem->am;	cjp, zer .+2;	;		shp+	| add dx to dst pixrect x offset
   1063  0a 00 e 0 0 9e15 0000  	subw d, r[21], r[21];		;		;		;			| sub dx since vertices will include it.
   1064  0a 17 3 0 2 9e88 1066  	addw d,r[8],r[8];	shmem->am;	cjp, zer .+2;	;		shp+	| add dy to dst pixrect y offset
   1065  0a 00 e 0 0 9e16 0000  	subw d, r[22], r[22];		;		;		;			| 
                                											  | now have physical device coord offsets
                                											  | for polygon vertices
   1066  08 27 e 0 1 9e9e 000a  	addw d,r[30],r[17];	10->am;		;		;			  | r[17] pts to vector of npts per boundary
   1067  08 17 e 0 e 9e91 0000  	addw d,r[17],r[30];	shmem->am;	;		;			  | r[30] now points to first vertex
   1068  0a 00 e 0 2 d8cd 0000  	movw d,r[13];		;		;		;		shp+	  | # of separate boundaries
   1069  0a 00 e 0 0 c1f1 0000  	sub2nw 0,r[17];		;		;		;			  | decrement r[17] because increment below
                                										|
                                										| edge structure is:
                                										| fpreg[edgptr+0]: ymin    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[edgptr+1]: ymax    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[edgptr+2]: xmax    32-bit float
                                										| fpreg[edgptr+3]: xmin    32-bit float
                                										| fpreg[edgptr+4]: X       don't care in high word
                                										|		   nxt     11-bit ptr in low word
                                										|
   106a  0a 27 e 0 0 d8cb 0190  	movw d,r[11];		400->am;	;		;			  | r[11]<-400
   106b  0a 00 e 0 0 c98e 0000  	mov2nw 4,r[14];	;		;		;			  | r[14]<-16
   106c  08 0e e 0 a c5ce 0000  	add2nw 2,r[14],r[10]; am->fpdp;	;		;			  | fpdp<-&et[0].nxt
   106d  0b 0b e 0 6 dd6a 0000  	incw r[10],r[10];	am->fpregl;	;		;		dp+	  | r[10]<-21; et[0].nxt<-r[10]; r[10] of
                                											  | dummy first edge
   106e  02 00 e 0 0 c1ed 0000  nxtbnd:	sub2nw,s 0,r[13],r[13];	;		;		;			  | if ((r[13] -= 1)<0), goto doscan
   106f  0a 0f 3 1 0 dd71 109b  	incw r[17],r[17];	am->shmemp;	cjp,neg doscan_pp; ;			| else get # of vertices for next
   1070  0a 17 e 0 0 d8cc 0000  	movw d,r[12];		shmem->am;	;		;			  | boundary
   1071  0a 00 e 0 0 ee01 0000  	sl0w d,acc;		;		;		;			  | acc <- r[12]*2
   1072  02 27 e 0 0 960c 0003  	subw,s d,r[12],y;	3->am;		;		;			  | if 0 <= r[12] < 3, not a good boundary
   1073  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp pts to vertices;update r[30] to
   1074  0a 00 3 a 0 989e 106e  	addw r[30],acc,r[30];	;		cjp,~cry nxtbnd;;			  | point to 1st loc after bndry's vertices
   1075  0a 17 e 0 2 8687 0000  	addw d,r[7],acc;	shmem->am;	;		;		shp+
   1076  0a 17 e 0 2 d886 0000  	movw acc,r[6];		shmem->am;	;		;		shp+	  | r[6] <- pt.x + r[7]
   1077  08 00 e 0 4 d966 0000  	movw r[6],r[4];		;		;		;			  | remember x coord of 1st bndry pt
   1078  08 00 e 0 5 9e88 0000  	addw d,r[8],r[5];	;		;		;			  | r[5] <- pt.y + r[8]
   1079  08 00 e 0 3 d965 0000  	movw r[5],r[3];		;		;		;			  | remember y coord of 1st bndry pt
   107a  02 00 e 0 0 c1ec 0000  nxtvrt:	sub2nw,s 0,r[12],r[12];	;		;		;			  | if ((r[12] -= 1)==0), goto endbnd
   107b  0a 17 3 0 2 d8c9 108d  	movw d,r[9];		shmem->am;	cjp,zer endbnd;	;		shp+	  | r[9] <- pt.x
   107c  0a 17 e 0 2 8688 0000  	addw d,r[8],acc;	shmem->am;	;		;		shp+	  | acc <- pt.y + r[8]
   107d  02 00 e 0 0 9105 0000  	xorw,s r[5],acc,y;	;		;		;			  | check for horizontal edge (r[5]==acc)
   107e  0a 07 3 8 0 d847 1080  	movw r[7],y;		am->am;		cjp,~zer .+2;	;			  | d <- r[7]
   107f  08 00 3 7 6 9e89 107a  	addw d,r[9],r[6];	;		cjp,go nxtvrt;	;			  | if horiz, r[6]<-r[9]+r[7] & goto nxtvrt
   1080  0a 0b e 0 6 d845 0000  	movw r[5],y;		am->fpregh;	;		;		dp+	  | fpreg[edgptr+0,high] <- r[5]
   1081  0a 0b e 0 6 d885 0000  	movw acc,r[5];		am->fpregh;	;		;		dp+	  | fpreg[edgptr+1,high] <- r[5] <- new y
   1082  03 0b e 0 0 8689 0000  	addw,s d,r[9],acc;	am->fpregl;	;		;			  | fpreg[edgptr+2,low]<-acc<-(r[9]+r[7])
   1083  02 00 3 1 0 d846 1085  	movw,s r[6],y;		;		cjp,neg .+2;	;			  | arrange sign extension bits in high word
   1084  0a 0b 3 7 6 f900 1086  	movw 0,y;		am->fpregh;	cjp,go .+2;	;		dp+	  | positive sign for (r[9]+r[7])
   1085  0a 2b e 0 6 7140 ffff  	;			0xFFFF->fpregh;	;		;		dp+	  | negative sign for (r[9]+r[7])
   1086  0b 0b 3 1 0 d846 1088  	movw r[6],y;		am->fpregl;	cjp,neg .+2;	;			  | fpreg[edgptr+3,low] <- r[6]
   1087  0a 0b 3 7 6 f900 1089  	movw 0,y;		am->fpregh;	cjp,go .+2;	;		dp+	  | positive sign for r[6]
   1088  0a 2b e 0 6 7140 ffff  	;			0xFFFF->fpregh;	;		;		dp+	  | negative sign for r[6]
   1089  02 00 e 0 0 c1eb 0000  	sub2nw,s 0,r[11],r[11];;		;		;			  | r[11]-=1
   108a  0a 27 e 0 0 d886 0005  	movw acc,r[6];		5->am;		;		;			  | r[6] <- (r[9]+r[7])
   108b  0b 0b 3 9 6 9e8a 107a  	addw d,r[10],r[10];	am->fpregl;	cjp,~neg nxtvrt;;		dp+	  | fpreg[edgptr+4,low]<-r[10]<-address of
                                											  | next edge;if edgtbl not full,goto nxtvrt
   108c  0a 00 3 7 0 db0b 107a  	compw 0,r[11];		;		cjp,go nxtvrt;	;			  | else r[11] <- -1 and goto nxtvrt
                                											  | last point in boundary
   108d  0a 0b e 0 6 d805 0000  endbnd:	movw r[5],acc;		am->fpregh;	;		;		dp+	  | fpreg[edgptr+0,high] <- r[5]
   108e  02 00 e 0 0 9103 0000  	xorw,s r[3],acc,y;	;		;		;			  | check for horizontal edge (r[5]==r[3])
   108f  0a 0b 3 8 6 d843 1091  	movw r[3],y;		am->fpregh;	cjp,~zer .+2;	;		dp+	  | fpreg[edgptr+1,high] <- r[3]
   1090  0a 0e 3 7 0 d84a 106e  	movw r[10],y;		am->fpdp;	cjp,go nxtbnd;	;			  | if horiz, reload fpdp and goto nxtbnd
   1091  03 0b e 0 0 d844 0000  	movw,s r[4],y;		am->fpregl;	;		;			  | fpreg[edgptr+2,low]<-r[4]
   1092  02 00 3 1 0 d846 1094  	movw,s r[6],y;	;			cjp,neg .+2;	;			  | arrange sign extension bits in high word
   1093  0a 0b 3 7 6 f900 1095  	movw 0,y;		am->fpregh;	cjp,go .+2;	;		dp+	  | positive sign for r[4]
   1094  0a 2b e 0 6 7140 ffff  	;			0xFFFF->fpregh;	;		;		dp+	  | negative sign for r[4]
   1095  0b 0b 3 1 0 d846 1097  	movw r[6],y;		am->fpregl;	cjp,neg .+2;	;			  | fpreg[edgptr+3,low] <- r[6]
   1096  0a 0b 3 7 6 f900 1098  	movw 0,y;		am->fpregh;	cjp,go .+2;	;		dp+	  | positive sign for r[6]
   1097  0a 2b e 0 6 7140 ffff  	;			0xFFFF->fpregh;	;		;		dp+	  | negative sign for r[6]
   1098  02 27 e 0 0 c1eb 0005  	sub2nw,s 0,r[11],r[11]; 5->am;	;		;			  | r[11]-=1
   1099  0b 0b 3 9 6 9e8a 106e  	addw d,r[10],r[10];	am->fpregl;	cjp,~neg nxtbnd;;		dp+	  | fpreg[edgptr+4,low]<-r[10]<-address of
                                											  | next edge;if edgtbl not full,goto nxtbnd
   109a  0a 00 3 7 0 db0b 106e  	compw 0,r[11];		;		cjp,go nxtbnd;	;			  | else r[11] <- -1 and goto nxtbnd
   109b  0a 00 2 0 0 7140 00af  doscan_pp: ;			;		jmap doscan;	;			| scan convert on vp bank
   109c  1a 06 a 4 0 f880 0000  wrfifo_pp: movw acc,y;		am->fifo1;	crtn,f1nf;	;			| 
   109d  0a 00 3 7 0 7140 109c  	;			;		cjp,go wrfifo_pp; ;			| 
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)statatts.vp.u 1.2 86/09/13 SMI
                                | texture and width registers
                                |	incw r[30],r[30];	;		jmap SETCOLOR;	;
                                SETCOLOR:
   109e  0a 00 e 0 0 949d 0000  	addw r[29], 3,y;;		;		;
   109f  0a 0f e 0 0 0003 0000  	;			am->shmemp;	;		;
   10a0  0a 0a 2 0 0 f880 0027  	movw acc,y;		am->shmem;	jmap getcmd;	;
                                |	add2nw 1,r[30],r[30];	shmem->am;	jmap SETROP;	;
   10a1  0a 00 e 0 0 949d 0000  SETROP:	addw r[29], 2,y;;		;		;
   10a2  0a 0f e 0 0 0002 0000  	;			am->shmemp;	;		;
   10a3  0a 0a 2 0 0 f8c0 0027  	movw d,y;		am->shmem;	jmap getcmd;	;
                                |	incw r[30],r[30];	;		jmap SETFBINDX;	;
                                SETFBINDX:
   10a4  0a 00 e 0 0 949d 0000  	addw r[29], 0,y;;		;		;
   10a5  0a 0f e 0 0 0000 0000  	;			am->shmemp;	;		;
   10a6  0a 0a 2 0 0 f880 0027  	movw acc,y;		am->shmem;	jmap getcmd;	;
                                |	incw r[30],r[30];	;		jmap SETPIXPLANES;;
                                SETPIXPLANES:
   10a7  0a 00 e 0 0 949d 0000  	addw r[29], 1,y;;	;		;
   10a8  0a 0f e 0 0 0001 0000  	;			am->shmemp;	;		;
   10a9  0a 0a 2 0 0 f880 0027  	movw acc,y;		am->shmem;	jmap getcmd;	;
                                |	movw 0,y;		am->fpdp;	jmap SETMATRIX_3D; ;			  | zero fpr dst ptr
   10aa  0a 07 4 7 0 eb9c 000f  SETMATRIX_3D: rolw 5,acc,y;	am->am;		push,go 15;	;			  | d <- index*32 (index is passed in acc)
   10ab  0a 1b e 0 2 ea81 0000  	addw d, 64,acc;	shmem->fpregh;	;		;		shp+	  | copy from r[0] list in shmem to fpr[0]
   10ac  1b 1b 8 0 c 0040 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+  | acc <-  64 + index*32
   10ad  0a 0f e 0 0 909d 0000  	addw r[29],acc,y;	am->shmemp;	;		;			  | shmemp <- addr to store matrix
   10ae  0a 0c 4 7 0 f900 000f  	movw 0,y;		am->fpap;	push,go 15;	;			  | zero fpr src ptr
   10af  0a 3a e 0 2 f8e1 0000  	movw 33,acc;		fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to frame in shmem
   10b0  1b 3a 8 0 b 0021 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
   10b1  0a 00 2 0 0 989e 0027  	addw r[30],acc,r[30];	;		jmap getcmd;	;
                                |	movw 0,y;		am->fpdp;	jmap GETMATRIX_3D; ;			  | zero fpr dst ptr
   10b2  0a 2c e 0 0 eb9d 0000  GETMATRIX_3D: rolw 5,acc,acc;	0->fpap;	;		;			  | acc <- index*32 (index is passed in acc)
   10b3  0a 27 e 0 0 e281 0040  	addw d,acc,acc;		 64->am;;		;			  | fpap <- 0
   10b4  0a 0f 4 7 0 909d 000f  	addw r[29],acc,y;	am->shmemp;	push,go 15;	;			  | shmemp <- addr to retrieve matrix
   10b5  0a 1b e 0 2 dc1e 0000  	incw r[30],acc;	shmem->fpregh;	;		;		shp+	  | copy from frame in shmem to fpr[0]
   10b6  1b 1b 8 0 c 7140 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+  | acc has shmem addr of flag
   10b7  0a 0f 4 7 0 fc80 000f  	incw acc,y;		am->shmemp;	push,go 15;	;			  | shmemp <- addr to store matrix
   10b8  0a 3a e 0 2 c49e 0000  	addw acc,33,r[30];	fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to shmem r[0] area
   10b9  1b 3a 8 0 b 0021 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | r[30] += 34
   10ba  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
   10bb  0a 0a 2 0 0 f900 0027  	movw 0,y;		am->shmem;	jmap getcmd;	;			  | flag <- 0; jump to r[0] loop
                                |	incw r[30],r[30];	;		jmap SETHIDDENSURF;;
                                SETHIDDENSURF:
   10bc  0a 00 e 0 0 949d 0000  	addw r[29],6,y;;	;		;
   10bd  0a 0f e 0 0 0006 0000  	;			am->shmemp;	;		;
   10be  0a 0a 2 0 0 f880 0027  	movw acc,y;		am->shmem;	jmap getcmd;	;
                                |	incw r[30],r[30];	;		jmap SELECTMATRIX;;			  | r[30] += 1
                                SELECTMATRIX:
   10bf  0a 27 e 0 0 eb9d 0005  	rolw 5,acc,acc;		5->am;;		;			  | acc <- index*32 (index is passed in acc)
   10c0  0a 0f e 0 0 969d 0000  	addw d,r[29],y;	am->shmemp;	;		;			  | shmemp <- addr to store matrixptr
   10c1  0a 27 e 0 0 809d 0040  	addw r[29],acc,acc;	 64->am;;		;			  | acc <- r[29] + index*32
   10c2  0a 0a 2 0 0 e280 0027  	addw d,acc,y;		am->shmem;	jmap getcmd;	;			  | matrixptr <- r[29] +  64 +
                                											  | index*32; jump back to r[0] loop
                                |	movw 0,y;		am->fpdp;	jmap SETVWP_3D; ;			  | zero fpr dst ptr
   10c3  0a 0c 4 7 0 f900 0005  SETVWP_3D: movw 0,y;		am->fpap;	push,go 5;	;			  | zero fpr src ptr
   10c4  0a 1b e 0 2 f8e1 0000  	movw  52,acc;shmem->fpregh;	;		;		shp+	  | copy from r[0] list in shmem to fpr[0]
   10c5  1b 1b 8 0 c 0034 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+
   10c6  0a 0f 4 7 0 909d 0005  	addw r[29],acc,y;	am->shmemp;	push,go 5;	;			  | add r[29] and viewport frame offset
   10c7  0a 3a e 0 2 f8e1 0000  	movw 13,acc;		fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to frame in shmem
   10c8  1b 3a 8 0 b 000d 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
   10c9  0a 00 2 0 0 989e 0027  	addw r[30],acc,r[30];	;		jmap getcmd;	;
                                |	movw d,r[0];		shmem->am;	jmap SETCLPLST;	;		shp+	  | r[0] <- NRECTS
   10ca  02 27 e 0 0 9600 003d  SETCLPLST: subw,s d,r[0],y;	61->am;		;		;
   10cb  02 07 3 a 0 85c0 10cf  	rolw,s 2,r[0],y;	am->am;		cjp,~cry getlst;;			  | d<-NRECTS*4; if 0 <= NRECTS < 60, getlst
   10cc  0a 00 3 0 0 ca9e 10d7  	addw d,-240,r[30];	;		cjp,zer nullst;	;			  | else use 1st 60 rects; fix r[30] to
   10cd  0a 28 c 0 0 ff10 00ef  	;			239->brreg;	ldct 239;	;			  | skip other rects; brreg<-60*4-1
   10ce  0a 0e 3 7 0 f901 10d1  	movw 0,acc;		am->fpdp;	cjp,go getlst1;	;			  | zero acc and fpdp
   10cf  0a 08 3 0 0 e195 10d7  getlst:	sub2nw 0,d,y;		am->brreg;	cjp,zer nullst;	;			  | brreg<-NRECTS*4-1; if NRECTS==0, nullst
   10d0  1a 0e c 0 0 f901 0000  	movw 0,acc;		am->fpdp;	ldct;		;			  | zero acc and fpdp
   10d1  0a 1b 9 0 c fc81 10d1  getlst1: incw acc,acc;		shmem->fpregh;	rpct .;		;		shp+,dp+  | move from r[0] blk to fpregs; cnt in acc
   10d2  0a 2c e 0 0 949d 0000  	addw r[29], 256,y; 0->fpap;	;		;			  | zero fpap
   10d3  0a 0f e 0 0 0100 0000  	;			am->shmemp;	;		;			  | shmemp <- clipping list address
   10d4  1a 0a 4 7 2 fd9d 0000  	rolw 14,acc,acc;	am->shmem;	push,go;	;		shp+	  | # of rects actually used is acc/4
   10d5  1a 3a 8 0 b dd7e 0000  	incw r[30],r[30];	fpregh->shmem;	rfct;		;		shp+,abp+ | move from fpregs to static blk
   10d6  0a 00 2 0 0 c3de 0027  	add2nw 1,r[30],r[30];	;		jmap getcmd;	;			  | r[30] is now adjusted for next r[0]
   10d7  0a 00 e 0 0 949d 0000  nullst:	addw r[29], 256,y; ;		;		;
   10d8  0a 0f e 0 0 0100 0000  	;			am->shmemp;	;		;			  | shmemp <- clipping list address
   10d9  0a 0a 4 7 2 fd00 0003  	incw 0,y;		am->shmem;	push,go 3;	;		shp+	  | set NRECT to 1
   10da  1a 0a 8 0 2 f900 0000  	movw 0,y;		am->shmem;	rfct;		;		shp+	  | rect coords are 0,0,0,0
   10db  0a 00 2 0 0 c3de 0027  	add2nw 1,r[30],r[30];	;		jmap getcmd;	;			  | r[30] is now adjusted for next r[0]
                                |	incw,s 0,y;		;		jmap SET_LINE_TEX; ;			  
                                SET_LINE_TEX:
   10dc  0a 0e c 0 0 f900 000f  	movw 0,y;		am->fpdp;	ldct 15;	;			  | Load counter & fp d-reg addr.
   10dd  02 17 3 0 2 f8c0 10e1  stexlp:	movw,s d,y;		shmem->am;	cjp, zer setstoff;;		shp+	  | Cc for 1st set in main.vp.u.
   10de  0a 0b 9 0 6 f8c0 10dd  	movw d,y;		am->fpregh;	rpct stexlp;	;		dp+	  | Pull segs till 16 or zero segment.
   10df  0a 17 e 0 2 f8c0 0000  	movw d,y;		shmem->am;	;		;		shp+	  | If had 16 segs, should be null term.
   10e0  0a 17 3 7 2 d8c0 10e2  	movw d,r[0];		shmem->am;	cjp, go setopt;	;		shp+	  | Fetch r[0].
   10e1  0a 00 e 0 0 d8c0 0000  setstoff: movw d,r[0];		;		;		;			  | Move d-latch into r[0].
   10e2  0a 17 e 0 0 d8c1 0000  setopt:	movw d,r[1];		shmem->am;	;		;			  | Fetch r[1].
   10e3  0a 00 e 0 0 949d 0000  setstore: addw r[29], 26,y; ;	;		;			  | Store r[0],r[1], then texture.
   10e4  0a 0f e 0 0 001a 0000  	;			am->shmemp;	;		;			  | Address where texture is stored.
   10e5  0a 0a e 0 2 d840 0000  	movw r[0],y;		am->shmem;	;		;		shp+	  | r[0]->att. block.
   10e6  0a 0a e 0 2 e1c1 0000  	bclrw 0,r[1];	am->shmem;	;		;		shp+	  | r[1]->att. block. (clear 5080 bit).	
   10e7  02 27 e 0 0 d8d0 0001  	movw,s d,r[16];	1->am;		;		;			  | Set status for first seg,r[16]=1.
   10e8  0a 0c c 0 0 f900 000f  	movw 0,y;		am->fpap;	ldct 15;	;			  | Load counter & fp a-reg addr.
   10e9  02 37 3 0 0 f8c0 10ec  storlp:	movw,s d,y;		fpregh->am;	cjp, zer setckfr; ;			  | Pull segment & set status.
   10ea  0a 3a 9 0 b dd70 10e9  	incw r[16],r[16];	fpregh->shmem;	rpct storlp;	;		shp+,abp+ | r[16]++, store & loop till 0 or 16.
   10eb  0a 00 e 0 0 dd70 0000  	incw r[16],r[16];	;		;		;			  | If was 16, must count null term also.
   10ec  0a 2f e 0 0 7140 01fe  setckfr: ;			510->shmemp; ;		;			  | Check which frames texture on PP.
   10ed  02 17 e 0 0 971d 0000  	xorw,s d,r[29],y;	shmem->am;	;		;			  | 
   10ee  0a 07 e 0 0 c3de 0000  	add2nw 1,r[30];	am->am;		;		;			  | r[30]+2 -> d-latch.
   10ef  08 00 3 8 e 9e90 10f1  	addw d,r[16],r[30];	;		cjp, ~zer stend; ;			| r[30] += r[16](r[16]+=1).
   10f0  0a 0a 1 7 0 d85d 1116  	movw r[29],y;	am->shmem;	cjs, go sendtex; ;			  |  Update PP r[20]/new texture.
   10f1  0a 00 2 0 0 7140 0027  stend:	;			;		jmap getcmd;	;			| 
                                |	movw 0,y;		am->fpdp;	jmap SET_LINE_WIDTH; ;
                                SET_LINE_WIDTH:
   10f2  0a 1b e 0 c 7140 0000  	;			shmem->fpregh;	;		;		shp+,dp+  | Pull width.
   10f3  0a 1b e 0 0 7140 0000  	;			shmem->fpregh;	;		;		          | Pull width.r[1].
   10f4  0a 00 e 0 0 949d 0000  	addw r[29], 44,y; ;		;		;			  | 
   10f5  0a 0f e 0 0 002c 0000  	;			am->shmemp;	;		;			  | 
   10f6  0a 0c e 0 0 f900 0000  	movw 0,y;		am->fpap;	;		;			  | 
   10f7  0a 3a e 0 b 7140 0000  	;			fpregh->shmem;	;		;		shp+,abp+ | width->static block.
   10f8  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | width.r[1]->static block.
   10f9  0a 2f e 0 0 c1de 01fe  	add2nw 0,r[30];	510->shmemp; ;		;			  | Check which frames texture on PP.
   10fa  02 17 e 0 0 971d 0000  	xorw,s d,r[29],y;	shmem->am;	;		;			  | If this frame, need to update 
   10fb  0a 00 3 8 0 c3de 1103  	add2nw 1,r[30];	;		cjp, ~zer swidend; ;			| r[30]+=3 (total cmds + 1).
   10fc  0a 0a e 0 0 d85d 0000  	movw r[29],y;	am->shmem;	;		;			|  PP r[20]/new texture.
   10fd  0a 00 e 0 0 949d 0000  	addw r[29], 44,y; ;		;		;			| 
   10fe  1a 0f 4 f 0 002c 0000  	;			am->shmemp;	push, ~go;	;			| 
   10ff  1a 26 d 4 0 7140 0022  	;			34->fifo1; loop, f1nf; ;			| setwidth command->fifo1 (PP).
   1100  0a 16 3 c 0 7140 1100  	;			shmem->fifo1;	cjp, f1f .;	;			| width->fifo1.
   1101  0a 00 e 0 2 7140 0000  	;			;		;		;		shp+	| 
   1102  0a 16 3 c 0 7140 1102  	;			shmem->fifo1;	cjp, f1f .;	;			| width.r[1]->fifo1, jump to getcmd.
   1103  0a 00 2 0 0 7140 0027  swidend: ;			;		jmap getcmd;	;			| 
                                |	tvec_attr_pp -- jmap'ed to from vp bank
                                |
                                |	Input Parameters:	shmemp -- points at frame's texture
                                tvec_attr_pp:
   1104  0a 00 e 0 0 949d 0000  	addw r[29], 44,y; ;		;		;			| 
   1105  0a 0f 3 8 0 002c 1109  	;			am->shmemp;	cjp, ~zer tveca2; ;			| Jump if textured.
   1106  02 17 e 0 0 e395 0000  	sub2nw,s 1,d,y;		shmem->am;	;		;			| Compute (width-2).
   1107  0a 0f 3 9 0 d85d 1109  	movw r[29],y;	am->shmemp;	cjp, ~neg tveca2; ;			| 
   1108  0a 00 2 0 0 7140 02bc  	;			;		jmap vec_attr;	;			| Jmp if solid, width 1.
   1109  0a 2f e 0 0 7140 01fe  tveca2:	;			510->shmemp; ;		;			| Check which frames texture on PP.
   110a  02 17 e 0 0 971d 0000  	xorw,s d,r[29],y;	shmem->am;	;		;			| Check if this frames texture on PP.
   110b  0a 00 3 0 0 7140 1112  	;			;		cjp, zer tveca3; ;			| If not, send tex,width, & update ptr.
   110c  0a 0a 1 7 0 d85d 1116  	movw r[29],y;	am->shmem;	cjs, go sendtex; ;			| Send texture to PP.
   110d  1a 00 4 f 0 7140 0000  	;			;		push, ~go;	;			| Send width by hand, since shmemp corr.
   110e  1a 26 d 4 0 7140 0022  	;			34->fifo1; loop, f1nf; ;			| setwidth command->fifo1 (PP).
   110f  0a 16 3 c 0 7140 110f  	;			shmem->fifo1;	cjp, f1f .;	;			| width->fifo1.
   1110  0a 00 e 0 2 7140 0000  	;			;		;		;		shp+	| 
   1111  0a 16 3 c 0 7140 1111  	;			shmem->fifo1;	cjp, f1f .;	;			| width.r[1]->fifo1.
   1112  1a 0f 4 f 0 d85d 0000  tveca3:	movw r[29],y;	am->shmemp;	push, ~go;	;			| Restore shmemp & fall through.
   1113  1a 26 d 4 0 7140 001f  	;			31->fifo1; loop, f1nf; ;			| Send line initialization command to pp.
   1114  0a 27 e 0 0 d8d1 0020  	movw d,r[17];		32->am;	;		;			| Textured vector command->r[17].
   1115  02 17 2 0 0 961c 02bf  	subw,s d,r[28],y;	shmem->am;	jmap vecatt2;	;			| tst oldfbindx - newfbindx & jump.
                                |   Sendtex sends the offset, r[1], and then the pattern, which is null terminated, except in the case
                                |   where it is exactly 16 segments long, and it is not null terminated.
   1116  0a 00 e 0 0 949d 0000  sendtex: addw r[29], 26,y; ;	;		;			| 
   1117  1a 0f 4 f 0 001a 0000  	;			am->shmemp;	push, ~go;	;			| 
   1118  1a 26 d 4 0 7140 0021  	;			33->fifo1; loop, f1nf; ;			| settex command->fifo1 (PP).
   1119  0a 16 3 c 0 7140 1119  	;			shmem->fifo1;	cjp, f1f .;	;			| r[0]->fifo1.
   111a  0a 00 e 0 2 7140 0000  	;			;		;		;		shp+	| 
   111b  0a 16 3 c 0 7140 111b  	;			shmem->fifo1;	cjp, f1f .;	;			| r[1]->fifo1.
   111c  0a 27 e 0 2 f8c1 002c  	movw d,acc;		 44->am;	;		;		shp+	| r[14] offset in acc.
   111d  0a 17 c 0 2 7140 000f  	;			shmem->am;	ldct 15;	;		shp+	| Fetch first pattern segment.
   111e  02 06 3 c 0 f8c0 111e  tveclp:	movw,s d,y;		am->fifo1;	cjp, f1f .;	;			| segment->fifo1.
   111f  0a 17 3 0 2 7140 1121  	;			shmem->am;	cjp, zer tvwid;	;		shp+	| Jump if just sent zero segment.
   1120  0a 00 9 0 0 7140 111e  	;			;		rpct tveclp;	;			| Loop until counter hits zero.
   1121  1a 0f a 7 0 909d 0000  tvwid:	addw r[29],acc,y;	am->shmemp;	crtn, go;	;			| Return & set pointer to width.


