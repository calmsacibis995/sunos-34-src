Warning: file main.vp.u, line 21: instr. moves fl2reg to am29116 & has D reg. as an am29116 operand

Sun Microsystems GP-1 Viewing Processor Microassembler -- Version 1.2 (26 October 1984) -- Company Confidential

   addr  fl mv s b d  alu  var  source line

                                | "@(#)main.vp.u 1.3 86/09/13"
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                | @(#)vp.h 1.4 86/09/13 SMI
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                | Microcode Version Number 1.0  (format is xx.xx where x is a hex digit)
                                | Origin of PP microcode
                                | Default board addresses  (top 8 bits of 24-bit VME address)
                                | Graphics Buffer inquiry routine constants:
                                | 0xFFFF if no gb, otherwise index (0-3) of corresponding cg2 board
                                | Naming convention:  TEX alone refers to 1-dimensional linear textures.
                                | TEX2 refers to 2-dimensional textures, either 1-bit or 8-bit.
                                | Global static block offsets (block 0)
                                | Static frame parameter offsets
                                | PP Commands
                                	org 0
                                	debug off
      0  02 01 e 0 0 f190 0000  reset:	btstw,s 8,d;		fl2reg->am;	;		;
      1  0a 00 3 0 0 7140 0012  	;			;		cjp,zer vpinit;	;
      2  0a 00 2 0 0 7140 1123  	;			;		jmap 0x1123;	;
      3  1a 27 a 7 0 f8c1 0101  gp1_code_ver: movw d,acc;	0x0101->am;crtn,go;	;			  | version number
      4  12 27 a 7 0 f8c1 0021  gp1_board_addr: movw,s d,acc;	0x21->am; crtn,go;	;			  | GP1: top 8 bits of 24-bit VME address
                                											  | change to 0xFFFF for release
      5  12 27 a 7 0 f8c1 0040  cg2_board_addr0: movw,s d,acc;	0x40->am; crtn,go;	;			  | board #0
                                											  | change to 0xFFFF for release
      6  12 27 a 7 0 f8c1 ffff  cg2_board_addr1: movw,s d,acc;	0xFFFF->am; crtn,go;	;			  | board #1
      7  12 27 a 7 0 f8c1 ffff  cg2_board_addr2: movw,s d,acc;	0xFFFF->am; crtn,go;	;			  | board #2
      8  12 27 a 7 0 f8c1 ffff  cg2_board_addr3: movw,s d,acc;	0xFFFF->am; crtn,go;	;			  | board #3
      9  12 27 a 7 0 f8c1 0000  gb_board_inq: movw,s d,acc;	0->am;	crtn,go;	;			  | graphics buffer inquiry routine
                                											  | change to 0xFFFF for release
                                											  | returns: 0xFFFF if no gb, otherwise
                                											  | index (0-3) of corresponding cg2 board
      a  282247502d3120         	sccsid("GP-1 Microcode 1.0 85/07/17 Copyr 1985 Sun Micro")
      b  4d6963726f636f         
      c  646520312e3020         
      d  38352f30372f31         
      e  3720436f707972         
      f  20313938352053         
     10  756e204d696372         
     11  6f222900000000         
     12  0a 2f e 0 0 7140 0002  vpinit:	;			2->shmemp;;		;
     13  0a 17 e 0 0 f8c1 0000  	movw d,acc;		shmem->am;	;		;
     14  0a 27 e 0 0 e2c1 00ff  	andw d,acc,acc;		0xFF->am;	;		;			  | set high byte of shared memory location
     15  0a 0a e 0 0 f182 0000  	bsetw 8,acc;		am->shmem;	;		;			  | 2 (2) to 0x1 to indicate
                                											  | 3.2FCS or later microcode
     16  0a 2f e 0 0 7140 01fc  	;			508->shmemp;;		;
     17  0a 2a e 0 2 7140 0302  	;			0x0302->shmem;;		;		shp+	  | set release number and serial number
     18  0a 2a e 0 0 7140 0107  	;			0x0107->shmem;;		;			  | in 508 and 508+1 (508,509)
     19  1a 00 4 f 0 d91f 0000  	movw 0,r[31];		;		push,~go;	;			  | r[31] <- 0
     1a  1a 26 d 4 0 7140 0003  	;			 3->fifo1;	loop,f1nf;	;			  | send  3 command to PP
     1b  0a 00 1 7 0 7140 0004  	;			;		cjs,go gp1_board_addr;;			  | get GP1 address
     1c  0a 00 3 1 0 7140 001b  	;			;		cjp,neg .-1;	;			  | loop if GP1 addr == 0xFFFF
     1d  0a 06 3 c 0 f880 001d  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			  | send address to PP
     1e  0a 00 1 7 0 f901 0082  	movw 0,acc;		;		cjs,go getfbaddr;;			  | send a valid fb address to PP and 
                                											  | set r[28] to correct value
     1f  0a 2f e 0 0 f901 01fe  	movw 0,acc;		510->shmemp; ;		;			  | zero acc, load initial value for which
     20  0a 2a e 0 2 7140 ffff  	;			0xffff->shmem;	;		;		shp+	  |  frames texture is on pp = -1.
     21  0a 2a e 0 0 7140 ffff  	;			0xffff->shmem;	;		;			  | Set ptr to 2d texture to -1.
     22  0a 27 e 0 0 7140 0008  vpidle:	;			0x8->am;	;		;
     23  0a 0f e 0 0 e280 0000  	addw d,acc,y;		am->shmemp;	;		;
     24  12 17 4 7 0 d8de 0000  	movw,s d,r[30];	shmem->am;	push,go;	;
     25  12 17 d 8 0 d8de 0000  	movw,s d,r[30];	shmem->am;	loop,~zer;	;
     26  0a 2a e 0 0 dd7f 0000  	incw r[31],r[31];	0->shmem;	;		;
     27  0a 0f e 0 0 d85e 0000  getcmd:	movw r[30],y;		am->shmemp;	;		;
     28  0a 17 e 0 2 b020 0000  	rolw 8,d,r[0];		shmem->am;	;		;		shp+
     29  02 27 e 0 0 96c0 00c0  	andw,s d,r[0],y;		0xC0->am;	;		;			  | test bits 6 & 7 of r[0]
     2a  0a 27 e 0 0 86c0 003f  	andw d,r[0],acc;		0x3F->am;	;		;
     2b  0a 27 e 0 0 91e0 002e  	rolw 8,r[0],r[0];		=cmdtbl->am;	;		;
     2c  0a 08 3 8 0 e280 006e  	addw d,acc,y;		am->brreg;	cjp,~zer badcmd;;			  | if r[0] bits 6 or 7 are set, goto badcmd
     2d  1a 27 3 7 0 86c0 00ff  	andw d,r[0],acc;		0xFF->am;	cjp,go;		;
     2e  02 00 2 0 0 efe0 006f  cmdtbl:	btstw,s	7,r[0];		;		jmap EOCL;	;			  | 0
     2f  0a 00 2 0 0 f39d 007a  	rolw 9,acc,acc;		;		jmap USEFRAME;	;			  | 1
     30  02 17 2 0 0 961c 0094  	subw,s d,r[28],y;	shmem->am;	jmap PRVEC;	;			  | 2
     31  02 17 2 0 0 961c 00c4  	subw,s d,r[28],y;	shmem->am;	jmap PRROPNF;	;			  | 3
     32  02 17 2 0 0 961c 0128  	subw,s d,r[28],y;	shmem->am;	jmap PRROPFF;	;			  | 4
     33  02 17 2 0 0 961c 00ad  	subw,s d,r[28],y;	shmem->am;	jmap PRPOLYSOL;	;			  | 5
     34  0a 0f 2 0 0 d85d 0fec  	movw r[29],y;	am->shmemp;	jmap SETZBUF;	;			  | 6
     35  0a 00 2 0 0 dd7e 10bc  	incw r[30],r[30];	;		jmap SETHIDDENSURF;;			  | 7
     36  0a 00 2 0 0 dd7e 10bf  	incw r[30],r[30];	;		jmap SELECTMATRIX;;			  | 8
     37  0a 17 2 0 0 deca 03e4  	negw d,r[10];		shmem->am;	jmap MUL_POINT_FLT_2D;;			  | 9
     38  0a 17 2 0 0 deca 07fe  	negw d,r[10];		shmem->am;	jmap MUL_POINT_FLT_3D;;			  | 10
     39  0a 17 2 0 0 d8cb 0994  	movw d,r[11];		shmem->am;	jmap XFPOLYGON_3D;;			  | 11 (r[11] is nbnds)
     3a  0a 17 2 0 0 d8cb 0557  	movw d,r[11];		shmem->am;	jmap XFPOLYGON_2D;;			  | 12 (r[11] is nbnds)
     3b  0a 17 2 0 0 deca 0797  	negw d,r[10];		shmem->am;	jmap CORENDCVEC_3D;;			  | 13
     3c  0a 17 2 0 0 deca 0374  	negw d,r[10];		shmem->am;	jmap CGIVEC;	;			  | 14
     3d  02 17 2 0 2 d8c0 10ca  	movw,s d,r[0];		shmem->am;	jmap SETCLPLST;	;		shp+	  | 15
     3e  0a 00 2 0 0 dd7e 10a4  	incw r[30],r[30];	;		jmap SETFBINDX;	;			  | 16
     3f  0a 0e 2 0 0 f900 10c3  	movw 0,y;		am->fpdp;	jmap SETVWP_3D; ;			  | 17
     40  0a 0e 2 0 0 f900 02b2  	movw 0,y;		am->fpdp;	jmap SETVWP_2D; ;			  | 18
     41  0a 17 2 0 0 c3de 10a1  	add2nw 1,r[30],r[30];	shmem->am;	jmap SETROP;	;			  | 19
     42  0a 00 2 0 0 dd7e 029d  	incw r[30],r[30];	;		jmap SETCLIPPLANES;;			  | 20
     43  0a 17 2 0 0 deca 03ee  	negw d,r[10];		shmem->am;	jmap MUL_POINT_INT_2D;;			  | 21	
     44  0a 17 2 0 0 deca 0808  	negw d,r[10];		shmem->am;	jmap MUL_POINT_INT_3D;;			  | 22
     45  0a 00 2 0 0 dd7e 10a7  	incw r[30],r[30];	;		jmap SETPIXPLANES;;			  | 23
     46  0a 0e 2 0 0 f900 10aa  	movw 0,y;		am->fpdp;	jmap SETMATRIX_3D;;			  | 24
     47  0a 17 2 0 0 deca 0787  	negw d,r[10];		shmem->am;	jmap XFVEC_3D;	;			  | 25
     48  0a 00 2 0 0 7140 006e  	;			;		jmap badcmd;	;			  | 26
                                |	mov2nw 1,acc;		shmem->am;	jmap PASSTHRU;	;		shp+	  | 26
     49  0a 17 2 0 0 deca 03cd  	negw d,r[10];		shmem->am;	jmap XFVEC_2D;	;			  | 27
     4a  0a 00 2 0 0 dd7e 109e  	incw r[30],r[30];	;		jmap SETCOLOR;	;			  | 28
     4b  0a 0e 2 0 0 f900 02a0  	movw 0,y;		am->fpdp;	jmap SETMATRIX_2D;;			  | 29
     4c  0a 17 2 0 0 d8cb 0992  	movw d,r[11];		shmem->am;	jmap CORENDCPOLY_3D;;			  | 30 (r[11] is nbnds)
     4d  0a 00 2 0 0 7140 006e  	;			;		jmap badcmd;	;			  | 31
                                |	;			;		jmap ZOOM;	;			  | 31
     4e  0a 17 2 0 2 eb99 0439  	rolw 5,d,acc;		shmem->am;	jmap MATMUL_2D;	;		shp+	  | 32
     4f  0a 17 2 0 2 eb99 0813  	rolw 5,d,acc;		shmem->am;	jmap MATMUL_3D;	;		shp+	  | 33
     50  0a 0e 2 0 0 f900 02a8  	movw 0,y;		am->fpdp;	jmap GETMATRIX_2D;;			  | 34
     51  0a 0e 2 0 0 f900 10b2  	movw 0,y;		am->fpdp;	jmap GETMATRIX_3D;;			  | 35
     52  0a 17 2 0 0 deca 07bc  	negw d,r[10];		shmem->am;	jmap COREWLDVECNDC_3D;;			  | 36
     53  0a 17 2 0 0 d8cb 0c01  	movw d,r[11];		shmem->am;	jmap COREWLDPOLYNDC_3D;;		  | 37 (r[11] is nbnds)
     54  0a 17 2 0 0 d8cb 072b  	movw d,r[11];		shmem->am;	jmap PROC_PGON_FLT_2D; ;		  | 38 (r[11] is nbnds)
                                |	mov2nw 12,acc;		;		jmap SET_5080_TEX; ;			  | 39 Set 5080 line texture.
     55  0a 00 2 0 0 7140 006e  	;			;		jmap badcmd;	;			  | 39
     56  02 17 2 0 0 961c 0096  	subw,s d,r[28],y;	shmem->am;	jmap PR_LINE;	;			  | 40 Textured & fat vectors.
     57  02 17 2 0 0 961c 0098  	subw,s d,r[28],y;	shmem->am;	jmap PR_POLYLINE; ;			  | 41 Textured & fat polylines.
     58  02 00 2 0 0 fd00 10dc  	incw,s 0,y;		;		jmap SET_LINE_TEX; ;			  | 42 Set line texture.
     59  0a 0e 2 0 0 f900 10f2  	movw 0,y;		am->fpdp;	jmap SET_LINE_WIDTH; ;			  | 43 Set line width.
     5a  0a 17 2 0 0 deca 0370  	negw d,r[10];		shmem->am;	jmap CGI_LINE;	;			  | 44 CGI textured & fat vectors.
     5b  0a 00 2 0 0 dd7e 0395  	incw r[30],r[30];	;		jmap XF_LINE_FLT_2D; ;			| 45 
     5c  0a 00 2 0 0 dd7e 0747  	incw r[30],r[30];	;		jmap XF_LINE_FLT_3D; ;			| 46
     5d  0a 00 2 0 0 dd7e 0764  	incw r[30],r[30];	;		jmap XF_LINE_INT_3D; ;			| 47
     5e  02 17 2 0 0 961c 009a  	subw,s d, r[28], y;	shmem->am;	jmap PR_POLYTEX; ;			| 48
     5f  02 17 2 0 0 961c 01d3  	subw,s d, r[28], y;	shmem->am;	jmap PR_ROPTEX1; ;			| 49
     60  0a 00 2 0 0 7140 0240  	;			;		jmap PR_ROPTEX8; ;			| 50
     61  0a 00 2 0 0 f39d 02f1  	rolw 9, acc, acc;	;		jmap SET_TEXFRAME; ;			| 51
     62  0a 00 2 0 0 7140 02f8  	;			;		jmap SET_TEX;	;			| 52
     63  0a 00 2 0 0 c3de 032c  	add2nw 1, r[30], r[30]; ;		jmap SET_SXSYSCRN; ;			| 53
     64  0a 0e 2 0 0 f900 0336  	movw 0, y;		am->fpdp;	jmap SET_TEXOFF2D; ;			| 54
     65  0a 0e 2 0 0 f900 0340  	movw 0, y;		am->fpdp;	jmap SET_TEXOFF3D; ;			| 55
     66  0a 00 2 0 0 7140 006e  	;			;		jmap badcmd;	;			| 56
     67  0a 00 2 0 0 dd7e 03b1  	incw r[30],r[30];	;		jmap XF_LINE_INT_2D; ;			  | 57  
     68  0a 17 2 0 0 d8cb 0554  	movw d,r[11];		shmem->am;	jmap XF_PGON_INT_2D; ;			  | 58 (r[11] is nbnds)
     69  0a 17 2 0 0 d8cb 0729  	movw d,r[11];		shmem->am;	jmap PROC_PGON_INT_2D;;			  | 59 (r[11] is nbnds)
     6a  0a 17 2 0 0 deca 03fb  	negw d,r[10];		shmem->am;	jmap PROC_LINE_FLT_2D;;			  | 60	
     6b  0a 17 2 0 0 deca 03f9  	negw d,r[10];		shmem->am;	jmap PROC_LINE_INT_2D;;			  | 61
     6c  0a 17 2 0 0 deca 07ba  	negw d,r[10];		shmem->am;	jmap PROC_LINE_INT_3D;;			  | 62
     6d  0a 17 2 0 0 d8cb 0bff  	movw d,r[11];		shmem->am;	jmap PROC_PGON_INT_3D;;			  | 63
                                stop
     6e  0a 00 3 7 0 7140 006e  badcmd:	;			;		cjp,go .;	;			  | hang GP until restarted
                                |	btstw,s	7,r[0];		;		jmap EOCL;	;
     6f  1a 27 4 f 0 86df 00ff  EOCL:	andw d,r[31],acc;	0xFF->am;	push,~go;	;
     70  1a 26 d 4 0 7140 0001  	;			 1->fifo1;	loop,f1nf;	;
     71  0a 06 3 c 0 d85f 0071  	movw r[31],y;		am->fifo1;	cjp,f1f .;	;
     72  02 17 3 0 2 d8c0 0022  freebf:	movw,s d,r[0];		shmem->am;	cjp,zer vpidle;	;		shp+
     73  02 17 3 0 0 d8c1 0077  	movw,s d,r[1];		shmem->am;	cjp,zer frbf2;	;
     74  0a 2f e 0 0 7140 0005  frbf1:	;			5->shmemp;;		;
     75  0a 17 e 0 0 9f00 0000  	xorw d,r[0],r[0];	shmem->am;	;		;
     76  0a 0a 3 0 0 d840 0022  	movw r[0],y;		am->shmem;	cjp,zer vpidle;	;
     77  0a 2f e 0 0 7140 0006  frbf2:	;			6->shmemp;;		;
     78  0a 17 e 0 0 9f01 0000  	xorw d,r[1],r[1];	shmem->am;	;		;
     79  0a 0a 3 7 0 d841 0022  	movw r[1],y;		am->shmem;	cjp,go vpidle;	;
                                |	rolw 9,acc,acc;		;		jmap USEFRAME;	;
     7a  0a 27 e 0 0 c2dd 0e00  USEFRAME: andw d,acc,r[29];	0x0E00->am;	;		;
     7b  0a 27 e 0 0 9e9d 3000  	addw d,r[29],r[29];0x3000->am;	;		;
     7c  0a 00 2 0 0 dd7e 0027  	incw r[30],r[30];	;		jmap getcmd;	;
     7d  1a 06 a 4 0 f880 0000  wrfifo:	movw acc,y;		am->fifo1;	crtn,f1nf;	;
     7e  0a 00 3 7 0 7140 007d  	;			;		cjp,go wrfifo;	;
                                			| set up shmemp, fpdp, and counter prior to call
     7f  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+
     80  0a 1b 9 0 2 7140 007f  shm_to_fpr: ;			shmem->fpregh;	rpct .-1;	;		shp+
     81  1b 1b a 7 c 7140 0000  	;			shmem->fpregl;	crtn,go;	;		shp+,dp+
     82  0a 27 e 0 0 c2dc 0003  getfbaddr: andw d,acc,r[28];	0x3->am;	;		;
     83  0a 27 e 0 0 869c 0005  	addw d,r[28],acc;	=cg2_board_addr0->am;;		;
     84  0a 08 e 0 0 f880 0000  	movw acc,y;		am->brreg;	;		;
     85  1a 00 1 7 0 7140 0000  	;			;		cjs,go;		;
     86  0a 00 1 1 0 7140 008b  	;			;		cjs,neg getvalidfb;;
     87  1a 00 4 f 0 7140 0000  	;			;		push,~go;	;
     88  1a 26 d 4 0 7140 0006  	;			6->fifo1;loop,f1nf;	;			  | send 6 command to PP
     89  0a 06 3 c 0 f880 0089  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			  | send address
     8a  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;
     8b  0a 00 1 7 0 d91c 0005  getvalidfb: movw 0,r[28];	;		cjs,go cg2_board_addr0;;		  | cycle through all 4 boards until a
     8c  1a 00 a 9 0 7140 0000  	;			;		crtn,~neg;	;			  | valid address is found;  set r[28] to
     8d  0a 00 1 7 0 dd7c 0006  	incw r[28],r[28];	;		cjs,go cg2_board_addr1;;		  | correspond to this address;  return
     8e  1a 00 a 9 0 7140 0000  	;			;		crtn,~neg;	;			  | top 8 bits of address in acc
     8f  0a 00 1 7 0 dd7c 0007  	incw r[28],r[28];	;		cjs,go cg2_board_addr2;;
     90  1a 00 a 9 0 7140 0000  	;			;		crtn,~neg;	;
     91  0a 00 1 7 0 dd7c 0008  	incw r[28],r[28];	;		cjs,go cg2_board_addr3;;
     92  1a 00 a 9 0 7140 0000  	;			;		crtn,~neg;	;
     93  0a 00 3 7 0 7140 008b  	;			;		cjp,go getvalidfb;;			  | try again until succeed
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)pixrect.vp.u 1.3 86/09/12 SMI
                                |	subw,s d,r[28],y;	shmem->am;	jmap PRVEC;	;
     94  0a 17 1 8 0 f8c1 0082  PRVEC:	movw d,acc;		shmem->am;	cjs,~zer getfbaddr;;
     95  0a 00 2 0 0 7140 100c  	;			;		jmap prvec_pp;	;			| 
                                |	subw,s d,r[28],y;	shmem->am;	jmap PR_LINE;	;	
     96  0a 17 1 8 0 f8c1 0082  PR_LINE: movw d,acc;		shmem->am;	cjs,~zer getfbaddr; ;			| 
     97  0a 00 2 0 0 7140 1017  	;			;		jmap pr_line_pp; ;			| 
                                |	subw,s d,r[28],y;	shmem->am;	jmap PR_POLYLINE; ;	
                                PR_POLYLINE:	
     98  0a 17 1 8 0 f8c1 0082  	movw d,acc;		shmem->am;	cjs,~zer getfbaddr; ;			| 
     99  0a 00 2 0 0 7140 102b  	;			;		jmap pr_polyline_pp;	;			| 
                                |   Textured 2D polygons.
                                |   Defined registers must match SET_TEX.
                                |   Can't use r[0] because PR_POLYTEX needs cmd (r[0]) preserved for use by PR_POLYSOL.
                                |   	subw,s d, r[28], y;	shmem->am;	jmap PR_POLYTEX; ;			| 
     9a  0a 17 1 8 2 f8c1 0082  PR_POLYTEX: movw d, acc;	shmem->am;	cjs, ~zer getfbaddr; ;		shp+	| if r[28] has changed get new address.
     9b  0a 00 3 c 0 7140 009b  	;			;		cjp, f1f .;	;			| 
     9c  0a 26 e 0 0 7140 001b  	;			 27->fifo1;	;		;			| 
     9d  0a 00 1 7 0 7140 0320  	;			;		cjs, go stprep;	;			| see SET_TEX.
     9e  0a 06 3 c 0 d84e 009e  	movw r[14], y;		am->fifo1;	cjp, f1f .;	;			| 
     9f  0a 08 e 0 0 d84c 0000  	movw r[12], y;		am->brreg;	;		;			| 
     a0  0a 06 3 c 0 d84d 00a0  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
     a1  08 00 e 0 b d96d 0000  	movw r[13], r[11];	;		;		;			| 
     a2  0a 06 3 c 0 d84f 00a2  	movw r[15], y;		am->fifo1;	cjp, f1f .;	;			| 
     a3  12 00 4 7 0 c1eb 0000  prptld:	sub2nw,s 0, r[11], r[11];	;		push, go;	;			| 
     a4  0a 16 3 c 0 d80f 00a4  	movw r[15], acc;	shmem->fifo1;	cjp, f1f .;	;			| 
     a5  1a 00 8 0 2 dd7e 0000     	incw r[30], r[30];	;		rfct;		;		shp+	| 
     a6  0a 08 3 8 0 d84c 00a3     	movw r[12], y;		am->brreg;	cjp, ~zer prptld; ;			| 
                                |   PRPOLYSOL1_PP does jmap getcmd.
     a7  0a 17 e 0 2 d8d5 0000  	movw d, r[21];		shmem->am;	;		;		shp+	| 
     a8  0a 17 e 0 2 d8d6 0000  	movw d, r[22];		shmem->am;	;		;		shp+	| 
     a9  0a 2f e 0 0 d890 01ff  	movw acc, r[16];	511->shmemp; ;	;			| Set PP tex block ptr to PIXRECT type.
     aa  0a 2a e 0 0 7140 ffff  	;			0xffff->shmem;	;		;			| Always load texture if -1 is block ptr.
     ab  0a 27 e 0 0 9e9e 0005  	addw d, r[30], r[30];	5->am;		;		;			| 5= r[15], r[14], r[13], r[21], r[22].
     ac  08 0f 2 0 2 c3de 1055  	add2nw 1, r[30], r[18]; am->shmemp;	jmap PRPOLYSOL1_PP; ;		| 
                                |	subw,s d,r[28],y;	shmem->am;	jmap PRPOLYSOL;	;
     ad  0a 17 1 8 2 f8c1 0082  PRPOLYSOL: movw d,acc;		shmem->am;	cjs,~zer getfbaddr;;		shp+	  | if r[28] has changed, get new address
     ae  0a 00 2 0 0 d910 1055  	movw 0, r[16];	;		jmap PRPOLYSOL1_PP; ;			| Solid => no texture.
     af  2b 0e e 0 0 c1ea 0230  doscan:	sub2nw 0,r[10],r[10];	am->fpdp;	;		lmode rn,ai,pipe,fast;	  | set Weitek mode
     b0  03 2b e 0 0 d84b 0000  	movw,s r[11],y;	0->fpregl;	;		;			  | load NULL r[10] for last edge
     b1  0a 00 3 1 0 9c0b 00c3  	subw,s r[11],400,r[11];;		cjp,neg noscan;	;			  | if # of edges > 400, goto noscan
     b2  02 27 e 0 0 0190 0017  	;			23->am;		;		;			  | compute real # of edges
     b3  0a 0c 3 0 0 d8cd 00c3  	movw d,r[13];		am->fpap;	cjp,zer noscan;	;			  | if # of edges == 0, goto noscan
     b4  2a 00 e 0 0 f8e1 00a0  	movw 5,acc;		;		;		floata,la,hi;		  | convert xmin and xmax in each edge
     b5  2b 00 e 0 4 0005 00a0  	;			;		;		;		ap+	  | structure to floats; start at xmax of
     b6  28 0e e 0 c d96d 00a0  	movw r[13],r[12];	am->fpdp;	;		floata,la,hi;		  | first real edge (address 23)
     b7  2b 0c e 0 0 988d 00a0  	addw r[13],acc,r[13];	am->fpap;	;		;
     b8  2a 00 e 0 0 f8e0 00a0  	movw =fltloop,y;	;		;		floata,la,hi;
     b9  2b 08 e 0 4 00be 00a0  	;			am->brreg;	;		;		ap+
     ba  3a 00 c 0 0 7140 00a0  	;			;		ldct;		floata,la,hi;		  | 2910 R reg is fltloop
     bb  2b 0c e 0 0 988d 00a0  	addw r[13],acc,r[13];	am->fpap;	;		;
     bc  2a 00 e 0 0 f8e0 00a2  	movw =doscan1,y;	;		;		floata,la,a,hi;
     bd  2b 08 e 0 4 00c2 00a2  	;			am->brreg;	;		;		ap+	  | brreg is doscan1; pipe now full
     be  22 00 e 0 0 c1eb 00a3  fltloop: sub2nw,s 0,r[11],r[11];;		;		floata,la,a,st,hi;	  | store xmax
     bf  2b 0c e 0 6 988d 00a3  	addw r[13],acc,r[13];	am->fpap;	;		;		dp+	  | reload fpap, increment fpdp
     c0  2a 00 e 0 0 7140 00a3  	;			;		;		floata,la,a,st,hi;	  | store xmin
     c1  3b 0e 7 0 4 988c 00a3  	addw r[12],acc,r[12];	am->fpdp;	jrp,zer;	;		ap+	  | reload fpdp, increment fpap; loop until
                                											  | all edges are done
     c2  0a 00 1 7 0 7140 0c5c  doscan1: ;			;		cjs,go polyscan; ;			| call scan conversion routine
     c3  0a 00 2 0 0 7140 0027  noscan:	;			;		jmap getcmd;	;			| 
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)ropnull.vp.u 1.2 86/09/12 SMI
                                |   Null to frame buffer rops.
                                |	subw,s d, r[28], y;	shmem->am;	jmap PRROPNF;	;
     c4  0a 17 1 8 2 f8c1 0082  PRROPNF: movw d, acc;		shmem->am;	cjs, ~zer getfbaddr; ;		shp+	| 
     c5  0a 28 e 0 0 f8e1 007d  	movw  8, acc;	=wrfifo->brreg;	;		;			| 
     c6  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs, f1f;	;			| 
     c7  1a 27 1 7 0 86c0 00ff  	andw d, r[0], acc;	0xff->am;	cjs, go;	;			| low 8 bits of r[0]
     c8  0a 17 1 7 2 d8cb 010d  	movw d, r[11];		shmem->am;	cjs, go roprect; ;		shp+	| 
                                |   SetUp ()
     c9  02 27 e 0 0 96cb 0001  	andw,s d, r[11], y;	1->am;		;		;			| if (!(r[11] & PIX_DONTCLIP)) prclip ()
     ca  0a 00 1 0 0 7140 0115  	;			;		cjs, zer prclip2;;			| 
     cb  02 00 e 0 0 de46 0000  	negw,s r[6], y;	;		;		;			| if ((dst.size.x <= 0) ||
     cc  02 00 3 9 0 de47 010b  	negw,s r[7], y;	;		cjp, ~neg prrnend;;			| (dst.size.y <= 0)) return
     cd  0a 00 3 9 0 7140 010b  	;			;		cjp, ~neg prrnend;;			| 
     ce  0a 28 e 0 0 f8e1 007d  	movw 4, acc;		=wrfifo->brreg;	;		;			| 
     cf  1a 06 1 c 0 0004 0000  	;			am->fifo1;	cjs, f1f;	;			| pp command
     d0  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| dst.pos.x += dbd->cgpr_offset.x
     d1  0a 00 e 0 0 9884 0000  	addw r[4], acc, r[4];	;		;		;			| 
     d2  0a 00 e 0 0 d801 0000  	movw r[1], acc;		;		;		;			| dst.pos.y += dbd->cgpr_offset.y
     d3  0a 00 e 0 0 9885 0000  	addw r[5], acc, r[5];	;		;		;			| 
     d4  08 27 e 0 f 9ec4 000f  	andw d, r[4], r[15];	0xf->am;	;		;			| skew= cg2_prskew (dst.pos.x) == r[4] & 15
     d5  0a 07 e 0 0 c1ef 0000  	sub2nw 0, r[15], r[15];	am->am;		;		;			| r[8]= (dst.size.x + skew - 1) >> 4.
     d6  0a 00 e 0 0 8686 0000  	addw d, r[6], acc;	;		;		;			| 
     d7  0a 00 e 0 0 b808 0000  	rolw 12, acc, r[8];	;		;		;			| 
     d8  0a 27 e 0 0 9ec8 0fff  	andw d, r[8], r[8];		0xfff->am;	;		;			| 
     d9  08 00 e 0 9 97eb 0000  	rolw 11, r[11], r[9];	;		;		;			| r[9]= PIX_COLOR (r[11])= (r[11] >> 5) & 0xff.
     da  0a 27 e 0 0 9ec9 00ff  	andw d, r[9], r[9];	0xff->am;	;		;			| 
     db  0a 00 e 0 0 cc8b 0000  	sr0w r[11], r[11];		;		;		;			| r[11]= (r[11] >> 1) & 0xf
     dc  0a 27 e 0 0 9ecb 000f  	andw d, r[11], r[11];		0xf->am;	;		;			| 
                                |   SetPPMask ()
     dd  0a 00 e 0 0 d80b 0000  	movw r[11], acc;		;		;		;			| PIXOP_NEEDS_DST (r[11]<<1)= (r[11]^(r[11]<<1)) &0xa
     de  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
     df  0a 28 e 0 0 810b 007d  	xorw r[11], acc, acc;	=wrfifo->brreg;	;		;			| 
     e0  02 27 e 0 0 e2c1 000a  	andw,s d, acc, acc;	0xa->am;	;		;			| 
     e1  0a 27 e 0 0 d8d0 0006  	movw d, r[16];	6->am;		;		;			| PWRWRD->am
     e2  0a 00 3 8 0 d911 00e5  	movw 0, r[17];		;		cjp, ~zer rnrop; ;			| 
     e3  0a 27 e 0 0 d8d0 0004  	movw d, r[16];	4->am;		;		;			| PRRWRD->am
     e4  0a 00 e 0 0 dd11 0000  	incw 0, r[17];		;		;		;			| 
     e5  1a 27 1 7 0 f8c1 0006  rnrop:	movw d, acc;		6->am;		cjs, go;	;			| PWRWRD->fifo1
     e6  1a 06 1 c 0 d80b 0000  rnopf:	movw r[11], acc;		am->fifo1;	cjs, f1f;	;			| cg2_setfunction (fb, CG2_ALLROP, r[11])
     e7  1a 06 1 c 0 f901 0000  	movw 0, acc;		am->fifo1;	cjs, f1f;	;			| RRPattern= 0
     e8  0a 27 e 0 0 86c4 000f  	andw d, r[4], acc;	0xf->am;	;		;			| RRMask1= mrc_lmasktable [dst.pos.x&0xf]
     e9  0a 27 e 0 0 e281 1000  	addw d, acc, acc;	4096->am;	;		;			| 
     ea  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
     eb  08 07 e 0 e c1e6 0000  	sub2nw 0, r[6], r[14];	am->am;		;		;			| RRMask2= mrc_rmasktable
     ec  0a 00 e 0 0 8684 0000  	addw d, r[4], acc;	;		;		;			| [(dst.pos.x+dst.size.x-1)&0xf]
     ed  0a 21 e 0 0 d8cf 0000  	movw d, r[15];		vpprom->am;	;		;			| r[15]= RRMask1
     ee  0a 27 e 0 0 e2c1 000f  	andw d, acc, acc;	0xf->am;	;		;			| 
     ef  0a 27 e 0 0 e281 1010  	addw d, acc, acc;	4112->am;	;		;			| 
     f0  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
     f1  0a 00 e 0 0 7140 0000  	;			;		;		;			| 
     f2  0a 00 e 0 0 7140 0000  	;			;		;		;			| 
     f3  0a 20 3 c 0 7140 00f3  rnrmaskf:;			vpprom->fifo1;	cjp, f1f rnrmaskf; ;			| Mask2
     f4  0a 06 3 c 0 d84f 00f4  rnlmaskf:movw r[15], y;		am->fifo1;	cjp, f1f rnlmaskf;;			| Mask1
     f5  0a 06 3 c 0 d848 00f5  rnwidf1:movw r[8], y;		am->fifo1;	cjp, f1f rnwidf1;;			| cg2_setwidth (fb, CG2_ALLROP, r[8], ...)
     f6  0a 06 3 c 0 d848 00f6  rnwidf2:movw r[8], y;		am->fifo1;	cjp, f1f rnwidf2;;			| cg2_setwidth (,,, r[8])
     f7  0a 27 e 0 0 f199 0001  	rolw 8, d, acc;		1->am;		;		;			| cg2_setshift (fb, CG2_ALLROP, 0, 1)
     f8  0a 06 3 c 0 f880 00f8  rnshiftf:movw acc, y;		am->fifo1;	cjp, f1f rnshiftf;;			| cg2_setshift (fb, CG2_ALLROP, 0, 1)
     f9  0a 00 e 0 0 9189 0000  	rolw 8, r[9], acc;	;		;		;			| RRSource2= r[9] | r[9] << 8
     fa  0a 00 e 0 0 8149 0000  	orw r[9], acc, acc;	;		;		;			| 
     fb  0a 06 3 c 0 f880 00fb  rnsr2f:	movw acc, y;		am->fifo1;	cjp, f1f rnsr2f;;			| 
     fc  08 00 1 7 e d965 0125  	movw r[5], r[14];	;		cjs, go MulSWWid;;			| by= cg2_ropwordaddr (fb,0,r[4],r[5])
     fd  0a 00 1 7 0 7140 01d0  	;			;		cjs, go fbaddr;	;			| 
     fe  0a 00 e 0 0 d88a 0000  	movw acc, r[10];		;		;		;			| 
     ff  0a 00 e 0 0 9b84 0000  	rolw 13, r[4], acc;	;		;		;			| 
    100  0a 27 e 0 0 e2c1 1fff  	andw d, acc, acc;	0x1fff->am;	;		;			| 
    101  0a 00 e 0 0 988d 0000  	addw r[13], acc, r[13];;		;		;			| 	
    102  0a 27 e 0 0 86aa 0020  	addcw d, r[10], acc;	0x20->am;	;		;			| RopFB->am
    103  0a 06 3 c 0 d84d 0103  rnalof:	movw r[13], y;		am->fifo1;	cjp, f1f rnalof;;			| 
    104  0a 00 e 0 0 988c 0000  	addw r[12], acc, r[12];;		;		;			| 
    105  0a 06 3 c 0 d84c 0105  rnahif:	movw r[12], y;		am->fifo1;	cjp, f1f rnahif;;			| 
    106  0a 06 3 c 0 d847 0106  rnrechtf:movw r[7], y;		am->fifo1;	cjp, f1f rnrechtf;;			| 
    107  0a 06 3 c 0 d849 0107  rncolorf:movw r[9], y;		am->fifo1;	cjp, f1f rncolorf;;			| 
    108  0a 06 3 c 0 d848 0108  rnwf:	movw r[8], y;		am->fifo1;	cjp, f1f rnwf;	;			| 
    109  0a 06 3 c 0 d851 0109  rnnodstf:movw r[17], y;		am->fifo1;	cjp, f1f rnnodstf;;			| 
    10a  0a 06 3 c 0 d850 010a  rnropmf:movw r[16], y;	am->fifo1;	cjp, f1f rnropmf;;			| 
    10b  0a 27 e 0 0 9e9e 000b  prrnend:addw d, r[30], r[30];	11->am;		;		;			| 
    10c  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;			| 
    10d  0a 17 e 0 2 d8c0 0000  roprect: movw d, r[0];		shmem->am;	;		;		shp+	| 
    10e  0a 17 e 0 2 d8c1 0000  	movw d, r[1];		shmem->am;	;		;		shp+	| 
    10f  0a 17 e 0 2 d8c2 0000  	movw d, r[2];		shmem->am;	;		;		shp+	| 
    110  0a 17 e 0 2 d8c3 0000  	movw d, r[3];		shmem->am;	;		;		shp+	| 
    111  0a 17 e 0 2 d8c4 0000  	movw d, r[4];		shmem->am;	;		;		shp+	| 
    112  0a 17 e 0 2 d8c5 0000  	movw d, r[5];		shmem->am;	;		;		shp+	| 
    113  0a 17 e 0 2 d8c6 0000  	movw d, r[6];		shmem->am;	;		;		shp+	| 
    114  1a 17 a 7 2 d8c7 0000  	movw d, r[7];		shmem->am;	crtn, go;	;		shp+	| 
    115  02 07 e 0 0 d844 0000  prclip2:movw,s r[4], y;		am->am;		;		;			| 
    116  02 00 3 9 0 d845 0119  	movw,s r[5], y;		;		cjp, ~neg prclip2a;;			| 
    117  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| 
    118  0a 00 e 0 0 d904 0000  	movw 0, r[4];		;		;		;			| 
    119  0a 07 3 9 0 d845 011c  prclip2a:movw r[5], y;		am->am;		cjp, ~neg prclip2b;;			| 
    11a  0a 00 e 0 0 9e87 0000  	addw d, r[7], r[7];	;		;		;			| 
    11b  0a 00 e 0 0 d905 0000  	movw 0, r[5];		;		;		;			| 
    11c  0a 07 e 0 0 d844 0000  prclip2b:movw r[4], y;		am->am;		;		;			| 
    11d  0a 00 e 0 0 8602 0000  	subw d, r[2], acc;	;		;		;			| 
    11e  02 00 e 0 0 9006 0000  	subw,s r[6], acc, y;	;		;		;			| 
    11f  0a 07 3 9 0 d845 0121  	movw r[5], y;		am->am;		cjp, ~neg prclip2c;;			| 
    120  0a 00 e 0 0 d886 0000  	movw acc, r[6];	;		;		;			| 
    121  0a 00 e 0 0 8603 0000  prclip2c:subw d, r[3], acc;	;		;		;			| 
    122  02 00 e 0 0 9007 0000  	subw,s r[7], acc, y;	;		;		;			| 
    123  1a 00 a 9 0 7140 0000  	;			;		crtn, ~neg;	;			| 
    124  1a 00 a 7 0 d887 0000  	movw acc, r[7];	;		crtn, go;	;			| 
                                |   Multiply by SWWidth (SWidth/8).  Number comes in r[14]
                                |   and goes out in r[0] (low) and r[1] (high).
                                |   Must save accumulator.
                                |   y * 128 = y << 7
    125  08 00 e 0 c 8fee 0000  MulSWWid:rolw 7, r[14], r[12];;		;		;			| (y << 3 + y) << 7.
    126  08 27 e 0 d 9ecc ff80  	andw d, r[12], r[13];	0xff80->am;	;		;			| 
    127  1a 27 a 7 0 9ecc 007f  	andw d, r[12], r[12];	0x7f->am;	crtn, go;	;			| 
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)ropfb.vp.u 1.2 86/09/12 SMI
                                |   Frame buffer to frame buffer rops.
                                |	subw,s d, r[28], y;	shmem->am;	jmap PRROPFF;	;
    128  0a 17 1 8 2 f8c1 0082  PRROPFF: movw d, acc;		shmem->am;	cjs, ~zer getfbaddr; ;		shp+	| 
    129  0a 28 e 0 0 f8e1 007d  	movw  8, acc;	=wrfifo->brreg;	;		;			| 
    12a  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs, f1f;	;			| 
    12b  1a 27 1 7 0 86c0 00ff  	andw d, r[0], acc;	0xff->am;	cjs, go;	;			| low 8 bits of r[0]
    12c  0a 17 1 7 2 d8d8 010d  	movw d, r[24];		shmem->am;	cjs, go roprect; ;		shp+	| 
    12d  0a 17 e 0 2 d8c8 0000  	movw d, r[8];		shmem->am;	;		;		shp+	| 
    12e  0a 17 e 0 2 d8c9 0000  	movw d, r[9];		shmem->am;	;		;		shp+	| 
    12f  0a 17 e 0 2 d8ca 0000  	movw d, r[10];		shmem->am;	;		;		shp+	| 
    130  0a 17 e 0 2 d8cb 0000  	movw d, r[11];		shmem->am;	;		;		shp+	| 
    131  0a 17 e 0 2 d8d2 0000  	movw d, r[18];		shmem->am;	;		;		shp+	| 
    132  0a 17 e 0 2 d8d3 0000  	movw d, r[19];		shmem->am;	;		;		shp+	| 
                                |   SetUp ()
    133  02 27 e 0 0 9738 fffe  	norw,s d, r[24], y;	0xfffe->am;	;		;			| if (!(r[24] & PIX_DONTCLIP)) prclip ()
    134  0a 00 1 8 0 7140 01ac  	;			;		cjs, ~zer prclip;;			| 
    135  02 00 e 0 0 de46 0000  	negw,s r[6], y;	;		;		;			| if ((dst.size.x <= 0)
    136  02 00 3 9 0 de47 019c  	negw,s r[7], y;	;		cjp, ~neg prrfend;;			| (dst.size.y <= 0)) return
    137  0a 00 3 9 0 7140 019c  	;			;		cjp, ~neg prrfend;;			| 
    138  0a 28 e 0 0 f8e1 007d  	movw 5, acc;		=wrfifo->brreg;	;		;			| 
    139  1a 06 1 c 0 0005 0000  	;			am->fifo1;	cjs, f1f;	;			| pp command
    13a  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| dst.pos.x += dbd->cgpr_offset.x
    13b  0a 00 e 0 0 9884 0000  	addw r[4], acc, r[4];	;		;		;			| 
    13c  0a 00 e 0 0 d801 0000  	movw r[1], acc;		;		;		;			| dst.pos.y += dbd->cgpr_offset.y
    13d  0a 00 e 0 0 9885 0000  	addw r[5], acc, r[5];	;		;		;			| 
    13e  08 27 e 0 f 9ec4 000f  	andw d, r[4], r[15];	0xf->am;	;		;			| skew= cg2_prskew (dst.pos.x) == r[4] & 15
    13f  0a 07 e 0 0 c1ef 0000  	sub2nw 0, r[15], r[15];	am->am;		;		;			| r[20]= (dst.size.x + skew - 1) >> 4.
    140  0a 00 e 0 0 8686 0000  	addw d, r[6], acc;	;		;		;			| 
    141  0a 00 e 0 0 b814 0000  	rolw 12, acc, r[20];	;		;		;			| 
    142  0a 27 e 0 0 9ed4 0fff  	andw d, r[20], r[20];		0xfff->am;	;		;			| 
    143  0a 00 e 0 0 cc98 0000  	sr0w r[24], r[24];		;		;		;			| r[24]= (r[24] >> 1) & 0xf
    144  0a 27 e 0 0 9ed8 000f  	andw d, r[24], r[24];		0xf->am;	;		;			| 
                                |   End SetUp ()
    145  0a 00 e 0 0 d808 0000  	movw r[8], acc;		;		;		;			| src.pos.x += sbd->cgpr_offset.x
    146  0a 00 e 0 0 9892 0000  	addw r[18], acc, r[18];	;		;		;			| 
    147  0a 00 e 0 0 d809 0000  	movw r[9], acc;		;		;		;			| src.pos.y += sbd->cgpr_offset.y
    148  0a 00 e 0 0 9893 0000  	addw r[19], acc, r[19];	;		;		;			| 
    149  0a 00 e 0 0 d804 0000  	movw r[4], acc;		;		;		;			| r[22]= rop_direction ()
    14a  0a 00 e 0 0 8080 0000  	addw r[0], acc, acc;	;		;		;			| 
    14b  0a 00 e 0 0 8012 0000  	subw r[18], acc, acc;	;		;		;			| 
    14c  02 00 e 0 0 8008 0000  	subw,s r[8], acc, acc;	;		;		;			| 
    14d  0a 00 3 9 0 d916 014f  	movw 0, r[22];		;		cjp, ~neg rfdir;;			| 
    14e  0a 00 e 0 0 c396 0000  	mov2nw 1, r[22];		;		;		;			| 
    14f  0a 00 e 0 0 d805 0000  rfdir:	movw r[5], acc;		;		;		;			| 
    150  0a 00 e 0 0 8081 0000  	addw r[1], acc, acc;	;		;		;			| 
    151  0a 00 e 0 0 8013 0000  	subw r[19], acc, acc;	;		;		;			| 
    152  02 00 e 0 0 8009 0000  	subw,s r[9], acc, acc;	;		;		;			| 
    153  0a 00 3 1 0 dd76 0158  	incw r[22], r[22];		;		cjp, neg rfsetpp;;			| if (rop_isdown (r[22]))
    154  0a 00 e 0 0 c1f6 0000  	sub2nw 0, r[22], r[22];	;		;		;			| 
    155  0a 27 e 0 0 8607 0001  	subw d, r[7], acc;	1->am;		;		;			| src.pos.y += dst.size.y - 1
    156  0a 00 e 0 0 9893 0000  	addw r[19], acc, r[19];	;		;		;			| 
    157  0a 00 e 0 0 9885 0000  	addw r[5], acc, r[5];	;		;		;			| dst.pos.y += dst.size.y - 1
                                |   SetPPMask () (actually no longer sets per plane mask).
    158  0a 00 e 0 0 d818 0000  rfsetpp:movw r[24], acc;		;		;		;			| PIXOP_NEEDS_DST (r[24]<<1)= (r[24]^(r[24]<<1)) &0xa
    159  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
    15a  0a 28 e 0 0 8118 007d  	xorw r[24], acc, acc;	=wrfifo->brreg;	;		;			| 
    15b  02 27 e 0 0 e2c1 000a  	andw,s d, acc, acc;	0xa->am;	;		;			| 
    15c  0a 27 e 0 0 d8d0 0006  	movw d, r[16];	6->am;		;		;			| PWRWRD->am
    15d  0a 00 3 8 0 d911 0160  	movw 0, r[17];		;		cjp, ~zer rfrop; ;			| 
    15e  0a 27 e 0 0 d8d0 0004  	movw d, r[16];	4->am;		;		;			| PRRWRD->am
    15f  0a 00 e 0 0 dd11 0000  	incw 0, r[17];		;		;		;			| 
    160  1a 27 1 7 0 f8c1 0006  rfrop:	movw d, acc;		6->am;		cjs, go;	;			| PWRWRD->fifo1
    161  1a 00 1 7 0 d818 0000  	movw r[24], acc;		;		cjs, go;	;			| cg2_setfunction (fb, CG2_ALLROP, r[24])
    162  1a 06 1 c 0 f901 0000  	movw 0, acc;		am->fifo1;	cjs, f1f;	;			| RRPattern= 0
    163  02 27 e 0 0 e3f6 0001  	btstw,s 1, r[22];		1->am;		;		;			| if (rop_isright (r[22]) && r[20])
    164  02 00 3 8 0 d854 0176  	movw,s r[20], y;		;		cjp, ~zer rfleft;;			| 
    165  0a 00 3 0 0 8606 0176  	subw d, r[6], acc;	;		cjp, zer rfleft;;			| dst.size.x - 1
    166  0a 00 e 0 0 9892 0000  	addw r[18], acc, r[18];	;		;		;			| src.pos.x += dst.size.x - 1
    167  0a 00 e 0 0 9884 0000  	addw r[4], acc, r[4];	;		;		;			| dst.pos.x += dst.size.x - 1
    168  0a 27 e 0 0 8606 0001  	subw d, r[6], acc;	1->am;		;		;			| RRMask2= mrc_lmasktable[(dst.size.x)&0xf]
    169  0a 00 e 0 0 8044 0000  	rsubw r[4], acc, acc;	;		;		;			| 
    16a  0a 27 e 0 0 e2c1 000f  	andw d, acc, acc;	0xf->am;	;		;			| 
    16b  0a 27 e 0 0 e281 1000  	addw d, acc, acc;	4096->am;	;		;			| 
    16c  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
    16d  0a 00 3 c 0 7140 016d  rfmask2:;			;		cjp, f1f rfmask2; ;			| 
    16e  0a 00 e 0 0 7140 0000  	;			;		;		;			| 
    16f  0a 20 e 0 0 7140 0000  	;			vpprom->fifo1;	;		;			| 
    170  0a 27 e 0 0 d8ce 1010  	movw d, r[14];		4112->am;	;		;			| SKEW (0, mrc_rmasktable)
    171  0a 00 1 7 0 d90f 019e  	movw 0, r[15];		;		cjs, go rfskew;	;			| 
    172  02 00 e 0 0 900f 0000  	subw,s r[15], acc, y;	;		;		;			| r[23]= srcskew <= skew
    173  0a 00 3 9 0 dd17 0175  	incw 0, r[23];		;		cjp, ~neg rfprim1;;			| 
    174  0a 00 e 0 0 d917 0000  	movw 0, r[23];		;		;		;			| 
    175  0a 00 3 7 0 7140 0183  rfprim1:;			;		cjp, go rfsrc2;	;			| 
    176  0a 27 e 0 0 8606 0001  rfleft:	subw d, r[6], acc;	1->am;		;		;			| RRMask2= mrc_rmasktable[(dst.size.x)&0xf]
    177  0a 00 e 0 0 8084 0000  	addw r[4], acc, acc;	;		;		;			| 
    178  0a 27 e 0 0 e2c1 000f  	andw d, acc, acc;	0xf->am;	;		;			| 
    179  0a 27 e 0 0 e281 1010  	addw d, acc, acc;	4112->am;	;		;			| 
    17a  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
    17b  0a 00 3 c 0 7140 017b  rfmask2a:;			;		cjp, f1f rfmask2a; ;			| 
    17c  0a 00 e 0 0 7140 0000  	;			;		;		;			| 
    17d  0a 20 e 0 0 7140 0000  	;			vpprom->fifo1;	;		;			| 
    17e  0a 27 e 0 0 d8ce 1000  	movw d, r[14];		4096->am;	;		;			| SKEW (1, mrc_lmasktable)
    17f  0a 00 1 7 0 dd0f 019e  	incw 0, r[15];		;		cjs, go rfskew;	;			| 
    180  02 00 e 0 0 904f 0000  	rsubw,s r[15], acc, y;	;		;		;			| 
    181  0a 00 3 9 0 dd17 0183  	incw 0, r[23];		;		cjp, ~neg rfsrc2; ;			| 
    182  0a 00 e 0 0 d917 0000  	movw 0, r[23];		;		;		;			| 
    183  0a 06 3 c 0 f900 0183  rfsrc2:	movw 0, y;		am->fifo1;	cjp, f1f rfsrc2; ;			| dummy src2
    184  0a 00 e 0 0 d813 0000  	movw r[19], acc;		;		;		;			| 
    185  0a 00 1 7 0 d88e 0125  	movw acc, r[14];	;		cjs, go MulSWWid;;			| sy= cg2_ropwordaddr (fb,0,r[18],r[19])
    186  0a 00 1 7 0 7140 01d0  	;			;		cjs, go fbaddr;	;			| 
    187  0a 00 e 0 0 d895 0000  	movw acc, r[21];		;		;		;			| 
    188  0a 00 e 0 0 9b92 0000  	rolw 13, r[18], acc;	;		;		;			| 
    189  0a 27 e 0 0 e2c1 1fff  	andw d, acc, acc;	0x1fff->am;	;		;			| 
    18a  0a 00 e 0 0 988d 0000  	addw r[13], acc, r[13];;		;		;			| 
    18b  0a 27 e 0 0 86b5 0020  	addcw d, r[21], acc;	0x20->am;	;		;			| RopFB->am
    18c  0a 06 3 c 0 d84d 018c  rfalof0:movw r[13], y;		am->fifo1;	cjp, f1f rfalof0;;			| 
    18d  0a 00 e 0 0 988c 0000  	addw r[12], acc, r[12];;		;		;			| 
    18e  0a 06 3 c 0 d84c 018e  rfahif0:movw r[12], y;		am->fifo1;	cjp, f1f rfahif0;;			| 
    18f  08 00 1 7 e d965 0125  	movw r[5], r[14];	;		cjs, go MulSWWid;;			| by= cg2_ropwordaddr (fb,0,r[4],r[5])
    190  0a 00 e 0 0 9b84 0000  	rolw 13, r[4], acc;	;		;		;			| 
    191  0a 27 e 0 0 e2c1 1fff  	andw d, acc, acc;	0x1fff->am;	;		;			| 
    192  0a 00 e 0 0 988d 0000  	addw r[13], acc, r[13];;		;		;			| 
    193  0a 27 e 0 0 86b5 0020  	addcw d, r[21], acc;	0x20->am;	;		;			| RopFB->am
    194  0a 06 3 c 0 d84d 0194  rfalof:	movw r[13], y;		am->fifo1;	cjp, f1f rfalof;;			| 
    195  0a 00 e 0 0 988c 0000  	addw r[12], acc, r[12];;		;		;			| 
    196  0a 06 3 c 0 d84c 0196  rfahif:	movw r[12], y;		am->fifo1;	cjp, f1f rfahif;;			| 
    197  0a 06 3 c 0 d854 0197  rfwf:	movw r[20], y;		am->fifo1;	cjp, f1f rfwf;	;			| 
    198  0a 06 3 c 0 d850 0198  rfropmf:movw r[16], y;	am->fifo1;	cjp, f1f rfropmf;;			| 
    199  0a 06 3 c 0 d847 0199  rfrechtf:movw r[7], y;		am->fifo1;	cjp, f1f rfrechtf;;			| 
    19a  0a 06 3 c 0 d856 019a  rfdirf:	movw r[22], y;		am->fifo1;	cjp, f1f rfdirf;;			| 
    19b  0a 06 3 c 0 d857 019b  rfprime:movw r[23], y;		am->fifo1;	cjp, f1f rfprime;;			| 
    19c  0a 27 e 0 0 9e9e 0011  prrfend:addw d, r[30], r[30];	17->am;		;		;			| 
    19d  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;			| 
                                |   SKEW (a,b)
                                |   (b) masktable address in r[14].  (a) is 0 or 1 in r[15].
                                |   Returns srcskew in r[15], and skew in acc.  Loads RRMask1 into fifo.
    19e  0a 27 e 0 0 86c4 000f  rfskew:	andw d, r[4], acc;	0xf->am;	;		;			| skew= cg2_prskew (dst.pos.x)
    19f  0a 09 e 0 0 908e 0000  	addw r[14], acc, y;	am->vppromp;	;		;			| *(b + (dst.pos.x & 0xf))
    1a0  08 00 e 0 0 91ef 0000  	rolw 8, r[15], r[0];	;		;		;			| Reuse r[24] reg.
    1a1  0a 07 e 0 0 d852 0000  	movw r[18], y;		am->am;		;		;			| 
    1a2  0a 00 e 0 0 d8ce 0000  	movw d, r[14];		;		;		;			| 
    1a3  08 27 e 0 f 9ece 000f  	andw d, r[14], r[15];	0xf->am;	;		;			| srcskew= cg2_prskew (src.pos.x).
    1a4  08 00 e 0 e 980f 0000  	subw r[15], acc, r[14];	;		;		;			| cg2_setshift (,, (skew - srcskew)&0xf, a)
    1a5  0a 00 e 0 0 9ece 0000  	andw d, r[14], r[14];	;		;		;			| 
    1a6  0a 20 3 c 0 7140 01a6  rfskew3:;			vpprom->fifo1;	cjp, f1f rfskew3;;			| RRMask1
    1a7  0a 06 3 c 0 d854 01a7  rfwidf1:movw r[20], y;		am->fifo1;	cjp, f1f rfwidf1;;			| cg2_setwidth (fb, CG2_ALLROP, r[20], ...)
    1a8  0a 06 3 c 0 d854 01a8  rfwidf2:movw r[20], y;		am->fifo1;	cjp, f1f rfwidf2;;			| cg2_setwidth (,,, r[20])
    1a9  0a 07 e 0 0 d84e 0000  	movw r[14], y;		am->am;		;		;			| 
    1aa  0a 06 3 c 0 9740 01aa  rfskew1:orw d, r[0], y;		am->fifo1;	cjp, f1f rfskew1;;			| RRShift
    1ab  1a 00 a 7 0 7140 0000  	;			;		crtn, go;	;			| 
                                |   First:  pr_clip1 (dstp, &dstp->size, srcp)
    1ac  02 07 e 0 0 d844 0000  prclip:	movw,s r[4], y;		am->am;		;		;			| if ((pra)->pos.x < 0)
    1ad  02 00 3 9 0 d845 01b1  	movw,s r[5], y;		;		cjp, ~neg prclipa;;			| if ((pra)->pos.y < 0)
    1ae  0a 00 e 0 0 9e12 0000  	subw d, r[18], r[18];	;		;		;			| (prb)->pos.x -= (pra)->pos.x
    1af  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| (size)->x += (pra)->pos.x
    1b0  0a 00 e 0 0 d904 0000  	movw 0, r[4];		;		;		;			| (pra)->pos.x = 0
    1b1  0a 07 3 9 0 d845 01b5  prclipa:movw r[5], y;		am->am;		cjp, ~neg prclipb;;			| 
    1b2  0a 00 e 0 0 9e13 0000  	subw d, r[19], r[19];	;		;		;			| (prb)->pos.y -= (prb)->pos.y
    1b3  0a 00 e 0 0 9e87 0000  	addw d, r[7], r[7];	;		;		;			| (size)->y += (pra)->pos.y
    1b4  0a 00 e 0 0 d905 0000  	movw 0, r[5];		;		;		;			| (pra)->pos.y = 0
                                |   The statement:  if ((a+b) > c) b= c-a; is equivalent to:  if (b > (c-a)) b= c-a;
                                |   Notice the common c-a expression.  The rest of the prclip code has been reordered for this.
    1b5  0a 07 e 0 0 d844 0000  prclipb:movw r[4], y;		am->am;		;		;			| 
    1b6  0a 00 e 0 0 8602 0000  	subw d, r[2], acc;	;		;		;			| (pra)->pr->pr_size.x - (pra)->pos.x
    1b7  02 00 e 0 0 9006 0000  	subw,s r[6], acc, y;	;		;		;			| < (size)->x.  { (c-a) < b }
    1b8  0a 07 3 9 0 d845 01ba  	movw r[5], y;		am->am;		cjp, ~neg prclipc;;			| 
    1b9  0a 00 e 0 0 d886 0000  	movw acc, r[6];	;		;		;			| b= c-a
    1ba  0a 00 e 0 0 8603 0000  prclipc:subw d, r[3], acc;	;		;		;			| (pra)->pr->pr_size.y - (pra)->pos.y
    1bb  02 00 e 0 0 9007 0000  	subw,s r[7], acc, y;	;		;		;			| < (size)->y.  { (c-a) < b }
    1bc  0a 00 3 9 0 7140 01be  	;			;		cjp, ~neg prclip1;;			| 
    1bd  0a 00 e 0 0 d887 0000  	movw acc, r[7];	;		;		;			| b= c-a
                                |   Second:  pr_clip1 (srcp, &dstp->size, dstp)
    1be  02 07 e 0 0 d852 0000  prclip1:movw,s r[18], y;		am->am;		;		;			| if ((pra)->pos.x < 0)
    1bf  02 00 3 9 0 d853 01c3  	movw,s r[19], y;		;		cjp, ~neg prclip1a;;			| if ((pra)->pos.y < 0)
    1c0  0a 00 e 0 0 9e04 0000  	subw d, r[4], r[4];	;		;		;			| (prb)->pos.x -= (pra)->pos.x
    1c1  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| (size)->x += (pra)->pos.x
    1c2  0a 00 e 0 0 d912 0000  	movw 0, r[18];		;		;		;			| (pra)->pos.x = 0
    1c3  0a 07 3 9 0 d853 01c7  prclip1a:movw r[19], y;		am->am;		cjp, ~neg prclip1b;;			| 
    1c4  0a 00 e 0 0 9e05 0000  	subw d, r[5], r[5];	;		;		;			| (prb)->pos.y -= (prb)->pos.y
    1c5  0a 00 e 0 0 9e87 0000  	addw d, r[7], r[7];	;		;		;			| (size)->y += (pra)->pos.y
    1c6  0a 00 e 0 0 d913 0000  	movw 0, r[19];		;		;		;			| (pra)->pos.y = 0
                                |   The statement:  if ((a+b) > c) b= c-a; is equivalent to:  if (b > (c-a)) b= c-a;
                                |   Notice the common c-a expression.  The rest of the prclip code has been reordered for this.
    1c7  0a 07 e 0 0 d852 0000  prclip1b:movw r[18], y;		am->am;		;		;			| 
    1c8  0a 00 e 0 0 860a 0000  	subw d, r[10], acc;	;		;		;			| (pra)->pr->pr_size.x - (pra)->pos.x
    1c9  02 00 e 0 0 9006 0000  	subw,s r[6], acc, y;	;		;		;			| < (size)->x.  { (c-a) < b }
    1ca  0a 07 3 9 0 d853 01cc  	movw r[19], y;		am->am;		cjp, ~neg prclip1c;;			| 
    1cb  0a 00 e 0 0 d886 0000  	movw acc, r[6];	;		;		;			| b= c-a
    1cc  0a 00 e 0 0 860b 0000  prclip1c:subw d, r[11], acc;	;		;		;			| (pra)->pr->pr_size.y - (pra)->pos.y
    1cd  02 00 e 0 0 9007 0000  	subw,s r[7], acc, y;	;		;		;			| < (size)->y.  { (c-a) < b }
    1ce  1a 00 a 9 0 7140 0000  	;			;		crtn, ~neg;	;			| 
    1cf  1a 00 a 7 0 d887 0000  	movw acc, r[7];	;		crtn, go;	;			| b= c-a
    1d0  0a 27 e 0 0 869c 0005  fbaddr:	addw d,r[28],acc;	=cg2_board_addr0->am; ;		;			| 
    1d1  0a 08 e 0 0 f880 0000  	movw acc,y;		am->brreg;	;		;
    1d2  1a 00 3 7 0 7140 0000  	;			;		cjp, go;	;			| cg2_board_addrx will do crtn, go.
                                | Copyright (c) 1986 by Sun Microsystems, Inc.
                                |  @(#)roptex.vp.u 1.2 86/09/12 SMI
                                |   Textured area rasterops:  pr_replrop ().
                                |   Depth, Width, Height, Words, Rows must match SET_TEX.
                                |	subw,s d, r[28], y;	shmem->am;	jmap PR_ROPTEX1; ;			|
    1d3  0a 00 2 0 0 dd7e 0027  PR_ROPTEX1: incw r[30], r[30]; ;		jmap getcmd;	;			| Go through PR_ROPTEX8 to rt1setup.
                                |   ELIMINATE and modify main.vp.u as well.
                                |   Follows code for cg2_rop.c, case 2d.2, memory to cg2.
                                |   Do texture in vertical strips maximum width of a strip is width of texture.  PP gets one strip at time.
                                |   A strip on the left or the right can be less wide.
                                rt1setup: 
    1d4  02 00 e 0 0 d808 0000  	movw,s r[8], acc;		;		;		;			| (r[8] mod r[14]).
    1d5  02 00 3 1 0 808e 01d5  	addw,s r[14], acc, acc; ;		cjp, neg .;	;			| r[8] might be negative.
    1d6  02 00 3 9 0 800e 01d6  	subw,s r[14], acc, acc; ;		cjp, ~neg .;	;			| 
    1d7  0a 00 e 0 0 808e 0000  	addw r[14], acc, acc;	;		;		;			| 
    1d8  08 07 1 7 8 988e 0221  	addw r[14], acc, r[8];	am->am;		cjs, go rt1stripw; ;			| cjs Calculate strip width.
    1d9  02 00 e 0 0 d809 0000  	movw,s r[9], acc;		;		;		;			| (r[9] mod r[13]).
    1da  02 00 3 1 0 808d 01da  	addw,s r[13], acc, acc; ;		cjp, neg .;	;			| r[9] might be negative.
    1db  02 00 3 9 0 800d 01db  	subw,s r[13], acc, acc; ;		cjp, ~neg .;	;			| 
    1dc  0a 00 e 0 0 808d 0000  	addw r[13], acc, acc;	;		;		;			| 
    1dd  08 00 e 0 9 988d 0000  	addw r[13], acc, r[9];	;		;		;			| 
    1de  0a 28 e 0 0 f8e1 007d  	movw 2, acc;	=wrfifo->brreg;	;		;			| 
    1df  1a 06 1 c 0 0002 0000  	;			am->fifo1;	cjs, f1f;	;			| pp command
    1e0  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| dst.pos.x += dbd->cgpr_offset.x
    1e1  0a 00 e 0 0 9884 0000  	addw r[4], acc, r[4];	;		;		;			| Now have screen coord r[4].
    1e2  0a 00 e 0 0 d801 0000  	movw r[1], acc;		;		;		;			| dst.pos.y += dbd->cgpr_offset.y
    1e3  0a 00 1 7 0 9885 0226  	addw r[5], acc, r[5];	;		cjs, go rt1w;	;			| Calculate r[22], r[20], and r[11].
    1e4  08 00 e 0 2 97f0 0000  	rolw 11, r[16], r[18]; ;		;		;			| r[18]= PIX_COLOR (r[17]) = (r[17] >> 5) & 0xff
    1e5  02 27 e 0 0 9ed2 00ff  	andw,s d, r[18], r[18];	0xff->am;	;		;			| 
    1e6  08 00 3 8 1 cc90 01e8  	sr0w r[16], r[17];	;		cjp, ~zer .+2;	;			| r[17]= (r[17] >> 1) & 0xf
    1e7  0a 27 e 0 0 d8d2 00ff  	movw d, r[18];		0xff->am;	;		;			| if (r[18] == 0) r[18]= -1
    1e8  0a 27 e 0 0 9ed1 000f  	andw d, r[17], r[17];		0xf->am;	;		;			| 
    1e9  0a 00 e 0 0 d811 0000  	movw r[17], acc;		;		;		;			| PIXOP_NEEDS_DST (r[17]<<1)= (r[17]^(r[17]<<1)) &0xa
    1ea  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
    1eb  0a 28 e 0 0 8111 007d  	xorw r[17], acc, acc;	=wrfifo->brreg;	;		;			| 
    1ec  02 27 e 0 0 e2c1 000a  	andw,s d, acc, acc;	0xa->am;	;		;			| r[19] depends on r[23]
    1ed  0a 27 e 0 0 d8d3 0002  	movw d, r[19];	2->am;		;		;			| PWWWRD->am
    1ee  0a 00 3 8 0 d917 01f1  	movw 0, r[23];		;		cjp, ~zer rt1rop; ;			| r[23]= 0
    1ef  0a 00 e 0 0 dd17 0000  	incw 0, r[23];		;		;		;			| r[23]= 1
    1f0  0a 27 e 0 0 d8d3 0000  	movw d, r[19];	0->am;		;		;			| PRWWRD->am
    1f1  1a 27 1 7 0 f8c1 0002  rt1rop:	movw d, acc;		2->am;		cjs, go;	;			| PWWWRD->fifo1.  First of pp ropreg values.
                                | cg2_setfunction (fb, CG2_ALLROP, r[17])
    1f2  1a 00 1 7 0 8991 0000  	rolw 4, r[17], acc;	;		cjs, go;	;			| r[17] & pattern mask.
    1f3  1a 06 1 c 0 f901 0000  	movw 0, acc;		am->fifo1;	cjs, f1f;	;			| RRPattern= 0
    1f4  0a 00 1 7 0 7140 0232  	;			;		cjs, go rt1mask; ;			| Set right and left mask and send to pp.
    1f5  0a 06 3 c 0 d854 01f5  	movw r[20], y;		am->fifo1;	cjp, f1f .;	;			| cg2_setwidth (fb, CG2_ALLROP, r[20], ...)
    1f6  0a 06 3 c 0 d854 01f6  	movw r[20], y;		am->fifo1;	cjp, f1f .;	;			| cg2_setwidth (,,, r[20])
    1f7  0a 06 3 c 0 d84b 01f7  	movw r[11], y;		am->fifo1;	cjp, f1f .;	;			| RRShift
    1f8  0a 06 3 c 0 f900 01f8  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Dummy src2
                                |   End of pp ropreg subroutine fifo values.
    1f9  0a 06 3 c 0 dc4c 01f9  	incw r[12], y;		am->fifo1;	cjp, f1f .;	;			| texture width in r[12].
    1fa  08 00 e 0 f d96c 0000  	movw r[12], r[15];	;		;		;			| Copy r[12] before it is clobbered.
    1fb  0a 06 3 c 0 d84d 01fb  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| texture height.
    1fc  0a 06 3 c 0 d853 01fc  	movw r[19], y;	am->fifo1;	cjp, f1f .;	;			| 
    1fd  0a 06 3 c 0 d847 01fd  	movw r[7], y;		am->fifo1;	cjp, f1f .;	;			| 
    1fe  0a 06 3 c 0 d857 01fe  	movw r[23], y;		am->fifo1;	cjp, f1f .;	;			| 
    1ff  0a 06 3 c 0 d852 01ff  	movw r[18], y;		am->fifo1;	cjp, f1f .;	;			| 
    200  0a 06 3 c 0 d854 0200  	movw r[20], y;		am->fifo1;	cjp, f1f .;	;			| 
                                |   Loop back to here.
    201  0a 06 3 c 0 d856 0201  rt1strip: movw r[22], y;	am->fifo1;	cjp, f1f .;	;			| 
    202  0a 00 e 0 0 dc0f 0000  	incw r[15], acc;	;		;		;			| src= (r[12] + 1) * r[9] + (r[8] >> 4)
    203  08 00 e 0 a d964 0000  	movw r[4], r[10];	;		;		;			| move r[4] out of the way of multiply.
    204  08 00 1 7 2 d969 0fcc  	movw r[9], r[2];		;		cjs, go multiply; ;			| 
    205  0a 00 e 0 0 9988 0000  	rolw 12, r[8], acc;	;		;		;			| 
    206  0a 27 e 0 0 e2c1 0fff  	andw d, acc, acc;	0xfff->am;	;		;			| 
    207  0a 06 3 c 0 9080 0207  	addw r[0], acc, y;	am->fifo1;	cjp, f1f .;	;			| Src address.
                                |	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| DEBUG.  Dummy src address.
    208  08 00 1 7 4 d96a 01d0  	movw r[10], r[4];	;		cjs, go fbaddr;	;			| r[4] was saved in r[10] before multiply
    209  0a 00 e 0 0 d895 0000  	movw acc, r[21];		;		;		;			| 
    20a  08 00 1 7 e d965 0125  	movw r[5], r[14];	;		cjs, go MulSWWid;;			| by= cg2_ropwordaddr (fb,0,r[4],r[5])
    20b  0a 00 e 0 0 9b84 0000  	rolw 13, r[4], acc;	;		;		;			| 
    20c  0a 27 e 0 0 e2c1 1fff  	andw d, acc, acc;	0x1fff->am;	;		;			| r[4] >> 3 (byte addressing)
    20d  0a 06 3 c 0 908d 020d  	addw r[13], acc, y;	am->fifo1;	cjp, f1f .;	;			| physical fb hi addr dest. 
    20e  0a 27 e 0 0 86b5 0020  	addcw d, r[21], acc;	0x20->am;	;		;			| RopFB->am
    20f  0a 06 3 c 0 908c 020f  	addw r[12], acc, y;	am->fifo1;	cjp, f1f .;	;			| physical fb lo addr dest. 
                                |   Compute new values for next pp strip or exit from here if all strips done.
    210  0a 00 e 0 0 d818 0000  	movw r[24], acc;	;		;		;			| 
    211  0a 00 e 0 0 9884 0000  	addw r[4], acc, r[4];	;		;		;			| r[4] += r[24]
    212  02 00 e 0 0 9806 0000  	subw,s r[6], acc, r[6]; ;		;		;			| r[6] = r[24] - r[6].
    213  0a 00 3 9 0 df66 021e  	negw r[6], r[6];	;		cjp, ~neg rt1end0; ;			| r[6] = -r[6]. (r[6] - r[24])
    214  0a 07 e 0 0 9888 0000  	addw r[8], acc, r[8];	am->am;		;		;			| r[8] += r[24]
    215  02 00 e 0 0 9659 0000  	rsubw,s d, r[25], y;	;		;		;			| if (r[8] >= r[25])
    216  0a 00 3 1 0 d819 0218  	movw r[25], acc;	;		cjp, neg .+2;	;			| 
    217  0a 07 e 0 0 9848 0000  	rsubw r[8], acc, r[8];	am->am;		;		;			| r[8] -= r[25]
    218  0a 00 1 7 0 7140 0221  	;			;		cjs, go rt1stripw; ;			| 
    219  0a 00 1 7 0 7140 0226  	;			;		cjs, go rt1w;	;			| Calculate r[22], r[20], and r[11].
    21a  0a 00 1 7 0 7140 0232  	;			;		cjs, go rt1mask; ;			| Set right and left mask and send to pp.
    21b  0a 06 3 c 0 d84b 021b  	movw r[11], y;		am->fifo1;	cjp, f1f .;	;			| 
    21c  0a 06 3 c 0 d854 021c  	movw r[20], y;		am->fifo1;	cjp, f1f .;	;			| Send r[20] (r[20], RRWidth, RROpCount)
    21d  0a 00 3 7 0 7140 0201  	;			;		cjp, go rt1strip; ;			| 
    21e  0a 06 3 c 0 fb00 021e  rt1end0: compw 0, y;		am->fifo1;	cjp, f1f .;	;			| Send pp end of r[0] flag.
    21f  0a 27 e 0 0 9e9e 0010  rt1end:addw d, r[30], r[30];	16->am;		;		;			| 16:Cmd,fb,r[17],2 rects,sd,sw,sh,r[8],r[9].
    220  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;			| 
                                |   if adding 16 collapse two previous lines.
                                |   Calculate strip width.  Expects r[8] in the d latch.
    221  08 00 e 0 8 9e19 0000  rt1stripw: subw d, r[25], r[24]; ;	;		;			| r[24]= r[25] - r[8]
    222  0a 00 e 0 0 d806 0000  	movw r[6], acc;	;		;		;			| 
    223  02 00 e 0 0 9018 0000  	subw,s r[24], acc, y; ;		;		;			| if (r[24] > r[6]) r[24]=r[6]
    224  1a 00 a 9 0 7140 0000  	;			;		crtn, ~neg;	;			| 
    225  1a 00 a 7 0 d898 0000  	movw acc, r[24];	;		crtn, go;	;			| 
                                rt1w:
    226  0a 27 e 0 0 86c4 000f  	andw d, r[4], acc;	0xf->am;	;		;			| r[20]= cg2_prskew (dst.pos.x) == r[4] & 15
    227  08 00 e 0 b 9ec8 0000  	andw d, r[8], r[11];	;		;		;			| r[11]= mprs_skew (r[8] + (src offset x == 0))
    228  02 00 e 0 0 980b 0000  	subw,s r[11], acc, r[11]; ;		;		;			| r[22]= (r[11] >= r[20]). Shift= (r[20]-r[11]) & 15
    229  0a 00 3 0 0 dd16 022c  	incw 0, r[22];		;		cjp, zer .+3;	;			| 
    22a  0a 00 3 1 0 7140 022c  	;			;		cjp, neg .+2;	;			| 
    22b  0a 00 e 0 0 d916 0000  	movw 0, r[22];		;		;		;			| 
    22c  0a 27 e 0 0 e201 0001  	subw d, acc, acc;	1->am;		;		;			| r[20]= (dst.size.x + r[20] - 1) >> 4.
    22d  0a 00 e 0 0 8098 0000  	addw r[24], acc, acc; ;		;		;			| First Strip (use r[24] as dst.size.x)
    22e  0a 00 e 0 0 b814 0000  	rolw 12, acc, r[20];	;		;		;			| >> 4
    22f  0a 27 e 0 0 9ed4 0fff  	andw d, r[20], r[20];		0xfff->am;	;		;			| 
    230  0a 27 e 0 0 9ecb 000f  	andw d, r[11], r[11];	0xf->am;	;		;			| 
    231  1a 27 a 7 0 9e8b 0100  	addw d, r[11], r[11];	0x100->am;	crtn, go;	;			| 
    232  0a 27 e 0 0 8618 0001  rt1mask: subw d, r[24], acc; 1->am;	;		;			| RRMask2= mrc_rmasktable []
    233  0a 00 e 0 0 8084 0000  	addw r[4], acc, acc;	;		;		;			| [(dst.pos.x + dst.size.x - 1) & 0xF]
    234  0a 27 e 0 0 e2c1 000f  	andw d, acc, acc;	0xf->am;	;		;			| 
    235  0a 27 e 0 0 e281 1010  	addw d, acc, acc;	4112->am;	;		;			| 
    236  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
    237  0a 00 e 0 0 7140 0000  	;			;		;		;			| Wait for vpprom?
    238  0a 00 e 0 0 7140 0000  	;			;		;		;			| Wait for vpprom?
    239  0a 20 3 c 0 d804 0239  	movw r[4], acc;		vpprom->fifo1;	cjp, f1f .;	;			| RRMask2
    23a  0a 27 e 0 0 e2c1 000f  	andw d, acc, acc;	0xf->am;	;		;			| RRMask1= mrc_lmasktable [dst.pos.x & 0xF]
    23b  0a 27 e 0 0 e281 1000  	addw d, acc, acc;	4096->am;	;		;			| 
    23c  0a 09 e 0 0 f880 0000  	movw acc, y;		am->vppromp;	;		;			| 
    23d  0a 00 e 0 0 7140 0000  	;			;		;		;			| Wait for vpprom?
    23e  0a 00 3 c 0 7140 023e  	;			;		cjp, f1f .;	;			| Wait for vpprom?
    23f  1a 20 a 7 0 7140 0000  	;			vpprom->fifo1;	crtn, go;	;			| RRMask1
                                |   PR_ROPTEX8:
                                |   Can't use r[0] until later parts of PR_ROPTEX.
                                |   #define r[0]	r[0]
                                |	subw,s d, r[28], y;	shmem->am;	jmap PR_ROPTEX8; ;			|
    240  0a 17 1 8 2 f8c1 0082  PR_ROPTEX8:movw d, acc;		shmem->am;	cjs, ~zer getfbaddr; ;		shp+	| if fb index has changed get new address.
    241  0a 28 e 0 0 f8e1 007d  	movw  8, acc;	=wrfifo->brreg;	;		;			| 
    242  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs, f1f;	;			| 
    243  1a 27 1 7 0 86c0 00ff  	andw d, r[0], acc;	0xff->am;	cjs, go;	;			| 
    244  0a 17 1 7 2 d8d0 010d  	movw d, r[16];	shmem->am;	cjs, go roprect; ;		shp+	| dst pixrect and region
    245  0a 00 1 7 0 7140 0115  	;			;		cjs, go prclip2; ;			| prclip2 mustn't alter brreg.
    246  0a 00 1 7 0 7140 0320  	;			;		cjs, go stprep;	;			| get texture size and calcs wordwidth
                                |	subw,s d, r[4], y;	362->am;	;		;			| DEBUG
                                |	;			;		cjp, ~zer .+4;	;			| DEBUG
                                |	subw,s d, r[5], y;	302->am;	;		;			| DEBUG
                                |	;			;		cjp, ~zer .+2;	;			| DEBUG
                                |	;			;		cjp, go prrtzip; ;			| DEBUG
    247  02 00 e 0 0 de46 0000  	negw,s r[6], y;	;		;		;			| if (dst.size.x <= 0) || (y <= 0) return
    248  02 00 3 9 0 de47 024a  	negw,s r[7], y;	;		cjp, ~neg prrtzip; ;			| 
    249  0a 00 3 1 0 7140 024e  	;			;		cjp, neg prrtprep; ;			| 
    24a  08 00 e 0 2 d96b 0000  prrtzip: movw r[11], r[2];	;		;		;			| "consume" texture words from r[0] buffer.
    24b  0a 00 1 7 0 dc0c 0fcc  	incw r[12], acc;	;		cjs, go multiply; ;			| r[12] is less one due to push, rfct.
    24c  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| 
    24d  0a 00 3 7 0 989e 029c  	addw r[30], acc, r[30]; ;		cjp, go prrtend; ;			| 
    24e  0a 27 e 0 0 f8c1 001b  prrtprep: movw d, acc;		 27->am;	;		;			| Assumes prclip2 hasn't altered brreg.
    24f  0a 06 3 c 0 f880 024f  	movw acc, y;		am->fifo1;	cjp, f1f .;	;			| 
    250  0a 06 3 c 0 d84e 0250  	movw r[14], y;		am->fifo1;	cjp, f1f .;	;			| 
                                |   	movw r[12], y;		am->brreg;	;		;			| DONE by stprep (SET_TEX).
    251  0a 06 3 c 0 d84d 0251  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    252  08 00 e 0 b d96d 0000  	movw r[13], r[11];	;		;		;			| 
    253  0a 06 3 c 0 d84f 0253  	movw r[15], y;		am->fifo1;	cjp, f1f .;	;			| 
    254  12 00 4 7 0 c1eb 0000  prrtld:	sub2nw,s 0, r[11], r[11];	;		push, go;	;			| 
    255  0a 16 3 c 0 7140 0255  	;			shmem->fifo1;	cjp, f1f .;	;			| 
    256  1a 00 8 0 2 dd7e 0000     	incw r[30], r[30];	;		rfct;		;		shp+	| 
    257  0a 08 3 8 0 d84c 0254     	movw r[12], y;		am->brreg;	cjp, ~zer prrtld; ;			| 
    258  0a 17 e 0 2 d8c8 0000  	movw d, r[8];		shmem->am;	;		;		shp+	| 
    259  0a 17 e 0 2 d8c9 0000  	movw d, r[9];		shmem->am;	;		;		shp+	| 
    25a  0a 2f e 0 0 7140 01ff  	;			511->shmemp; ;	;			| Set PP tex block ptr to PIXRECT type.
    25b  0a 2a e 0 0 d80e ffff  	movw r[14], acc;	0xffff->shmem;	;		;			| Always load texture if -1 is block ptr.
    25c  02 00 e 0 0 e1ef 0000  	btstw,s 0, r[15];	;		;		;			| 
    25d  0a 00 3 8 0 d899 01d4  	movw acc, r[25];	;		cjp, ~zer rt1setup; ;			| 
    25e  0a 28 e 0 0 7140 007d  rt8:	;			=wrfifo->brreg;	;		;			| 
    25f  1a 27 1 7 0 f8c1 000a  	movw d, acc;		10->am;	cjs, go;	;			| LATER make loading 1 clip rect a routine?
    260  0a 06 3 c 0 fd00 0260  	incw 0, y;		am->fifo1;	cjp, f1f .;	;			| 1 clip rect.
    261  0a 06 3 c 0 d840 0261  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    262  0a 06 3 c 0 d841 0262  	movw r[1], y;		am->fifo1;	cjp, f1f .;	;			| 
    263  0a 06 3 c 0 d842 0263  	movw r[2], y;		am->fifo1;	cjp, f1f .;	;			| send dst pixrect x size
    264  0a 06 3 c 0 d843 0264  	movw r[3], y;		am->fifo1;	cjp, f1f .;	;			| send dst pixrect y size
    265  1a 27 1 7 0 f8c1 0015  	movw d, acc;		21->am;	cjs, go;	;			| 
    266  0a 07 e 0 0 d840 0000  	movw r[0], y;		am->am;		;		;			| Make x1
    267  0a 00 e 0 0 9e84 0000  	addw d, r[4], r[4];	;		;		;			| 
    268  08 00 e 0 1 cc90 0000  	sr0w r[16], r[17];	;		;		;			| 
    269  0a 27 e 0 0 9ed1 000f  	andw d, r[17], r[17];		0xf->am;	;		;			| 
                                | PIXOP_NEEDS_DST (r[17] << 1)= (r[17]^(r[17] << 1)) & 0xa
    26a  0a 00 e 0 0 d811 0000  	movw r[17], acc;		;		;		;			| 
    26b  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
    26c  0a 00 e 0 0 8111 0000  	xorw r[17], acc, acc;	;		;		;			| 
    26d  02 27 e 0 0 e281 000a  	addw,s d, acc, acc;	0xa->am;	;		;			| 
    26e  0a 00 3 0 0 7140 0271  	;			;		cjp, zer prrtnodst; ;			| 
    26f  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| SWWPIX
    270  0a 00 3 7 0 7140 0272  	;			;		cjp, go prrtropreg; ;			| 
    271  0a 27 e 0 0 7140 0001  prrtnodst: ;			1->am;		;		;			| SRWPIX
    272  0a 06 3 c 0 f8c0 0272  prrtropreg: movw d, y;		am->fifo1;	cjp, f1f .;	;			| RopMode
    273  0a 07 e 0 0 d841 0000  	movw r[1], y;		am->am;		;		;			| Make y1
    274  0a 00 e 0 0 9e85 0000  	addw d, r[5], r[5];	;		;		;			| 
    275  0a 06 3 c 0 d851 0275  	movw r[17], y;		am->fifo1;	cjp, f1f .;	;			| Op
    276  0a 07 e 0 0 d844 0000  	movw r[4], y;		am->am;		;		;			| Make x2
    277  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| 
    278  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| Patt
    279  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| Mask2
    27a  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| Mask1
    27b  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| r[14]
    27c  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| OpCnt
    27d  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| Shift
    27e  1a 27 1 7 0 f8c1 0000  	movw d, acc;		0->am;		cjs, go;	;			| PrimeSrc2
    27f  02 00 e 0 0 e1ef 0000  	btstw,s 0, r[15];	;		;		;			| 
    280  0a 00 3 0 0 7140 0293  	;			;		cjp, zer prrtpp8; ;			| 
    281  0a 00 e 0 0 9790 0000  	rolw 11, r[16], acc;	;		;		;			| r[18]= PIX_COLOR(r[17]) = (r[17]>>5) & 0xff
    282  02 27 e 0 0 c2d2 07ff  	andw,s d, acc, r[18];	0x7ff->am;	;		;			| if (r[18] == 0) r[18]= all ones.
    283  0a 00 3 8 0 7140 0285  	;			;		cjp, ~zer .+2;	;			| 
    284  0a 27 e 0 0 d8d2 ffff  	movw d, r[18];		0xffff->am;	;		;			| 
    285  08 27 e 0 1 9ed0 001f  	andw d, r[16], r[17];	0x1f->am;	;		;			| 
    286  02 28 e 0 0 c1e7 007d  prrtpp1:sub2nw,s 0, r[7], r[7]; =wrfifo->brreg; ;		;			| 
    287  0a 00 3 1 0 7140 029c  	;			;		cjp, neg prrtend; ;			| 
    288  1a 27 1 7 0 f8c1 001c  	movw d, acc;		28->am;	cjs, go;	;			| 
    289  0a 06 3 c 0 d845 0289  	movw r[5], y;		am->fifo1;	cjp, f1f .;	;			| 
    28a  0a 00 e 0 0 dd65 0000  	incw r[5], r[5];	;		;		;			| 
    28b  0a 06 3 c 0 d844 028b  	movw r[4], y;		am->fifo1;	cjp, f1f .;	;			| 
    28c  0a 06 3 c 0 d846 028c  	movw r[6], y;		am->fifo1;	cjp, f1f .;	;			| 
    28d  0a 06 3 c 0 d852 028d  	movw r[18], y;		am->fifo1;	cjp, f1f .;	;			| 
    28e  0a 06 3 c 0 f900 028e  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| color0= 0
    28f  0a 06 3 c 0 d851 028f  	movw r[17], y;		am->fifo1;	cjp, f1f .;	;			| 
    290  0a 06 3 c 0 d848 0290  	movw r[8], y;		am->fifo1;	cjp, f1f .;	;			| 
    291  0a 06 3 c 0 d969 0291  	movw r[9], r[9];		am->fifo1;	cjp, f1f .;	;			| 
    292  0a 00 3 7 0 dd69 0286  	incw r[9], r[9];		;		cjp, go prrtpp1; ;			| 
    293  0a 28 e 0 0 7140 007d  prrtpp8:;			=wrfifo->brreg;	;		;			| 
    294  1a 27 1 7 0 f8c1 0023  	movw d, acc;		35->am;	cjs, go;	;			| PP command.
    295  0a 06 3 c 0 d844 0295  	movw r[4], y;		am->fifo1;	cjp, f1f .;	;			| 
    296  0a 06 3 c 0 d845 0296  	movw r[5], y;		am->fifo1;	cjp, f1f .;	;			| 
    297  0a 06 3 c 0 d846 0297  	movw r[6], y;		am->fifo1;	cjp, f1f .;	;			| 
    298  0a 06 3 c 0 d847 0298  	movw r[7], y;		am->fifo1;	cjp, f1f .;	;			| 
                                |   	movw r[16], acc;	;		;		;			| r[17]= (r[17] >> 1) & 0xf
                                |   	sr0w acc, acc;		;		;		;			| 
                                |   	andw d, acc, acc;	0xf->am;	cjs, go;	;			| 
    299  0a 06 3 c 0 d850 0299  	movw r[16], y;	am->fifo1;	cjp, f1f .;	;			| 
    29a  0a 06 3 c 0 d808 029a  	movw r[8], acc;		am->fifo1;	cjp, f1f .;	;			| 
    29b  0a 06 3 c 0 d809 029b  	movw r[9], acc;		am->fifo1;	cjp, f1f .;	;			| 
    29c  0a 00 2 0 0 c9de 0027  prrtend: add2nw 4, r[30], r[30]; ;		jmap getcmd;	;			| 16:Cmd,fb,r[17],2 rects,sd,sw,sh,r[8],r[9].
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)attributes.vp.u 1.3 86/09/13 SMI
                                | vector attributes
                                | polygon attributes
                                |	incw r[30],r[30];	;		jmap SETCLIPPLANES;;
                                SETCLIPPLANES:
    29d  0a 00 e 0 0 949d 0000  	addw r[29], 4,y;;	;		;
    29e  0a 0f e 0 0 0004 0000  	;			am->shmemp;	;		;
    29f  0a 0a 2 0 0 f880 0027  	movw acc,y;		am->shmem;	jmap getcmd;	;
                                |	movw 0,y;		am->fpdp;	jmap SETMATRIX_2D; ;			  | zero fpr dst ptr
    2a0  0a 07 4 7 0 eb9c 0005  SETMATRIX_2D: rolw 5,acc,y;	am->am;		push,go 5;	;			  | d <- index*32 (index is passed in acc)
    2a1  0a 1b e 0 2 ea81 0000  	addw d, 64,acc;	shmem->fpregh;	;		;		shp+	  | copy from r[0] list in shmem to fpr[0]
    2a2  1b 1b 8 0 c 0040 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+  | acc <-  64 + index*32
    2a3  0a 0f e 0 0 909d 0000  	addw r[29],acc,y;	am->shmemp;	;		;			  | shmemp <- addr to store matrix
    2a4  0a 0c 4 7 0 f900 0005  	movw 0,y;		am->fpap;	push,go 5;	;			  | zero fpr src ptr
    2a5  0a 3a e 0 2 f8e1 0000  	movw 13,acc;		fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to frame in shmem
    2a6  1b 3a 8 0 b 000d 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
    2a7  0a 00 2 0 0 989e 0027  	addw r[30],acc,r[30];	;		jmap getcmd;	;
                                |	movw 0,y;		am->fpdp;	jmap GETMATRIX_2D; ;			  | zero fpr dst ptr
    2a8  0a 2c e 0 0 eb9d 0000  GETMATRIX_2D: rolw 5,acc,acc;	0->fpap;	;		;			  | acc <- index*32 (index is passed in acc)
    2a9  0a 27 e 0 0 e281 0040  	addw d,acc,acc;		 64->am;;		;			  | fpap <- 0
    2aa  0a 0f 4 7 0 909d 0005  	addw r[29],acc,y;	am->shmemp;	push,go 5;	;			  | shmemp <- addr to retrieve matrix
    2ab  0a 1b e 0 2 dc1e 0000  	incw r[30],acc;	shmem->fpregh;	;		;		shp+	  | copy from frame in shmem to fpr[0]
    2ac  1b 1b 8 0 c 7140 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+  | acc has shmem addr of flag
    2ad  0a 0f 4 7 0 fc80 0005  	incw acc,y;		am->shmemp;	push,go 5;	;			  | shmemp <- addr to store matrix
    2ae  0a 3a e 0 2 c49e 0000  	addw acc,13,r[30];	fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to shmem r[0] area
    2af  1b 3a 8 0 b 000d 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | r[30] += 14
    2b0  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
    2b1  0a 0a 2 0 0 f900 0027  	movw 0,y;		am->shmem;	jmap getcmd;	;			  | flag <- 0; jump to r[0] loop
                                |	movw 0,y;		am->fpdp;	jmap SETVWP_2D; ;			  | zero fpr dst ptr
    2b2  0a 0c 4 7 0 f900 0003  SETVWP_2D: movw 0,y;		am->fpap;	push,go 3;	;			  | zero fpr src ptr
    2b3  0a 1b e 0 2 f8e1 0000  	movw  52,acc;shmem->fpregh;	;		;		shp+	  | copy from r[0] list in shmem to fpr[0]
    2b4  1b 1b 8 0 c 0034 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+
    2b5  0a 0f 4 7 0 909d 0003  	addw r[29],acc,y;	am->shmemp;	push,go 3;	;			  | add r[29] and viewport frame offset
    2b6  0a 3a e 0 2 f8e1 0000  	movw 9,acc;		fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to frame in shmem
    2b7  1b 3a 8 0 b 0009 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
    2b8  0a 00 2 0 0 989e 0027  	addw r[30],acc,r[30];	;		jmap getcmd;	;
                                |	tvec_attr -- setup attributes for drawing fat and textured vectors
                                |
                                |	Input Parameters:	shmemp -- points at frame's texture
    2b9  02 17 2 0 0 f8c0 1104  tvec_attr: movw,s d,y;		shmem->am;	jmap tvec_attr_pp; ;			| Test first segment of pattern.
                                |	vec_attr -- setup attributes for drawing vectors
                                |
                                |	Input Parameters:	shmemp -- points at beginning of attribute frame
    2ba  1a 27 4 f 0 d8d1 000d  vec_attr: movw d,r[17];	 13->am;	push, ~go;	;			  | will send solid vec r[0] to fifo
    2bb  1a 26 d 4 0 7140 000c  	;			12->fifo1; loop, f1nf;	;			  | initialization for solid xf vectors
    2bc  02 17 e 0 0 961c 0000  	subw,s d,r[28],y;	shmem->am;	;		;			  | tst oldfbindx - newfbindx
    2bd  0a 17 1 8 2 f8c1 0082  vecatt2: movw d,acc;		shmem->am;	cjs,~zer getfbaddr; ;		shp+	  | if oldfbindx != newfbindx, send to PP
    2be  0a 28 e 0 0 f8e1 007d  	movw  8,acc;	=wrfifo->brreg;	;		;			  | send  8 command to PP
    2bf  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs,f1f;	;
    2c0  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | send bit plane mask
    2c1  0a 17 e 0 2 d8cd 0000  	movw d,r[13];		shmem->am;	;		;		shp+	  | save r[13]
    2c2  0a 17 e 0 2 d8cc 0000  	movw d,r[12];		shmem->am;	;		;		shp+	  | save r[12]
    2c3  0a 17 e 0 2 d8cb 0000  	movw d,r[11];	shmem->am;	;		;		shp+	  | save r[11]
    2c4  1a 17 4 f 2 d8c9 0000  	movw d,r[9];	shmem->am;	push,~go;	;		shp+	  | save r[9]
    2c5  1a 26 d 4 0 f186 000a  	mov2nw 8,acc;		10->fifo1;loop,f1nf;	;			  | send Rectlist
    2c6  0a 0f e 0 0 909d 0000  	addw r[29],acc,y;	am->shmemp;	;		;			  | starts at frame offset 0x100
    2c7  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | Number of rectangles.
    2c8  02 00 4 7 0 e185 0003  vecatt1:sub2nw,s 0,acc;		;		push,go 3;	;			  | 4 values in one rectangle
    2c9  0a 16 3 c 0 7140 02c9  	;			shmem->fifo1;	cjp,f1f .;	;
    2ca  1a 00 8 0 2 7140 0000  	;			;		rfct;		;		shp+
    2cb  0a 00 3 8 0 7140 02c8  	;			;		cjp, ~zer vecatt1;;
    2cc  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;
                                polygon_attr_3D:
                                |   Low byte of arg passed in acc indicates shading style:
                                |   constant: 0, Gouraud: 1, textured: 2 (high byte assumed to be 0).  After
                                |   setting up regular 2-D polygon attributes, check hidden surface
                                |   flag.  Return if no hidden surface removal (HSR) else check whether
                                |   gbuffer is present.  If not, return; else test if gbuffer is
                                |   associated with the current frame buffer; if not, return; else
                                |   set bit 8 of shade style register and return.  Upper byte of
                                |   r[24] indicates hidden surface method: none: 0,
                                |   zbuffer: 1.
    2cd  0a 00 1 7 0 d898 02dd  	movw acc, r[24]; ;		cjs,go polygon_attr_2D; ;		| Move low byte of command to style.
    2ce  0a 27 e 0 0 869d 0006  	addw d,r[29],acc;	6->am;;		;			  | 
    2cf  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;			  | 
    2d0  0a 17 e 0 2 f8c1 0000  	movw d, acc;		shmem->am;	;		;		shp+	| 
    2d1  02 00 e 0 0 e3f8 0000  	btstw,s 1, r[24]; ;		;		;			| if (shadestyle & 2) textured.
    2d2  0a 17 3 0 0 d8c0 02d7  	movw d, r[0];		shmem->am;	cjp, zer pa3hsr; ;			| Get depth.
    2d3  02 00 e 0 0 e7e0 0000  	btstw,s 3, r[0];	;		;		;			| if (depth == 8)
    2d4  0a 00 3 0 0 e3d8 02d6  	bclrw 1, r[24]; ;		cjp, zer pa3tex1; ;			| 
    2d5  0a 00 3 7 0 f5b8 02d7  	bsetw 10, r[24]; ;		cjp, go pa3hsr;	;			| 
    2d6  0a 00 e 0 0 f3b8 0000  pa3tex1: bsetw 9, r[24]; ;		;		;			| else (depth == 1)
    2d7  02 00 e 0 0 f880 0000  pa3hsr:	movw,s acc, y;		;		;		;			| Test acc for HSR.
    2d8  1a 00 a 0 0 7140 0000  	;			;		crtn,zer;	;			  | return if no hidden surface removal
    2d9  0a 00 1 7 0 7140 0009  	;			;		cjs,go gb_board_inq;;			  | 
    2da  12 00 a 1 0 911c 0000  	xorw,s r[28],acc,y;	;		crtn,neg;	;			  | 
    2db  1a 00 a 8 0 7140 0000  	;			;		crtn,~zer;	;			  | 
    2dc  1a 00 a 7 0 f1b8 0000  	bsetw 8,r[24];	;		crtn,go;	;			  | 
                                polygon_attr_2D:
    2dd  02 17 e 0 0 961c 0000  	subw,s d,r[28],y;	shmem->am;	;		;			  | tst oldfbindx - newfbindx
    2de  0a 17 1 8 2 f8c1 0082  	movw d,acc;		shmem->am;	cjs,~zer getfbaddr;;		shp+	  | if oldfbindx != newfbindx, send to PP
    2df  0a 28 e 0 0 f8e1 007d  	movw  8,acc;	=wrfifo->brreg;	;		;			  | send  8 command to PP
    2e0  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs,f1f;	;
    2e1  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | send bit plane mask
    2e2  0a 17 e 0 2 f8c1 0000  	movw d,acc;		shmem->am;	;		;		shp+	  | get r[13]
    2e3  0a 27 e 0 0 e2c1 001f  	andw d,acc,acc;		0x1F->am;	;		;			  | mask off upper 11 bits
    2e4  0a 17 e 0 2 aa2d 0000  	rolw 5,d,r[13];	shmem->am;	;		;		shp+	  | get r[12]
    2e5  0a 27 e 0 0 9ecd 1fe0  	andw d,r[13],r[13]; 0x1FE0->am;;		;			  | mask out noncolor bits
    2e6  0a 00 e 0 0 994d 0000  	orw r[13],acc,r[13];;	;		;			  | combine r[12] and r[13] into r[13]
    2e7  0a 17 e 0 2 d8cc 0000  	movw d,r[12];	shmem->am;	;		;		shp+	  | save r[11]
    2e8  1a 17 4 f 2 d8c9 0000  	movw d,r[9];	shmem->am;	push,~go;	;		shp+	  | save r[9]
    2e9  1a 26 d 4 0 f186 000a  	mov2nw 8,acc;		10->fifo1;loop,f1nf;	;			  | send Rectlist
    2ea  0a 0f e 0 0 909d 0000  	addw r[29],acc,y;	am->shmemp;	;		;			  | starts at frame offset 0x100
    2eb  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | acc <- # of rectangles & send to PP
    2ec  02 00 4 7 0 e185 0003  plyatt1:sub2nw,s 0,acc;		;		push,go 3;	;			  | 4 values in one rectangle.
    2ed  0a 16 3 c 0 7140 02ed  	;			shmem->fifo1;	cjp,f1f .;	;
    2ee  1a 00 8 0 2 7140 0000  	;			;		rfct;		;		shp+
    2ef  0a 00 3 8 0 7140 02ec  	;			;		cjp, ~zer plyatt1;;
    2f0  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;
                                | "@(#)%M 1.2 86/09/12 SMI"
                                | Copyright (c) 1986 by Sun Microsystems, Inc.
                                |   Utilities for texture.
                                |   	rolw 9, acc, acc;	;		jmap SET_TEXFRAME; ;			|
    2f1  02 27 e 0 0 e2c0 f1ff  SET_TEXFRAME: andw,s d, acc, y;	0xf1ff->am;	;		;			| Check for out of range block. comp 0x0e00
    2f2  0a 00 3 0 0 dd7e 02f4  	incw r[30], r[30];	;		cjp, zer stfok;	;			| 
    2f3  0a 00 3 7 0 fb01 02f5  	compw 0, acc;		;		cjp, go stfshm;	;			| Invalid tex frame is -1.
    2f4  0a 27 e 0 0 e281 3000  stfok:	addw d, acc, acc;	0x3000->am;	;		;			| Similar to USEFRAME
    2f5  0a 00 e 0 0 949d 0000  stfshm:	addw r[29], 10, y; ;	;		;			| 
    2f6  0a 0f e 0 0 000a 0000  	;			am->shmemp;	;		;			| 
    2f7  0a 0a 2 0 0 f880 0027  	movw acc, y;		am->shmem;	jmap getcmd;	;			| 
                                |   Can't use r[0] in stprep or stexld because PR_POLYTEX needs cmd (r[0]) preserved for use by PR_POLYSOL.
                                |   Loads 8-bit pixels packed two per 16 bit word.
    2f8  0a 00 e 0 0 949d 0000  SET_TEX: addw r[29], 10, y; ;	;		;			| Check for valid block ptr.
    2f9  0a 0f e 0 0 000a 0000  	;			am->shmemp;	;		;			| 
    2fa  02 17 e 0 0 d8ca 0000  	movw,s d, r[10];	shmem->am;	;		;			| -1 == invalid tex frame.
    2fb  0a 0f 3 9 0 dc5e 0307  	incw r[30], y;		am->shmemp;	cjp, ~neg stcmdok; ;			| restore r[30].
    2fc  0a 17 e 0 2 d8cf 0000  	movw d, r[15];		shmem->am;	;		;		shp+	| 
    2fd  0a 17 e 0 2 d8c2 0000  	movw d, r[2];		shmem->am;	;		;		shp+	| r[14].  Pad it out.
    2fe  02 00 e 0 0 e7ef 0000  	btstw,s 3, r[15];	;		;		;			| 
    2ff  0a 00 3 0 0 c5de 0302  	add2nw 2, r[30], r[30]; ;		cjp, zer stbad1; ;			| 4= r[0], depth, width, height
    300  0a 27 e 0 0 9e82 0001  	addw d, r[2], r[2];	1->am;		;		;			| 8-bit:  r[14]= (r[14] + 1) >> 1
    301  0a 00 3 7 0 cc82 0305  	sr0w r[2], r[2];	;		cjp, go stbad0;	;			| 
    302  0a 27 e 0 0 9e82 000f  stbad1:	addw d, r[2], r[2];	15->am;		;		;			| 1-bit:  r[14]= (r[14] + 15) >> 4
    303  0a 00 e 0 0 99e2 0000  	rolw 12, r[2], r[2];	;		;		;			| 
    304  0a 27 e 0 0 9ec2 0fff  	andw d, r[2], r[2];	0xfff->am;	;		;			| 
    305  0a 17 1 7 2 f8c1 0fcc  stbad0:	movw d, acc;		shmem->am;	cjs, go multiply; ;		shp+	| NumWords= r[14] * r[13]...
    306  0a 00 2 0 0 989e 0027  	addw r[30], acc, r[30]; ;		jmap getcmd;	;			| Skip r[30] over texture.
    307  0a 00 3 c 0 7140 0307  stcmdok: ;			;		cjp, f1f .;	;			| 
    308  0a 26 e 0 0 7140 001b  	;			 27->fifo1;	;		;			| 
    309  0a 00 1 7 0 7140 0320  	;			;		cjs, go stprep;	;			| 
    30a  12 00 4 7 0 c1eb 0000  stexld0:sub2nw,s 0, r[11], r[11];	;		push, go;	;			| Copy texture into floating pt. regs.
    30b  1b 1b 8 0 c 7140 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+| 
    30c  0a 08 3 8 0 d84c 030a  	movw r[12], y;		am->brreg;	cjp, ~zer stexld0; ;			| 
    30d  0a 06 3 c 0 d84e 030d  	movw r[14], y;		am->fifo1;	cjp, f1f .;	;			| stores d,r[20],h and setups shmemp.
    30e  0a 00 e 0 0 949d 0000  	addw r[29], 7, y; ;	;		;			| 
    30f  0a 0f e 0 0 0007 0000  	;			am->shmemp;	;		;			| 
    310  0a 06 3 c 0 d84d 0310  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    311  0a 0a e 0 2 d84f 0000  	movw r[15], y;		am->shmem;	;		;		shp+	| 
    312  0a 0a e 0 2 d84e 0000  	movw r[14], y;		am->shmem;	;		;		shp+	| 
    313  0a 0a e 0 2 d84d 0000  	movw r[13], y;		am->shmem;	;		;		shp+	| 
    314  0a 06 3 c 0 d84f 0314  	movw r[15], y;		am->fifo1;	cjp, f1f .;	;			| 
    315  0a 2f e 0 0 7140 01ff  	;			511->shmemp; ;	;			| What texture is on PP.
    316  0a 0a e 0 0 d84a 0000  	movw r[10], y;		am->shmem;	;		;			| 
    317  0a 0f e 0 0 d84a 0000  	movw r[10], y;		am->shmemp;	;		;			| TexBlock pointer -> shmemp.
    318  0a 08 e 0 0 d84c 0000  	movw r[12], y;		am->brreg;	;		;			| 
    319  08 2c e 0 b d96d 00e6  	movw r[13], r[11];	230->fpap; ;		;			| 
    31a  12 00 4 7 0 c1eb 0000  stexld:	sub2nw,s 0, r[11], r[11];	;		push, go;	;			| Copy from fl. pt. regs to shmem & fifo
    31b  0b 36 3 c 0 7140 031b     	;			fpregl->fifo1;	cjp, f1f .;	;			| 
    31c  0b 3a e 0 4 dd7e 0000  	incw r[30], r[30];	fpregl->shmem;	;		;		ap+	| 
    31d  1a 27 8 0 2 f8c1 0004  	movw d, acc;		4->am;		rfct;		;		shp+	| shp+,ap+ illegal combination of controls
    31e  0a 08 3 8 0 d84c 031a  	movw r[12], y;		am->brreg;	cjp, ~zer stexld; ;			| 
    31f  0a 00 2 0 0 989e 0027  streturn: addw r[30], acc, r[30]; ;		jmap getcmd;	;			| 
                                |   stprep does not adjust r[30], which must account for 3 items (d, r[20], h) taken from shared memory.
    320  0a 17 e 0 2 d8cf 0000  stprep:	movw d, r[15];		shmem->am;	;		;		shp+	| 
    321  0a 17 e 0 2 d8ce 0000  	movw d, r[14];		shmem->am;	;		;		shp+	| 
    322  0a 17 e 0 2 d8cd 0000  	movw d, r[13];		shmem->am;	;		;		shp+	| 
    323  02 28 e 0 0 e7ef 0329  	btstw,s 3, r[15];	=stex8->brreg;	;		;			| 
    324  12 27 3 8 0 96ce 000f  	andw,s d, r[14], y;	0xf->am;	cjp, ~zer;	;			| Is r[14] a multiple of 16?
    325  08 27 e 0 c 99ee 0fff  	rolw 12, r[14], r[12];	0xfff->am;	;		;			| r[12]= r[14] >> 4
    326  0a 08 3 8 0 9ecc 0328  	andw d, r[12], r[12];	am->brreg;	cjp, ~zer .+2;	;			| 
    327  0a 08 e 0 0 c1ec 0000  	sub2nw 0, r[12], r[12];	am->brreg;	;		;			| If (r[14] not a multiple of 16) r[12]++
    328  18 2e a 7 b d96d 00e6  	movw r[13], r[11];	230->fpdp; crtn, go;	;			| Really decrement r[12] for loop.
    329  08 00 e 0 c c1ee 0000  stex8:	sub2nw 0, r[14], r[12];	;		;		;			| 
    32a  0a 08 e 0 0 cc8c 0000  	sr0w r[12], r[12];	am->brreg;	;		;			| Packed 2 per 16 bit word.
    32b  18 2e a 7 b d96d 00e6  	movw r[13], r[11];	230->fpdp; crtn, go;	;			| 230 to avoid matrices.
                                |   	add2nw 1, r[30], r[30]; ;		jmap SET_SXSYSCRN; ;			| 
    32c  0a 17 e 0 2 d8c0 0000  SET_SXSYSCRN:movw d, r[0];	shmem->am;	;		;		shp+	| temp store sx.
    32d  0a 17 e 0 0 d8c1 0000  	movw d, r[1];		shmem->am;	;		;			| temp store sy.
    32e  0a 27 e 0 0 869d 000c  	addw d, r[29], acc;	 12->am; ;		;			| 
    32f  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    330  0a 0a e 0 2 d840 0000  	movw r[0], y;		am->shmem;	;		;		shp+	| store sx.
    331  0a 0a e 0 0 d841 0000  	movw r[1], y;		am->shmem;	;		;			| store sy.
    332  0a 27 e 0 0 869d 0018  	addw d, r[29], acc;	24->am; ;	;			| Set kind = screen sx sy
    333  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    334  0a 2a e 0 0 7140 0000  	;			0->shmem; ;		;			| 
    335  0a 00 2 0 0 dd7e 0027  	incw r[30], r[30];	;		jmap getcmd;	;			| 
                                |   	movw 0, y;		am->fpdp;	jmap SET_TEXOFF2D; ;			| 
    336  0a 0c 4 7 0 f900 0001  SET_TEXOFF2D:movw 0, y;		am->fpap;	push, go 1;	;			| 
    337  0a 1b e 0 2 f8e1 0000  	movw 14, acc; shmem->fpregh; ;		;		shp+	| 
    338  1b 1b 8 0 c 000e 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+| 
    339  0a 0f 4 7 0 909d 0001  	addw r[29], acc, y;	am->shmemp;	push, go 1;	;			| 
    33a  0a 3a e 0 2 f8e1 0000  	movw 5, acc;		fpregh->shmem;	;		;		shp+	| 
    33b  1b 3a 8 0 2 0005 0000  	;			fpregl->shmem;	rfct;		;		shp+	| 
    33c  08 27 e 0 0 9e9d 0018  	addw d, r[29], r[16]; 24->am; ;	;			| Set kind = 2D
    33d  0a 0f e 0 0 d850 0000  	movw r[16], y;		am->shmemp;	;		;			| 
    33e  0a 2a e 0 0 7140 0001  	;			 1->shmem; ;		;			| 
    33f  0a 00 2 0 0 989e 0027  	addw r[30], acc, r[30]; ;		jmap getcmd;	;			| 
                                |   	movw 0, y;		am->fpdp;	jmap SET_TEXOFF3D; ;			| 
    340  0a 0c 4 7 0 f900 0002  SET_TEXOFF3D:movw 0, y;		am->fpap;	push, go 2;	;			| 
    341  0a 1b e 0 2 f8e1 0000  	movw 18, acc; shmem->fpregh; ;		;		shp+	| 
    342  1b 1b 8 0 c 0012 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+| 
    343  0a 0f 4 7 0 909d 0002  	addw r[29], acc, y;	am->shmemp;	push, go 2;	;			| 
    344  0a 3a e 0 2 f8e1 0000  	movw 7, acc;		fpregh->shmem;	;		;		shp+	| 
    345  1b 3a 8 0 2 0007 0000  	;			fpregl->shmem;	rfct;		;		shp+	| 
    346  08 27 e 0 0 9e9d 0018  	addw d, r[29], r[16]; 24->am; ;	;			| Set kind = 3D
    347  0a 0f e 0 0 d850 0000  	movw r[16], y;		am->shmemp;	;		;			| 
    348  0a 2a e 0 0 7140 0002  	;			 2->shmem; ;		;			| 
    349  0a 00 2 0 0 989e 0027  	addw r[30], acc, r[30]; ;		jmap getcmd;	;			| 
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)recip.vp.u 1.2 86/09/12 SMI
                                |   Reciprocal and integer multiplication routines for viewing processor.
                                |	Recip -- compute reciprocal of floating point number (IEEE single precision)
                                |
                                |	Input Parameters:	fpap -- Address of X, number to be reciprocated
                                |				recaddr -- register containing fpreg address for Y, the reciprocal
                                |				N.B.: fpap and recaddr cannot point to the same location
                                |
                                |	Method:	1) Initial Guess
                                |		   Y0 = (2B-lambda)-X
                                |			A 32-bit integer subtraction
                                |			The constant 2B-lambda is looked up in a table stored in the VP Prom
                                |			The table index is the 1st 11 bits of the mantissa of X
                                |			See notes by W. Kahan and D. Hough
                                |		2) Iteration
                                |		   Y1 = Y0 + Y0 * (1.0 - X * Y0)
                                |			Floating point operations
                                |			The approximation Y1 is taken to be Y, i.e. only one iteration
    34a  0b 37 e 0 0 f8c1 0000  recip:	movw d,acc;		fpregl->am;	;		;			  | get low order X
    34b  0a 37 e 0 0 78c1 0000  	movb d,acc;		fpregh->am;	;		;		 	  | get low 8 bits of high order X
    34c  0a 27 e 0 0 eb9d 0ffe  	rolw 5,acc,acc;		0xFFE->am;	;		;			  | compute address of low order 2B-lambda
    34d  0a 09 e 0 0 e2c1 0000  	andw d,acc,acc;		am->vppromp;	;		;			  | load address into VP Prom pointer
    34e  0b 37 e 0 0 d8c1 0000  	movw d,r[1];		fpregl->am;	;		;			  | low order X again
    34f  02 37 e 0 0 d8c0 0000  	movw,s d,r[0];		fpregh->am;	;		;			  | high order X again, save sign of X
    350  0a 21 e 0 0 ffc0 0000  	bclrw 15,r[0];		vpprom->am;	;		;			  | compute positive X
    351  0a 09 e 0 0 fc80 0000  	incw acc,y;		am->vppromp;	;		;			  | Prom address for high order 2B-lambda
    352  0a 0e e 0 0 d842 0000  	movw r[2],y;		am->fpdp;	;		;			  | set up fpdp
    353  0b 0b e 0 0 9e41 0000  	rsubw d,r[1],r[1];	am->fpregl;	;		;			  | low order 2B - lambda - X
    354  0a 21 3 1 0 9e60 0356  	rsubcw d,r[0],r[0];	vpprom->am;	cjp,neg negrecip;;			  | high order 2B - lambda - X
    355  0a 0b 3 7 0 ffc0 0357  	bclrw 15,r[0];		am->fpregh;	cjp,go recip1;	;			  | store positive reciprocal
    356  0a 0b e 0 0 ffa0 0000  negrecip: bsetw 15,r[0];		am->fpregh;	;		;			  | store negative reciprocal
    357  2a 0d e 0 0 d842 0230  recip1:	movw r[2],y;		am->fpbp;	;		lmode rn,ai,flow,fast;	  | do iteration step in flow mode
    358  22 00 e 0 0 e186 0010  	mov2nw,s 0,acc;		;		;		maba,lab,hi;		  | x * Y0; acc <- 1
    359  2b 0b e 0 0 f900 0010  	movw 0,y;		am->fpregl;	;		;			  | fpr[r[2]] <- low order 1.0
    35a  0a 2b e 0 0 7140 3f80  	;			0x3F80->fpregh;	;		;			  | fpr[r[2]] <- high order 1.0
    35b  02 00 3 9 0 e185 035b  	sub2nw,s 0,acc;		;		cjp,~neg .;	;			  | delay until unload
    35c  2a 00 e 0 0 7140 0104  	;			;		;		adda,m,hi;		  | enable unload
    35d  2b 00 e 0 0 7140 0104  	;			;		;		;
    35e  22 00 e 0 0 e186 0198  	mov2nw,s 0,acc;		;		;		rsubr,lab,hi;		  | 1.0 - (X*Y0); acc <- 1
    35f  2b 0b e 0 0 d841 0198  	movw r[1],y;		am->fpregl;	;		;			  | fpr[r[2]] <- low order Y0
    360  0a 0b e 0 0 d840 0000  	movw r[0],y;		am->fpregh;	;		;			  | fpr[r[2]] <- high order Y0
    361  02 00 3 9 0 e185 0361  	sub2nw,s 0,acc;		;		cjp,~neg .;	;			  | delay until unload
    362  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;		  | enable unload
    363  2b 00 e 0 0 7140 0102  	;			;		;		;
    364  2a 00 e 0 0 7140 0018  	;			;		;		mabr,lab,hi;		  | Y0 * (1.0-X*Y0)
    365  23 00 e 0 0 e386 0018  	mov2nw,s 1,acc;		;		;		;
    366  02 00 3 9 0 e185 0366  	sub2nw,s 0,acc;		;		cjp,~neg .;	;			  | delay until unload
    367  2a 00 e 0 0 7140 0104  	;			;		;		adda,m,hi;		  | enable unload
    368  2b 00 e 0 0 7140 0104  	;			;		;		;
    369  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | Y0 + (Y0*(1.0-X*Y0))
    36a  23 00 e 0 0 e386 0118  	mov2nw,s 1,acc;		;		;		;
    36b  02 00 3 9 0 e185 036b  	sub2nw,s 0,acc;		;		cjp,~neg .;	;			  | delay until unload
    36c  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;		  | enable unload
    36d  2b 00 e 0 0 7140 0102  	;			;		;		;
    36e  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store Y1
    36f  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | return
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)cgi.vp.u 1.2 86/09/12 SMI
                                |	negw d,r[10];		shmem->am;	jmap CGI_LINE;	;
    370  0a 00 e 0 0 949d 0000  CGI_LINE: addw r[29], 28,y; ;		;		;			| 
    371  0a 0f 1 7 0 001c 02b9  	;			am->shmemp;	cjs, go tvec_attr; ;			| Texture addr->scrmemp
    372  0a 00 c 0 0 949d 0003  	addw r[29], 52,y; ;	ldct 3;		;			| 
    373  0a 0f 3 7 0 0034 0377  	;			am->shmemp;	cjp, go cgiv2;	;			| 
                                |	negw d,r[10];		shmem->am;	jmap CGIVEC;	;
    374  0a 0f 1 7 0 d85d 02ba  CGIVEC:	movw r[29],y;	am->shmemp;	cjs,go vec_attr;;
    375  0a 27 e 0 0 7140 0034  	;			 52->am;;		;
    376  0a 0f c 0 0 969d 0003  	addw d,r[29],y;	am->shmemp;	ldct 3;		;			  | shmemp <- addr of vwp params
    377  0a 0e 1 7 0 eb96 0080  cgiv2:	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr; ;			  | move viewport parameters to fpr[32]
    378  0a 0f c 0 0 c3de 0003  	add2nw 1,r[30];	am->shmemp;	ldct 3;		;			  | shmemp <- (r[30] += 2)
    379  0a 0e 1 7 0 ed96 0080  nxtcgivec: mov2nw 6,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move vector endpoints to fpr[64]
    37a  2b 0c e 0 0 cd8e 0230  	mov2nw 6,r[14];	am->fpap;	;		lmode rn,ai,pipe,fast;	  | fpap <- addr of endpoints; pipe mode
    37b  2a 08 e 0 0 e396 00a0  	mov2nw 1,y;		am->brreg;	;		floata,la,hi;		  | convert x0 to float; brreg <- 2
    37c  3b 00 4 7 4 c5ce 00a0  	add2nw 2,r[14];	;		push,go;	;		ap+	  | r[14] <- 68, put vwpscld pts at fpr[68]
    37d  2a 00 e 0 0 f8e0 00a0  	movw =vwpsv2,y;		;		;		floata,la,hi;		  | convert y0, x1, and y1
    37e  3b 08 8 0 4 04b3 00a0  	;			am->brreg;	rfct;		;		ap+	  | brreg pts to routine to finish vwp scale
    37f  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		  | pipeline advance
    380  2b 0d e 0 0 eb86 0122  	mov2nw 5,acc;		am->fpbp;	;		;			  | fpbp <- &VWPXSCL
    381  2a 00 e 0 0 7140 001a  	;			;		;		mabr,lab,a,hi;		  | x0 * VWPXSCL
    382  2b 0d e 0 0 e384 001a  	add2nw 1,acc;		am->fpbp;	;		;
    383  2a 00 e 0 0 7140 001a  	;			;		;		mabr,lab,a,hi;		  | y0 * VWPYSCL
    384  2b 0d e 0 0 e385 001a  	sub2nw 1,acc;		am->fpbp;	;		;
    385  2a 00 e 0 0 7140 001a  	;			;		;		mabr,lab,a,hi;		  | x1 * VWPXSCL
    386  2b 0d e 0 0 e384 001a  	add2nw 1,acc;		am->fpbp;	;		;
    387  2a 00 e 0 0 7140 0018  	;			;		;		mabr,lab,hi;		  | y1 * VWPYSCL
    388  3b 0d 1 7 0 e185 0018  	sub2nw 0,acc;		am->fpbp;	cjs,go;		;			  | call vwpsv2 to finish vwp scale and send
                                											  | vector to PP; r[14]==68,fpbp<-&VWPXOFF
    389  02 00 c 0 0 dd6a 0003  	incw,s r[10],r[10];	;		ldct 3;		;			  | reload 2910 R reg,increment loop counter
    38a  0a 0f 3 8 0 c7de 0379  	add2nw 3,r[30];	am->shmemp;	cjp,~zer nxtcgivec;;			  | shmemp<-(r[30] += 8),loop if more vecs
    38b  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;			  | jump to r[0] loop
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)2Dfp.vp.u 1.2 86/09/12 SMI
                                | data pointers for 2-D transform routine
                                | register which directs what vector command is being called
                                |   Floating point register addresses for xf_line_flt_2d & xf_line_int_2d
                                |   	store pt1	stored at fpr[64] (fpdp=64)
                                |   	store pt2	stored at fpr[66] (fpdp=66)
                                |	xform pt1	r[15]=64, r[14] = 68
                                |	xform pt2	r[15]=66, r[14] = 70
                                |   	clip vector	r[15]=68, r[14] = x
                                |	vwp pts 1 & 2	r[15]=68, r[14] = 72	
                                |   	store xf pt2	stored at fpr[76] (this is done before we clip)
                                |   xfln3dinit sets up the texture attributes on the pp, loads the 3d matrix and viewport scaling parameters,
                                |   and loads 1.0 for w2 before returning.  It is called by xflineflt3d, and xflineint3d. 
                                xfln2dinit:
    38c  0a 00 e 0 0 949d 0000  	addw r[29], 28,y; ;		;		;			| DEBUG
    38d  0a 0f 1 7 0 001c 02b9  	;			am->shmemp;	cjs,go tvec_attr; ;			| Texture addr->scrmemp.
    38e  0a 0f c 0 0 d849 0005  	movw r[9],y;	am->shmemp;	ldct 5;		;			| 
    38f  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr; ;			| 0 matrix to fpr[16]
    390  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am; ;		;			| 
    391  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;			| 0 viewport parameters to fpr[32]
    392  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr; ;			| 
    393  0a 0f c 0 0 d85e 0001  	movw r[30],y;		am->shmemp;	ldct 1;		;			| 
    394  12 17 a 7 2 d8d0 0000  	movw,s d,r[16];	shmem->am;	crtn,go;	;		shp+	| pull first r[16] element & return
                                |	incw r[30],r[30];	;		jmap XF_LINE_FLT_2D;			| r[30] points to first element of r[16]			
                                XF_LINE_FLT_2D: 
    395  0a 00 1 7 0 7140 038c  	;			;		cjs,go xfln2dinit; ;			| 
    396  0a 0e 1 7 0 cd8f 0080  xf1stpt2: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			| r[15]=64, 0 pt1 x,y to here
    397  0a 27 e 0 0 9e9e 0005  	addw d,r[30],r[30];	5->am;		;		;			| r[30] += 5
    398  0a 00 3 1 0 7140 0027  	;			;		cjp,neg getcmd; ;			| return if was last pt
    399  02 17 c 0 2 e190 0001  	btstw,s 0,d;		shmem->am;	ldct 1;		;		shp+	| r[16] for second point
    39a  02 00 3 8 0 d8d0 0396  	movw,s d,r[16];	;		cjp,~zer xf1stpt2; ;			| jump if 2nd point is a 0.
    39b  08 00 e 0 e c5cf 0000  	add2nw 2,r[15],r[14];	;		;		;			| r[14]=68, want xf pt1 x,y,z,r[20] here
    39c  0a 0d 1 7 0 e996 046a  	mov2nw 4,y;		am->fpbp;	cjs,go xf2;	;			| matrix ptr in fpap; convert to int & xform 1st point
    39d  0a 00 e 0 0 c5cf 0000  	add2nw 2,r[15];		;		;		;			| r[15] = 68
    39e  0a 00 e 0 0 c5ce 0000  	add2nw 2,r[14];	;		;		;			| r[14] = 72
    39f  0a 2d e 0 0 7140 0010  xf2ndpt2: ;			16->fpbp;	;		;			| 0 pt2 x,y,z coords to fpr[66]
    3a0  0a 0e 1 7 0 c3ef 0080  	sub2nw 1,r[15];		am->fpdp;	cjs,go shm_to_fpr; ;			| r[15] = 66, fetch pt2 x,y,z & store here
    3a1  0a 00 1 7 0 c3ee 046a  	sub2nw 1,r[14];	;		cjs,go xf2;	;			| r[14] = 70, convert 2nd pt to int & xform to here
    3a2  0a 2e e 0 0 7140 004c  	;			76->fpdp;	;		;			| store xformed, unclipped pt2 at fpr[76]
    3a3  0a 2c e 0 0 c382 0046  	mov2nw 1,r[2];		70->fpap;	;		;			| xformed pt2 is currently at fpr[70]
    3a4  02 3b e 0 0 c1e2 0000  xfsvpt2: sub2nw,s 0,r[2];	fpregh->fpregh;	;		;			| 
    3a5  03 3b 3 8 8 d84b 03a4  	movw,s r[11],y;	fpregl->fpregl;	cjp,~zer xfsvpt2; ;		adp+	| increment a & d pointers, loop till done
    3a6  02 0c 1 8 0 c3cf 04db  	add2nw,s 1,r[15];	am->fpap;	cjs,~zer clpvec2; ;			| r[15] = 68 (xf 1st pt.) clip vector if r[11]!=0;
                                											| also if no clip, force cc to ~zer so vec is drawn
    3a7  0a 00 1 8 0 c3ce 04aa  	add2nw 1,r[14];	;		cjs,~zer vwpsndvec2; ;			| r[14] = 72.  if visible, scale to viewport, cnvrt to
                                											| int, & xmit to PP
    3a8  02 27 e 0 0 d850 0005  	movw,s r[16],y;	5->am;		;		;			| test if just sent last vector
    3a9  0a 0f 3 1 0 9e9e 0027  	addw d,r[30],r[30];	am->shmemp;	cjp,neg getcmd;	;			| r[30] += 5 and exit if was last vector
    3aa  0a 17 c 0 2 d8d0 0001  	movw d,r[16];		shmem->am;	ldct 1;		;		shp+	| fetch r[16] for next point
    3ab  02 2c e 0 0 e1f0 004c  	btstw,s 0,r[16];	76->fpap;	;		;			| copy xf pt2 (before clip) to xf pt1 area
    3ac  0a 2e e 0 0 c382 0044  	mov2nw 1,r[2];		68->fpdp;	;		;			| 
    3ad  02 00 3 8 0 d850 0396  	movw,s r[16],y;	;		cjp,~zer xf1stpt2; ;			| Will check if last point if jump.
    3ae  02 3b e 0 0 c1e2 0000  	sub2nw,s 0,r[2];	fpregh->fpregh;	;		;			| jump if 2nd point is a movw
    3af  0b 3b 3 0 8 7140 039f  xfswap2: ;			fpregl->fpregl;	cjp,zer xf2ndpt2; ;		adp+	| increment a & d pointers
    3b0  02 3b 3 7 0 c1e2 03af  	sub2nw,s 0,r[2];	fpregh->fpregh;	cjp,go xfswap2; ;			| loop
                                |	incw r[30],r[30];	;		jmap XF_LINE_INT_2D;			| r[30] points to first element of r[16]			
                                XF_LINE_INT_2D: 
    3b1  0a 00 1 7 0 7140 038c  	;			;		cjs,go xfln2dinit; ;			| 
    3b2  0a 0e 1 7 0 cd8f 0080  xf1stpt2i: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			| r[15]=64, 0 pt1 x,y to here
    3b3  0a 27 e 0 0 9e9e 0005  	addw d,r[30],r[30];	5->am;		;		;			| r[30] += 5
    3b4  0a 00 3 1 0 7140 0027  	;			;		cjp,neg getcmd; ;			| return if was last pt
    3b5  02 17 c 0 2 e190 0001  	btstw,s 0,d;		shmem->am;	ldct 1;		;		shp+	| r[16] for second point
    3b6  02 00 3 8 0 d8d0 03b2  	movw,s d,r[16];	;		cjp,~zer xf1stpt2i; ;			| jump if 2nd point is a 0.
    3b7  08 00 e 0 e c5cf 0000  	add2nw 2,r[15],r[14];	;		;		;			| r[14]=68, want xf pt1 x,y,z,r[20] here
    3b8  0a 0d 1 7 0 e996 045b  	mov2nw 4,y;		am->fpbp;	cjs,go xfint2; ;			| matrix ptr in fpap; convert to int & xform 1st point
    3b9  0a 00 e 0 0 c5cf 0000  	add2nw 2,r[15];		;		;		;			| r[15] = 68
    3ba  0a 00 e 0 0 c5ce 0000  	add2nw 2,r[14];	;		;		;			| r[14] = 72
    3bb  0a 2d e 0 0 7140 0010  xf2ndpt2i: ;			16->fpbp;	;		;			| 0 pt2 x,y,z coords to fpr[66]
    3bc  0a 0e 1 7 0 c3ef 0080  	sub2nw 1,r[15];		am->fpdp;	cjs,go shm_to_fpr; ;			| r[15] = 66, fetch pt2 x,y,z & store here
    3bd  0a 00 1 7 0 c3ee 045b  	sub2nw 1,r[14];	;		cjs,go xfint2; ;			| r[14] = 70, convert 2nd pt to int & xform to here
    3be  0a 2e e 0 0 7140 004c  	;			76->fpdp;	;		;			| store xformed, unclipped pt2 at fpr[76]
    3bf  0a 2c e 0 0 c382 0046  	mov2nw 1,r[2];		70->fpap;	;		;			| xformed pt2 is currently at fpr[70]
    3c0  02 3b e 0 0 c1e2 0000  xfsvpt2i: sub2nw,s 0,r[2];	fpregh->fpregh;	;		;			| 
    3c1  03 3b 3 8 8 d84b 03c0  	movw,s r[11],y;	fpregl->fpregl;	cjp,~zer xfsvpt2i; ;		adp+	| increment a & d pointers, loop till done
    3c2  02 0c 1 8 0 c3cf 04db  	add2nw,s 1,r[15];	am->fpap;	cjs,~zer clpvec2; ;			| r[15] = 68 (xf 1st pt.) clip vector if r[11]!=0;
                                											| also if no clip, force cc to ~zer so vec is drawn
    3c3  0a 00 1 8 0 c3ce 04aa  	add2nw 1,r[14];	;		cjs,~zer vwpsndvec2; ;			| r[14] = 72.  if visible, scale to viewport, cnvrt to
                                											| int, & xmit to PP
    3c4  02 27 e 0 0 d850 0005  	movw,s r[16],y;	5->am;		;		;			| test if just sent last vector
    3c5  0a 0f 3 1 0 9e9e 0027  	addw d,r[30],r[30];	am->shmemp;	cjp,neg getcmd;	;			| r[30] += 5 and exit if was last vector
    3c6  0a 17 c 0 2 d8d0 0001  	movw d,r[16];		shmem->am;	ldct 1;		;		shp+	| fetch r[16] for next point
    3c7  02 2c e 0 0 e1f0 004c  	btstw,s 0,r[16];	76->fpap;	;		;			| copy xf pt2 (before clip) to xf pt1 area
    3c8  0a 2e e 0 0 c382 0044  	mov2nw 1,r[2];		68->fpdp;	;		;			| 
    3c9  02 00 3 8 0 d850 03b2  	movw,s r[16],y;	;		cjp,~zer xf1stpt2i; ;			| Will check if last point if jump.
    3ca  02 3b e 0 0 c1e2 0000  	sub2nw,s 0,r[2];	fpregh->fpregh;	;		;			| jump if 2nd point is a movw
    3cb  0b 3b 3 0 8 7140 03bb  xfswap2i: ;			fpregl->fpregl;	cjp,zer xf2ndpt2i; ;		adp+	| increment a & d pointers
    3cc  02 3b 3 7 0 c1e2 03cb  	sub2nw,s 0,r[2];	fpregh->fpregh;	cjp,go xfswap2i; ;			| loop
                                |	negw d,r[10];		shmem->am;	jmap XFVEC_2D;	;
    3cd  0a 0f 1 7 0 d85d 02ba  XFVEC_2D: movw r[29],y;	am->shmemp;	cjs,go vec_attr;;
    3ce  0a 0f c 0 0 d849 0005  	movw r[9],y;	am->shmemp;	ldct 5;		;
    3cf  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    3d0  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    3d1  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;
    3d2  0a 0e 1 7 0 eb96 0080  xfv2D2:	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr; ;			  | move viewport parameters to fpr[32]
    3d3  0a 0f c 0 0 c3de 0003  	add2nw 1,r[30];	am->shmemp;	ldct 3;		;
    3d4  0a 0e 1 7 0 cd8f 0080  nxtvec2: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr;;			  | move vector endpoints to fpr[64]
    3d5  02 2d e 0 0 d84b 0010  	movw,s r[11],y;	16->fpbp;	;		;			  | r[11]==0? (xf2 doesn't affect cc's)
    3d6  08 00 1 7 e c5cf 046a  	add2nw 2,r[15],r[14];	;		cjs,go xf2;	;			  | want transformed endpoints at fpr[68]
                                											  | transform 1st point
    3d7  0a 2d e 0 0 c3cf 0010  	add2nw 1,r[15];		16->fpbp;	;		;
    3d8  0a 00 1 7 0 c3ce 046a  	add2nw 1,r[14];	;		cjs,go xf2;	;			  | transform 2nd point
    3d9  02 0c 1 8 0 c3cf 04db  	add2nw,s 1,r[15];	am->fpap;	cjs,~zer clpvec2;;			  | clip vector if r[11]!=0, also if no
                                											  | clip force cc to ~zer so vec is drawn
    3da  0a 00 1 8 0 c3ce 04aa  	add2nw 1,r[14];	;		cjs,~zer vwpsndvec2;;			  | if visible, scale to viewport, cnvrt to
                                											  | int, & xmit to PP
    3db  02 00 c 0 0 dd6a 0003  	incw,s r[10],r[10];	;		ldct 3;		;			  | reload 2910 R reg, incr vector loop ctr
    3dc  0a 0f 3 8 0 c7de 03d4  	add2nw 3,r[30];	am->shmemp;	cjp,~zer nxtvec2;;			  | r[30] += 8 and loop if more vectors
    3dd  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |   mulptinit2 does necessary initialization for the int & float mulpt routines.
                                mulptinit2: 
    3de  0a 28 e 0 0 949d 0001  	addw r[29],5,y; 1->brreg; ;		;			  | brreg <- 1
    3df  0a 0f e 0 0 0005 0000  	;			am->shmemp;	;		;			  | shmemp <- addr of r[9]
    3e0  0a 1f c 0 0 c38e 0005  	mov2nw 1,r[14];	shmem->shmemp;	ldct 5;		;			  | shmemp <- addr of matrix; r[14] <- 2
    3e1  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    3e2  1a 0f c 0 0 c3de 0000  	add2nw 1,r[30];	am->shmemp;	ldct;		;			  | shmemp <- (r[30] += 2), addr of 1st pt
    3e3  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			| 
                                |	negw d,r[10];		shmem->am;	jmap MUL_POINT_FLT_2D;;			  | r[10] <- -npts
                                MUL_POINT_FLT_2D:
    3e4  0a 00 1 7 0 7140 03de  	;			;		cjs, go mulptinit2; ;			  | do initialization for mulpt2 routines
    3e5  0a 0e 1 7 0 d90f 0080  xfpt2nxt: movw 0,r[15];		am->fpdp;	cjs,go shm_to_fpr;;			  | move pt[i] to fpr[0]
    3e6  0a 0d 1 7 0 e996 046a  	mov2nw 4,y;		am->fpbp;	cjs,go xf2;	;			  | xform pt and store result at fpr[2]
    3e7  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- addr of pt
    3e8  12 2c 4 7 0 dd6a 0002  	incw,s r[10],r[10];	2->fpap;	push,go;	;			  | r[10] += 1; fpap <- addr of xformed pt
    3e9  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move xformed pt to shared memory,
    3ea  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | overwriting original pt
    3eb  1a 27 c 0 0 9e9e 0005  	addw d,r[30],r[30];	5->am;		ldct;		;			  | r[30] += 5, addr of pt[i+1]
    3ec  0a 0a 3 8 2 f900 03e5  	movw 0,y;		am->shmem;	cjp,~zer xfpt2nxt;;		shp+	  | flag[i] <- 0, indicating xform done
                                											  | loop back for next pt;shmemp == &pt[i+1]
    3ed  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                											  | 2-D Matrix Multiply: C = A x B
                                |	negw d,r[10];		shmem->am;	jmap MUL_POINT_INT_2D;;			  | r[10] <- -npts
                                MUL_POINT_INT_2D:
    3ee  0a 00 1 7 0 7140 03de  	;			;		cjs, go mulptinit2; ;			  | do initialization for mulpt2 routines
    3ef  0a 0e 1 7 0 d90f 0080  xfpt2nxti: movw 0,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			  | move pt[i] to fpr[0]
    3f0  0a 0d 1 7 0 e996 045b  	mov2nw 4,y;		am->fpbp;	cjs,go xfint2;	;			  | xform pt and store result at fpr[2]
    3f1  08 00 1 7 f d96e 044c  	movw r[14],r[15];	;		cjs,go fltoint2; ;			  | convert float res to int, need r[15]
    3f2  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- addr of pt
    3f3  12 2c 4 7 0 dd6a 0002  	incw,s r[10],r[10];	2->fpap;	push,go;	;			  | r[10] += 1; fpap <- addr of xformed pt
    3f4  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move xformed pt to shared memory,
    3f5  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | overwriting original pt
    3f6  1a 27 c 0 0 9e9e 0005  	addw d,r[30],r[30];	5->am;		ldct;		;			  | r[30] += 5, addr of pt[i+1]
    3f7  0a 0a 3 8 2 f900 03ef  	movw 0,y;		am->shmem;	cjp,~zer xfpt2nxti;;		shp+	  | flag[i] <- 0, indicating xform done
                                											  | loop back for next pt;shmemp == &pt[i+1]
    3f8  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |	negw d,r[10];		shmem->am;	jmap PROC_LINE_INT_2D;;
                                PROC_LINE_INT_2D:
    3f9  0a 27 e 0 0 d8c5 084f  	movw d,r[5];		=xfint3->am;	;		;			  | set ptr to fixtofloat routine
    3fa  0a 00 3 7 0 7140 03fc  	;			;		cjp,go cwdvec2;	;			  | and fall through to xf3. otherwise
                                											  | use regular float routine
                                |	negw d,r[10];		shmem->am;	jmap PROC_LINE_FLT_2D;;
                                PROC_LINE_FLT_2D:
    3fb  0a 27 e 0 0 d8c5 0860  	movw d,r[5];		=xf3->am;	;		;			  | set ptr to regular xf3 routine
    3fc  0a 27 e 0 0 869d 0004  cwdvec2: addw d,r[29],acc;	 4->am; ;		;			  | 
    3fd  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
    3fe  0a 17 c 0 2 d8cb 0001  	movw d,r[11];	shmem->am;	ldct 1;		;		shp+	  | save r[11]
    3ff  0a 1f 1 7 0 d906 0429  	movw 0,r[6];	shmem->shmemp;	cjs,go expmtrx;	;			  | shmemp <- r[9]
    400  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    401  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;			  | shmemp <- addr of vwp params
    402  0a 0e 1 7 0 eb96 0426  	mov2nw 5,y;		am->fpdp;	cjs,go expvwp;	;			  | move viewport parameters to fpr[32]
    403  0a 0f c 0 0 c3de 0001  	add2nw 1,r[30];	am->shmemp;	ldct 1;		;
                                cwnnxtvec2:
    404  0a 0e 1 7 2 cd8f 0080  	mov2nw 6,r[15];		am->fpdp;	cjs,go shm_to_fpr; ;		shp+	  | move pt1 x,y coords to fpr[64]
    405  0a 0b e 0 0 f900 0000  	movw 0,y;		am->fpregh;	;		;			  | expand pt1 with z=0
    406  0b 0b e 0 6 f900 0000  	movw 0,y;		am->fpregl;	;		;		dp+	  | z->fpr[66]
    407  0a 2b e 0 0 7140 3f80  	;			0x3F80->fpregh;	;		;			  | w1 = 1.0
    408  0b 0b c 0 6 f900 0001  	movw 0,y;		am->fpregl;	ldct 1;		;		dp+	  | ldct 2 into 2910 counter
    409  02 00 1 7 0 d84b 0080  	movw,s r[11],y;	;		cjs,go shm_to_fpr; ;			  | move pt2 x,y,z coords to fpr[68]
                                											  | r[11]==0? (xf3 doesn't affect cc's)
    40a  0a 0b e 0 0 f900 0000  	movw 0,y;		am->fpregh;	;		;			  | expand pt2 with z=0
    40b  0b 0b e 0 6 f900 0000  	movw 0,y;		am->fpregl;	;		;		dp+	  | z->fpr[70]
    40c  0a 00 1 7 0 7140 07e1  	;			;		cjs,go cwn3;	;			  | 
    40d  02 00 e 0 0 e1e6 0000  cwnout2: btstw,s 0,r[6];	;		;		;			  | test if invisible
    40e  0a 00 3 8 0 7140 0423  	;			;		cjp,~zer cwnnovec2; ;			  | if so get next vector
    40f  2b 0c e 0 0 d844 0230  	movw r[4],y;	am->fpap;	;		lmode rn,ai,pipe,fast;	  | fpap <- &x0; pipeline mode
    410  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | convert x0 to integer
    411  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+
    412  2a 00 e 0 0 f8e0 00e0  	movw 76,y;		;		;		fixa,la,hi;		  | y0
    413  2b 0c e 0 0 004c 00e0  	;			am->fpap;	;		;			  | fpap <- &x1
    414  2a 00 e 0 0 f8e0 00e0  	movw 3,y;		;		;		fixa,la,hi;		  | x1
    415  2b 08 e 0 4 0003 00e0  	;			am->brreg;	;		;		ap+	  | brreg <- 3
    416  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | y1
    417  2b 00 e 0 0 7140 00e0  	;			;		;		;			  | 
    418  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		  | 
    419  3b 0e 4 7 0 f900 0122  	movw 0,y;		am->fpdp;	push,go;	;			  | fpdp <- 0; 2910 R reg <- 3
    41a  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store x0,y0,x1,y1 starting
    41b  3b 0c 8 0 6 f900 0123  	movw 0,y;		am->fpap;	rfct;		;		dp+	  | fpreg[0]; fpap <- 0
    41c  1a 27 4 7 0 9e9e 0009  	addw d,r[30],r[30];	9->am;		push,go;	;			  | r[30] += 9
    41d  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | overwrite original coords in shmem
    41e  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
                                cwnloop2:
    41f  0a 0a e 0 2 f900 0000  	movw 0,y;		am->shmem;	;		;		shp+	  | dataready[i] <- 0;shmemp <- nxt vec addr
    420  02 00 c 0 0 dd6a 0001  	incw,s r[10],r[10];	;		ldct 1;		;			  | reload 2910 R reg; incr vec loop cntr
    421  0a 00 3 8 0 dd7e 0404  	incw r[30],r[30];	;		cjp,~zer cwnnxtvec2;;			  | r[30] += 1 and loop if more vectors
    422  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                cwnnovec2:
    423  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- &resultflag[i]
    424  0a 2a e 0 0 9c9e ffff  	addw r[30],9,r[30];	0xFFFF->shmem;	;		;			  | resultflag for this vector <- 0xFFFF
    425  0a 0f 3 7 0 0009 041f  	;			am->shmemp;	cjp,go cwnloop2; ;			  | shmemp <- r[30] <- &dataready[i]
    426  0a 00 1 7 0 7140 0080  expvwp:	;			;		cjs,go shm_to_fpr; ;			  | move 2D viewport in
    427  0a 00 c 0 0 7140 0001  	;			;		ldct 1;		;			  | move 0 into z scale and offset for 3D
    428  0a 00 3 7 0 7140 0437  	;			;		cjp,go expzero;	;			  | return directly to calling routine
                                expmtrx:
    429  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr; ;			  | move 2D matrix to fpr[16]
    42a  0a 00 c 0 0 7140 0001  	;			;		ldct 1;		;			  | move 0 into 13 14
    42b  0a 00 1 7 0 7140 0437  	;			;		cjs,go expzero;	;			  | 
    42c  0a 00 c 0 0 7140 0001  	;			;		ldct 1;		;			  | 
    42d  0a 00 1 7 0 7140 0080  	;			;		cjs,go shm_to_fpr; ;			  | move 2D matrix to fpr[20]
    42e  0a 00 c 0 0 7140 0005  	;			;		ldct 5;		;			  | move 0 into 23 24
    42f  0a 00 1 7 0 7140 0437  	;			;		cjs,go expzero;	;			  |       31 32 33 34
    430  0a 00 c 0 0 7140 0001  	;			;		ldct 1;		;			  | 
    431  0a 00 1 7 0 7140 0080  	;			;		cjs,go shm_to_fpr; ;			  | move 2D matrix to fpr[28]
    432  0a 0b e 0 0 f900 0000  	movw 0,y;		am->fpregh;	;		;			  | 
    433  0b 0b e 0 6 f900 0000  	movw 0,y;		am->fpregl;	;		;		dp+	  | move 0 into 43
    434  0a 2b e 0 0 7140 3f80  	;			0x3f80->fpregh;	;		;			  | move 1 into    44
    435  1b 0b a 7 6 f900 0000  	movw 0,y;		am->fpregl;	crtn,go;	;		dp+	  | 
    436  0b 0b e 0 6 f900 0000  	movw 0,y;		am->fpregl;	;		;		dp+	| 
    437  0a 0b 9 0 0 f900 0436  expzero: movw 0,y;		am->fpregh;	rpct .-1;	;			| 
    438  1b 0b a 7 6 f900 0000  	movw 0,y;		am->fpregl;	crtn,go;	;		dp+	| 
                                |	rolw 5,d,acc;		shmem->am;	jmap MATMUL_2D;	;		shp+	  | acc <- indexA*32
                                MATMUL_2D:
    439  0a 17 e 0 2 aa20 0000  	rolw 5,d,r[0];		shmem->am;	;		;		shp+	  | r[0] <- indexB*32
    43a  0a 17 e 0 0 aa21 0000  	rolw 5,d,r[1];		shmem->am;	;		;			  | r[1] <- indexC*32
    43b  0a 27 e 0 0 e281 0040  	addw d,acc,acc;		 64->am;;		;
    43c  0a 0f c 0 0 909d 0005  	addw r[29],acc,y;	am->shmemp;	ldct 5;		;			  | shmemp <- addr of matrix A
    43d  0a 0e 1 7 0 c98f 0080  	mov2nw 4,r[15];		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix A to fpr[16]
    43e  0a 27 e 0 0 8680 0040  	addw d,r[0],acc;	 64->am;;		;
    43f  0a 0f c 0 0 909d 0005  	addw r[29],acc,y;	am->shmemp;	ldct 5;		;			  | shmemp <- addr of matrix B
    440  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix B to fpr[32]
    441  0a 0d e 0 0 eb96 0000  	mov2nw 5,y;		am->fpbp;	;		;			  | fpbp <- addr of matrix B (in fpr)
    442  0a 00 1 7 0 cd8e 048d  	mov2nw 6,r[14];	;		cjs,go xf2_noxl;;			  | r[14] <- addr of matrix C (fpr[64])
                                											  | r[15] == addr of 1st row of matrix A
                                											  | xf2_noxl produces 1st row of matrix C 
                                											  | xf2_noxl uses no translation terms, so
                                											  | we have the effect of the third element
                                											  | of the A row vector being 0.0
    443  0a 2d e 0 0 c3cf 0020  	add2nw 1,r[15];		32->fpbp;	;		;
    444  0a 00 1 7 0 c3ce 048d  	add2nw 1,r[14];	;		cjs,go xf2_noxl;;			  | produce 2nd row of matrix C
    445  0a 2d e 0 0 c3cf 0020  	add2nw 1,r[15];		32->fpbp;	;		;
    446  0a 00 1 7 0 c3ce 046a  	add2nw 1,r[14];	;		cjs,go xf2;	;			  | produce 3rd row of matrix C
                                											  | xf2 does use the translation terms, so
                                											  | we have the effect of the third element
                                											  | of the A row vector being 1.0
    447  0a 2c e 0 0 8681 0040  	addw d,r[1],acc;	64->fpap;	;		;			  | fpap <- addr of matrix C (in fpr)
    448  0a 0f 4 7 0 909d 0005  	addw r[29],acc,y;	am->shmemp;	push,go 5;	;			  | shmemp <- addr of matrix C (in shmem)
                                											  | d still has XFORM_FRMOFF
    449  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move matrix C to shmem
    44a  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
    44b  0a 00 2 0 0 c5de 0027  	add2nw 2,r[30],r[30];	;		jmap getcmd;	;			  | r[30] += 4; jump to r[0] loop
                                |	fltoint2 -- 2D conversion from float to int.  Operates on a single point and converts
                                |   	            the points in place, ie, overwrites the original floating point value.
                                |
                                |	Input Parameters:	r[15] -- Location of point to be converted.
    44c  2b 0c e 0 0 d84f 0230  fltoint2: movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	| 
    44d  2a 0e e 0 0 d84f 00e0  	movw r[15],y;		am->fpdp;	;		fixa,la,hi;		| convert x to int
    44e  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    44f  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		| convert y to int	
    450  2b 00 e 0 0 7140 00e0  	;			;		;		;			| 
    451  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;			| 
    452  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    453  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;			| 
    454  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    455  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		| 
    456  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    457  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		| overwrite x
    458  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    459  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		| overwrite x
    45a  3b 00 a 7 0 7140 0101  	;			;		crtn, go;	;			| 
                                |	xfint2 -- convert point from fix to float and fall through to xf2
                                |
                                |	Important Properties:	Does not use brreg; Does not use 2910 R register (counter)
                                |				Does not change latched 29116 condition code status
                                |
    45b  2b 0c e 0 0 d84f 0230  xfint2:	movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;
    45c  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | x
    45d  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    45e  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | y
    45f  2b 00 e 0 0 7140 00a0  	;			;		;		;
    460  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    461  2b 00 e 0 0 7140 0120  	;			;		;		;
    462  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    463  2b 00 e 0 0 7140 0120  	;			;		;		;
    464  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    465  2b 0e e 0 0 d84f 0122  	movw r[15],y;		am->fpdp;	;		;
    466  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite x
    467  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    468  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | overwrite y
    469  2b 00 e 0 0 7140 0101  	;			;		;		;			  | fall through to xf2
                                |	xf2 -- 2-D floating point transform
                                |
                                |	Input Parameters:	r[15] -- Address of input point
                                |				r[14] -- Address of output point
                                |				matrix -- fpbp should have been loaded
                                |					  with the address of the matrix
                                |					  prior to calling this routine.
                                |					  A 3x2 matrix.  3rd column is
                                |					  assumed to be 0,0,1.
    46a  2b 0c e 0 0 d84f 0230  xf2:	movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;
    46b  2a 0e e 0 0 d84e 0010  	movw r[14],y;		am->fpdp;	;		maba,lab,hi;		  | x*m11
    46c  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    46d  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x*m12
    46e  2b 00 e 0 7 7140 0010  	;			;		;		;		abp+
    46f  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y*m21
    470  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    471  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y*m22
    472  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    473  2a 00 e 0 0 7140 0124  	;			;		;		adda,la,m,hi;
    474  2b 00 e 0 0 7140 0124  	;			;		;		;
    475  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (x*m11)+m31
    476  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    477  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (x*m12)+m32
    478  2b 00 e 0 0 7140 011c  	;			;		;		;
    479  2a 0d e 0 0 d84e 0125  	movw r[14],y;		am->fpbp;	;		adda,la,m,st,hi;		  | store y*m21
    47a  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+
    47b  2a 00 e 0 0 7140 0121  	;			;		;		adda,la,st,hi;		  | store y*m22
    47c  2b 00 e 0 0 7140 0121  	;			;		;		;
    47d  2a 0e e 0 0 d84e 0122  	movw r[14],y;		am->fpdp;	;		adda,la,a,hi;
    47e  2b 00 e 0 0 7140 0122  	;			;		;		;
    47f  2a 00 e 0 0 7140 011a  	;			;		;		addr,lab,a,hi;		  | ((x*m11)+m31)+(y*m21)
    480  2b 00 e 0 5 7140 011a  	;			;		;		;		bp+
    481  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | ((x*m12)+m32)+(y*m22)
    482  2b 00 e 0 0 7140 0118  	;			;		;		;
    483  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    484  2b 00 e 0 0 7140 0120  	;			;		;		;
    485  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    486  2b 00 e 0 0 7140 0120  	;			;		;		;
    487  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    488  2b 00 e 0 0 7140 0122  	;			;		;		;
    489  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store new x
    48a  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    48b  2a 00 e 0 0 7140 0121  	;			;		;		adda,la,st,hi;		  | store new y
    48c  3b 00 a 7 0 7140 0121  	;			;		crtn,go;	;
    48d  2b 0c e 0 0 d84f 0230  xf2_noxl: movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;
    48e  2a 0e e 0 0 d84e 0010  	movw r[14],y;		am->fpdp;	;		maba,lab,hi;		  | x*m11
    48f  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    490  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x*m12
    491  2b 00 e 0 7 7140 0010  	;			;		;		;		abp+
    492  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y*m21
    493  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    494  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y*m22
    495  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    496  2a 00 e 0 0 7140 0124  	;			;		;		adda,la,m,hi;
    497  2b 00 e 0 0 7140 0124  	;			;		;		;
    498  2a 00 e 0 0 7140 0125  	;			;		;		adda,la,m,st,hi;		  | store x*m11
    499  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+
    49a  2a 00 e 0 0 7140 0125  	;			;		;		adda,la,m,st,hi;		  | store x*m12
    49b  2b 0d e 0 0 d84e 0125  	movw r[14],y;		am->fpbp;	;		;
    49c  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (x*m11)+y*m21
    49d  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    49e  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | (x*m12)+y*m22
    49f  2b 00 e 0 0 7140 0118  	;			;		;		;
    4a0  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    4a1  2b 00 e 0 0 7140 0120  	;			;		;		;
    4a2  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    4a3  2b 00 e 0 0 7140 0120  	;			;		;		;
    4a4  2a 0e e 0 0 d84e 0122  	movw r[14],y;		am->fpdp;	;		adda,la,a,hi;
    4a5  2b 00 e 0 0 7140 0122  	;			;		;		;
    4a6  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store new x
    4a7  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    4a8  2a 00 e 0 0 7140 0121  	;			;		;		adda,la,st,hi;		  | store new y
    4a9  3b 00 a 7 0 7140 0121  	;			;		crtn,go;	;
                                |	vwpsndvec2 -- scale 2-D vector to viewport, convert floating point
                                |		      coordinates to integer, and send to Painting Processor
                                |		      input vectors are in NDC, i.e. clipped vectors will have
                                |		      -1.0 <= x,y <= +1.0
                                |
                                |	Input Parameters:	fpap -- points to coords to be converted
                                |				r[14] -- points to a place to deposit the converted coords
                                |
    4aa  2b 0d e 0 0 eb86 0230  vwpsndvec2: mov2nw 5,acc;	am->fpbp;	;		lmode rn,ai,pipe,fast;	  | fpbp pts to viewport params
    4ab  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x0 * VWPXSCL
    4ac  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    4ad  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y0 * VWPYSCL
    4ae  2b 0d e 0 4 e385 0010  	sub2nw 1,acc;		am->fpbp;	;		;		ap+
    4af  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x1 * VWPXSCL
    4b0  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    4b1  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y1 * VWPYSCL
    4b2  2b 0d e 0 0 e185 0010  	sub2nw 0,acc;		am->fpbp;	;		;
                                											  | can arrive here from above for 2-D vecs
                                											  | or from vwpsndvec3 for 3-D vecs
    4b3  2a 00 e 0 0 f8e0 0124  vwpsv2:	movw =wrfifo,y;		;		;		adda,la,m,hi;
    4b4  2b 08 e 0 0 007d 0124  	;			am->brreg;	;		;
    4b5  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (x0 * VWPXSCL) + VWPXOFF
    4b6  2b 0d e 0 0 e384 011c  	add2nw 1,acc;		am->fpbp;	;		;
    4b7  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (y0 * VWPYSCL) + VWPYOFF
    4b8  2b 0d e 0 0 e385 011c  	sub2nw 1,acc;		am->fpbp;	;		;
    4b9  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | (x1 * VWPXSCL) + VWPXOFF
    4ba  2b 0d e 0 0 e384 011c  	add2nw 1,acc;		am->fpbp;	;		;
    4bb  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | (y1 * VWPYSCL) + VWPYOFF
    4bc  3b 06 1 c 0 d811 0118  	movw r[17],acc;	am->fifo1;	cjs,f1f;	;			  | send vector command
    4bd  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    4be  2b 00 e 0 0 7140 0122  	;			;		;		;
    4bf  2a 00 e 0 0 7140 00ea  	;			;		;		fixr,la,a,hi;		  | convert x0 to int
    4c0  2b 00 e 0 0 7140 00ea  	;			;		;		;
    4c1  2a 00 e 0 0 7140 00ea  	;			;		;		fixr,la,a,hi;		  | convert y0 to int
    4c2  2b 00 e 0 0 7140 00ea  	;			;		;		;
    4c3  2a 00 e 0 0 7140 00ea  	;			;		;		fixr,la,a,hi;		  | convert x1 to int
    4c4  2b 00 e 0 0 7140 00ea  	;			;		;		;
    4c5  2a 00 e 0 0 7140 00e8  	;			;		;		fixr,la,hi;		  | convert y1 to int
    4c6  2b 00 e 0 0 7140 00e8  	;			;		;		;
    4c7  2a 0e e 0 0 d84e 0122  	movw r[14],y;		am->fpdp;	;		adda,la,a,hi;
    4c8  2b 0c e 0 0 d84e 0122  	movw r[14],y;		am->fpap;	;		;
    4c9  2a 00 e 0 0 d8e0 0123  	movw =fifofull,r[0];	;		;		adda,la,a,st,hi;
    4ca  2b 08 e 0 6 04d3 0123  	;			am->brreg;	;		;		dp+
    4cb  2a 00 e 0 0 f8e1 0123  	movw 3,acc;		;		;		adda,la,a,st,hi;
    4cc  3b 36 3 c 6 0003 0123  	;			fpregl->fifo1;	cjp,f1f;	;		dp+	  | x0
    4cd  2a 08 e 0 4 c3c0 0123  	add2nw 1,r[0];		am->brreg;	;		adda,la,a,st,hi;	ap+
    4ce  3b 36 3 c 6 e185 0123  	sub2nw 0,acc;		fpregl->fifo1;	cjp,f1f;	;		dp+	  | y0
    4cf  2a 08 e 0 4 c3c0 0101  	add2nw 1,r[0];		am->brreg;	;		adda,st,hi;	ap+
    4d0  3b 36 3 c 0 e185 0101  	sub2nw 0,acc;		fpregl->fifo1;	cjp,f1f;	;			  | x1
    4d1  0a 00 c 0 4 7140 04d9  	;			;		ldct sv2ret;	;		ap+
    4d2  0b 36 7 c 0 7140 04d2  sv2loop1: ;			fpregl->fifo1;	jrp,f1f sv2loop1;;			  | y1
    4d3  2a 00 e 0 0 7140 0123  fifofull: ;			;		;		adda,la,a,st,hi;
    4d4  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    4d5  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;
    4d6  2b 00 e 0 0 7140 0101  	;			;		;		;
    4d7  03 36 3 c 0 f880 04d7  sv2loop2: movw,s acc,y;		fpregl->fifo1;	cjp,f1f sv2loop2;;
    4d8  0a 00 3 8 4 e185 04d7  	sub2nw 0,acc;		;		cjp,~zer sv2loop2;;		ap+
    4d9  0a 00 1 7 0 d80d 007d  sv2ret:	movw r[13],acc;		;		cjs,go wrfifo;	;			  | now send r[13] and r[12]
    4da  0a 00 3 7 0 d80c 007d  	movw r[12],acc;		;		cjp,go wrfifo;	;			  | return to calling routine from wrfifo
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)clpvec2.vp.u 1.2 86/09/12 SMI
                                |	clpvec2 -- clip a 2-D vector to a normalized window (-1.0 <= x,y <= 1.0)
                                |
                                |	Input Parameters:	r[15],fpap -- Address of vector to be clipped (N.B.: fpap must be set to r[15] prior to call)
                                |
                                |
                                |	Output:		clipped vector endpoints are written over input points
                                |			return with r[15]==fpap if vector is visible
                                |			Am29116 Z condition flag Z: 0 (2910 branch condition ~zer) => all or part of input vector is visible
                                |						    1 (2910 branch condition  zer) => input vector is not visible
                                |
    4db  2b 0e e 0 0 f900 0230  clpvec2: movw 0,y;		am->fpdp;	;		lmode rn,ai,pipe,fast;	  | fpreg's 0-15 are scratch memory
    4dc  08 2b e 0 4 9deb 3f80  	rolw 14,r[11],r[4];0x3F80->fpregh;;		;			  | fpreg[0] = 1.0
    4dd  0b 2b e 0 0 7140 0000  	;			0x0->fpregl;	;		;			  | r[4] is 2-D version of r[11]
    4de  0a 2d e 0 0 7140 0000  	;			0->fpbp;	;		;			  | i.e. L|R|B|T is bits 3|2|1|0
    4df  2a 08 e 0 0 e396 0110  	mov2nw 1,y;		am->brreg;	;		adda,lab,hi;		  | wec0_left = 1.0 + x0
    4e0  3b 00 c 0 0 7140 0110  	;			;		ldct;		;			  | Am2910 R reg <- 2 (used below)
    4e1  2a 00 e 0 0 948f 01a0  	addw r[15],2,y;		;		;		rsuba,la,hi;		  | wec0_right = 1.0 - x0
    4e2  2b 0d e 0 4 0002 01a0  	;			am->fpbp;	;		;		ap+	  | fpbp <- &x1 (used at next lab)
    4e3  2a 00 e 0 0 db06 0120  	compw 0,r[6];	;		;		adda,la,hi;		  | wec0_bottom = 1.0 + y0
    4e4  2b 00 e 0 0 fb01 0120  	compw 0,acc;	;		;		;
    4e5  2a 00 e 0 0 f8e0 01a0  	movw =reject2,y;	;		;		rsuba,la,hi;		  | wec0_top = 1.0 - y0
    4e6  2b 08 e 0 4 0520 01a0  	;			am->brreg;	;		;		ap+
    4e7  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		  | wec1_left = 1.0 + x1
    4e8  2b 00 e 0 0 7140 0122  	;			;		;		;
    4e9  2a 00 e 0 0 7140 01a3  	;			;		;		rsuba,la,a,st,hi;	  | wec1_right = 1.0 - x1, store wec0_left
    4ea  2b 31 e 0 8 6e00 01a3  	sl0b d,y;		fpstreg->am;	;		;		adp+
    4eb  2a 00 e 0 0 cc46 0123  	slqw r[6],r[6];	;		;		adda,la,a,st,hi;	  | wec1_bottom = 1.0 + y1, store wec0_right
    4ec  2b 31 e 0 6 6e00 0123  	sl0b d,y;		fpstreg->am;	;		;		dp+
    4ed  2a 00 e 0 0 cc46 01a3  	slqw r[6],r[6];	;		;		rsuba,la,a,st,hi;	  | wec1_top = 1.0 - y1, store wec0_bottom
    4ee  2b 0c e 0 6 d84f 01a3  	movw r[15],y;		am->fpap;	;		;		dp+
    4ef  2a 31 e 0 0 6e00 0193  	sl0b d,y;		fpstreg->am;	;		rsuba,lab,a,st,hi;	  | dx = x1 - x0, store wec0_top
    4f0  2b 00 e 0 a cc46 0193  	slqw r[6],r[6];	;		;		;		abdp+
    4f1  2a 31 e 0 0 6e00 0192  	sl0b d,y;		fpstreg->am;	;		rsuba,lab,a,hi;		  | dy = y1 - y0
    4f2  3b 00 4 f 0 cc46 0192  	slqw r[6],r[6];	;		push,~go;	;
    4f3  2a 31 e 0 0 6e00 0122  	sl0b d,y;		fpstreg->am;	;		adda,la,a,hi;		  | rpt 3 times for acc L,R, & B bits
    4f4  3b 00 8 0 0 ec41 0122  	slqw acc,acc;	;		rfct;		;
    4f5  2a 31 e 0 0 6e00 0123  	sl0b d,y;		fpstreg->am;	;		adda,la,a,st,hi;		  | acc T bit & store dx
    4f6  2b 00 e 0 6 ec41 0123  	slqw acc,acc;	;		;		;		dp+
    4f7  2a 07 e 0 0 90e6 0101  	nandw r[6],acc,y; am->am;	;		adda,st,hi;		  | store dy
    4f8  21 00 e 0 5 9ec4 0101  	andw,s d,r[4],r[5];;		;		;			  | r[5] != 0 iff >= 1 pt outside window
    4f9  0a 07 3 0 0 9126 0521  	norw r[6],acc,y; am->am;	cjp,zer trivaccept2;;			  | trivial accept case
    4fa  02 2c e 0 0 96c4 0000  	andw,s d,r[4],y;	0->fpap;	;		;			  | result != 0 iff 2 pts outside >= 1 plane
    4fb  1a 2e 3 8 0 94c5 0000  	andw,s r[5],0xC,y;	0->fpdp;	cjp,~zer;	;			  | trivial reject case (=reject2 in brreg)
    4fc  02 37 e 0 4 000c 0000  	;			fpregh->am;	;		;		ap+	  | need -wec0_left & -wec0_bottom for
                                											  | intersection calculations below;
                                											  | computed the negatives above to make
                                											  | detection of outside points a simple fp
                                											  | sign bit test; otherwise would have to
                                											  | distinguish +0.0 from truly >0.0
    4fd  0a 0b e 0 8 ff94 0000  	add2nw 15,d,y;		am->fpregh;	;		;		adp+	  | negate wec0_left
    4fe  0a 37 e 0 0 c782 0000  	mov2nw 3,r[2];	fpregh->am;	;		;			  | store recips computed below at fpreg[8]
    4ff  0a 00 e 0 6 7140 0000  	;			;		;		;		dp+	  | hardware can't dp+ in previous cycle 
    500  0a 0b 3 8 0 ff94 0502  	add2nw 15,d,y;		am->fpregh;	cjp,~zer xrecip2;;			  | negate wec0_bottom and if line crosses
                                											  | an x plane, compute dx_recip
                                											  | r[5] bits indicate line crossings:
                                											  | L|R|B|T is 3|2|1|0
    501  0a 0c 3 7 0 e596 0505  	mov2nw 2,y;		am->fpap;	cjp,go yrecip2;	;			  | if line didn't cross an x plane and was
                                											  | not trivially accepted, it must cross a
                                											  | y plane
    502  0a 0c 1 7 0 e596 034a  xrecip2: mov2nw 2,y;		am->fpap;	cjs,go recip;	;			  | fpap<-&dx, r[2]<-&dx_recip (fpreg[8])
    503  02 27 e 0 0 96c5 0003  	andw,s d,r[5],y;	0x3->am;	;		;			  | chk for line crossing y planes
    504  0a 00 3 0 0 7140 0506  	;			;		cjp,zer t0t1_2;	;			  | if not, go compute intersections
    505  0a 00 1 7 4 dd62 034a  yrecip2: incw r[2],r[2];	;		cjs,go recip;	;		ap+	  | fpap<-&dy, r[2]<-&dy_recip (fpreg[9])
                                											  | have now computed dx_recip and dy_recip
                                											  | for the intersection calculations if the
                                											  | corresponding t values will be used
    506  2b 0c e 0 0 d904 0230  t0t1_2:	movw 0,r[4];		am->fpap;	;		lmode rn,ai,pipe,fast;	  | t0 = 0.0, param t value for line begin
    507  0a 2d e 0 0 d903 0008  	movw 0,r[3];		8->fpbp;	;		;			  | fpap <- &wec0's, fpbp <- &dx_recip
    508  2a 00 e 0 0 d8e0 0010  	movw 0x3F80,r[0];	;		;		maba,lab,hi;		  | wec0_left * dx_recip (divide wec by dx)
    509  2b 00 e 0 4 3f80 0010  	;			;		;		;		ap+	  | r[0] <- high order 1.0
    50a  28 00 e 0 2 d960 0020  	movw r[0],r[2];	;		;		maba,la,hi;		  | wec0_right * dx_recip
    50b  2b 0e e 0 7 d901 0020  	movw 0,r[1];		am->fpdp;	;		;		abp+	  | t1 = 1.0, param t value for line end
                                											  | fpdp<-0,store candidate t's at fpreg[0]
    50c  2a 00 e 0 0 f8e0 0010  	movw =intersect2,y;	;		;		maba,lab,hi;		  | wec0_bottom * dy_recip
    50d  2b 08 e 0 4 0543 0010  	;			am->brreg;	;		;		ap+	  | set up brreg for calls to intersect2
    50e  2a 00 e 0 0 db66 0020  	compw r[6],r[6];;		;		maba,la,hi;		  | wec0_top * dy_recip; now r[6] bits
    50f  2b 0c e 0 0 f900 0020  	movw 0,y;		am->fpap;	;		;			  | have same polarity as r[5] bits
    510  22 00 e 0 0 99e5 0124  	rolw,s 12,r[5],r[5];;		;		adda,la,m,hi;		  | L|R|B|T now 15|14|13|12, advance pipe
    511  33 00 1 1 0 99e6 0124  	rolw,s 12,r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses L plane
    512  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | R|B|T now 15|14|13, advance pipe
    513  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses R plane
    514  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | B|T now 15|14, advance pipe
    515  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses B plane
    516  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | T now 15, advance pipe
    517  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses T plane
                                											  | now t0 and t1 represent clipped
                                											  | endpoints iff t0 <= t1
    518  02 0b e 0 0 d844 0000  newpts2: movw,s r[4],y;	am->fpregh;	;		;			  | fpreg[0] <- t0 & test r[4]==0 which
    519  0b 0b e 0 6 d843 0000  	movw r[3],y;		am->fpregl;	;		;		dp+	  | implies t0==0.0 since fast Weitek mode
    51a  0a 0b e 0 0 d802 0000  	movw r[2],acc;		am->fpregh;	;		;			  | will not produce denormalized results
    51b  0b 0b 3 0 0 d841 0522  	movw r[1],y;		am->fpregl;	cjp,zer t0eq0_2;;			  | fpreg[1]<-t1 & jump if t0==0.0
    51c  02 2d e 0 0 9100 0004  	xorw,s r[0],acc,y;	4->fpbp;	;		;			  | fpbp<-&dx, test r[2] == high order 1.0
                                											  | which means t1 == 1.0, since t1 started
                                											  | at 1.0 and could only decrease
    51d  0b 37 3 0 0 9601 0523  vischk_2: subw d,r[1],y;	fpregl->am;	cjp,zer t1eq1_2;;			  | jump if t1==1.0, else check for t0>t1,
    51e  02 37 e 0 0 9622 0000  	subcw,s d,r[2],y;	fpregh->am;	;		;			  | which means line is outside window
    51f  0a 00 3 2 0 7140 0523  	;			;		cjp,cry twonewpts_2;;			  | jump on no borrow (t1 - t0 >= 0.0)
                                											  |
    520  12 00 a 7 0 f900 0000  reject2: movw,s 0,y;		;		crtn,go;	;			  | Z bit <- 1 (indicating rejection) & rtn
                                											  |
    521  12 0c a 7 0 d84f 0000  trivaccept2: movw,s r[15],y;	am->fpap;	crtn,go;	;			  | Z bit <- 0 (indicating acceptance),
                                											  | fpap <- r[15], and return
                                											  |
    522  0a 0d 3 7 4 e596 0527  t0eq0_2: mov2nw 2,y;		am->fpbp;	cjp,go t0eq0_2a;;		ap+	  | if t0 == 0.0, then the t0,t1 segment is
                                											  | visible since t1 >= 0.0; also, t1 != 1.0
                                											  | at this point since that would imply
                                											  | trivial acceptance; fpbp<-&dx,fpap<-&t1,
                                											  | & jump into the middle of the code to
                                											  | compute two new endpoints;  we arrange
                                											  | below to compute and store only the 2nd
                                											  | point, thus saving a few cycles
                                											  |
                                t1eq1_2: 										  | if t1 == 1.0, then the t0,t1 segment is
                                											  | visible since t0 <= 1.0; also, t0 != 0.0
                                											  | at this point since that would imply
                                											  | trivial acceptance; we fall into the
                                											  | code to compute two new endpoints, but
                                											  | arrange below to store only the 1st
                                											  | point, thus saving a few cycles
                                											  |
    523  2a 00 e 0 0 7140 0010  twonewpts_2: ;			;		;		maba,lab,hi;		  | t0 * dx
    524  2b 00 e 0 5 7140 0010  	;			;		;		;		bp+
    525  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | t0 * dy
    526  2b 0d e 0 4 e596 0010  	mov2nw 2,y;		am->fpbp;	;		;		ap+
    527  2a 00 e 0 0 f8e0 0010  t0eq0_2a: movw =t0eq0_2b,y;	;		;		maba,lab,hi;		  | t1 * dx
    528  2b 08 e 0 5 053f 0010  	;			am->brreg;	;		;		bp+
    529  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | t1 * dy
    52a  2b 00 e 0 0 7140 0010  	;			;		;		;
    52b  2a 00 e 0 0 7140 0124  	;			;		;		adda,la,m,hi;
    52c  2b 0d e 0 0 d84f 0124  	movw r[15],y;		am->fpbp;	;		;			  | fpbp points to input pts
    52d  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | x0 + (t0 * dx)
    52e  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    52f  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | y0 + (t0 * dy)
    530  2b 0d e 0 0 d84f 011c  	movw r[15],y;		am->fpbp;	;		;
    531  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | x0 + (t1 * dx)
    532  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    533  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | y0 + (t1 * dy)
    534  2b 0e e 0 0 d84f 0118  	movw r[15],y;		am->fpdp;	;		;			  | will store new pts over old pts
    535  22 00 e 0 0 d844 0122  	movw,s r[4],y;		;		;		adda,la,a,hi;		  | goto t0eq0_2b if t0==0.0, to
    536  3b 00 3 0 0 7140 0122  	;			;		cjp,zer;	;			  | avoid overwriting x0 & y0
    537  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store x0'
    538  2b 00 e 0 6 9502 0123  	xorw,s r[2],0x3F80,y;	;		;		;		dp+	  | test for t1==1.0
    539  22 00 e 0 0 3f80 0123  	;			;		;		adda,la,a,st,hi;		  | store y0'
    53a  33 0c a 0 6 d84f 0123  	movw,s r[15],y;		am->fpap;	crtn,zer;	;		dp+	  | if t1==1.0, Z bit<-0,fpap<-r[15] & rtn
    53b  2a 00 e 0 0 7140 0123  t0eq0_2c: ;			;		;		adda,la,a,st,hi;		  | store x1'
    53c  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    53d  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store y1'
    53e  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | return with Z bit==0 & fpap==r[15]
                                											  |
    53f  2a 00 e 0 6 f8e0 0120  t0eq0_2b: movw =t0eq0_2c,y;	;		;		adda,la,hi;		dp+	  | pipe advance
    540  2b 08 e 0 6 053b 0120  	;			am->brreg;	;		;		dp+	  | increment dp to store x1'
    541  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    542  33 0c 3 7 0 d84f 0122  	movw,s r[15],y;		am->fpap;	cjp,go;		;			  | Z bit<-0,fpap<-r[15], and goto t0eq0_2c
                                											  |
                                											  |
    543  2a 00 e 0 0 7140 0101  intersect2: ;			;		;		adda,st,hi;		  | fpreg[0] <- candidate value
    544  2b 00 e 0 0 ff87 0101  	not2nw 15,acc;		;		;		;			  | acc <- 0x7FFF
    545  02 37 3 9 0 e2c1 054c  	andw,s d,acc,acc;	fpregh->am;	cjp,~neg updt1_2;;			  | update t0 or t1 based upon previously
                                											  | tested bit of r[6]; acc <- high
                                											  | order t & 0x7FFF (to convert -0.0 to
                                											  | +0.0,since t is guaranteed 0.0<=t<=1.0)
    546  0b 37 e 0 0 9603 0000  updt0_2: subw d,r[3],y;	fpregl->am;	;		;			  | compare t with t0 (t0 - t)
    547  02 00 e 0 0 9064 0000  	rsubcw,s r[4],acc,y;	;		;		;
    548  02 00 3 2 0 ffc5 0552  	bclrw,s 15,r[5];	;		cjp,cry chkthru2;;			  | no borrow means t <= t0
    549  0a 00 e 0 0 d884 0000  	movw acc,r[4];		;		;		;			  | else t0 <- t
    54a  0a 00 b 0 0 d8c3 0518  	movw d,r[3];		;		cjpp,zer newpts2;;			  | r[5]==0 -> no more intersections
    54b  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | else return to check next plane
    54c  0b 37 e 0 0 9641 0000  updt1_2: rsubw d,r[1],y;	fpregl->am;	;		;			  | compare t with t1 (t - t1)
    54d  02 00 e 0 0 9022 0000  	subcw,s r[2],acc,y;	;		;		;
    54e  02 00 3 2 0 ffc5 0552  	bclrw,s 15,r[5];	;		cjp,cry chkthru2;;			  | no borrow means t >= t1
    54f  0a 00 e 0 0 d882 0000  	movw acc,r[2];		;		;		;			  | else t1 <- t
    550  0a 00 b 0 0 d8c1 0518  	movw d,r[1];		;		cjpp,zer newpts2;;			  | r[5]==0 -> no more intersections
    551  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | else return to check next plane
    552  1a 00 a 8 0 7140 0000  chkthru2: ;			;		crtn,~zer;	;			  | r[5] != 0 -> more intersections, rtn
    553  0a 00 b 7 0 7140 0518  	;			;		cjpp,go newpts2;;			  | else pop stack and goto newpts2
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)xfpolygon2.vp.u 1.2 86/09/12 SMI
                                |	movw d,r[11];		shmem->am;	jmap XF_PGON_INT_2D;;			  | # of separate boundaries
    554  0a 00 e 0 0 d890 0000  XF_PGON_INT_2D: movw acc, r[16]; ;		;		;			  | flag from command.
    555  0a 27 e 0 0 d8c5 045b  	movw d,r[5];		=xfint2->am;	;		;			| r[5] pts to 2D transform routine
                                											  | xfint2 converts from fix to float
                                											  | before calling the regular xf2 routine
    556  0a 00 3 7 0 7140 0559  	;			;		cjp,go xfpoly2D;;			  | fall into rest of polygon code
                                |	movw d,r[11];		shmem->am;	jmap XFPOLYGON_2D;;			  | # of separate boundaries
    557  0a 00 e 0 0 d890 0000  XFPOLYGON_2D: movw acc, r[16]; ;		;		;			  | flag from command.
    558  0a 27 e 0 0 d8c5 046a  	movw d,r[5];		=xf2->am;	;		;			  | use the regular xf2 routine
    559  0a 0f 1 7 0 d85d 02dd  xfpoly2D: movw r[29],y;	am->shmemp;	cjs,go polygon_attr_2D; ;		  | 
    55a  0a 0f c 0 0 d849 0005  	movw r[9],y;	am->shmemp;	ldct 5;		;
    55b  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    55c  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    55d  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;
    55e  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move viewport parameters to fpr[32]
    55f  08 00 e 0 1 dd7e 0000  	incw r[30],r[17];	;		;		;			  | r[17] pts to vector of npts per boundary
                                											  | (after increment below)
    560  0a 27 e 0 0 868b 0002  	addw d,r[11],acc;	2->am;		;		;
    561  0a 00 e 0 0 989e 0000  	addw r[30],acc,r[30];	;		;		;			  | r[30] now points to first vertex
                                										|
                                										| edge structure is:
                                										| fpreg[r[14]+0]: ymin    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[r[14]+1]: ymax    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[r[14]+2]: xmax    32-bit float
                                										| fpreg[r[14]+3]: xmin    32-bit float
                                										| fpreg[r[14]+4]: X       don't care in high word
                                										|		   nxt     11-bit ptr in low word
                                										|
    562  0a 27 e 0 0 d8c9 0172  	movw d,r[9];		370->am;	;		;			  | r[9]<-370
    563  0a 27 e 0 0 d8c8 0080  	movw d,r[8];		128->am;	;		;			  | address of dummy 1st edge
    564  0a 0e e 0 0 c5c8 0000  	add2nw 2,r[8],r[8]; am->fpdp;	;		;			  | fpdp<-&dummy edge r[8]
    565  0b 0b e 0 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	;		;			  | dummy edge r[8]<-ptr to 1st real edge
    566  02 00 e 0 0 c1eb 0000  xf2nxtbnd: sub2nw,s 0,r[11],r[11];;		;		;			  | if ((r[11] -= 1)<0), goto xf2doscan
    567  0a 0f 3 1 0 dd71 05cd  	incw r[17],r[17];	am->shmemp;	cjp,neg xf2doscan;;			  | else get # of vertices for next
    568  0a 17 e 0 0 d8ca 0000  	movw d,r[10];		shmem->am;	;		;			  | boundary
    569  0a 00 e 0 0 e599 0000  	rolw 2,d,acc;		;		;		;			  | acc <- r[10]*4
    56a  02 27 e 0 0 960a 0003  	subw,s d,r[10],y;	3->am;		;		;			  | if 0 <= r[10] < 3, not a good boundary
    56b  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp pts to vertices;update r[30] to
    56c  0a 00 3 a 0 989e 0566  	addw r[30],acc,r[30];	;		cjp,~cry xf2nxtbnd;;			  | point to 1st loc after bndry's vertices
    56d  02 27 e 0 0 960a 001a  	subw,s d,r[10],y;	26->am;	;		;			  | if (r[10]>=26),goto xf2lrgpoly
    56e  08 08 3 9 0 c1ea 0619  	sub2nw 0,r[10],r[0];	am->brreg;	cjp,~neg xf2lrgpoly; ;			  | brreg <- r[10]-1
                                xf2smlpoly:
    56f  0a 27 e 0 0 d8ce 07c6  	movw d,r[14];		1990->am;	;		;			  | r[14] <- address for transformed pts
    570  02 2d e 0 0 d84c 0010  	movw,s r[12],y;	16->fpbp;	;		;			  | fpbp <- address of matrix
                                											  | r[12]==0?(xf2 doesn't affect cc's)
    571  1a 08 4 7 0 d845 0000  	movw r[5],y;		am->brreg;	push,go;	;			  | brreg <- addr of transform routine
                                											  | now loop through r[10] pts & xform them
    572  0a 0e e 0 0 d90f 0000  	movw 0,r[15];		am->fpdp;	;		;			  | put untransformed pt at fpr[0]
    573  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[0] <- x[i]
    574  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+
    575  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[1] <- y[i]
    576  1b 1b 1 7 2 7140 0000  	;			shmem->fpregl;	cjs,go;		;		shp+	  | transform pt and deposit in pt buffer
    577  1a 2d 8 0 0 c3ce 0010  	add2nw 1,r[14],r[14];	16->fpbp;	rfct;		;			  | increment r[14] and loop
    578  08 08 e 0 0 c1ea 0000  	sub2nw 0,r[10],r[0];	am->brreg;	;		;			  | brreg <- r[10]-1
    579  0a 0e 3 0 0 f900 059a  	movw 0,y;		am->fpdp;	cjp,zer vwpsmlpoly2;;			  | if clipping disabled, goto vwpsmlpoly2
    57a  08 2b e 0 0 9dec 3f80  	rolw 14,r[12],r[0];0x3F80->fpregh;;		;			  | else do a fast clip test
    57b  0b 2b e 0 0 9cc0 0000  	andw r[0],0xF,r[0];0->fpregl;;			;			  | fpreg[0] <- 1.0
    57c  0a 2c e 0 0 000f 07c6  	;			1990->fpap;	;		;			  | fpap <- address of transformed pts
    57d  08 2d e 0 2 d960 0000  	movw r[0],r[2];0->fpbp;	;		;			  | fpbp <- address of 1.0
                                											  | get 2-D version of r[12],
                                											  | i.e. L|R|B|T is bits 3|2|1|0 with
                                											  | leading zeroes where a "1" means clip
                                											  | against the plane
                                											  | r[2] <- r[0]
                                											  | r[1] <- ~r[0]
    57e  28 00 e 0 1 db60 0110  	compw r[0],r[1];;		;		adda,lab,hi;		  | left plane: x[0] + 1.0; test sign below
    57f  2b 00 e 0 0 d802 0110  	movw r[2],acc;	;		;		;			  | clip to -1.0 <= x <= 1.0; init acc for
                                											  | first pass through loop below
    580  2a 00 e 0 0 7140 01a0  	;			;		;		rsuba,la,hi;		  | right plane: 1.0 - x[0]; test sign below
    581  2b 00 e 0 4 7140 01a0  	;			;		;		;		ap+
    582  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;		  | bottom plane: y[0] + 1.0;test sign below
    583  2b 00 e 0 0 7140 0120  	;			;		;		;
    584  2a 00 e 0 0 7140 01a0  	;			;		;		rsuba,la,hi;		  |top plane: 1.0 - y[0]; test sign below
    585  3b 00 4 7 4 7140 01a0  	;			;		push,go;	;		ap+	  | loop through r[10] pts (brreg set above)
    586  2a 00 e 0 0 98c2 0122  plyclptst2: andw r[2],acc,r[2];;	;		adda,la,a,hi;		  | accumulate r[2] & r[22] pipe
    587  2b 00 e 0 0 f901 0122  	movw 0,acc;		;		;		;			  | zero acc for next pass through loop
    588  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		  | x[i] + 1.0; unload x[i-1] + 1.0 and
    589  2b 31 e 0 0 6e00 0122  	sl0b d,y;		fpstreg->am;	;		;			  | save the sign bit (throw away result)
    58a  2a 00 e 0 0 ec41 01a2  	slqw acc,acc;		;		;		rsuba,la,a,hi;		  | 1.0 - x[i];	unload 1.0 - x[i-1] and
    58b  2b 31 e 0 4 6e00 01a2  	sl0b d,y;		fpstreg->am;	;		;		ap+	  | save the sign bit (throw away result)
    58c  2a 00 e 0 0 ec41 0122  	slqw acc,acc;		;		;		adda,la,a,hi;		  | y[i] + 1.0; unload y[i-1] + 1.0 and
    58d  2b 31 e 0 0 6e00 0122  	sl0b d,y;		fpstreg->am;	;		;			  | save the sign bit (throw away result)
    58e  2a 00 e 0 0 ec41 01a2  	slqw acc,acc;		;		;		rsuba,la,a,hi;		  | 1.0 - y[i];	unload 1.0 - y[i-1] and
    58f  2b 31 e 0 4 6e00 01a2  	sl0b d,y;		fpstreg->am;	;		;		ap+	  | save the sign bit (throw away result)
    590  0a 00 e 0 0 ec41 0000  	slqw acc,acc;		;		;		;			  | dummy result from adda,la now being ignored
    591  1a 00 8 0 0 9941 0000  	orw r[1],acc,r[1];;		rfct;		;			  | accumulate r[1] & loop until done
    592  0a 00 e 0 0 80c2 0000  	andw r[2],acc,acc;;		;		;			  | accumulate r[2] for last point
    593  02 00 e 0 0 9100 0000  	xorw,s r[0],acc,y;	;		;		;			  | if (r[2] == r[0]), then
                                											  | all pts are inside the clip region,
    594  02 00 3 0 0 da01 059a  	compw,s r[1],acc;	;		cjp,zer vwpsmlpoly2;;			  | so goto vwpsmlpoly2
    595  0a 28 e 0 0 d8e3 0624  	movw 1990,r[3];	=clppoly2->brreg;;		;			  | if (~r[1] != 0), all pts were
    596  0a 00 3 8 0 07c6 0566  	;			;		cjp,~zer xf2nxtbnd;;			  | outside at least 1 clipping plane so
    597  0a 27 e 0 0 d8d2 0613  	movw d,r[18];	=nxtxfpt2->am;	;		;			  | goto xf2nxtbnd; else call clppoly2 with
    598  1a 27 1 7 0 d8d3 06e5  	movw d,r[19];	=mkedges2->am;	cjs,go;		;			  | r[3] pointing to 1st transformed
    599  0a 00 3 7 0 7140 0566  	;			;		cjp,go xf2nxtbnd;;			  | point, r[18] pointing to the
                                											  | subroutine nxtxfpt2, and r[19]
                                											  | pointing to the subroutine mkedges2
                                											  | after return, goto xf2nxtbnd
                                vwpsmlpoly2:										  | brreg == r[10]-1 on entry
    59a  0a 27 e 0 0 d8c0 07c6  	movw d,r[0];		1990->am;	;		;			  | r[0] <- 1990 (address of xformed pts)
    59b  0a 0d 1 7 0 eb86 06c5  	mov2nw 5,acc;		am->fpbp;	cjs,go vwpsclpts2;;			  | acc and fpbp point to viewport params
                                											  | scale r[10] pts to the viewport
                                											  | scaling is done in-place
                                xf2smledgs:
    59c  2a 0c e 0 0 dc40 0230  	incw r[0],y;		am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap <- 1990 + 1; use flowthrough mode
    59d  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | y[0]
    59e  2b 00 e 0 0 7140 00e0  	;			;		;		;
    59f  0a 00 e 0 0 7140 0000  	;			;		;		;
    5a0  08 08 e 0 0 c3ea 0000  	sub2nw 1,r[10],r[0];	am->brreg;	;		;			  | brreg <- r[10]-2
    5a1  0a 27 e 0 0 d8c3 07c6  	movw d,r[3];	1990->am;	;		;			  | r[3] <- 1990
    5a2  0a 00 e 0 0 7140 0000  	;			;		;		;			  | wait for fixed y[0]
    5a3  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    5a4  2b 0e e 0 0 f900 0102  	movw 0,y;		am->fpdp;	;		;
    5a5  2a 0c e 0 0 f900 0101  	movw 0,y;		am->fpap;	;		adda,st,hi;		  | fpreg[0] <- y[0] (integer)
    5a6  2b 00 e 0 0 c3c3 0101  	add2nw 1,r[3],r[3];;		;		;			  | r[3] <- &x[1]
    5a7  0b 37 e 0 0 d8c4 0000  	movw d,r[4];		fpregl->am;	;		;			  | r[4] <- low word of integer y[0]
    5a8  1a 00 4 7 0 d804 0000  	movw r[4],acc;	;		push,go;	;			  | acc <- y[0]; start loop to build 1st n-1
                                xf2smledgloop:										  | edges; notation: i runs from 1 to n-1
    5a9  0a 0c e 0 0 dc43 0000  	incw r[3],y;	am->fpap;	;		;			  | fpap <- &y[i]
    5aa  28 0e e 0 0 c3c8 00e0  	add2nw 1,r[8],r[0];	am->fpdp;	;		fixa,la,hi;		  | fix y[i]; fpdp <- &edg.xmax
    5ab  2b 0c e 0 0 d843 00e0  	movw r[3],y;	am->fpap;	;		;			  | fpap <- &x[i]
    5ac  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- x[i]
    5ad  0b 3b e 0 6 7140 0000  	;			fpregl-> fpregl;;		;		dp+
    5ae  08 0c e 0 0 c3e3 0000  	sub2nw 1,r[3],r[0];	am->fpap;	;		;			  | fpap <- &x[i-1]
    5af  08 3b e 0 0 d968 0000  	movw r[8],r[0];	fpregh->fpregh;	;		;			  | edg.xmin <- x[i-1]; save r[8] in r[0]
    5b0  0b 3b e 0 6 c5c8 0000  	add2nw 2,r[8],r[8];	fpregl->fpregl;	;		;		dp+	  | r[8] += 4
    5b1  0b 0b e 0 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	;		;			  | edg.nxt <- r[8] <- addr of next edge
    5b2  0a 0e e 0 0 d840 0000  	movw r[0],y;		am->fpdp;	;		;			  | fpdp <- address of this edge
    5b3  2a 0b e 0 6 f880 0102  	movw acc,y;		am->fpregh;	;		adda,a,hi;	dp+	  | edg.ymin <- y[i-1] (16-bit integer)
    5b4  2b 00 e 0 0 c3c3 0102  	add2nw 1,r[3],r[3];;		;		;			  | r[3] <- &x[i+1]
    5b5  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | edg.ymax <- y[i] (32-bit integer)
    5b6  2b 0c e 0 0 dc40 0101  	incw r[0],y;		am->fpap;	;		;			  | fpap <- &edg.ymax
    5b7  03 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregl->am;	;		;			  | check for horizontal edges
    5b8  0b 37 3 0 0 f8c1 05be  	movw d,acc;		fpregl->am;	cjp,zer xf2horizedg;;			  | acc <- low order 16 bits of int y[i]
    5b9  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | r[9] -= 1
    5ba  0a 0b 3 1 0 f880 05bd  	movw acc,y;		am->fpregh;	cjp,neg xf2edgovflw;;			  | move low 16 bits to high 16 bits where
    5bb  1a 00 8 0 0 7140 0000  	;			;		rfct;		;			  | scan conversion code expects to see it
                                											  | also handle case of too many edges
    5bc  0a 00 3 7 0 7140 05bf  	;			;		cjp,go xf2lastedg;;
                                xf2edgovflw:
    5bd  0a 00 e 0 0 db09 0000  	compw 0,r[9];		;		;		;			  | r[9] <- -1 and adjust r[8]
                                xf2horizedg:
    5be  1a 27 8 0 0 9e08 0005  	subw d,r[8],r[8];	5->am;		rfct;		;			  | ignore horizontal and overflow edges
                                xf2lastedg:
    5bf  02 00 e 0 0 9104 0000  	xorw,s r[4],acc,y;	;		;		;			  | ignore horizontal last edge
    5c0  0a 0e 3 0 0 d848 0566  	movw r[8],y;		am->fpdp;	cjp,zer xf2nxtbnd;;			  | fpdp <- address of nth edge
    5c1  0a 0b e 0 6 f880 0000  	movw acc,y;		am->fpregh;	;		;		dp+	  | edg.ymin <- y[n-1]
    5c2  0a 0b e 0 6 d844 0000  	movw r[4],y;		am->fpregh;	;		;		dp+	  | edg.ymax <- y[0]
    5c3  0a 2c e 0 0 7140 07c6  	;			1990->fpap;	;		;			  | fpap <- &x[0]
    5c4  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- x[0]
    5c5  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    5c6  0a 0c e 0 0 c3e3 0000  	sub2nw 1,r[3],r[3]; am->fpap;	;		;			  | fpap <- &x[n-1]
    5c7  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmin <- x[n-1]
    5c8  0b 3b e 0 6 c5c8 0000  	add2nw 2,r[8],r[8];	fpregl->fpregl;	;		;		dp+	  | r[8] += 4
    5c9  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | r[9] -= 1
    5ca  0b 0b 3 9 0 dd68 0566  	incw r[8],r[8];	am->fpregl;	cjp,~neg xf2nxtbnd;;			  | edg.nxt <- r[8] <- addr of next edge
    5cb  0a 27 e 0 0 9e08 0005  	subw d,r[8],r[8];	5->am;		;		;			  | goto xf2nxtbnd; if (r[9] < 0),
    5cc  0a 00 3 7 0 db09 0566  	compw 0,r[9];		;		cjp,go xf2nxtbnd;;			  | r[9] <- -1 and adjust r[8]
                                xf2doscan:
                                |   if # of edges != 0, call polyscan with r[14] and r[15].
    5cd  02 2f e 0 0 d850 01ff  	movw,s r[16], y;	511->shmemp; ;	;			| Test r[16] to see if textured.
    5ce  0a 17 3 0 0 d8c0 060c  	movw d, r[0];		shmem->am;	cjp, zer xf2polyscan; ;			| What texture is in PP?
    5cf  0a 27 e 0 0 869d 000a  	addw d, r[29], acc;	10->am; ;		;			| Compare PP tex block ptr with our own.
    5d0  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    5d1  02 17 e 0 0 f8c0 0000  	movw,s d, y;		shmem->am;	;		;			| Check for invalid tex block (-1)
    5d2  02 17 3 9 0 9600 05d4  	subw,s d, r[0], y;	shmem->am;	cjp, ~neg xf2tex; ;			| Compare tex pointers.
    5d3  0a 00 3 7 0 d910 060c  	movw 0, r[16];	;		cjp, go xf2polyscan; ;			| 
    5d4  0a 00 3 0 0 7140 05e6  xf2tex:	;			;		cjp, zer xf2texoff; ;			| 
    5d5  0a 27 e 0 0 869d 0007  	addw d, r[29], acc;	7->am; ;		;			| if (reload pp) shmemp = 7
    5d6  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    5d7  1a 17 4 f 0 d8d0 0000  	movw d, r[16];	shmem->am;	push, ~go;	;			| 
    5d8  1a 26 d 4 0 7140 001b  	;			 27->fifo1;	loop, f1nf;	;			| 
    5d9  08 00 1 7 0 d96d 0320  	movw r[13], r[0];	;		cjs, go stprep;	;			| Save r[13].  stprep incr shmemp.
    5da  0a 06 3 c 0 d84e 05da  	movw r[14], y;		am->fifo1;	cjp, f1f .;	;			| 
    5db  0a 17 e 0 0 d8c1 0000  	movw d, r[1];		shmem->am;	;		;			| TEX2FRAME (stprep incr shmemp)
    5dc  0a 2f e 0 0 7140 01ff  	;			511->shmemp; ;	;			| 
    5dd  0a 06 3 c 0 d84d 05dd  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    5de  0a 0a e 0 0 d841 0000  	movw r[1], y;		am->shmem;	;		;			| Remember what frame is on PP.
    5df  08 00 e 0 d d960 0000  	movw r[0], r[13];	;		;		;			| Restore r[13].
    5e0  0a 06 3 c 0 d84f 05e0  	movw r[15], y;		am->fifo1;	cjp, f1f .;	;			| 
    5e1  0a 0f e 0 0 d841 0000  	movw r[1], y;		am->shmemp;	;		;			| Address texture frame.
    5e2  12 00 4 7 0 c1eb 0000  xf2ltex: sub2nw,s 0, r[11], r[11]; ;		push, go;	;			| Copy texture to PP.
    5e3  0a 16 3 c 0 7140 05e3  	;			shmem->fifo1;	cjp, f1f .;	;			| 
    5e4  1a 00 8 0 2 7140 0000  	;			;		rfct;		;		shp+	| 
    5e5  0a 08 3 8 0 d84c 05e2  	movw r[12], y;		am->brreg;	cjp, ~zer xf2ltex; ;			| Copy next row of texture.
    5e6  0a 27 e 0 0 869d 0007  xf2texoff: addw d, r[29], acc; 7->am; ;	;			| 
    5e7  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    5e8  0a 17 e 0 0 d8d0 0000  	movw d, r[16];	shmem->am;	;		;			| 
    5e9  0a 27 e 0 0 869d 0018  	addw d, r[29], acc; 24->am; ;	;			| 
    5ea  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    5eb  02 17 e 0 0 f8c1 0000  	movw,s d, acc;		shmem->am;	;		;			| if (Kind == 0)
    5ec  0a 0e 3 0 0 d90f 0608  	movw 0, r[15];		am->fpdp;	cjp, zer xf2sxsy; ;			| else if (==  1) store pt at fpreg[0]
    5ed  0a 27 e 0 0 869d 000e  	addw d, r[29], acc;	14->am; ;		;			| 
    5ee  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    5ef  0a 08 e 0 0 d845 0000  	movw r[5], y;		am->brreg;	;		;			| 
    5f0  0a 1b e 0 2 c38e 0000  	mov2nw 1, r[14];	shmem->fpregh;	;		;		shp+	| Output point at fpreg[2].
    5f1  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+| 
    5f2  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	| 
    5f3  0b 1b e 0 0 7140 0000  	;			shmem->fpregl;	;		;			| 
    5f4  1a 0d 1 7 0 e996 0000  	mov2nw 4, y;		am->fpbp;	cjs,go;		;			| bp= 16 (address of matrix).
    5f5  0a 28 e 0 0 c380 0000  	mov2nw 1, r[0];		0->brreg;	;		;			| Do in-place viewport xform.
    5f6  0a 0d 1 7 0 eb86 06c5  	mov2nw 5,acc;		am->fpbp;	cjs,go vwpsclpts2; ;			| acc and fpbp point to viewport params
    5f7  2b 0c e 0 0 e396 0230  	mov2nw 1, y;		am->fpap;	;		lmode rn, ai, pipe, fast; |
    5f8  2a 0e e 0 0 f900 00e0  	movw 0, y;		am->fpdp;	;		fixa, la, hi;		| Fix r[21] and r[22].
    5f9  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    5fa  2a 00 e 0 0 7140 00e0  	;			;		;		fixa, la, hi;		| 
    5fb  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    5fc  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    5fd  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    5fe  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    5ff  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    600  2a 00 e 0 0 7140 0122  	;			;		;		adda,la, a, hi;		| 
    601  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    602  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 
    603  2b 00 e 0 6 f8e0 0123  	movw =xf2polyscan, y;	;		;		;		dp+	| 
    604  2a 08 e 0 0 060c 0121  	;			am->brreg;	;		adda,la, st, hi;		| 
    605  2b 0c e 0 0 f900 0121  	movw 0, y;		am->fpap;	;		;			| 
    606  0b 37 e 0 4 d8d5 0000  	movw d, r[21];		fpregl->am;	;		;		ap+	| 
    607  1b 37 3 7 0 d8d6 0000  	movw d, r[22];		fpregl->am;	cjp, go;	;			| 
    608  0a 27 e 0 0 869d 000c  xf2sxsy: addw d, r[29], acc;	 12->am; ;		;			| 
    609  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    60a  0a 17 e 0 2 d8d5 0000  	movw d, r[21];		shmem->am;	;		;		shp+	| retrieve r[21].
    60b  0a 17 e 0 0 d8d6 0000  	movw d, r[22];		shmem->am;	;		;			| retrieve r[22].
    60c  0a 0e e 0 0 c1e8 0000  xf2polyscan: sub2nw 0,r[8],r[8]; am->fpdp;	;		;			| fpdp <- &edg.nxt for last edge
    60d  03 2b e 0 0 d849 0000  	movw,s r[9],y;	0->fpregl;	;		;			  | load NULL r[8] for last edge
    60e  0a 00 3 1 0 9c09 0612  	subw,s r[9],370,r[9];;		cjp,neg xf2noscan;;			  | if # of edges > 370, goto xf2noscan
    60f  02 27 e 0 0 0172 0080  	;			128->am;	;		;			  | compute real # of edges
    610  0a 00 3 0 0 d8ce 0612  	movw d,r[14];		;		cjp, zer xf2noscan; ;			| 
    611  08 00 1 7 f d96d 0c5c  	movw r[13],r[15]; ;		cjs, go polyscan; ;			| 
    612  0a 00 2 0 0 7140 0027  xf2noscan: ;			;		jmap getcmd;	;
    613  0a 0e e 0 0 d847 0000  nxtxfpt2: movw r[7],y;	am->fpdp;	;		;			  | fpdp <- address for next pt to clip
    614  0a 0c e 0 0 d843 0000  	movw r[3],y;		am->fpap;	;		;			  | fpap <- address of next transformed pt
    615  02 3b e 0 0 c1ea 0000  	sub2nw,s 0,r[10],r[10];	fpregh->fpregh;	;		;			  | transfer x; r[10]-=1, set cc to
                                											  | reflect result (neg means no more pts)
    616  1b 3b a 1 8 c3c3 0000  	add2nw 1,r[3],r[3];fpregl->fpregl;crtn,neg;	;		adp+	  | r[3] += 2 & return if no more pts
    617  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | transfer y
    618  1b 3b a 7 0 7140 0000  	;			fpregl->fpregl;	crtn,go;	;			  | return
    619  0a 27 e 0 0 d8d2 061d  xf2lrgpoly: movw d,r[18];	=nxtcmdpt2->am;	;		;			  | r[18] points to subroutine nxtcmdpt2
    61a  0a 27 e 0 0 d8d3 06e5  	movw d,r[19];	=mkedges2->am;	;		;			  | r[19] points to subroutine mkedges2
    61b  0a 00 1 7 0 7140 0624  	;			;		cjs,go clppoly2;;			  | call clppoly2
    61c  0a 00 3 7 0 7140 0566  	;			;		cjp,go xf2nxtbnd;;			  | loop back to xf2nxtbnd
    61d  02 2d e 0 0 c1ea 0010  nxtcmdpt2: sub2nw,s 0,r[10],r[10]; 16->fpbp;	;		;			  | fpbp pts to matrix; r[10] -= 1, cc
    61e  18 2e a 1 e d967 07c6  	movw r[7],r[14];	1990->fpdp;	crtn,neg;	;			  | reflects result; return if no more pts
                                											  | else fpdp<-1990 (addr for new pt)
    61f  0a 08 e 0 0 d845 0000  	movw r[5],y;		am->brreg;	;		;			  | brreg pts to appropriate xform routine
    620  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpreg[1990] <- next x; r[14] <- addr
    621  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+  | for xformed pts
    622  0a 1b e 0 2 d8ef 0000  	movw 1990,r[15];	shmem->fpregh;	;		;		shp+	  | fpreg[1990+1] <- next y; r[15] <- 1990
    623  1b 1b 3 7 2 07c6 0000  	;			shmem->fpregl;	cjp,go;		;		shp+	  | jump to xf2 which will return to caller
                                											  | xf2 will xform pt and put result at
                                											  | *r[7]; shmemp now pts to next pt
                                clppoly2:
    624  02 2e e 0 0 d914 0000  	movw,s 0,r[20];	0->fpdp;	;		;			  | r[20] <- FALSE; cc == zer (tested
                                											  | below at nxtpt2)
    625  0a 2b e 0 0 dd15 3f80  	incw 0,r[21];	0x3f80->fpregh;	;		;			  | r[21] <- TRUE; fpreg[0] <- 1.0
    626  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;
    627  0a 2e e 0 0 7140 0028  	;			40->fpdp;;		;
    628  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 40.firstvtx <- TRUE
    629  0a 2e e 0 0 7140 0032  	;			50->fpdp;;		;
    62a  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 50.firstvtx <- TRUE
    62b  0a 2e e 0 0 7140 003c  	;			60->fpdp;;		;
    62c  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 60.firstvtx <- TRUE
    62d  0a 2e e 0 0 7140 0046  	;			70->fpdp;;		;
    62e  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 70.firstvtx <- TRUE
    62f  1a 08 a 8 0 d852 0000  nxtpt2: movw r[18],y;	am->brreg;	crtn,~zer;	;			  | when reach here, cc reflects state of
                                											  | r[20]; return when out of pts; else
                                											  | call routine to get next point with
    630  1a 27 1 7 0 d8c7 0050  	movw d,r[7];	80->am;	cjs,go;		;			  | r[7]==80; returns
    631  02 00 3 1 0 d84c 064c  	movw,s r[12],y;	;		cjp,neg closepoly2;;			  | with cc neg when out of points
    632  0a 00 3 0 0 dd16 0649  	incw 0,r[22];		;		cjp,zer putpts2;;			  | r[22]<-1; if clip disabled, goto putpts2
                                											  | else r[7] points to new pt; r[22]==1
    633  0a 27 e 0 0 d8c6 0064  nxtpt2a: movw d,r[6];	100->am;	;		;			  | r[6]<-100
    634  02 27 e 0 0 ebec 0028  clpleft2: btstw,s 5,r[12]; 40->am;;		;			  | if left clipping enabled, call clppln2
    635  0a 00 3 0 0 d8c4 0639  	movw d,r[4];		;		cjp,zer clptop2;;			  | with r[4]==40
    636  0a 28 e 0 0 7140 0680  	;			=wec_left2->brreg;;		;			  | and brreg==wec_left2
    637  0a 00 1 7 0 d917 0651  	movw 0,r[23];		;		cjs,go clppln2;	;
    638  08 00 1 7 6 d977 064e  	movw r[23],r[22];		;		cjs,go switchbuf2;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    639  02 27 e 0 0 e5ec 0032  clptop2: btstw,s 2,r[12];	50->am;;		;			  | if top clipping enabled, call clppln2
    63a  0a 00 3 0 0 d8c4 063e  	movw d,r[4];		;		cjp,zer clpright2;;			  | with r[4]==50
    63b  0a 28 e 0 0 7140 0689  	;			=wec_top2->brreg;;		;			  | and brreg==wec_top2
    63c  0a 00 1 7 0 d917 0651  	movw 0,r[23];		;		cjs,go clppln2;	;
    63d  08 00 1 7 6 d977 064e  	movw r[23],r[22];		;		cjs,go switchbuf2;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    63e  02 27 e 0 0 e9ec 003c  clpright2: btstw,s 4,r[12];60->am;;		;			  | if right clipping enabled, call clppln2
    63f  0a 00 3 0 0 d8c4 0643  	movw d,r[4];		;		cjp,zer clpbottom2;;			  | with r[4]==60
    640  0a 28 e 0 0 7140 068a  	;			=wec_right2->brreg;;		;			  | and brreg==wec_right2
    641  0a 00 1 7 0 d917 0651  	movw 0,r[23];		;		cjs,go clppln2;	;
    642  08 00 1 7 6 d977 064e  	movw r[23],r[22];		;		cjs,go switchbuf2;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    643  02 27 e 0 0 e7ec 0046  clpbottom2: btstw,s 3,r[12];70->am;;		;			  | if bottom clipping enabled, call clppln2
    644  0a 00 3 0 0 d8c4 0649  	movw d,r[4];		;		cjp,zer putpts2;;			  | with r[4]==70
    645  0a 28 e 0 0 7140 067f  	;			=wec_bottom2->brreg;;		;			  | and brreg==wec_bottom2
    646  0a 00 1 7 0 d917 0651  	movw 0,r[23];		;		cjs,go clppln2;	;
    647  08 00 e 0 6 d977 0000  	movw r[23],r[22];		;		;		;			  | # of output pts is # of pts which are
    648  08 00 e 0 7 d966 0000  	movw r[6],r[7];;		;		;			  | passed to the pt consuming routine
    649  0a 08 e 0 0 d853 0000  putpts2: movw r[19],y;	am->brreg;	;		;			  | r[7] points to the pts
    64a  18 00 1 7 f d967 0000  	movw r[7],r[15];	;		cjs,go;		;			  | call the consuming routine
    64b  02 00 3 7 0 d854 062f  	movw,s r[20],y;	;		cjp,go nxtpt2;	;			  | get next input pt; cc reflects state of
                                											  | variable r[20]
    64c  0a 00 c 0 0 dd14 0649  closepoly2: incw 0,r[20];	;		ldct putpts2;	;			  | r[20] <- TRUE; r[22] <- 0
    64d  0a 00 7 8 0 d916 0633  	movw 0,r[22];		;		jrp,~zer nxtpt2a;;			  | if clipping is disabled, goto putpts2;
                                											  | else do one more pass
                                											  | through clipping loop to flush out
                                											  | possible intersection points by passing
                                											  | each plane's saved 1st vertex to it as
                                											  | its last vertex
    64e  08 00 e 0 0 d966 0000  switchbuf2: movw r[6],r[0];	;		;		;			  | switch buffer ptrs
    64f  08 00 e 0 6 d967 0000  	movw r[7],r[6];;		;		;
    650  18 00 a 7 7 d960 0000  	movw r[0],r[7];	;		crtn,go;	;
    651  08 00 e 0 f d967 0000  clppln2: movw r[7],r[15];	;		;		;			  | use local copy of r[7]
    652  08 00 e 0 e d966 0000  	movw r[6],r[14];	;		;		;			  | use local copy of r[6]
    653  02 00 e 0 0 d856 0000  cpln2loop: movw,s r[22],y;	;		;		;			  | if r[22] == 0, goto chklastpt2
    654  02 00 3 0 0 c1f6 0661  	sub2nw,s 0,r[22];	;		cjp,zer chklastpt2;;			  | if ((r[22] -= 1) < 0), return
    655  1a 0c a 1 0 d844 0000  	movw r[4],y;		am->fpap;	crtn,neg;	;			  | fpap <- r[4]
    656  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;			  | if r[4]->firstvtxflg == FALSE, goto
    657  0a 0c 3 0 0 d84f 0665  	movw r[15],y;		am->fpap;	cjp,zer subseqvtx2;;			  | subseqvtx2; fpap <- r[15]
    658  0a 0e e 0 0 d844 0000  firstvtx2: movw r[4],y;	am->fpdp;	;		;			  | fpdp <- r[4]
    659  0a 0b 4 7 6 f900 0001  	movw 0,y;		am->fpregh;	push,go 1;	;		dp+	  | r[4]->firstvtxflg <- FALSE
    65a  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | r[4]->firstvtx <- input pt
    65b  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    65c  0a 0c 4 7 0 d84f 0001  	movw r[15],y;		am->fpap;	push,go 1;	;			  | fpap <- r[15]
    65d  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | r[4]->savdvtx <- input pt
    65e  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    65f  1a 0c 1 7 0 d84f 0000  	movw r[15],y;		am->fpap;	cjs,go;		;			  | call routine to compute window edge
                                											  | coordinate for this plane and this pt
                                											  | (brreg has address of routine)
                                											  | wec is stored in r[4]->savdwec
    660  0a 00 3 7 0 c3cf 0675  	add2nw 1,r[15],r[15];	;		cjp,go cpln2vischk;;			  | r[15] += 2;go check visibility using wec
    661  02 00 e 0 0 d854 0000  chklastpt2: movw,s r[20],y;	;		;		;			  | if there are more pts, return; else
    662  1a 0c a 0 0 d844 0000  	movw r[4],y;		am->fpap;	crtn,zer;	;			  | if r[4]->firstvtxflg == TRUE, return
    663  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;
    664  18 0c a 8 f dd64 0000  	incw r[4],r[15];	am->fpap;	crtn,~zer;	;			  | else fpap <- r[15] <- &r[4]->firstvtx
                                											  | and fall through to subseqvtx2
    665  1a 2e 1 7 0 7140 0001  subseqvtx2: ;			1->fpdp;	cjs,go;		;			  | fpreg[1] <-  wec for this plane and pt
    666  08 2c e 0 0 c5c4 0001  	add2nw 2,r[4],r[0];	1->fpap;	;		;			  | fpap <- address of input wec
    667  0a 37 e 0 0 f8c1 0000  	movw d,acc;		fpregh->am;	;		;			  | acc <- high word of input wec
    668  0a 0c e 0 0 dc40 0000  	incw r[0],y;		am->fpap;	;		;			  | fpap <- address of saved wec
    669  02 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregh->am;	;		;			  | test sign of (input wec) ^ (saved wec)
    66a  0a 00 1 1 0 7140 0693  	;			;		cjs,neg plnintsct2;;			  | if signs differ a polygon edge crosses
                                											  | this plane; call plnintsct2 to compute
                                											  | the intersection and add it to the
                                											  | output buffer
    66b  0a 0c e 0 0 d84f 0000  	movw r[15],y;		am->fpap;	;		;			  | fpap <- address of input pt
    66c  0a 27 e 0 0 8684 0003  	addw d,r[4],acc;	3->am;		;		;			  | acc <- &r[4]->savdvtx
    66d  0a 0e e 0 0 f880 0000  	movw acc,y;		am->fpdp;	;		;			  | fpdp <- &r[4]->savdvtx
    66e  0a 3b e 0 0 c3cf 0000  	add2nw 1,r[15],r[15];	fpregh->fpregh;	;		;			  | r[4]->savdvtx <- input pt; r[15] += 2
    66f  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    670  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;
    671  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    672  0a 2c e 0 0 7140 0001  	;			1->fpap;	;		;			  | fpap <- address of input wec
    673  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | r[4]->savdwec <- input wec
    674  0b 3b e 0 0 7140 0000  	;			fpregl->fpregl;	;		;
    675  0a 00 e 0 0 8484 0000  cpln2vischk: addw r[4],5,acc;	;		;		;			  | fpap <- acc <- &r[4]->savdwec
    676  0a 0c e 0 0 0005 0000  	;			am->fpap;	;		;
    677  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;
    678  02 00 3 1 0 d856 0653  	movw,s r[22],y;		;		cjp,neg cpln2loop;;			  | wec < 0 => pt not visible
    679  0a 0e 3 1 0 d84e 0653  	movw r[14],y;		am->fpdp;	cjp,neg cpln2loop;;			  | (r[22] >= 0) => add pt to output
                                											  | (r[20] == TRUE) && (r[22] < 0) =>
                                											  | this last pt is the same as the first pt
                                											  | so ignore it (only reach here with
                                											  | r[22] < 0 when r[20] == TRUE)
                                cpln2vis:										  | fpdp <- r[14] (above)
    67a  0a 0c e 0 0 e385 0000  	sub2nw 1,acc;		am->fpap;	;		;			  | fpap <- &r[4]->savdvtx
    67b  0a 3b e 0 0 dd77 0000  	incw r[23],r[23];		fpregh->fpregh;	;		;			  | output buffer <- current point
    67c  0b 3b e 0 8 c3ce 0000  	add2nw 1,r[14],r[14];	fpregl->fpregl;	;		;		adp+
    67d  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;
    67e  0b 3b 3 7 0 7140 0653  	;			fpregl->fpregl;	cjp,go cpln2loop;;			  | goto cpln2loop
    67f  0a 00 e 0 4 7140 0000  wec_bottom2: ;			;		;		;		ap+	  | fpap pts to pt.y for wec_bottom2 or to
    680  2a 0d e 0 0 f900 0230  wec_left2: movw 0,y;		am->fpbp;	;		lmode rn,ai,flow,fast;	  | pt.x for wec_left2;fpbp pts to const 1.0
    681  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | pt.x + 1.0 (left plane wec) OR
    682  2b 00 e 0 0 7140 0110  	;			;		;		;			  | pt.y + 1.0 (bottom plane wec)
    683  0a 00 4 7 0 7140 0002  	;			;		push,go 2;	;
    684  1a 00 8 0 0 7140 0000  	;			;		rfct;		;
    685  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    686  2b 00 e 0 0 7140 0102  	;			;		;		;
    687  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store result and return; result < 0 =>
    688  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | pt is on invisible side of pln
    689  0a 00 e 0 4 7140 0000  wec_top2: ;			;		;		;		ap+	  | fpap pts to pt.y for wec_top2 or to pt.x
    68a  2a 0d e 0 0 f900 0230  wec_right2: movw 0,y;		am->fpbp;	;		lmode rn,ai,flow,fast;	  | for wec_right2; fpbp pts to const 1.0
    68b  2a 00 e 0 0 7140 0190  	;			;		;		rsuba,lab,hi;		  | 1.0 - pt.x (right plane wec) OR
    68c  2b 00 e 0 0 7140 0190  	;			;		;		;			  | 1.0 - pt.y (top plane wec)
    68d  0a 00 4 7 0 7140 0002  	;			;		push,go 2;	;
    68e  1a 00 8 0 0 7140 0000  	;			;		rfct;		;
    68f  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    690  2b 00 e 0 0 7140 0102  	;			;		;		;
    691  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store result and return; result < 0 =>
    692  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | pt is on invisible side of pln
    693  0a 2d e 0 0 9484 0001  plnintsct2: addw r[4],5,y;	1->fpbp;	;		;			  | fbbp pts to wec of new input pt
    694  2a 0c e 0 0 0005 0230  	;			am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap pts to wec of saved pt
    695  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | saved wec - input wec
    696  2b 00 e 0 0 7140 0150  	;			;		;		;
    697  0a 00 4 7 0 7140 0002  	;			;		push,go 2;	;			  | delay for flowthrough mode
    698  1a 00 8 0 0 7140 0000  	;			;		rfct;		;
    699  2a 0e e 0 0 e396 0102  	mov2nw 1,y;		am->fpdp;	;		adda,a,hi;		  | fpdp <- 2
    69a  2b 0c e 0 0 e396 0102  	mov2nw 1,y;		am->fpap;	;		;			  | fpap <- 2
    69b  2a 00 e 0 0 d8e2 0101  	movw 3,r[2];		;		;		adda,st,hi;		  | store wec_diff in fpreg[2]
    69c  2b 00 e 0 0 0003 0101  	;			;		;		;			  | r[2] <- 3
    69d  0a 00 1 7 0 7140 034a  	;			;		cjs,go recip;	;			  | fpreg[3] <- reciprocal of difference
    69e  2b 0d e 0 0 d842 0230  	movw r[2],y;		am->fpbp;	;		lmode rn,ai,pipe,fast;	  | fpbp <- 3; set pipeline mode
    69f  0a 00 c 0 0 9484 0001  	addw r[4],5,y;	;		ldct 1;		;			  | 2910 R reg <- 1
    6a0  0a 0c e 0 0 0005 0000  	;			am->fpap;	;		;			  | fpap pts to wec of saved pt
    6a1  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | compute t = (wec of saved pt)/wec_diff
    6a2  2b 0c e 0 0 d84f 0010  	movw r[15],y;		am->fpap;	;		;			  | fpap <- address of input pt
    6a3  2a 00 e 0 0 9484 0120  	addw r[4],3,y;	;		;		adda,la,hi;
    6a4  2b 0d e 0 0 0003 0120  	;			am->fpbp;	;		;			  | fpbp <- address of saved pt
    6a5  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dx (input x - saved x)
    6a6  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+
    6a7  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dy (input y - saved y)
    6a8  2b 00 e 0 0 7140 0150  	;			;		;		;
    6a9  2a 00 e 0 0 7140 0124  	;			;		;		adda,la,m,hi;
    6aa  2b 0e e 0 0 e396 0124  	mov2nw 1,y;		am->fpdp;	;		;			  | fpdp <- 2
    6ab  2a 0d e 0 0 e396 0121  	mov2nw 1,y;		am->fpbp;	;		adda,la,st,hi;		  | fpreg[2] <- t; fpbp <- 2
    6ac  2b 00 e 0 0 7140 0121  	;			;		;		;
    6ad  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    6ae  2b 00 e 0 0 7140 0122  	;			;		;		;
    6af  2a 00 e 0 0 7140 001a  	;			;		;		mabr,lab,a,hi;		  | dx * t
    6b0  2b 00 e 0 0 7140 001a  	;			;		;		;
    6b1  2a 00 e 0 0 7140 0018  	;			;		;		mabr,lab,hi;		  | dy * t
    6b2  3b 00 4 f 0 7140 0018  	;			;		push,~go;	;			  | 2910 cntr was set to 1 above
    6b3  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    6b4  3b 00 8 0 0 7140 0120  	;			;		rfct;		;
    6b5  2a 00 e 0 0 9484 0124  	addw r[4],3,y;	;		;		adda,la,m,hi;
    6b6  2b 0d e 0 0 0003 0124  	;			am->fpbp;	;		;			  | fpbp <- address of saved pt
    6b7  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | saved x + (dx * t)
    6b8  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    6b9  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | saved y + (dy * t)
    6ba  2b 00 e 0 0 7140 0118  	;			;		;		;
    6bb  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    6bc  2b 00 e 0 0 7140 0120  	;			;		;		;
    6bd  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    6be  2b 00 e 0 0 7140 0120  	;			;		;		;
    6bf  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    6c0  2b 0e e 0 0 d84e 0122  	movw r[14],y;		am->fpdp;	;		;
    6c1  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | add x coord of intersect pt to output
    6c2  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    6c3  2a 00 e 0 0 dd77 0101  	incw r[23],r[23];		;		;		adda,st,hi;		  | add y coord of intersect pt to output
    6c4  3b 00 a 7 0 c3ce 0101  	add2nw 1,r[14],r[14];	;		crtn,go;	;			  | r[23] += 1; r[14] += 2; return
                                vwpsclpts2:										  | in-place 2-D viewport scale
                                											  | enter with acc,fpbp pointing to viewport
                                											  | params, r[0] pointing to pts to be scaled
                                											  | to viewport, and brreg containing npts-1
    6c5  2b 0c e 0 0 d840 0230  	movw r[0],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	  | fpap <- address of input pts
    6c6  2a 0e e 0 0 d840 0010  	movw r[0],y;		am->fpdp;	;		maba,lab,hi;		  | x[0] * VWPXSCL; fpdp points to input pts
    6c7  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    6c8  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y[0] * VWPYSCL
    6c9  2b 0d e 0 4 e385 0010  	sub2nw 1,acc;		am->fpbp;	;		;		ap+
    6ca  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x[1] * VWPXSCL
    6cb  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    6cc  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y[1] * VWPYSCL
    6cd  2b 0d e 0 4 e385 0010  	sub2nw 1,acc;		am->fpbp;	;		;		ap+
    6ce  2a 00 e 0 0 7140 0014  	;			;		;		maba,lab,m,hi;		  | x[2] * VWPXSCL;
    6cf  3b 0d 4 7 4 e384 0014  	add2nw 1,acc;		am->fpbp;	push,go;	;		ap+	  | loop through all pts (brreg == npts-1)
    6d0  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | y[i] * VWPYSCL; store x[i-2]
    6d1  2b 0d e 0 8 e385 0015  	sub2nw 1,acc;		am->fpbp;	;		;		adp+
    6d2  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | x[i+1] * VWPYSCL; store y[i-2]
    6d3  3b 0d 8 0 8 e384 0015  	add2nw 1,acc;		am->fpbp;	rfct;		;		adp+
    6d4  0a 0d e 0 0 e185 0000  	sub2nw 0,acc;		am->fpbp;	;		;			  | fpbp pts to VWPXOFF
    6d5  0a 0c e 0 0 d840 0000  	movw r[0],y;		am->fpap;	;		;			  | fpap <- address of scaled pts
    6d6  2a 0e e 0 0 d840 0110  	movw r[0],y;		am->fpdp;	;		adda,lab,hi;		  | (x[0] * VWPXSCL) + VWPXOFF;fpdp<-pt addr
    6d7  2b 0d e 0 4 e384 0110  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    6d8  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | (y[0] * VWPYSCL) + VWPYOFF
    6d9  2b 0d e 0 4 e385 0110  	sub2nw 1,acc;		am->fpbp;	;		;		ap+
    6da  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | (x[1] * VWPXSCL) + VWPXOFF
    6db  2b 0d e 0 4 e384 0110  	add2nw 1,acc;		am->fpbp;	;		;		ap+
    6dc  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | (y[1] * VWPYSCL) + VWPYOFF
    6dd  2b 0d e 0 4 e385 0110  	sub2nw 1,acc;		am->fpbp;	;		;		ap+
    6de  2a 00 e 0 0 7140 0112  	;			;		;		adda,lab,a,hi;		  | (x[2] * VWPXSCL) + VWPXOFF
    6df  3b 0d 4 7 4 e384 0112  	add2nw 1,acc;		am->fpbp;	push,go;	;		ap+	  | loop through all pts (brreg == npts-1)
    6e0  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | (y[i] * VWPYSCL) + VWPYOFF; store x[i-2]
    6e1  2b 0d e 0 8 e385 0113  	sub2nw 1,acc;		am->fpbp;	;		;		adp+
    6e2  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | (x[i+1] * VWPYSCL)+VWPXOFF;store y[i-2]
    6e3  3b 0d 8 0 8 e384 0113  	add2nw 1,acc;		am->fpbp;	rfct;		;		adp+
    6e4  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | return
    6e5  02 00 e 0 0 d856 0000  mkedges2: movw,s r[22],y;	;		;		;
    6e6  02 00 3 8 0 d854 06e9  	movw,s r[20],y;	;		cjp,~zer edgpts2;;			  | if (r[22] > 0) goto edgpts2
    6e7  0a 00 3 8 0 7140 0718  	;			;		cjp,~zer lastedg2;;			  | else if no more pts in this boundary
    6e8  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | goto lastedg2; else return
    6e9  08 08 e 0 8 c1f6 0000  edgpts2: sub2nw 0,r[22],r[24];	am->brreg;	;		;			  | brreg <- r[22]-1
    6ea  08 00 e 0 0 d96f 0000  	movw r[15],r[0];		;		;		;			  | r[0] points to input pts
    6eb  0a 0d 1 7 0 eb86 06c5  	mov2nw 5,acc;		am->fpbp;	cjs,go vwpsclpts2;;			  | fpbp,acc <- address of viewport params
                                											  | vwpsclpts2 scales pts in place
    6ec  02 00 e 0 0 d855 0000  	movw,s r[21],y;	;		;		;
    6ed  0a 00 3 0 0 d915 06fe  	movw 0,r[21];	;		cjp,zer mkedg2;	;			  | if not 1st pt of boundary, goto mkedg2
                                											  | r[21] <- FALSE
    6ee  2a 0c e 0 0 dc4f 0230  firstpt2: incw r[15],y;		am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap points to 1st pt y; flow mode
    6ef  2a 0e e 0 0 e596 00e0  	mov2nw 2,y;		am->fpdp;	;		fixa,la,hi;		  | convert y to int; fpdp <- 4
    6f0  2b 0c e 0 0 d84f 00e0  	movw r[15],y;		am->fpap;	;		;			  | fpap pts to 1st pt x
    6f1  0a 3b e 0 0 c1f6 0000  	sub2nw 0,r[22],r[22];	fpregh->fpregh;	;		;			  | fpreg[4] <- 1st pt x; r[22] -= 1
    6f2  0b 3b e 0 0 c3cf 0000  	add2nw 1,r[15],r[15];	fpregl->fpregl;	;		;			  | r[15] += 2
    6f3  0a 0e e 0 0 e796 0000  	mov2nw 3,y;		am->fpdp;	;		;			  | fpdp <- 8
    6f4  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | fpreg[8] <- 1st pt x (prev pt storage)
    6f5  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    6f6  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    6f7  2b 00 e 0 0 7140 0102  	;			;		;		;
    6f8  2a 00 e 0 0 f8e0 0101  	movw 9,y;		;		;		adda,st,hi;		  | fpreg[9] <- fixed y
    6f9  2b 0c e 0 0 0009 0101  	;			am->fpap;	;		;			  | fpap <- 9
    6fa  0b 37 e 0 0 f8c1 0000  	movw d,acc;		fpregl->am;	;		;			  | acc <- low 16 bits of int y
    6fb  0a 0b e 0 0 f880 0000  	movw acc,y;		am->fpregh;	;		;			  | low 16 bits to high word of fpreg[9]
    6fc  0a 2e e 0 0 7140 0005  	;			5->fpdp;	;		;			  | (prev pt storage in fpreg[9]); fpdp<-5
    6fd  0a 0b e 0 0 f880 0000  	movw acc,y;		am->fpregh;	;		;			  | fpreg[5,high]<-int y (1st pt storage)
    6fe  22 00 e 0 0 c1f6 0230  mkedg2:	sub2nw,s 0,r[22],r[22];	;		;		lmode rn,ai,flow,fast;	  | select flow mode; if((r[22]-=1)<0),
    6ff  0a 0c 3 1 0 dc4f 0717  	incw r[15],y;		am->fpap;	cjp,neg chklastedg2;;			  | goto chklastedg2; fpap <- &y[i]
    700  28 0e e 0 0 c3c8 00e0  	add2nw 1,r[8],r[0];	am->fpdp;	;		fixa,la,hi;		  | fix y[i]; fpdp <- &edg.xmax
    701  2b 0c e 0 0 d84f 00e0  	movw r[15],y;		am->fpap;	;		;			  | fpap <- &x[i]
    702  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- x[i]
    703  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    704  0a 0c e 0 0 e796 0000  	mov2nw 3,y;		am->fpap;	;		;			  | fpap <- &x[i-1] (prev pt)
    705  08 3b e 0 0 d968 0000  	movw r[8],r[0];	fpregh->fpregh;	;		;			  | edg.xmin <- x[i-1]; save r[8] in r[0]
    706  0b 3b e 0 8 c5c8 0000  	add2nw 2,r[8],r[8];	fpregl->fpregl;	;		;		adp+	  | r[8] += 4
    707  0b 0b e 0 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	;		;			  | edg.nxt <- r[8] <- addr of next edge
    708  0a 0e e 0 0 d840 0000  	movw r[0],y;		am->fpdp;	;		;			  | fpdp <- addr of this edge
    709  2a 3b e 0 6 7140 0102  	;			fpregh->fpregh;	;		adda,a,hi;	dp+	  | edg.ymin <- y[i-1] (prev y,16-bit int)
    70a  2b 00 e 0 0 c3cf 0102  	add2nw 1,r[15],r[15];	;		;		;			  | r[15] <- &x[i+1]
    70b  2a 37 e 0 0 f8c1 0101  	movw d,acc;		fpregh->am;	;		adda,st,hi;		  | edg.ymax<-y[i](32-bit int);acc<-prev y
    70c  2b 0c e 0 0 dc40 0101  	incw r[0],y;		am->fpap;	;		;			  | fpap <- &edg.ymax
    70d  03 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregl->am;	;		;			  | check for horizontal edges
    70e  0b 37 3 0 4 f8c1 0712  	movw d,acc;		fpregl->am;	cjp,zer horizedg2;;		ap+	  | acc <- low order 16 bits of int y[i]
    70f  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | if (r[9] -= 1) >= 0, goto savpt2
    710  0a 0b 3 9 0 f880 0713  	movw acc,y;		am->fpregh;	cjp,~neg savpt2;;			  | move low 16 bits to high word where
                                											  | scan conversion code expects to see it
    711  0a 00 e 0 0 db09 0000  edgovflw2: compw 0,r[9];	;		;		;			  | on edge overflow, r[9] <- -1 and
                                											  | adjust r[8]
    712  0a 27 e 0 0 9e08 0005  horizedg2: subw d,r[8],r[8]; 5->am;		;		;			  | ignore horizontal and overflow edges
    713  0a 0e e 0 0 e796 0000  savpt2:	mov2nw 3,y;		am->fpdp;	;		;			  | fpdp <- addr of prev pt (fpreg[8-9])
    714  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | prev pt <- current pt
    715  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+	  | 32-bit float x
    716  0a 0b 3 7 0 f880 06fe  	movw acc,y;		am->fpregh;	cjp,go mkedg2;	;			  | 16-bit int y in high word; loop back
    717  02 00 e 0 0 d854 0000  chklastedg2: movw,s r[20],y;;		;		;
    718  12 00 a 0 0 d855 0000  lastedg2: movw,s r[21],y;	;		crtn,zer;	;			  | return if may be more pts in boundary
    719  1a 2c a 8 0 7140 0005  	;			5->fpap;	crtn,~zer;	;			  | fpap <- addr of 1st y; return if no pts
    71a  0a 37 e 0 0 d8c0 0000  	movw d,r[0];		fpregh->am;	;		;			  | r[0] <- 1st y (16-bit int)
    71b  0a 2c e 0 0 7140 0009  	;			9->fpap;	;		;			  | fpap <- addr of prev pt y
    71c  02 37 e 0 0 9700 0000  	xorw,s d,r[0],y;		fpregh->am;	;		;			  | check for horizontal last edge
    71d  1a 0e a 0 0 d848 0000  	movw r[8],y;		am->fpdp;	crtn,zer;	;			  | rtn if horiz; fpdp<-addr for last edge
    71e  0a 3b e 0 6 7140 0000  	;			fpregh->fpregh;	;		;		dp+	  | edg.ymin <- prev y
    71f  0a 0b e 0 6 d840 0000  	movw r[0],y;		am->fpregh;	;		;		dp+	  | edg.ymax <- 1st y
    720  0a 0c e 0 0 e596 0000  	mov2nw 2,y;		am->fpap;	;		;			  | fpap <- addr of 1st pt x
    721  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- 1st x
    722  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    723  0a 0c e 0 0 e796 0000  	mov2nw 3,y;		am->fpap;	;		;			  | fpap <- addr of prev pt x
    724  0a 3b e 0 0 c5c8 0000  	add2nw 2,r[8],r[8];	fpregh->fpregh;	;		;			  | edg,xmin <- prev x; r[8] += 4
    725  03 3b e 0 6 c1e9 0000  	sub2nw,s 0,r[9],r[9]; fpregl->fpregl;;		;		dp+	  | r[9] -= 1
    726  1b 0b a 9 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	crtn,~neg;	;			  | edg.nxt <- r[8] <- addr of next edge
                                											  | if r[9] >= 0, return
    727  0a 00 e 0 0 db09 0000  	compw 0,r[9];		;		;		;			  | else r[9] <- -1
    728  1a 27 a 7 0 9e08 0005  	subw d,r[8],r[8];	5->am;		crtn,go;	;			  | adjust r[8] and return
                                 |	movw d,r[11];		shmem->am;	jmap PROC_PGON_INT_2D;;			  | # of separate boundaries
                                PROC_PGON_INT_2D:
    729  0a 27 e 0 0 d8c5 084f   	movw d,r[5];		=xfint3->am;	;		;			  | set ptr to do fixtofloat and fall 
                                 											  | through to use regular xf3 routine
    72a  0a 00 3 7 0 d918 072d   	movw 0,r[24]; ;		cjp,go cwpoly2;	;			  | after set ptr, use float routine
                                 |	movw d,r[11];		shmem->am;	jmap PROC_PGON_FLT_2D;;			  | # of separate boundaries
                                PROC_PGON_FLT_2D:
    72b  0a 27 e 0 0 d8c5 0860   	movw d,r[5];		=xf3->am;	;		;			  | use the regular xf3 routine
    72c  0a 00 e 0 0 d918 0000   	movw 0,r[24];;		;		;
    72d  0a 27 e 0 0 869d 0004  cwpoly2: addw d,r[29],acc;	 4->am; ;		;			  | 
    72e  0a 0f e 0 0 f880 0000   	movw acc,y;		am->shmemp;	;		;
    72f  0a 17 c 0 2 d8cc 0001   	movw d,r[12];	shmem->am;	ldct 1;		;		shp+	  | save clipplanes
    730  0a 1f 1 7 0 7140 0429   	;			shmem->shmemp;	cjs,go expmtrx; ;			  | shmemp <- r[9]
    731  0a 27 e 0 0 869d 0034   	addw d,r[29],acc;	 52->am;;		;
    732  0a 0f c 0 0 f880 0003   	movw acc,y;		am->shmemp;	ldct 3;		;			  | shmemp <- addr of vwp params
    733  0a 0e 1 7 0 eb96 0426   	mov2nw 5,y;		am->fpdp;	cjs,go expvwp;	;			  | move viewport parameters to fpr[32]
    734  0a 00 1 7 0 ffb8 0c0b   	bsetw 15,r[24]; ;		cjs,go cwp3;	;			  | continue with PROC_PGON_FLT_3D
    735  0a 3a e 0 2 c5d2 0000  cwpout2: add2nw 2,r[18],r[18]; fpregh->shmem; ;		;		shp+	  | x,y to shmem
    736  0b 3a e 0 b 7140 0000  	;			fpregl->shmem; ;		;		shp+,abp+ | r[18] += 4
    737  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  |	
    738  0b 3a 4 7 b 7140 0002  	;			fpregl->shmem;	push,go 2;	;		shp+,abp+ |
    739  1a 00 8 0 4 7140 0000  	;			;		rfct;		;		ap+	  | skip z,r[20],i
    73a  02 00 3 7 0 c1ea 0c47  	sub2nw,s 0,r[10],r[10]; ;		cjp,go corendcvertloop3; ;		  | r[10]-=1 and loop back
                                | "@(#)3Dfp.vp.u 1.4 86/09/13"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                | data pointers for 3-D routines
                                |   Floating point register addresses for xf_line_flt_3d & xf_line_int_3d
                                |   	store pt1	stored at fpr[64] (fpdp=64)
                                |   	store pt2	stored at fpr[68] (fpdp=68)
                                |	xform pt1	r[15]=64, r[14] = 72
                                |	xform pt2	r[15]=68, r[14] = 76
                                |   	clip vector	r[15]=72, r[14] = x
                                |	vwp pts 1 & 2	r[15]=72, r[14] = 80	
                                |   	store xf pt2	stored at fpr[88] (this is done before we clip)
                                |   xfln3dinit sets up the texture attributes on the pp, loads the 3d matrix and viewport scaling parameters,
                                |   and loads 1.0 for w2 before returning.  It is called by xflineflt3d, and xflineint3d. 
                                xfln3dinit:
    73b  0a 00 e 0 0 949d 0000  	addw r[29], 28,y; ;		;		;			| 
    73c  0a 0f 1 7 0 001c 02b9  	;			am->shmemp;	cjs, go tvec_attr; ;			| Texture addr->scrmemp.
    73d  0a 0f c 0 0 d849 000f  	movw r[9],y;	am->shmemp;	ldct 15;	;			| 
    73e  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr; ;			| 0 matrix to fpr[16]
    73f  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am; ;		;			| 
    740  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;			| 0 viewport parameters to fpr[32]
    741  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr; ;			| N.B.: only x and y params (not z)
    742  0a 2e e 0 0 7140 0047  	;			71->fpdp;	;		;			| movw w2=1.0 to fpr[71] (only done once)
    743  0a 2b e 0 0 7140 3f80  	;			0x3F80->fpregh;	;		;			| 
    744  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
    745  0a 0f c 0 0 d85e 0002  	movw r[30],y;		am->shmemp;	ldct 2;		;			| 
    746  12 17 a 7 2 d8d0 0000  	movw,s d,r[16];	shmem->am;	crtn, go;	;		shp+	| pull first r[16] element & return.
                                |	incw r[30],r[30];	;		jmap XF_LINE_FLT_3D;			| r[30] points to first element of r[16]			
                                XF_LINE_FLT_3D: 
    747  0a 00 1 7 0 7140 073b  	;			;		cjs,go xfln3dinit; ;			| 
    748  0a 0e 1 7 0 cd8f 0080  xf1stpt: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			| r[15]=64, 0 pt1 x,y,z to here
    749  0a 27 e 0 0 9e9e 0007  	addw d,r[30],r[30];	7->am;		;		;			| r[30] += 7
    74a  0a 00 3 1 0 7140 0027  	;			;		cjp,neg getcmd; ;			| return if was last pt
    74b  02 17 c 0 2 e190 0002  	btstw,s 0,d;		shmem->am;	ldct 2;		;		shp+	| r[16] for second point
    74c  02 00 3 8 0 d8d0 0748  	movw,s d,r[16];	;		cjp,~zer xf1stpt; ;			| jump if 2nd point is a 0.
    74d  08 2b e 0 e c7cf 3f80  	add2nw 3,r[15],r[14];	0x3F80->fpregh;	;		;			| r[14]=72, want xf pt1 x,y,z,r[20] here
    74e  0b 0b e 0 0 f900 0000  	movw 0,y;		am->fpregl;	;		;			| w1 = 1.0 at fpr[67]
    74f  0a 0c 1 7 0 e996 0860  	mov2nw 4,y;		am->fpap;	cjs,go xf3;	;			| matrix ptr in fpap; xform 1st point
    750  0a 00 e 0 0 c7cf 0000  	add2nw 3,r[15];		;		;		;			| r[15] = 72
    751  0a 00 e 0 0 c7ce 0000  	add2nw 3,r[14];	;		;		;			| r[14] = 80
    752  0a 2c e 0 0 7140 0010  xf2ndpt: ;			16->fpap;	;		;			| 0 pt2 x,y,z coords to fpr[68]
    753  0a 0e 1 7 0 c5ef 0080  	sub2nw 2,r[15];		am->fpdp;	cjs,go shm_to_fpr; ;			| r[15] = 68, fetch pt2 x,y,z & store here
    754  0a 00 1 7 0 c5ee 0860  	sub2nw 2,r[14];	;		cjs,go xf3;	;			| r[14] = 76, want xf 2nd pt here
    755  0a 2e e 0 0 7140 0058  	;			88->fpdp;	;		;			| store xformed, unclipped pt2 at fpr[88]
    756  0a 2c e 0 0 c580 004c  	mov2nw 2,r[0];		76->fpap;	;		;			| xformed pt2 is currently at fpr[76]
    757  02 3b e 0 0 c1e0 0000  xfstpt2: sub2nw,s 0,r[0];	fpregh->fpregh;	;		;			| 
    758  03 3b 3 8 8 d84b 0757  	movw,s r[11],y;	fpregl->fpregl;	cjp,~zer xfstpt2; ;		adp+	| increment a & d pointers, loop till done
    759  02 0c 1 8 0 c5cf 08d7  	add2nw,s 2,r[15];	am->fpap;	cjs,~zer clpvec3;;			| r[15] = 72 (xf 1st pt.) clip vector if r[11]!=0;
                                											| also if no clip, force cc to ~zer so vec is drawn
    75a  0a 00 1 8 0 c5ce 08a9  	add2nw 2,r[14];	;		cjs,~zer vwpsndvec3_xy;;		| r[14] = 80.  if visible, scale to viewport, cnvrt to
                                											| int, & xmit to PP
    75b  02 27 e 0 0 d850 0007  	movw,s r[16],y;	7->am;		;		;			| test if just sent last vector
    75c  0a 0f 3 1 0 9e9e 0027  	addw d,r[30],r[30];	am->shmemp;	cjp,neg getcmd;	;			| r[30] += 7 and exit if was last vector
    75d  0a 17 c 0 2 d8d0 0002  	movw d,r[16];		shmem->am;	ldct 2;		;		shp+	| fetch r[16] for next point
    75e  02 2c e 0 0 e1f0 0058  	btstw,s 0,r[16];	88->fpap;	;		;			| copy xf pt2 to xf pt1 area
    75f  0a 2e e 0 0 c580 0048  	mov2nw 2,r[0];		72->fpdp;	;		;			| 
    760  02 00 3 8 0 d850 0748  	movw,s r[16],y;	;		cjp,~zer xf1stpt; ;			| Will check if last point if jump.
    761  02 3b e 0 0 c1e0 0000  	sub2nw,s 0,r[0];	fpregh->fpregh;	;		;			| jump if 2nd point is a movw
    762  0b 3b 3 0 8 7140 0752  xfswap:	;			fpregl->fpregl;	cjp,zer xf2ndpt; ;		adp+	| increment a & d pointers
    763  02 3b 3 7 0 c1e0 0762  	sub2nw,s 0,r[0];	fpregh->fpregh;	cjp,go xfswap;	;			| loop
                                |	incw r[30],r[30];	;		jmap XF_LINE_INT_3D;			| r[30] points to first element of r[16]			
                                XF_LINE_INT_3D: 
    764  0a 00 1 7 0 7140 073b  	;			;		cjs,go xfln3dinit; ;			| 
    765  0a 0e 1 7 0 cd8f 0080  xf1stpti: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			| r[15]=64, 0 pt1 x,y,z to here
    766  0a 27 e 0 0 9e9e 0007  	addw d,r[30],r[30];	7->am;		;		;			| r[30] += 7
    767  0a 00 3 1 0 7140 0027  	;			;		cjp,neg getcmd; ;			| return if was last pt
    768  02 17 c 0 2 e190 0002  	btstw,s 0,d;		shmem->am;	ldct 2;		;		shp+	| r[16] for second point
    769  02 00 3 8 0 d8d0 0765  	movw,s d,r[16];	;		cjp,~zer xf1stpti; ;			| jump if 2nd point is a 0.
    76a  08 2b e 0 e c7cf 3f80  	add2nw 3,r[15],r[14];	0x3F80->fpregh;	;		;			| r[14]=72, want xf pt1 x,y,z,r[20] here
    76b  0b 0b e 0 0 f900 0000  	movw 0,y;		am->fpregl;	;		;			| w1 = 1.0 at fpr[67]
    76c  0a 0c 1 7 0 e996 084f  	mov2nw 4,y;		am->fpap;	cjs,go xfint3; ;			| matrix ptr in fpap; convert to int & xform 1st point
    76d  0a 00 e 0 0 c7cf 0000  	add2nw 3,r[15];		;		;		;			| r[15] = 72
    76e  0a 00 e 0 0 c7ce 0000  	add2nw 3,r[14];	;		;		;			| r[14] = 80
    76f  0a 2c e 0 0 7140 0010  xf2ndpti: ;			16->fpap;	;		;			| 0 pt2 x,y,z coords to fpr[68]
    770  0a 0e 1 7 0 c5ef 0080  	sub2nw 2,r[15];		am->fpdp;	cjs,go shm_to_fpr; ;			| r[15] = 68, fetch pt2 x,y,z & store here
    771  0a 00 1 7 0 c5ee 084f  	sub2nw 2,r[14];	;		cjs,go xfint3; ;			| r[14] = 76, 2nd pt->int & xform to here
    772  0a 2e e 0 0 7140 0058  	;			88->fpdp;	;		;			| store xformed, unclipped pt2 at fpr[88]
    773  0a 2c e 0 0 c580 004c  	mov2nw 2,r[0];		76->fpap;	;		;			| xformed pt2 is currently at fpr[76]
    774  02 3b e 0 0 c1e0 0000  xfstpt2i: sub2nw,s 0,r[0];	fpregh->fpregh;	;		;			| 
    775  03 3b 3 8 8 d84b 0774  	movw,s r[11],y;	fpregl->fpregl;	cjp,~zer xfstpt2i; ;		adp+	| increment a & d pointers, loop till done
    776  02 0c 1 8 0 c5cf 08d7  	add2nw,s 2,r[15];	am->fpap;	cjs,~zer clpvec3;;			| r[15] = 72 (xf 1st pt.) clip vector if r[11]!=0;
                                											| also if no clip, force cc to ~zer so vec is drawn
    777  0a 00 1 8 0 c5ce 08a9  	add2nw 2,r[14];	;		cjs,~zer vwpsndvec3_xy;;		| r[14] = 80.  if visible, scale to viewport, cnvrt to
                                											| int, & xmit to PP
    778  02 27 e 0 0 d850 0007  	movw,s r[16],y;	7->am;		;		;			| test if just sent last vector
    779  0a 0f 3 1 0 9e9e 0027  	addw d,r[30],r[30];	am->shmemp;	cjp,neg getcmd;	;			| r[30] += 7 and exit if was last vector
    77a  0a 17 c 0 2 d8d0 0002  	movw d,r[16];		shmem->am;	ldct 2;		;		shp+	| fetch r[16] for next point
    77b  02 2c e 0 0 e1f0 0058  	btstw,s 0,r[16];	88->fpap;	;		;			| copy xf pt2 to xf pt1 area
    77c  0a 2e e 0 0 c580 0048  	mov2nw 2,r[0];		72->fpdp;	;		;			| 
    77d  02 00 3 8 0 d850 0765  	movw,s r[16],y;	;		cjp,~zer xf1stpti; ;			| Will check if last point if jump.
    77e  02 3b e 0 0 c1e0 0000  	sub2nw,s 0,r[0];	fpregh->fpregh;	;		;			| jump if 2nd point is a movw
    77f  0b 3b 3 0 8 7140 076f  xfswapi: ;			fpregl->fpregl;	cjp,zer xf2ndpti; ;		adp+	| increment a & d pointers
    780  02 3b 3 7 0 c1e0 077f  	sub2nw,s 0,r[0];	fpregh->fpregh;	cjp,go xfswapi; ;			| loop
                                |   xfln3dinit is called by xfvec_3d and corendcvec_3d to perform initialization.
                                xfvec3dinit:
    781  0a 0f 1 7 0 d85d 02ba  	movw r[29],y;	am->shmemp;	cjs,go vec_attr; ;			  | 
    782  0a 0f c 0 0 d849 000f  	movw r[9],y;	am->shmemp;	ldct 15;	;
    783  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    784  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    785  0a 0f c 0 0 f880 0003  	movw acc,y;		am->shmemp;	ldct 3;		;			  | move viewport parameters to fpr[32]
    786  0a 0e 3 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjp,go shm_to_fpr; ;			  | only x and y params, will return
                                |	negw d,r[10];		shmem->am;	jmap XFVEC_3D;	;
    787  0a 00 1 7 0 7140 0781  XFVEC_3D: ;			;		cjs,go xfvec3dinit; ;			  | initialization for old format opers.
    788  0a 0f c 0 0 c3de 0002  	add2nw 1,r[30];	am->shmemp;	ldct 2;		;
    789  0a 0e 1 7 0 cd8f 0080  nxtvec3: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr;;			  | move pt1 x,y,z coords to fpr[64]
    78a  0a 2b e 0 0 c5de 3f80  	add2nw 2,r[30];	0x3F80->fpregh;	;		;			  | w1 = 1.0, r[30] += 4
    78b  0b 0b c 0 6 f900 0002  	movw 0,y;		am->fpregl;	ldct 2;		;		dp+	  | ldct 2 into 2910 counter
    78c  02 00 1 7 0 d84b 0080  	movw,s r[11],y;	;		cjs,go shm_to_fpr;;			  | move pt2 x,y,z coords to fpr[68]
                                											  | r[11]==0? (xf3 doesn't affect cc's)
    78d  08 2b e 0 e c7cf 3f80  	add2nw 3,r[15],r[14];	0x3F80->fpregh;	;		;			  | want transformed endpoints at fpr[72]
    78e  0b 0b e 0 0 f900 0000  	movw 0,y;		am->fpregl;	;		;			  | w2 = 1.0
    78f  0a 0c 1 7 0 e996 0860  	mov2nw 4,y;		am->fpap;	cjs,go xf3;	;			  | matrix ptr in fpap; xform 1st point
    790  0a 2c e 0 0 c5cf 0010  	add2nw 2,r[15];		16->fpap;	;		;
    791  0a 00 1 7 0 c5ce 0860  	add2nw 2,r[14];	;		cjs,go xf3;	;			  | transform 2nd point
    792  02 0c 1 8 0 c5cf 08d7  	add2nw,s 2,r[15];	am->fpap;	cjs,~zer clpvec3;;			  | clip vector if r[11]!=0; also if no
                                											  | clip, force cc to ~zer so vec is drawn
    793  0a 00 1 8 0 c5ce 08a9  	add2nw 2,r[14];	;		cjs,~zer vwpsndvec3_xy;;		  | if visible, scale to viewport, cnvrt to
                                											  | int, & xmit to PP
    794  02 00 c 0 0 dd6a 0002  	incw,s r[10],r[10];	;		ldct 2;		;			  | reload 2910 R reg; incr vec loop cntr
    795  0a 0f 3 8 0 c7de 0789  	add2nw 3,r[30];	am->shmemp;	cjp,~zer nxtvec3;;			  | r[30] += 8 and loop if more vectors
    796  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |	negw d,r[10];		shmem->am;	jmap CORENDCVEC_3D;;
                                CORENDCVEC_3D:
    797  0a 00 1 7 0 7140 0781  	;			;		cjs,go xfvec3dinit; ;			  | initialization for old format opers.
    798  0a 0f c 0 0 c3de 0002  	add2nw 1,r[30];	am->shmemp;	ldct 2;		;
    799  0a 0e 1 7 0 cd8f 0080  cnxtvec3: mov2nw 6,r[15];	am->fpdp;	cjs,go shm_to_fpr;;			  | move pt1 x,y,z coords to fpr[64]
    79a  0a 2b e 0 0 c5de 3f80  	add2nw 2,r[30];	0x3F80->fpregh;	;		;			  | w1 = 1.0, r[30] += 4
    79b  0b 0b c 0 6 f900 0002  	movw 0,y;		am->fpregl;	ldct 2;		;		dp+	  | ldct 2 into 2910 counter
    79c  02 00 1 7 0 d84b 0080  	movw,s r[11],y;	;		cjs,go shm_to_fpr;;			  | move pt2 x,y,z coords to fpr[68]
                                											  | r[11]==0? (xf3 doesn't affect cc's)
    79d  08 2b e 0 e c7cf 3f80  	add2nw 3,r[15],r[14];	0x3F80->fpregh;	;		;			  | want transformed endpoints at fpr[72]
    79e  0b 0b 1 7 0 f900 07a7  	movw 0,y;		am->fpregl;	cjs,go ndcflt3;	;			  | w2 = 1.0; convert xyz's to float
    79f  0a 0c 1 7 0 e996 0860  	mov2nw 4,y;		am->fpap;	cjs,go xf3;	;			  | matrix ptr in fpap; xform 1st point
    7a0  0a 2c e 0 0 c5cf 0010  	add2nw 2,r[15];		16->fpap;	;		;
    7a1  0a 00 1 7 0 c5ce 0860  	add2nw 2,r[14];	;		cjs,go xf3;	;			  | transform 2nd point
    7a2  02 0c 1 8 0 c5cf 08d7  	add2nw,s 2,r[15];	am->fpap;	cjs,~zer clpvec3;;			  | clip vector if r[11]!=0; also if no
                                											  | clip, force cc to ~zer so vec is drawn
    7a3  0a 00 1 8 0 c5ce 08a9  	add2nw 2,r[14];	;		cjs,~zer vwpsndvec3_xy;;		  | if visible, scale to viewport, cnvrt to
                                											  | int, & xmit to PP
    7a4  02 00 c 0 0 dd6a 0002  	incw,s r[10],r[10];	;		ldct 2;		;			  | reload 2910 R reg; incr vec loop cntr
    7a5  0a 0f 3 8 0 c7de 0799  	add2nw 3,r[30];	am->shmemp;	cjp,~zer cnxtvec3;;			  | r[30] += 8 and loop if more vectors
    7a6  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
    7a7  2b 0c e 0 0 d84f 0230  ndcflt3: movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	  | cnvrt 2 xyz's starting at inptr to float
    7a8  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | x0
    7a9  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    7aa  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | y0
    7ab  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    7ac  2a 00 e 0 0 848f 00a0  	addw r[15],4,acc;	;		;		floata,la,hi;		  | z0
    7ad  2b 0c e 0 0 0004 00a0  	;			am->fpap;	;		;
    7ae  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | x1
    7af  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    7b0  2a 08 e 0 0 e196 00a2  	mov2nw 0,y;		am->brreg;	;		floata,la,a,hi;		  | y1
    7b1  3b 0e 4 7 4 d84f 00a2  	movw r[15],y;		am->fpdp;	push,go;	;		ap+
    7b2  2a 00 e 0 0 7140 00a3  	;			;		;		floata,la,a,st,hi;	  | z1; store x0' & y0'
    7b3  3b 00 8 0 6 7140 00a3  	;			;		rfct;		;		dp+
    7b4  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store z0
    7b5  3b 0e 4 7 0 f880 0123  	movw acc,y;		am->fpdp;	push,go;	;
    7b6  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store x1 and y1
    7b7  3b 00 8 0 6 7140 0123  	;			;		rfct;		;		dp+
    7b8  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store z1
    7b9  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | return
                                |	negw d,r[10];		shmem->am;	jmap PROC_LINE_INT_3D;;
                                PROC_LINE_INT_3D:
    7ba  0a 27 e 0 0 d8c5 084f  	movw d,r[5];		=xfint3->am;	;		;			  | set ptr to fixtofloat routine
    7bb  0a 00 3 7 0 7140 07bd  	;			;		cjp,go cwdvec3;	;			  | and fall through to xf3. otherwise
                                											  | use regular float routine
                                |	negw d,r[10];		shmem->am;	jmap COREWLDVECNDC_3D;;
                                COREWLDVECNDC_3D:
    7bc  0a 27 e 0 0 d8c5 0860  	movw d,r[5];		=xf3->am;	;		;			  | set ptr to regular xf3 routine
    7bd  0a 27 e 0 0 869d 0004  cwdvec3: addw d,r[29],acc;	 4->am; ;		;			  | 
    7be  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
    7bf  0a 17 e 0 2 d8cb 0000  	movw d,r[11];	shmem->am;	;		;		shp+	  | save r[11]
    7c0  0a 1f c 0 0 d906 000f  	movw 0,r[6];	shmem->shmemp;	ldct 15;	;			  | shmemp <- r[9]
    7c1  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    7c2  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    7c3  0a 0f c 0 0 f880 0005  	movw acc,y;		am->shmemp;	ldct 5;		;			  |shmemp <- addr of vwp params
    7c4  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move viewport parameters to fpr[32]
    7c5  0a 0f c 0 0 c3de 0002  	add2nw 1,r[30];	am->shmemp;	ldct 2;		;
                                cwnnxtvec3:
    7c6  0a 0e 1 7 2 cd8f 0080  	mov2nw 6,r[15];		am->fpdp;	cjs,go shm_to_fpr;;		shp+	  | move pt1 x,y,z coords to fpr[64]
    7c7  0a 2b e 0 0 7140 3f80  	;			0x3F80->fpregh;	;		;			  | w1 = 1.0
    7c8  0b 0b c 0 6 f900 0002  	movw 0,y;		am->fpregl;	ldct 2;		;		dp+	  | ldct 2 into 2910 counter
    7c9  02 00 1 7 0 d84b 0080  	movw,s r[11],y;	;		cjs,go shm_to_fpr;;			  | move pt2 x,y,z coords to fpr[68]
                                											  | r[11]==0? (xf3 doesn't affect cc's)
    7ca  0a 00 1 7 0 7140 07e1  	;			;		cjs,go cwn3;	;			  | shared routine to process 3D vector
    7cb  02 00 e 0 0 e1e6 0000  cwnout3: btstw,s 0,r[6];	;		;		;			  | test if invisible
    7cc  0a 00 3 8 0 7140 07f5  	;			;		cjp,~zer cwnnovec3; ;			  | if so next vector
    7cd  2b 0c e 0 0 d844 0230  	movw r[4],y;	am->fpap;	;		lmode rn,ai,pipe,fast;	  | fpap <- &x0; pipeline mode
    7ce  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | convert x0 to integer
    7cf  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+
    7d0  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | y0
    7d1  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+
    7d2  2a 00 e 0 0 f8e0 00e0  	movw 76,y;		;		;		fixa,la,hi;		  | z0
    7d3  2b 0c e 0 0 004c 00e0  	;			am->fpap;	;		;			  | fpap <- &x1
    7d4  2a 00 e 0 0 f8e0 00e0  	movw 5,y;		;		;		fixa,la,hi;		  | x1
    7d5  2b 08 e 0 4 0005 00e0  	;			am->brreg;	;		;		ap+	  | brreg <- 5
    7d6  2a 00 e 0 0 7140 00e2  	;			;		;		fixa,la,a,hi;		  | y1
    7d7  3b 0e 4 7 4 f900 00e2  	movw 0,y;		am->fpdp;	push,go;	;		ap+	  | fpdp <- 0; 2910 R reg <- 5
    7d8  2a 00 e 0 0 7140 00e3  	;			;		;		fixa,la,a,st,hi;	  | fix z1; store x0,y0,z0,x1,y1,z1 starting
    7d9  3b 0c 8 0 6 f900 00e3  	movw 0,y;		am->fpap;	rfct;		;		dp+	  | fpreg[0]; fpap <- 0
    7da  1a 27 4 7 0 9e9e 000d  	addw d,r[30],r[30];	13->am;		push,go;	;			  | r[30] += 13
    7db  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | overwrite original coords in shmem
    7dc  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
                                cwnloop3:
    7dd  0a 0a e 0 2 f900 0000  	movw 0,y;		am->shmem;	;		;		shp+	  | dataready[i] <- 0;shmemp <- nxt vec addr
    7de  02 00 c 0 0 dd6a 0002  	incw,s r[10],r[10];	;		ldct 2;		;			  | reload 2910 R reg; incr vec loop cntr
    7df  0a 00 3 8 0 dd7e 07c6  	incw r[30],r[30];	;		cjp,~zer cwnnxtvec3;;			  | r[30] += 1 and loop if more vectors
    7e0  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
    7e1  0a 08 e 0 0 d845 0000  cwn3:	movw r[5],y;		am->brreg;	;		;			  | 
    7e2  08 2b e 0 e c7cf 3f80  	add2nw 3,r[15],r[14];	0x3F80->fpregh;	;		;			  | want transformed endpoints at fpr[72]
    7e3  0b 0b e 0 0 f900 0000  	movw 0,y;		am->fpregl;	;		;			  | w2 = 1.0
    7e4  1a 0c 1 7 0 e996 0000  	mov2nw 4,y;		am->fpap;	cjs,go;		;			  | matrix ptr in fpap; xform 1st point
    7e5  0a 2c e 0 0 c5cf 0010  	add2nw 2,r[15];		16->fpap;	;		;
    7e6  1a 00 1 7 0 c5ce 0000  	add2nw 2,r[14];	;		cjs,go;		;			  | transform 2nd point
    7e7  02 0c 1 8 0 c5cf 08d7  	add2nw,s 2,r[15];	am->fpap;	cjs,~zer clpvec3;;			  | clip vector if r[11]!=0; also if no
                                											  | clip, force cc to ~zer so vec is vwpscld
    7e8  0a 00 3 0 0 d80b 07f4  	movw r[11],acc;	;		cjp,zer cwnsetreslt;;			  | if invisible, don't scale to viewport
    7e9  02 00 e 0 0 90c7 0000  	andw,s r[7],acc,y;;		;		;			  | set cc to reflect clip status of pt1
    7ea  0a 00 3 0 0 d900 07ec  	movw 0,r[0];		;		cjp,zer .+2;	;			  | r[0]<-0; compute resultflag[i] in r[0]
    7eb  0a 00 e 0 0 e1a0 0000  	bsetw 0,r[0];		;		;		;			  | set bit 0 if pt1 was clipped
    7ec  02 00 e 0 0 90c8 0000  	andw,s r[8],acc,y;;		;		;			  | set cc to reflect clip status of pt2
    7ed  0a 0f 3 0 0 d85e 07ef  	movw r[30],y;		am->shmemp;	cjp,zer .+2;	;			  | shmemp <- &resultflag[i]
    7ee  0a 0a 3 7 2 e3a0 07f0  	bsetw 1,r[0];		am->shmem;	cjp,go .+2;	;		shp+	  | set bit 1 if pt2 clip; resultflag<-r[0]
    7ef  0a 0a e 0 2 d840 0000  	movw r[0],y;		am->shmem;	;		;		shp+	  | resultflag<-r[0] (if pt2 not clipped)
                                											  | clpvec3 returns with fpap==r[15] if pt
                                											  | visible, so fpap==r[15]==72 from above
    7f0  08 0e 4 7 4 c1ef 0003  	sub2nw 0,r[15],r[4]; am->fpdp;	push,go 3;	;			  | fpdp <- r[4] <- 71
    7f1  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | shift x0,y0,z0,w0 up by 1 fpreg location
    7f2  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | so spacing between x0 and x1 is correct
                                											  | for vwpsclpts3 routine (5 locations)
    7f3  0a 08 3 7 0 fd00 0b69  	incw 0,y;		am->brreg;	cjp,go vwpsclpts3;;			  | call vwpsclpts3 with brreg==1 (npts-1)
                                											  | & r[4]==&x0 to vwpscl pts in place
                                cwnsetreslt:
    7f4  1a 00 a 7 0 c186 0000  	mov2nw 0,r[6];	;		crtn,go;	;			  | set resultflag = 1 for invisible
                                cwnnovec3:
    7f5  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- &resultflag[i]
    7f6  0a 2a e 0 0 9c9e ffff  	addw r[30],13,r[30];	0xFFFF->shmem;	;		;			  | resultflag for this vector <- 0xFFFF
    7f7  0a 0f 3 7 0 000d 07dd  	;			am->shmemp;	cjp,go cwnloop3;;			  | shmemp <- r[30] <- &dataready[i]
                                											  | goto cwnloop3
                                |   mulptinit3 does the initialization for mulpt int and flt 3d.
                                mulptinit3:
    7f8  0a 28 e 0 0 949d 0003  	addw r[29],5,y; 3->brreg; ;		;			  | brreg <- 3
    7f9  0a 0f e 0 0 0005 0000  	;			am->shmemp;	;		;			  | shmemp <- addr of r[9]
    7fa  0a 1f c 0 0 c58e 000f  	mov2nw 2,r[14];	shmem->shmemp;	ldct 15;	;			  | shmemp <- addr of matrix; r[14] <- 4
    7fb  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    7fc  1a 0f c 0 0 c3de 0000  	add2nw 1,r[30];	am->shmemp;	ldct;		;			  | shmemp <- (r[30] += 2), addr of 1st pt
    7fd  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | 
                                |	negw d,r[10];		shmem->am;	jmap MUL_POINT_FLT_3D;;			  | r[10] <- -npts
                                MUL_POINT_FLT_3D:
    7fe  0a 00 1 7 0 7140 07f8  	;			;		cjs,go mulptinit3; ;			  | 
    7ff  0a 0e 1 7 0 d90f 0080  xfpt3nxt: movw 0,r[15];		am->fpdp;	cjs,go shm_to_fpr;;			  | move pt[i] to fpr[0]
    800  0a 0c 1 7 0 e996 0860  	mov2nw 4,y;		am->fpap;	cjs,go xf3;	;			  | xform pt and store result at fpr[4]
    801  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- addr of pt
    802  12 2c 4 7 0 dd6a 0004  	incw,s r[10],r[10];	4->fpap;	push,go;	;			  | r[10] += 1; fpap <- addr of xformed pt
    803  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move xformed pt to shared memory,
    804  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | overwriting original pt
    805  1a 27 c 0 0 9e9e 0009  	addw d,r[30],r[30];	9->am;		ldct;		;			  | r[30] += 9, addr of pt[i+1]
    806  0a 0a 3 8 2 f900 07ff  	movw 0,y;		am->shmem;	cjp,~zer xfpt3nxt;;		shp+	  | flag[i] <- 0, indicating xform done
                                											  | loop back for next pt;shmemp == &pt[i+1]
    807  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |	negw d,r[10];		shmem->am;	jmap MUL_POINT_INT_3D;;			  | r[10] <- -npts
                                MUL_POINT_INT_3D:
    808  0a 00 1 7 0 7140 07f8  	;			;		cjs,go mulptinit3; ;			  | 
    809  0a 0e 1 7 0 d90f 0080  xfpt3nxti: movw 0,r[15];	am->fpdp;	cjs,go shm_to_fpr; ;			  | move pt[i] to fpr[0]
    80a  0a 0c 1 7 0 e996 083b  	mov2nw 4,y;		am->fpap;	cjs,go xfint3w;	;			  | xform pt & r[20] & store result at fpr[4]
    80b  08 00 1 7 f d96e 0828  	movw r[14],r[15];	;		cjs,go fltoint3; ;			  | convert float res to int, need r[15]
    80c  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp <- addr of pt
    80d  12 2c 4 7 0 dd6a 0004  	incw,s r[10],r[10];	4->fpap;	push,go;	;			  | r[10] += 1; fpap <- addr of xformed pt
    80e  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move xformed pt to shared memory,
    80f  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | overwriting original pt
    810  1a 27 c 0 0 9e9e 0009  	addw d,r[30],r[30];	9->am;		ldct;		;			  | r[30] += 9, addr of pt[i+1]
    811  0a 0a 3 8 2 f900 0809  	movw 0,y;		am->shmem;	cjp,~zer xfpt3nxti;;		shp+	  | flag[i] <- 0, indicating xform done
                                											  | loop back for next pt;shmemp == &pt[i+1]
    812  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |	rolw 5,d,acc;		shmem->am;	jmap MATMUL_3D;	;		shp+	  | acc <- indexA*32
                                MATMUL_3D:
    813  0a 17 e 0 2 aa20 0000  	rolw 5,d,r[0];		shmem->am;	;		;		shp+	  | r[0] <- indexB*32
    814  0a 17 e 0 0 aa21 0000  	rolw 5,d,r[1];		shmem->am;	;		;			  | r[1] <- indexC*32
    815  0a 27 e 0 0 e281 0040  	addw d,acc,acc;		 64->am;;		;
    816  0a 0f c 0 0 909d 000f  	addw r[29],acc,y;	am->shmemp;	ldct 15;	;			  | shmemp <- addr of matrix A
    817  0a 0e 1 7 0 c98f 0080  	mov2nw 4,r[15];		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix A to fpr[16]
    818  0a 27 e 0 0 8680 0040  	addw d,r[0],acc;	 64->am;;		;
    819  0a 0f c 0 0 909d 000f  	addw r[29],acc,y;	am->shmemp;	ldct 15;	;			  | shmemp <- addr of matrix B
    81a  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix B to fpr[32]
    81b  0a 0c e 0 0 eb96 0000  	mov2nw 5,y;		am->fpap;	;		;			  | fpap <- addr of matrix B (in fpr)
    81c  0a 00 1 7 0 cd8e 0860  	mov2nw 6,r[14];	;		cjs,go xf3;	;			  | r[14] <- addr of matrix C (fpr[64])
                                											  | r[15] == addr of 1st row of matrix A
                                											  | xf3 produces 1st row of matrix C 
    81d  0a 2c e 0 0 c5cf 0020  	add2nw 2,r[15];		32->fpap;	;		;
    81e  0a 00 1 7 0 c5ce 0860  	add2nw 2,r[14];	;		cjs,go xf3;	;			  | produce 2nd row of matrix C
    81f  0a 2c e 0 0 c5cf 0020  	add2nw 2,r[15];		32->fpap;	;		;
    820  0a 00 1 7 0 c5ce 0860  	add2nw 2,r[14];	;		cjs,go xf3;	;			  | produce 3rd row of matrix C
    821  0a 2c e 0 0 c5cf 0020  	add2nw 2,r[15];		32->fpap;	;		;
    822  0a 00 1 7 0 c5ce 0860  	add2nw 2,r[14];	;		cjs,go xf3;	;			  | produce 4th row of matrix C
    823  0a 2c e 0 0 8681 0040  	addw d,r[1],acc;	64->fpap;	;		;			  | fpap <- addr of matrix C (in fpr)
    824  0a 0f 4 7 0 909d 000f  	addw r[29],acc,y;	am->shmemp;	push,go 15;	;			  | shmemp <- addr of matrix C (in shmem)
                                											  | (d still has XFORM_FRMOFF)
    825  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | move matrix C to shmem
    826  1b 3a 8 0 b 7140 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
    827  0a 00 2 0 0 c5de 0027  	add2nw 2,r[30],r[30];	;		jmap getcmd;	;			  | r[30] += 4; jump to r[0] loop
                                |	fltoint3 -- 3D conversion from float to int.  Operates on a single point and converts
                                |   		    the points in place, ie, overwrites the original floating point value.
                                |
                                |	Input Parameters:	r[15] -- Location of point to be converted.
    828  2b 0c e 0 0 d84f 0230  fltoint3: movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	| 
    829  2a 0e e 0 0 d84f 00e0  	movw r[15],y;		am->fpdp;	;		fixa,la,hi;		| convert x to int
    82a  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    82b  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		| convert y to int	
    82c  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    82d  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		| convert z to int	
    82e  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    82f  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		| convert r[20] to int	
    830  2b 00 e 0 0 7140 00e0  	;			;		;		;			| 
    831  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		| 
    832  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    833  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		| overwrite x
    834  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    835  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		| overwrite y
    836  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    837  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		| overwrite z
    838  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    839  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		| overwrite r[20]
    83a  3b 00 a 7 0 7140 0101  	;			;		crtn, go;	;			| 
                                |	xfint3w -- convert point from fix to float, including r[20], and jump to xf3.
                                |
                                |	Important Properties:	Does not use brreg; Does not use 2910 R register (counter)
                                |				Does not change latched 29116 condition code status
                                |   	Note: difference with xfint3 is that this converts r[20] also.
                                |
    83b  2b 0c e 0 0 d84f 0230  xfint3w: movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	  | 
    83c  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | x
    83d  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    83e  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | y
    83f  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    840  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | z
    841  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    842  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | r[20]
    843  2b 00 e 0 0 7140 00a0  	;			;		;		;
    844  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    845  2b 0e e 0 0 d84f 0122  	movw r[15],y;		am->fpdp;	;		;
    846  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite x
    847  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    848  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite y
    849  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    84a  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite z
    84b  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+  
    84c  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | overwrite r[20]
    84d  2b 0c e 0 0 e996 0101  	mov2nw 4,y;		am->fpap;	;		;			  | reload fpap and call xf3
    84e  0a 00 3 7 0 7140 0860  	;			;		cjp,go xf3;	;			  | 
                                |
                                |	Important Properties:	Does not use brreg; Does not use 2910 R register (counter)
                                |				Does not change latched 29116 condition code status
                                |
    84f  2b 0c e 0 0 d84f 0230  xfint3:	movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	  | 
    850  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | x
    851  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    852  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | y
    853  2b 00 e 0 4 7140 00a0  	;			;		;		;		ap+
    854  2a 00 e 0 0 7140 00a0  	;			;		;		floata,la,hi;		  | z
    855  2b 00 e 0 0 7140 00a0  	;			;		;		;
    856  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;
    857  2b 00 e 0 0 7140 0120  	;			;		;		;
    858  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    859  2b 0e e 0 0 d84f 0122  	movw r[15],y;		am->fpdp;	;		;
    85a  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite x
    85b  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    85c  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | overwrite y
    85d  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    85e  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | overwrite z
    85f  2b 0c e 0 0 e996 0101  	mov2nw 4,y;		am->fpap;	;		;			  | reload fpap and fall through to xf3
                                |	xf3 -- 3-D floating point transform
                                |
                                |	Input Parameters:	r[15] -- Address of input point
                                |				r[14] -- Address of output point
                                |				matrix -- fpap should have been loaded
                                |					  with the address of the matrix
                                |					  prior to calling this routine.
                                |					  A 4x4 matrix
                                |
                                |	Comments:	Locations at address r[14] are used as temporary storage.
                                |			This routine cannot be used to transform a point in place,
                                |			i.e. r[15] should not be the same as r[14].
                                |
                                |
                                |	Important Properties:	Does not use brreg; Does not use 2910 R register (counter)
                                |				Does not change latched 29116 condition code status
                                |
    860  2b 0d e 0 0 d84f 0230  xf3:	movw r[15],y;		am->fpbp;	;		lmode rn,ai,pipe,fast;
    861  2a 0e e 0 0 d84e 0010  	movw r[14],y;		am->fpdp;	;		maba,lab,hi;		  | m11*x
    862  2b 00 e 0 4 7140 0010  	;			;		;		;		ap+
    863  2a 00 e 0 0 7140 0020  	;			;		;		maba,la,hi;		  | m12*x
    864  2b 00 e 0 4 7140 0020  	;			;		;		;		ap+
    865  2a 00 e 0 0 7140 0020  	;			;		;		maba,la,hi;		  | m13*x
    866  2b 00 e 0 4 7140 0020  	;			;		;		;		ap+
    867  2a 00 e 0 0 7140 0020  	;			;		;		maba,la,hi;		  | m14*x
    868  2b 00 e 0 7 7140 0020  	;			;		;		;		abp+
    869  2a 00 e 0 0 7140 0014  	;			;		;		maba,lab,m,hi;		  | m21*y
    86a  2b 00 e 0 4 7140 0014  	;			;		;		;		ap+
    86b  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | m22*y , store m11*x
    86c  2b 00 e 0 8 7140 0025  	;			;		;		;		adp+
    86d  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | m23*y , store m12*x
    86e  2b 00 e 0 8 7140 0025  	;			;		;		;		adp+
    86f  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | m24*y , store m13*x
    870  2b 00 e 0 8 7140 0025  	;			;		;		;		adp+
    871  2a 0d e 0 0 d84e 0125  	movw r[14],y;		am->fpbp;	;		adda,la,m,st,hi;		  | store m14*x
    872  2b 0e e 0 0 d84e 0125  	movw r[14],y;		am->fpdp;	;		;
    873  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m21*y + m11*x
    874  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    875  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m22*y + m12*x
    876  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    877  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m23*y + m13*x
    878  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    879  2a 00 e 0 0 948f 0118  	addw r[15],2,y;		;		;		addr,lab,hi;		  | m24*y + m14*x
    87a  2b 0d e 0 0 0002 0118  	;			am->fpbp;	;		;
    87b  2a 00 e 0 0 7140 0012  	;			;		;		maba,lab,a,hi;		  | m31*z
    87c  2b 00 e 0 4 7140 0012  	;			;		;		;		ap+
    87d  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m32*z , store m21*y + m11*x
    87e  2b 00 e 0 8 7140 0023  	;			;		;		;		adp+
    87f  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m33*z , store m22*y + m12*x
    880  2b 00 e 0 8 7140 0023  	;			;		;		;		adp+
    881  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m34*z , store m23*y + m13*x
    882  2b 00 e 0 8 7140 0023  	;			;		;		;		adp+
    883  2a 0d e 0 0 d84e 0125  	movw r[14],y;		am->fpbp;	;		adda,la,m,st,hi;		  | store m24*y + m14*x
    884  2b 0e e 0 0 d84e 0125  	movw r[14],y;		am->fpdp;	;		;
    885  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m31*z + (m21*y + m11*x)
    886  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    887  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m32*z + (m22*y + m12*x)
    888  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    889  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m33*z + (m23*y + m13*x)
    88a  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    88b  2a 00 e 0 0 948f 0118  	addw r[15],3,y;		;		;		addr,lab,hi;		  | m34*z + (m24*y + m14*x)
    88c  2b 0d e 0 0 0003 0118  	;			am->fpbp;	;		;
    88d  2a 00 e 0 0 7140 0012  	;			;		;		maba,lab,a,hi;		  | m41*r[20]
    88e  2b 00 e 0 4 7140 0012  	;			;		;		;		ap+
    88f  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m42*r[20] , store m31*z + (m21*y + m11*x)
    890  2b 00 e 0 8 7140 0023  	;			;		;		;		adp+
    891  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m43*r[20] , store m32*z + (m22*y + m12*x)
    892  2b 00 e 0 8 7140 0023  	;			;		;		;		adp+
    893  2a 00 e 0 0 7140 0023  	;			;		;		maba,la,a,st,hi;	  | m44*r[20] , store m33*z + (m23*y + m13*x)
    894  2b 00 e 0 6 7140 0023  	;			;		;		;		dp+
    895  2a 0d e 0 0 d84e 0125  	movw r[14],y;		am->fpbp;	;		adda,la,m,st,hi;		  | store m34*z + (m24*y + m14*x)
    896  2b 0e e 0 0 d84e 0125  	movw r[14],y;		am->fpdp;	;		;
    897  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m41*r[20] + (m31*z + m21*y + m11*x)
    898  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    899  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m42*r[20] + (m32*z + m22*y + m12*x)
    89a  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    89b  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | m43*r[20] + (m33*z + m23*y + m13*x)
    89c  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    89d  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | m44*r[20] + (m34*z + m24*y + m14*x)
    89e  2b 00 e 0 0 7140 0118  	;			;		;		;
    89f  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;
    8a0  2b 00 e 0 0 7140 0122  	;			;		;		;
    8a1  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | x' = m41*w + m31*z + m21*y + m11*x
    8a2  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    8a3  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | y' = m42*w + m32*z + m22*y + m12*x
    8a4  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    8a5  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | z' = m43*w + m33*z + m23*y + m13*x
    8a6  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    8a7  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | r[20]' = m44*w + m34*z + m24*y + m14*x
    8a8  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;
                                |	vwpsndvec3_xy -- scale 3-D vector (x0,y0,z0,w0 x1,y1,z1,w1) to viewport,
                                |			 convert floating point coordinates to integer, and
                                |			 send to Painting Processor
                                |			 produces only scaled x and y
                                |			 input vectors are in NDC, i.e. clipped vectors will have
                                |			 -1.0 <= x/r[20],y/r[20] <= 1.0
                                |
                                |	Input Parameters:	r[15] -- address of first input point x,y,z,r[20]
                                |				r[14] -- address for scaled x,y
                                |
                                |
                                vwpsndvec3_xy:
    8a9  08 27 e 0 2 d96e 0003  	movw r[14],r[2];	3->am;		;		;			  | use fpr[r[14],r[14]+1] for reciprocals
    8aa  0a 0c 1 7 0 968f 08cc  	addw d,r[15],y;		am->fpap;	cjs,go paratest; ;			  | test for parallel proj: r[20] == 1
    8ab  0a 27 e 0 0 dd62 0007  	incw r[2],r[2];	7->am;		;		;
    8ac  0a 0c 1 7 0 968f 034a  vwrecp2: addw d,r[15],y;	am->fpap;	cjs,go recip;	;			| compute reciprocal of w1
    8ad  2b 0c e 0 0 d84f 0230  	movw r[15],y;		am->fpap;	;		lmode rn,ai,pipe,fast;	| 
    8ae  0a 0d e 0 0 d84e 0000  	movw r[14],y;		am->fpbp;	;		;
    8af  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x0 * 1/w0
    8b0  2b 00 e 0 4 7140 0010  	;			;		;		;		ap+
    8b1  2a 00 e 0 0 948f 0020  	addw r[15],4,y;		;		;		maba,la,hi;		  | y0 * 1/w0
    8b2  2b 0c e 0 5 0004 0020  	;			am->fpap;	;		;		bp+
    8b3  2a 00 e 0 0 f8e0 0010  	movw =vwpsv2,y;		;		;		maba,lab,hi;		  | x1 * 1/w1
    8b4  2b 08 e 0 4 04b3 0010  	;			am->brreg;	;		;		ap+
    8b5  2a 00 e 0 0 7140 0020  	;			;		;		maba,la,hi;		  | y1 * 1/w1
    8b6  2b 00 e 0 0 7140 0020  	;			;		;		;
    8b7  2a 0d e 0 0 eb86 0124  	mov2nw 5,acc;		am->fpbp;	;		adda,la,m,hi;		  | fpbp pts to viewport params
    8b8  2b 00 e 0 0 7140 0124  	;			;		;		;
    8b9  2a 00 e 0 0 7140 001c  	;			;		;		mabr,lab,m,hi;		  | x0 * VWPXSCL
    8ba  2b 0d e 0 0 e384 001c  	add2nw 1,acc;		am->fpbp;	;		;
    8bb  2a 00 e 0 0 7140 001c  	;			;		;		mabr,lab,m,hi;		  | y0 * VWPYSCL
    8bc  2b 0d e 0 0 e385 001c  	sub2nw 1,acc;		am->fpbp;	;		;
    8bd  2a 00 e 0 0 7140 001c  	;			;		;		mabr,lab,m,hi;		  | x1 * VWPXSCL
    8be  2b 0d e 0 0 e384 001c  	add2nw 1,acc;		am->fpbp;	;		;
    8bf  2a 00 e 0 0 7140 0018  	;			;		;		mabr,lab,hi;		  | y1 * VWPYSCL
    8c0  3b 0d 3 7 0 e185 0018  	sub2nw 0,acc;		am->fpbp;	cjp,go;		;			  | fpbp<-&Vwpxoff; jump to vwpsv2 to
                                											  | finish scaling, conversion, & xmit to PP
    8c1  2b 0d e 0 0 eb86 0230  vwparll: mov2nw 5,acc;		am->fpbp;	;		lmode rn,ai,pipe,fast;	| fpbp pts to viewport params
    8c2  0a 00 e 0 0 f8e0 0000  	movw =vwpsv2,y;		;		;		;			| 
    8c3  2a 08 e 0 0 04b3 0010  	;			am->brreg;	;		maba,lab,hi;		| x0 * VWPXSCL
    8c4  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+	| 
    8c5  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y0 * VWPYSCL
    8c6  2b 0d e 0 4 e385 0010  	sub2nw 1,acc;		am->fpbp;	;		;		ap+	| 
    8c7  08 0c e 0 0 c5cf 0000  	add2nw 2,r[15],r[0];	am->fpap;	;		;			| 
    8c8  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x1 * VWPXSCL
    8c9  2b 0d e 0 4 e384 0010  	add2nw 1,acc;		am->fpbp;	;		;		ap+	| 
    8ca  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y1 * VWPYSCL
    8cb  3b 0d 3 7 0 e185 0010  	sub2nw 0,acc;		am->fpbp;	cjp, go;	;			| fpbp<-&Vwpxoff; jump to vwpsv2 to
                                											| finish scaling, conversion, & xmit to PP
                                paratest:
    8cc  0a 27 e 0 0 f8c1 3f80  	movw d,acc;		0x3f80->am;	;		;			  | test for fp 1.0
    8cd  02 37 e 0 0 e200 0000  	subw,s d,acc,y;		fpregh->am;	;		;			| compare msw
    8ce  03 37 3 8 0 f8c0 034a  	movw,s d,y;		fpregl->am;	cjp,~zer recip;	;			| compare lsw, if either fail jp recip
    8cf  0a 0e 3 8 0 d842 034a  	movw r[2],y;		am->fpdp;	cjp,~zer recip;	;			  | otherwise no need for divide
    8d0  08 0c e 0 0 c1ee 0000  	sub2nw 0,r[14],r[0];	am->fpap;	;		;			| w2 is at (r[14]-1)
    8d1  02 37 e 0 0 e200 0000  	subw,s d,acc,y;		fpregh->am;	;		;			| compare msw (fp 1 is in acc)
    8d2  03 37 3 8 0 f8c0 08d4  	movw,s d,y;		fpregl->am;	cjp,~zer parecip; ;			| jump if w2 is also 1
    8d3  0a 0c b 0 0 d84f 08c1  	movw r[15],y;		am->fpap;	cjpp,zer vwparll; ;			| jump to vwp scale if w2==1 also
    8d4  0a 0c e 0 0 c5e0 0000  parecip: sub2nw 2,r[0];		am->fpap;	;		;			| 'a' ptr set to w1
    8d5  0a 3b e 0 0 dd62 0000  	incw r[2],r[2];	fpregh->fpregh;	;		;			| need to set w1==1 for multiply
    8d6  0b 3b b 7 0 7140 08ac  	;			fpregl->fpregl;	cjpp,go vwrecp2; ;			| return to find recip for pt2
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)clpvec3.vp.u 1.2 86/09/12 SMI
                                |	clpvec3 -- clip a 3-D vector to a normalized window (-1.0 <= x/r[20],y/r[20] <= 1.0, 0.0 <= z/r[20] <= 1.0)
                                |		   operates in homogeneous coordinates and clips to the region of positive r[20] only
                                |
                                |	Input Parameters:	r[15],fpap -- Address of vector to be clipped (N.B.: fpap must be set to r[15] prior to call)
                                |
                                |
                                |	Output:		clipped vector endpoints are written over input points
                                |			return with r[15]==fpap if vector is visible
                                |			Am29116 Z condition flag Z: 0 (2910 branch condition ~zer) => all or part of input vector is visible
                                |						    1 (2910 branch condition  zer) => input vector is not visible
                                |
    8d7  29 00 e 0 0 c3cf 0230  clpvec3: add2nw 1,r[15],r[0];	;		;		lmode rn,ai,pipe,fast;    | fpreg's 0-15 are scratch memory
    8d8  0a 0d e 0 0 dd60 0000  	incw r[0],r[0];		am->fpbp;	;		;			  | fpbp <- &w0
    8d9  2a 0e e 0 0 e786 0110  	mov2nw 3,acc;		am->fpdp;	;		adda,lab,hi;		  | wec0_left = w0 + x0; fpdp <- 8
    8da  2b 0b e 0 0 f900 0110  	movw 0,y;		am->fpregl;	;		;			  | fpr[8] <- 0.0
    8db  2a 0b e 0 0 f900 01a0  	movw 0,y;		am->fpregh;	;		rsuba,la,hi;		  | wec0_right = w0 - x0
    8dc  2b 00 e 0 4 e185 01a0  	sub2nw 0,acc;		;		;		;		ap+	  | acc <- 7 (used below)
    8dd  2a 00 e 0 0 f8e0 0120  	movw =trivaccept3,y;	;		;		adda,la,hi;		  | wec0_bottom = w0 + y0
    8de  2b 08 e 0 0 0939 0120  	;			am->brreg;	;		;			  | set up brreg for possible branch later
    8df  2a 00 e 0 0 d908 01a0  	movw 0,r[8];	;		;		rsuba,la,hi;		  | wec0_top = w0 - y0; r[8]<-0, for
    8e0  2b 0d e 0 4 e796 01a0  	mov2nw 3,y;		am->fpbp;	;		;		ap+	  | COREWLDVECNDC_3D r[0]; fpbp <- 8
    8e1  2a 0e e 0 0 f900 0112  	movw 0,y;		am->fpdp;	;		adda,lab,a,hi;		  | wec0_hither = 0.0 + z0; fpdp <- 0
    8e2  2b 0d e 0 0 d840 0112  	movw r[0],y;		am->fpbp;	;		;			  | fpbp <- &w0
    8e3  2a 00 e 0 0 db06 0193  	compw 0,r[6];	;		;		rsuba,lab,a,st,hi;	  | wec0_yon = w0 - z0; r[6] = 0xFFFF
    8e4  2b 31 e 0 8 6e00 0193  	sl0b d,y;		fpstreg->am;	;		;		adp+	  | get L bit of r[6]
    8e5  28 0d e 0 1 988f 0101  	addw r[15],acc,r[1];	am->fpbp;	;		adda,st,hi;		  | can't set both a & b ptrs fast enough
    8e6  2b 00 e 0 8 cc46 0101  	slqw r[6],r[6];	;		;		;		adp+	  | to keep pipe going; fpbp<-&w1,fpap<-&x1
    8e7  2a 31 e 0 0 6e00 0112  	sl0b d,y;		fpstreg->am;	;		adda,lab,a,hi;		  | wec1_left = w1 + x1
    8e8  2b 00 e 0 0 cc46 0112  	slqw r[6],r[6];	;		;		;			  | R bit of r[6]
    8e9  2a 00 e 0 0 fb01 01a3  	compw 0,acc;	;		;		rsuba,la,a,st,hi;	  | wec1_right = w1 - x1; acc = 0xFFFF
    8ea  2b 31 e 0 8 6e00 01a3  	sl0b d,y;		fpstreg->am;	;		;		adp+	  | B bit of r[6]
    8eb  2a 00 e 0 0 cc46 0123  	slqw r[6],r[6];	;		;		adda,la,a,st,hi;	  | wec1_bottom = w1 + y1
    8ec  2b 31 e 0 6 6e00 0123  	sl0b d,y;		fpstreg->am;	;		;		dp+	  | T bit of r[6]
    8ed  2a 00 e 0 0 cc46 01a3  	slqw r[6],r[6];	;		;		rsuba,la,a,st,hi;	  | wec1_top = w1 - y1
    8ee  2b 0d e 0 8 c782 01a3  	mov2nw 3,r[2];		am->fpbp;	;		;		adp+	  | fpbp <- 8
    8ef  2a 31 e 0 0 6e00 0113  	sl0b d,y;		fpstreg->am;	;		adda,lab,a,st,hi;	  | wec1_hither = 0.0 + z1
    8f0  2b 00 e 0 6 cc46 0113  	slqw r[6],r[6];	;		;		;		dp+	  | H bit of r[6]
    8f1  2a 31 e 0 0 6e00 0101  	sl0b d,y;		fpstreg->am;	;		adda,st,hi;		  | have to hiccup pipe to avoid losing last
    8f2  2b 0d e 0 6 d841 0101  	movw r[1],y;		am->fpbp;	;		;		dp+	  | r[6] bit; fpbp <- &w1
    8f3  2a 00 e 0 0 cc46 0192  	slqw r[6],r[6];	;		;		rsuba,lab,a,hi;		  | wec1_yon = w1 - z1; Y bit of r[6]
    8f4  2b 31 e 0 0 6e00 0192  	sl0b d,y;		fpstreg->am;	;		;			  | L bit of acc
    8f5  2a 00 e 0 0 ec41 0101  	slqw acc,acc;	;		;		adda,st,hi;		  | hiccup pipe to reload a and b ptrs
    8f6  2b 0c e 0 6 f900 0101  	movw 0,y;		am->fpap;	;		;		dp+	  | fpap <- 0, address of wec0's
    8f7  0a 0d e 0 0 c3e2 0000  	sub2nw 1,r[2];		am->fpbp;	;		;			  | fpbp <- 6, address of wec1's
    8f8  2a 31 e 0 0 6e00 0152  	sl0b d,y;		fpstreg->am;	;		suba,lab,a,hi;		  | wec0_left - wec1_left
    8f9  2b 00 e 0 7 ec41 0152  	slqw acc,acc;	;		;		;		abp+	  | R bit of acc
    8fa  28 00 e 0 7 db66 0153  	compw r[6],r[7];;		;		suba,lab,a,st,hi;	  | wec0_right - wec1_right
    8fb  2b 31 e 0 a 6e00 0153  	sl0b d,y;		fpstreg->am;	;		;		abdp+	  | B bit of acc
                                											  | r[7]<-~r[6](COREWLDVECNDC_3D)
    8fc  2a 00 e 0 0 ec41 0153  	slqw acc,acc;	;		;		suba,lab,a,st,hi;	  | wec0_bottom - wec1_bottom
    8fd  2b 31 e 0 a 6e00 0153  	sl0b d,y;		fpstreg->am;	;		;		abdp+	  | T bit of acc
    8fe  2a 00 e 0 0 ec41 0153  	slqw acc,acc;	;		;		suba,lab,a,st,hi;	  | wec0_top - wec1_top
    8ff  2b 31 e 0 a 6e00 0153  	sl0b d,y;		fpstreg->am;	;		;		abdp+	  | H bit of acc
    900  2a 00 e 0 0 ec41 0153  	slqw acc,acc;	;		;		suba,lab,a,st,hi;	  | wec0_hither - wec1_hither
    901  2b 0e e 0 7 c1c2 0153  	add2nw 0,r[2];		am->fpdp;	;		;		abp+	  | fpdp <- 7, store wec diffs there
    902  2a 31 e 0 0 6e00 0153  	sl0b d,y;		fpstreg->am;	;		suba,lab,a,st,hi;	  | wec0_yon - wec1_yon;store wec left diff
    903  2b 00 e 0 6 ec41 0153  	slqw acc,acc;	;		;		;		dp+	  | Y bit of acc
    904  2a 07 e 0 0 90e6 0123  	nandw r[6],acc,y; am->am;	;		adda,la,a,st,hi;		  | store wec right diff
    905  23 00 e 0 6 96cb 0123  	andw,s d,r[11],y;	;		;		;		dp+	  | result != 0 iff >= 1 pt outside window
    906  38 00 3 0 5 9ecb 0123  	andw d,r[11],r[5];;		cjp,zer;	adda,la,a,st,hi;		  | jump if trivial accept; 2-reg op ok here
    907  2b 00 e 0 6 f8e0 0123  	movw =reject3,y;	;		;		;		dp+	  | store wec bottom diff
    908  2a 08 e 0 0 0938 0123  	;			am->brreg;	;		adda,la,a,st,hi;		  | store wec top diff
    909  2b 07 e 0 6 9126 0123  	norw r[6],acc,y; am->am;	;		;		dp+
    90a  22 00 e 0 0 96cb 0123  	andw,s d,r[11],y;	;		;		adda,la,a,st,hi;		  | result != 0 iff 2 pts outside >= 1 plane
    90b  3b 0c 3 8 6 d842 0123  	movw r[2],y;		am->fpap;	cjp,~zer;	;		dp+	  | jump if trivial reject;store hither diff
    90c  2a 00 e 0 0 c1e2 0101  	sub2nw 0,r[2],r[2];	;		;		adda,st,hi;		  | fpap<-7; r[2]<-6; store wec yon diff
    90d  23 00 e 0 0 ebe5 0101  	btstw,s 5,r[5];	;		;		;
    90e  0a 00 1 8 0 da88 034a  	compw acc,r[8];;		cjs,~zer recip;	;			  | compute left recip if intersect
                                											  | r[8]<-~acc(COREWLDVECNDC_3D)
    90f  02 00 e 0 0 e9e5 0000  	btstw,s 4,r[5];	;		;		;
    910  0a 00 1 8 4 dd62 034a  	incw r[2],r[2];	;		cjs,~zer recip;	;		ap+	  | compute right recip if intersect
    911  02 00 e 0 0 e7e5 0000  	btstw,s 3,r[5];	;		;		;
    912  0a 00 1 8 4 dd62 034a  	incw r[2],r[2];	;		cjs,~zer recip;	;		ap+	  | compute bottom recip if intersect
    913  02 00 e 0 0 e5e5 0000  	btstw,s 2,r[5];	;		;		;
    914  0a 00 1 8 4 dd62 034a  	incw r[2],r[2];	;		cjs,~zer recip;	;		ap+	  | compute top recip if intersect
    915  02 00 e 0 0 e3e5 0000  	btstw,s 1,r[5];	;		;		;
    916  0a 00 1 8 4 dd62 034a  	incw r[2],r[2];	;		cjs,~zer recip;	;		ap+	  | compute hither recip if intersect
    917  02 00 e 0 0 e1e5 0000  	btstw,s 0,r[5];	;		;		;
    918  0a 00 1 8 4 dd62 034a  	incw r[2],r[2];	;		cjs,~zer recip;	;		ap+	  | compute yon recip if intersect
                                											  | r[5] bits indicate line crossings:
                                											  | L|R|B|T|H|Y is 5|4|3|2|1|0
                                											  | have now computed recips for the
                                											  | intersection calculations below if the
                                											  | corresponding t values will be used
                                											  | The calculations of candidate values of
                                											  | t below are of the form :
                                											  |	t = wec0_x / (wec0_x - wec1_x)
                                											  | where x is left, right, bottom, top,
                                											  | hither, or yon.
    919  2b 0c e 0 0 d904 0230  t0t1_3:	movw 0,r[4];		am->fpap;	;		lmode rn,ai,pipe,fast;	  | t0 = 0.0, param t value for line begin
    91a  0a 2d e 0 0 d903 0006  	movw 0,r[3];		6->fpbp;	;		;			  | fpap <- &wec0's, fpbp <- &diff_recip's
    91b  2a 00 e 0 0 d8e0 0010  	movw 0x3F80,r[0];	;		;		maba,lab,hi;		  | wec0_left * recip_left
    91c  2b 00 e 0 7 3f80 0010  	;			;		;		;		abp+	  | r[0] <- high order 1.0
    91d  28 00 e 0 2 d960 0010  	movw r[0],r[2];	;		;		maba,lab,hi;		  | wec0_right * recip_right
    91e  2b 0e e 0 7 d901 0010  	movw 0,r[1];		am->fpdp;	;		;		abp+	  | t1 = 1.0, param t value for line end
                                											  | fpdp<-0,store candidate t's at fpreg[0]
    91f  2a 00 e 0 0 f8e0 0010  	movw =intersect3,y;	;		;		maba,lab,hi;		  | wec0_bottom * recip_bottom
    920  2b 08 e 0 7 0981 0010  	;			am->brreg;	;		;		abp+	  | set up brreg for calls to intersect3
    921  2a 00 e 0 0 db66 0010  	compw r[6],r[6];;		;		maba,lab,hi;		  | wec0_top * recip_top; now r[6] bits
    922  2b 00 e 0 7 7140 0010  	;			;		;		;		abp+	  | have same polarity as r[5] bits
    923  22 00 e 0 0 95e5 0014  	rolw,s 10,r[5],r[5];;		;		maba,lab,m,hi;		  | wec0_hither * recip_hither
    924  33 00 1 1 5 95e6 0014  	rolw,s 10,r[6],r[6];;		cjs,neg;	;		bp+	  | call intersect2 if line crosses L plane
                                											  | L|R|B|T|H|Y now 15|14|13|12|11|10
    925  0a 2c e 0 0 7140 0005  	;			5->fpap;	;		;			  | reset fpap for final t value
    926  22 00 e 0 0 cc05 0014  	sl0w,s r[5],r[5];;		;		maba,lab,m,hi;		  | wec0_yon * recip_yon
    927  33 00 1 1 0 cc06 0014  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses R plane
                                											  | R|B|T|H|Y now 15|14|13|12|11
    928  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | B|T|H|Y now 15|14|13|12, advance pipe
    929  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses B plane
    92a  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | T|H|Y now 15|14|13, advance pipe
    92b  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses T plane
    92c  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | H|Y now 15|14, advance pipe
    92d  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses H plane
    92e  22 00 e 0 0 cc05 0124  	sl0w,s r[5],r[5];;		;		adda,la,m,hi;		  | Y now 15, advance pipe
    92f  33 00 1 1 0 cc06 0124  	sl0w,s r[6],r[6];;		cjs,neg;	;			  | call intersect2 if line crosses Y plane
                                											  | now t0 and t1 represent clipped
                                											  | endpoints iff t0 <= t1
    930  02 0b e 0 0 d844 0000  newpts3: movw,s r[4],y;	am->fpregh;	;		;			  | fpreg[0] <- t0 & test r[4]==0 which
    931  0b 0b e 0 6 d843 0000  	movw r[3],y;		am->fpregl;	;		;		dp+	  | implies t0==0.0 since fast Weitek mode
    932  0a 0b e 0 0 d802 0000  	movw r[2],acc;		am->fpregh;	;		;			  | will not produce denormalized results
    933  0b 0b 3 0 0 d841 093a  	movw r[1],y;		am->fpregl;	cjp,zer t0eq0_3;;			  | fpreg[1]<-t1 & jump if t0==0.0
    934  02 2c e 0 0 9100 0000  	xorw,s r[0],acc,y;	0->fpap;	;		;			  | fpap<-&t0; test r[2] == high order 1.0
                                											  | which means t1 == 1.0, since t1 started
                                											  | at 1.0 and could only decrease
    935  0b 37 3 0 0 9601 093c  vischk_3: subw d,r[1],y;	fpregl->am;	cjp,zer t1eq1_3;;			  | jump if t1==1.0, else check for t0>t1,
    936  02 37 e 0 0 9622 0000  	subcw,s d,r[2],y;	fpregh->am;	;		;			  | which means line is outside window
    937  0a 00 3 2 0 d900 093d  	movw 0,r[0];		;		cjp,cry twonewpts_3;;			  | jump on no borrow (t1 - t0 >= 0.0)
                                											  | r[0]<-&t0 (used below); cc indicating
                                											  | cry causes both pts to be computed below
    938  12 00 a 7 0 f900 0000  reject3: movw,s 0,y;		;		crtn,go;	;			  | Z bit <- 1 (indicating rejection) & rtn
                                											  |
    939  12 0c a 7 0 d84f 0000  trivaccept3: movw,s r[15],y;	am->fpap;	crtn,go;	;			  | Z bit <- 0 (indicating acceptance),
                                											  | fpap <- r[15], and return
                                											  |
    93a  02 28 e 0 0 dd00 0974  t0eq0_3: incw,s 0,r[0];		=t0eq0_3a->brreg;;		;			  | if t0 == 0.0, then the t0,t1 segment is
    93b  0a 00 3 7 0 7140 093d  	;			;		cjp,go twonewpts_3;;			  | visible since t1 >= 0.0; also, t1 != 1.0
                                											  | at this point since that would imply
                                											  | trivial acceptance; force cc to indicate
                                											  | ~cry -- we use this to arrange
                                											  | below to compute and store only one
                                											  | point; brreg has a branch address to
                                											  | compute the t1 point; r[0]<-&t1
                                											  |
    93c  02 28 e 0 0 d900 0973  t1eq1_3: movw,s 0,r[0];		=t1eq1_3a->brreg;;		;			  | if t1 == 1.0, then the t0,t1 segment is
                                											  | visible since t0 <= 1.0; also, t0 != 0.0
                                											  | at this point since that would imply
                                											  | trivial acceptance; force cc to indicate
                                											  | ~cry -- we use this to arrange
                                											  | below to compute and store only one
                                											  | point; brreg has a branch address to
                                											  | compute the t0 point; r[0]<-&t0
                                											  |
                                											  | when we arrive here cc indicates whether
                                											  | we have to compute 1 or 2 pts
                                											  | cry => need to compute 2 pts
                                											  | ~cry => need to compute 1 pt
                                											  |
    93d  0a 0d e 0 0 d80f 0000  twonewpts_3: movw r[15],acc;	am->fpbp;	;		;			  | fpbp <- &x0
    93e  0a 0c e 0 0 e584 0000  	add2nw 2,acc;		am->fpap;	;		;			  | fpap <- &x1
    93f  2a 0e e 0 0 e396 0150  	mov2nw 1,y;		am->fpdp;	;		suba,lab,hi;		  | dx = x1 - x0
    940  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+	  | fpdp <- 2 -- put deltas at fpreg[2-5]
    941  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dy = y1 - y0
    942  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+
    943  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dz = z1 - z0
    944  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+
    945  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dw = w1 - w0
    946  2b 00 e 0 0 7140 0150  	;			;		;		;
    947  2a 0d e 0 0 d840 0122  	movw r[0],y;		am->fpbp;	;		adda,la,a,hi;		  | fpbp<-&t0 or &t1, as previously set up
    948  2b 00 e 0 0 7140 0122  	;			;		;		;			  | advance pipe
    949  2a 00 e 0 0 7140 001b  	;			;		;		mabr,lab,a,st,hi;	  | t? * dx; store dx
    94a  2b 00 e 0 6 7140 001b  	;			;		;		;		dp+
    94b  2a 00 e 0 0 7140 002b  	;			;		;		mabr,la,a,st,hi;	  | t? * dy; store dy
    94c  2b 00 e 0 6 7140 002b  	;			;		;		;		dp+
    94d  2a 00 e 0 0 7140 002b  	;			;		;		mabr,la,a,st,hi;	  | t? * dz; store dz
    94e  2b 00 e 0 6 7140 002b  	;			;		;		;		dp+
    94f  2a 00 e 0 0 7140 0029  	;			;		;		mabr,la,st,hi;		  | t? * dw; store dw
    950  3b 0c 3 a 9 e396 0029  	mov2nw 1,y;		am->fpap;	cjp,~cry;	;		bdp+	  | jump to compute only 1 pt; brreg
                                											  | previously set to t0eq0_3a or t1eq1_3a
                                											  | else fpap<-&dx, fpbp<-&t1,
                                											  | fpdp<-6 -- store t0*d's at fpreg[6-9]
                                											  | only reach here if computing 2 points
    951  2a 00 e 0 0 7140 0014  	;			;		;		maba,lab,m,hi;		  | t1 * dx
    952  2b 00 e 0 4 7140 0014  	;			;		;		;		ap+
    953  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | t1 * dy; store (t0 * dx)
    954  2b 00 e 0 8 7140 0025  	;			;		;		;		adp+
    955  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | t1 * dz; store (t0 * dy)
    956  2b 00 e 0 8 f8e0 0025  	movw 6,y;		;		;		;		adp+
    957  2a 0d e 0 0 0006 0025  	;			am->fpbp;	;		maba,la,m,st,hi;	  | t1 * dw; store (t0 * dz); fpbp<-&(t0*dx)
    958  2b 0c e 0 6 d84f 0025  	movw r[15],y;		am->fpap;	;		;		dp+	  | fpap<-&x0;store t1*d's at fpreg[10-13]
    959  2a 00 e 0 0 7140 0115  	;			;		;		adda,lab,m,st,hi;	  | x0' = x0 + (t0*dx); store (t0 * dw)
    95a  2b 00 e 0 a 7140 0115  	;			;		;		;		abdp+
    95b  2a 00 e 0 0 7140 0115  	;			;		;		adda,lab,m,st,hi;	  | y0' = y0 + (t0*dy); store (t1 * dx)
    95c  2b 00 e 0 a 7140 0115  	;			;		;		;		abdp+
    95d  2a 00 e 0 0 7140 0115  	;			;		;		adda,lab,m,st,hi;	  | z0' = z0 + (t0*dz); store (t1 * dy)
    95e  2b 00 e 0 a 7140 0115  	;			;		;		;		abdp+
    95f  2a 00 e 0 0 7140 0115  	;			;		;		adda,lab,m,st,hi;	  | w0' = w0 + (t0*dw); store (t1 * dz)
    960  2b 0c e 0 9 d84f 0115  	movw r[15],y;		am->fpap;	;		;		bdp+	  | fpap<-&x0; fpbp<-&(t1*dx)
    961  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | x1' = x0 + (t1*dx); store (t1 * dw)
    962  2b 0e e 0 7 d84f 0113  	movw r[15],y;		am->fpdp;	;		;		abp+	  | fpdp<-&x0
    963  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | y1' = y0 + (t1*dy); store x0'
    964  2b 00 e 0 a 7140 0113  	;			;		;		;		abdp+
    965  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | z1' = z0 + (t1*dz); store y0'
    966  2b 00 e 0 a 7140 0113  	;			;		;		;		abdp+
    967  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | w1' = w0 + (t1*dw); store z0'
    968  2b 00 e 0 6 7140 0113  	;			;		;		;		dp+
    969  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store w0'
    96a  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
                                											  | can reach here to store pt1' from above
                                											  | when computing 2 pts or from below when
                                											  | computing only pt1'; also can reach here
                                											  | from below to store pt0' when computing
                                											  | only that pt
    96b  2a 00 e 0 0 7140 0123  storept_3: ;			;		;		adda,la,a,st,hi;		  | store x1' (or x0')
    96c  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    96d  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store y1' (or y0')
    96e  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    96f  2a 00 e 0 0 7140 0123  	;			;		;		adda,la,a,st,hi;		  | store z1' (or z0')
    970  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+
    971  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store w1' (or w0')
    972  33 0c a 7 0 d84f 0101  	movw,s r[15],y;		am->fpap;	crtn,go;	;			  | return with Z bit==0 & fpap==r[15]
                                											  |
    973  0a 0e 3 7 0 d84f 0975  t1eq1_3a: movw r[15],y;		am->fpdp;	cjp,go onenewpt_3;;			  | fpdp<-&x0 so we will store x0'
                                											  |
    974  0a 0e e 0 0 f880 0000  t0eq0_3a: movw acc,y;		am->fpdp;	;		;			  | fpdp<-&x1 so we will store x1'
                                											  | arrive here to compute only 1 pt; pipe
                                											  | contains either t0*d's or t1*d's
    975  2a 0d e 0 0 d84f 0124  onenewpt_3: movw r[15],y;	am->fpbp;	;		adda,la,m,hi;		  | fpbp<-&x0; advance pipeline
    976  2b 00 e 0 0 7140 0124  	;			;		;		;
    977  2a 00 e 0 0 f8e0 011c  	movw =storept_3,y;	;		;		addr,lab,m,hi;		  | x?' = x0 + (t?*dx)
    978  2b 08 e 0 5 096b 011c  	;			am->brreg;	;		;		bp+	  | brreg<-storept_3 for subsequent branch
    979  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | y?' = y0 + (t?*dy)
    97a  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    97b  2a 00 e 0 0 7140 011c  	;			;		;		addr,lab,m,hi;		  | z?' = z0 + (t?*dz)
    97c  2b 00 e 0 5 7140 011c  	;			;		;		;		bp+
    97d  2a 00 e 0 0 7140 0118  	;			;		;		addr,lab,hi;		  | r[20]?' = w0 + (t?*dw)
    97e  2b 00 e 0 0 7140 0118  	;			;		;		;
    97f  2a 00 e 0 0 7140 0122  	;			;		;		adda,la,a,hi;		  | advance pipeline
    980  3b 00 3 7 0 7140 0122  	;			;		cjp,go;		;			  | goto storept_3
                                											  |
                                											  |
    981  2a 0c e 0 0 f900 0101  intersect3: movw 0,y;		am->fpap;	;		adda,st,hi;		  | fpreg[0] <- candidate value; fpap<-0
    982  2b 00 e 0 0 ff87 0101  	not2nw 15,acc;		;		;		;			  | acc <- 0x7FFF
    983  02 37 3 9 0 e2c1 098a  	andw,s d,acc,acc;	fpregh->am;	cjp,~neg updt1_3;;			  | update t0 or t1 based upon previously
                                											  | tested bit of r[6]; acc <- high
                                											  | order t & 0x7FFF (to convert -0.0 to
                                											  | +0.0,since t is guaranteed 0.0<=t<=1.0)
    984  0b 37 e 0 0 9603 0000  updt0_3: subw d,r[3],y;	fpregl->am;	;		;			  | compare t with t0 (t0 - t)
    985  02 00 e 0 0 9064 0000  	rsubcw,s r[4],acc,y;	;		;		;
    986  02 00 3 2 0 ffc5 0990  	bclrw,s 15,r[5];	;		cjp,cry chkthru3;;			  | no borrow means t <= t0
    987  0a 00 e 0 0 d884 0000  	movw acc,r[4];		;		;		;			  | else t0 <- t
    988  0a 00 b 0 0 d8c3 0930  	movw d,r[3];		;		cjpp,zer newpts3;;			  | r[5]==0 -> no more intersections
    989  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | else return to check next plane
    98a  0b 37 e 0 0 9641 0000  updt1_3: rsubw d,r[1],y;	fpregl->am;	;		;			  | compare t with t1 (t - t1)
    98b  02 00 e 0 0 9022 0000  	subcw,s r[2],acc,y;	;		;		;
    98c  02 00 3 2 0 ffc5 0990  	bclrw,s 15,r[5];	;		cjp,cry chkthru3;;			  | no borrow means t >= t1
    98d  0a 00 e 0 0 d882 0000  	movw acc,r[2];		;		;		;			  | else t1 <- t
    98e  0a 00 b 0 0 d8c1 0930  	movw d,r[1];		;		cjpp,zer newpts3;;			  | r[5]==0 -> no more intersections
    98f  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | else return to check next plane
    990  1a 00 a 8 0 7140 0000  chkthru3: ;			;		crtn,~zer;	;			  | r[5] != 0 -> more intersections, rtn
    991  0a 00 b 7 0 7140 0930  	;			;		cjpp,go newpts3;;			  | else pop stack and goto newpts3
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)xfpolygon3.vp.u 1.2 86/09/12 SMI
                                |	movw d,r[11];		shmem->am;	jmap CORENDCPOLY_3D;;			  | # of separate boundaries
                                CORENDCPOLY_3D:
    992  0a 27 e 0 0 d8c5 084f  	movw d,r[5];		=xfint3->am;	;		;			  | r[5] pts to 3D transform routine
                                											  | xfint3 converts from fix to float
                                											  | before calling the regular xf3 routine
    993  0a 00 3 7 0 7140 0995  	;			;		cjp,go xfpoly3D;;			  | fall into rest of polygon code
                                |	movw d,r[11];		shmem->am;	jmap XFPOLYGON_3D;;			  | # of separate boundaries
                                XFPOLYGON_3D:
    994  0a 27 e 0 0 d8c5 0860  	movw d,r[5];		=xf3->am;	;		;			  | use the regular xf3 routine
    995  0a 0f 1 7 0 d85d 02cd  xfpoly3D: movw r[29],y;	am->shmemp;	cjs,go polygon_attr_3D;;		  | option bits passed to polygon_attr_3D
    996  0a 0f c 0 0 d849 000f  	movw r[9],y;	am->shmemp;	ldct 15;	;			  | in acc -- constant:0, Gouraud:1
    997  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    998  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    999  0a 0f c 0 0 f880 0005  	movw acc,y;		am->shmemp;	ldct 5;		;
    99a  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move viewport parameters to fpr[32]
                                										|
                                										| edge structure is:
                                										| fpreg[r[14]+0]: ymin    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[r[14]+1]: ymax    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[r[14]+2]: xmax    32-bit float
                                										| fpreg[r[14]+3]: zmax    32-bit float
                                										| fpreg[r[14]+4]: imax    32-bit float
                                										| fpreg[r[14]+5]: xmin    32-bit float
                                										| fpreg[r[14]+6]: zmin    32-bit float
                                										| fpreg[r[14]+7]: imin    32-bit float
                                										| fpreg[r[14]+8]: X       don't care in high word
                                										|		   nxt     11-bit ptr in low word
                                										|
                                	| Initialization for edge table variables when the edge-building routines
                                	|  are the consuming routines for the points output by the polygon clipper
    99b  0a 27 e 0 0 d8c9 00b4  	movw d,r[9];		180->am;	;		;			  | r[9]<-180
    99c  0a 27 e 0 0 d8c8 00e6  	movw d,r[8];		230->am;	;		;			  | address of dummy 1st edge
    99d  0a 0e e 0 0 c7c8 0000  	add2nw 3,r[8],r[8]; am->fpdp;	;		;			  | fpdp<-&dummy edge r[8]
    99e  0b 0b e 0 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	;		;			  | dummy edge r[8]<-ptr to 1st real edge
    99f  0a 27 e 0 0 d8d3 0baa  	movw d,r[19];	=mkedges3->am;	;		;			  | r[19] <- mkedges3, ptr to point-
                                											  | consuming routine
                                	| Start of reading input polygon and xform-clip-vwpscale pipeline
                                procpoly3:
    9a0  08 00 e 0 1 dd7e 0000  	incw r[30],r[17];	;		;		;			  | r[17] pts to vector of npts per boundary
                                											  | (after increment below)
    9a1  0a 27 e 0 0 868b 0002  	addw d,r[11],acc;	2->am;		;		;
    9a2  0a 00 e 0 0 989e 0000  	addw r[30],acc,r[30];	;		;		;			  | r[30] now points to first vertex
    9a3  02 00 e 0 0 c1eb 0000  xf3nxtbnd: sub2nw,s 0,r[11],r[11];;		;		;			  | if ((r[11] -= 1)<0), goto xf3nxtstep
    9a4  0a 0f 3 1 0 dd71 0a96  	incw r[17],r[17];	am->shmemp;	cjp,neg xf3nxtstep;;			  | else get # of vertices for next
    9a5  0a 17 e 0 0 d8ca 0000  	movw d,r[10];		shmem->am;	;		;			  | boundary
    9a6  02 2e e 0 0 fff8 0003  	btstw,s 15,r[24]; 3->fpdp;	;		;			  | test for 2D or 3D input routine
    9a7  0a 00 3 8 0 858a 09ac  	rolw 2,r[10],acc;	;		cjp,~zer xf32nxbnd; ;			  | if 2D, acc == r[10]*4
    9a8  02 00 e 0 0 e1f8 0000  	btstw,s 0,r[24]; ;		;		;			  | set cc to reflect shading type &
    9a9  0a 00 3 8 0 e39d 09ac  	rolw 1,acc,acc;		;		cjp,~zer .+3;	;			  | fpdp <- 3 (used below); acc <- r[10]*8
    9aa  0a 00 e 0 0 800a 0000  	subw r[10],acc,acc;	;		;		;			  | if Gouraud shading, acc == r[10]*8
    9ab  0a 00 e 0 0 800a 0000  	subw r[10],acc,acc;	;		;		;			  | if constant shading, acc <- r[10]*6
    9ac  02 27 e 0 0 960a 0003  xf32nxbnd: subw,s d,r[10],y;	3->am;		;		;			  | if 0 <= r[10] < 3, not a good boundary
    9ad  08 0f e 0 0 d97e 0000  	movw r[30],r[16];	am->shmemp;	;		;			  | shmemp pts to vertices;update r[30] to
    9ae  0a 00 3 a 0 989e 09a3  	addw r[30],acc,r[30];	;		cjp,~cry xf3nxtbnd;;			  | point to 1st loc after bndry's vertices
    9af  02 27 e 0 0 960a 001a  	subw,s d,r[10],y;	26->am;	;		;			  | if (r[10]>=26),goto xf3lrgpoly
    9b0  08 08 3 9 0 c1ea 0aa0  	sub2nw 0,r[10],r[0];	am->brreg;	cjp,~neg xf3lrgpoly;;			  | brreg <- r[10]-1; r[16] has shmem addr
                                											  | of 1st vertex of this boundary -- this
                                											  | is used if we jump to xf3lrgpoly
                                xf3smlpoly:
    9b1  0a 27 e 0 0 d8ce 077b  	movw d,r[14];		1915->am;	;		;			  | r[14] <- address for transformed pts
    9b2  0a 2c e 0 0 d8e0 0010  	movw 1889,r[0];	16->fpap;	;		;			  | fpap <- address of matrix; r[0] <- addr
    9b3  0a 2b e 0 0 0761 3f80  	;			0x3f80->fpregh;	;		;			  | to temporarily hold vertex intensities
    9b4  03 2b e 0 0 fff8 0000  	btstw,s 15,r[24]; 0->fpregl ;	;		;			  | test for 2D or 3D input routine
    9b5  02 00 3 8 0 e1f8 0a8b  	btstw,s 0,r[24]; ;		cjp,~zer xf32smlp; ;			  | fpr[3] <- 1.0 (fpdp was set above)
                                											  | set cc to reflect constant or Gouraud
                                											  | shading (xf3 doesn't affect cc's)
    9b6  1a 08 4 7 0 d845 0000  	movw r[5],y;		am->brreg;	push,go;	;			  | brreg <- addr of transform routine
                                											  | now loop through r[10] pts & xform them
    9b7  0a 0e e 0 0 d90f 0000  	movw 0,r[15];		am->fpdp;	;		;			  | put untransformed pt at fpr[0]
    9b8  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[0] <- x[i]
    9b9  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+
    9ba  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[1] <- y[i]
    9bb  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+
    9bc  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[2] <- z[i]
    9bd  1b 1b 1 7 2 7140 0000  	;			shmem->fpregl;	cjs,go;		;		shp+	  | transform pt and deposit in pt buffer
    9be  0a 0c 3 8 0 e996 09c1  	mov2nw 4,y;		am->fpap;	cjp,~zer .+3;	;			  | reload matrix ptr; if constant shading,
    9bf  1a 27 8 0 0 9e8e 0005  	addw d,r[14],r[14];	5->am;		rfct;		;			  | increment r[14] and loop
    9c0  02 00 3 7 0 d84c 09cf  	movw,s r[12],y;	;		cjp,go xf3smlclp;;			  | if constant shading, goto xf3smlclp
                                											  | when loop is complete
                                											  | also set cc to reflect clipping state
    9c1  0a 0e e 0 0 dd60 0000  	incw r[0],r[0];		am->fpdp;	;		;			  | if Gouraud shading, fpdp<-1890 loc for
    9c2  0a 17 e 0 2 9c8e 0000  	addw r[14],5,r[14];	shmem->am;	;		;		shp+	  | ith vertex intensity; convert int[i]
    9c3  0b 1b e 0 2 0005 0000  	;			shmem->fpregl;	;		;		shp+	  | fixed point representation from unsigned
    9c4  1a 0b 8 0 0 ef95 0000  	sub2nw 7,d,y;		am->fpregh;	rfct;		;			  | (8-bit integer, 16-bit fraction) to
                                											  | signed (7-bit integer, 16-bit fraction)
                                											  | by subtracting 2^^7 from integer since
                                											  | Weitek float and fix ops only handle
                                											  | 24-bit twos-complement integers
                                											  | r[14] += 5, and loop
    9c5  2b 08 e 0 0 e396 0230  	mov2nw 1,y;		am->brreg;	;		lmode rn,ai,pipe,fast;	  | brreg <- 2; set Weitek pipeline mode
    9c6  0a 2c e 0 0 7140 0762  	;			1890->fpap;	;		;			  | fpap <- addr of vertex intensities
    9c7  2a 00 e 0 0 d8f0 00a0  	movw 1919,r[16];	;		;		floata,la,hi;		  | convert intensities to float
    9c8  3b 0e 4 7 4 077f 00a0  	;			am->fpdp;	push,go;	;		ap+	  | fpdp<-1915+4,addr for 1st cnvrtd intns
    9c9  2a 00 e 0 0 f8e1 00a0  	movw 5,acc;		;		;		floata,la,hi;		  | repeat these 2 instructions 3 times
    9ca  3b 00 8 0 4 0005 00a0  	;			;		rfct;		;		ap+	  | acc <- 5
    9cb  28 08 e 0 0 c1ea 00a2  	sub2nw 0,r[10],r[0];	am->brreg;	;		floata,la,a,hi;		  | brreg <- r[10]-1
    9cc  3b 00 4 7 4 7140 00a2  	;			;		push,go;	;		ap+	  | pipe full,enable unload of 1st intensity
    9cd  22 00 e 0 0 d84c 00a3  	movw,s r[12],y;	;		;		floata,la,a,st,hi;	  | store int[i], start converting int[i+5]
    9ce  3b 0e 8 0 4 9890 00a3  	addw r[16],acc,r[16];	am->fpdp;	rfct;		;		ap+	  | fpdp+=5;set cc to reflect clipping state
    9cf  0a 0e 3 0 0 f900 09f3  xf3smlclp: movw 0,y;		am->fpdp;	cjp,zer fastpoly3;;			  | if clipping disabled, goto fastpoly3
    9d0  0a 2c e 0 0 9ccc 077b  	andw r[12],0x3F,r[12]; 1915->fpap;;	;			  | else do a fast clip test; fpdp <- 0
    9d1  0a 2d e 0 0 003f 077e  	;			1918->fpbp;	;		;			  | fpap<-&x0;fpbp<-&w0;r[12] format:
                                											  | L|R|B|T|H|Y is bits 5|4|3|2|1|0 with
                                											  | leading zeroes where a "1" means clip
                                											  | against the plane
                                											  | Note that lmode is still rn,ai,pipe,fast
                                											  | either from xf3 or from float cnvrt loop
    9d2  28 00 e 0 2 d96c 0110  	movw r[12],r[2];;		;		adda,lab,hi;		  | left plane: w0 + x0; test sign below
    9d3  29 00 e 0 1 db6c 0110  	compw r[12],r[1];;		;		;			  | r[2] <- r[12]
                                											  | r[1] <- ~r[12]
    9d4  2a 0b e 0 0 f900 01a0  	movw 0,y;		am->fpregh;	;		rsuba,la,hi;		  | right plane: w0 - x0; test sign below
    9d5  2b 0b e 0 4 f900 01a0  	movw 0,y;		am->fpregl;	;		;		ap+	  | fpr[0] <- 0.0
    9d6  28 08 e 0 0 c1ea 0120  	sub2nw 0,r[10],r[0];	am->brreg;	;		adda,la,hi;		  | bottom plane: w0 + y0; test sign below
    9d7  2b 00 e 0 0 d8e0 0120  	movw 1918,r[0];	;		;		;			  | r[0] <- &w0 (1915+3); brreg <- r[10]-1
    9d8  2a 00 e 0 0 077e 01a0  	;			;		;		rsuba,la,hi;		  | top plane: w0 - y0; test sign below
    9d9  3b 0d 4 7 4 f900 01a0  	movw 0,y;		am->fpbp;	push,go;	;		ap+	  | fpbp pts to 0.0
                                											  | loop through r[10] pts (brreg set above)
    9da  2a 00 e 0 0 f901 0112  plyclptst3: movw 0,acc;		;		;		adda,lab,a,hi;		  | hither plane: 0.0 + z[i];test sign below
    9db  2b 0d e 0 0 d840 0112  	movw r[0],y;		am->fpbp;	;		;			  | zero acc; fpbp <- &r[20][i]
    9dc  2a 00 e 0 0 c5c0 0192  	add2nw 2,r[0];		;		;		rsuba,lab,a,hi;		  | yon plane: r[20][i] - z[i]; test sign below
    9dd  2b 31 e 0 4 6e00 0192  	sl0b d,y;		fpstreg->am;	;		;		ap+	  | r[0] += 4; save sign bit of r[20][i]+x[i]
    9de  2a 00 e 0 4 ec41 0122  	slqw acc,acc;		;		;		adda,la,a,hi;	ap+	  | advance pipeline
    9df  2b 0d e 0 4 dd60 0122  	incw r[0],r[0];		am->fpbp;	;		;		ap+	  | fpap <- &x[i+1]; fpbp <- r[0] <- &r[20][i+1]
    9e0  2a 31 e 0 0 6e00 0112  	sl0b d,y;		fpstreg->am;	;		adda,lab,a,hi;		  | r[20][i+1]+x[i+1];save sign bit of r[20][i]-x[i]
    9e1  2b 00 e 0 0 ec41 0112  	slqw acc,acc;		;		;		;
    9e2  2a 31 e 0 0 6e00 01a2  	sl0b d,y;		fpstreg->am;	;		rsuba,la,a,hi;		  | r[20][i+1]-x[i+1];save sign bit of r[20][i]+y[i]
    9e3  2b 00 e 0 4 ec41 01a2  	slqw acc,acc;		;		;		;		ap+
    9e4  2a 31 e 0 0 6e00 0122  	sl0b d,y;		fpstreg->am;	;		adda,la,a,hi;		  | r[20][i+1]+y[i+1];save sign bit of r[20][i]-y[i]
    9e5  2b 00 e 0 0 ec41 0122  	slqw acc,acc;		;		;		;
    9e6  2a 31 e 0 0 6e00 01a0  	sl0b d,y;		fpstreg->am;	;		rsuba,la,hi;		  | r[20][i+1]-y[i+1];save sign bit of 0.0+z[i]
    9e7  2b 00 e 0 4 ec41 01a0  	slqw acc,acc;		;		;		;		ap+
    9e8  0a 31 e 0 0 6e00 0000  	sl0b d,y;		fpstreg->am;	;		;			  | save sign bit of r[20][i]-z[i]
    9e9  0a 2d e 0 0 ec41 0000  	slqw acc,acc;		0->fpbp;	;		;			  | fpbp pts to 0.0
    9ea  0a 00 e 0 0 9941 0000  	orw r[1],acc,r[1];;		;		;			  | accumulate r[1]
    9eb  1a 00 8 0 0 98c2 0000  	andw r[2],acc,r[2];;	rfct;		;			  | accumulate r[2] & loop until done
    9ec  0a 00 e 0 0 d802 0000  	movw r[2],acc;	;		;		;			  | acc <- r[2]
    9ed  02 00 e 0 0 910c 0000  	xorw,s r[12],acc,y;;		;		;			  | if (r[2] == r[12]), then
                                											  | all pts are inside the clip region,
    9ee  02 00 3 0 0 da01 09f3  	compw,s r[1],acc;	;		cjp,zer fastpoly3;;			  | so goto fastpoly3
    9ef  0a 28 e 0 0 d8e3 0aca  	movw 1915,r[3];	=clppoly3->brreg;;		;			  | if (~r[1] != 0), all pts were
    9f0  0a 00 3 8 0 077b 09a3  	;			;		cjp,~zer xf3nxtbnd;;			  | outside at least 1 clipping plane so
    9f1  1a 27 1 7 0 d8d2 0a98  	movw d,r[18];	=nxtxfpt3->am;	cjs,go;		;			  | goto xf3nxtbnd; else call clppoly3 with
                                											  | r[3] pointing to 1st transformed
    9f2  0a 00 3 7 0 7140 09a3  	;			;		cjp,go xf3nxtbnd;;			  | point and r[18] pointing to the
                                											  | subroutine nxtxfpt3
                                											  | after return, goto xf3nxtbnd
    9f3  02 27 e 0 0 9713 0baa  fastpoly3: xorw,s d,r[19],y; =mkedges3->am;;		;			  | if r[19] != mkedges3, goto
    9f4  0a 00 3 8 0 7140 0bf5  	;			;		cjp,~zer procfastbnd3;;			  | procfastbnd3; else fall through to
                                											  | the code below which is an accelerator
                                											  | for the case of small polygons which
                                											  | do not require clipping, when the edge-
                                											  | building routines are output routines
                                vwpsmlpoly3:
    9f5  0a 27 e 0 0 d8c4 077b  	movw d,r[4];	1915->am;	;		;			  | r[4]<-1915(address of xformed pts)
    9f6  08 08 1 7 0 c1ea 0b69  	sub2nw 0,r[10],r[0];	am->brreg;	cjs,go vwpsclpts3;;			  | vwpsclpts3 assumes vwp params at fpr[32]
                                											  | scale r[10] pts to the viewport
                                											  | scaling is done in-place
                                											  | pass r[10]-1 in brreg
                                xf3smledgs:
    9f7  2a 0c e 0 0 dc44 0230  	incw r[4],y;	am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap <- 1915 + 1; use flowthrough mode
    9f8  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | y[0]
    9f9  2b 00 e 0 0 7140 00e0  	;			;		;		;
    9fa  0a 00 e 0 0 7140 0000  	;			;		;		;
    9fb  08 08 e 0 0 c3ea 0000  	sub2nw 1,r[10],r[0];	am->brreg;	;		;			  | brreg <- r[10]-2
    9fc  0a 27 e 0 0 d8c3 077b  	movw d,r[3];	1915->am;	;		;			  | r[3] <- 1915
    9fd  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			  | d<-5; wait for fixed y[0]
    9fe  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    9ff  2b 0e e 0 0 f900 0102  	movw 0,y;		am->fpdp;	;		;
    a00  2a 0c e 0 0 f900 0101  	movw 0,y;		am->fpap;	;		adda,st,hi;		  | fpreg[0] <- y[0] (integer)
    a01  2b 00 e 0 0 9e83 0101  	addw d,r[3],r[3];;		;		;			  | r[3] <- &x[1]
    a02  0b 37 e 0 0 d8c4 0000  	movw d,r[4];		fpregl->am;	;		;			  | r[4] <- low word of integer y[0]
    a03  1a 27 4 7 0 d804 0005  	movw r[4],acc;	5->am;		push,go;	;			  | acc<-y[0]; d<-5; start loop to build 1st
                                xf3smledgloop:										  | n-1 edges;notation: i runs from 1 to n-1
    a04  0a 0c e 0 0 dc43 0000  	incw r[3],y;	am->fpap;	;		;			  | fpap <- &y[i]
    a05  28 0e e 0 0 c3c8 00e0  	add2nw 1,r[8],r[0];	am->fpdp;	;		fixa,la,hi;		  | fix y[i]; fpdp <- &edg.xmax
    a06  2b 0c e 0 0 d843 00e0  	movw r[3],y;	am->fpap;	;		;			  | fpap <- &x[i]
    a07  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- x[i]
    a08  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a09  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a0a  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.zmax <- z[i]
    a0b  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a0c  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a0d  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.imax <- intensity[i]
    a0e  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    a0f  0a 0c e 0 0 9603 0000  	subw d,r[3],y;	am->fpap;	;		;			  | fpap <- &x[i-1]
    a10  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmin <- x[i-1]
    a11  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a12  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a13  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.zmin <- z[i-1]
    a14  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a15  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a16  08 3b e 0 0 d968 0000  	movw r[8],r[0];	fpregh->fpregh;	;		;			  | edg.imin <- intensity[i-1]; r[0]<-r[8]
    a17  0b 3b e 0 6 c7c8 0000  	add2nw 3,r[8],r[8];	fpregl->fpregl;	;		;		dp+	  | r[8] += 8
    a18  0b 0b e 0 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	;		;			  | edg.nxt <- r[8] <- addr of next edge
    a19  0a 0e e 0 0 d840 0000  	movw r[0],y;		am->fpdp;	;		;			  | fpdp <- address of this edge
    a1a  2a 0b e 0 6 f880 0102  	movw acc,y;		am->fpregh;	;		adda,a,hi;	dp+	  | edg.ymin <- y[i-1] (16-bit integer)
    a1b  2b 00 e 0 0 9e83 0102  	addw d,r[3],r[3];;		;		;			  | r[3] <- &x[i+1]
    a1c  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | edg.ymax <- y[i] (32-bit integer)
    a1d  2b 0c e 0 0 dc40 0101  	incw r[0],y;		am->fpap;	;		;			  | fpap <- &edg.ymax
    a1e  03 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregl->am;	;		;			  | check for horizontal edges
    a1f  0b 37 3 0 0 f8c1 0a25  	movw d,acc;		fpregl->am;	cjp,zer xf3horizedg;;			  | acc <- low order 16 bits of int y[i]
    a20  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | r[9] -= 1
    a21  0a 0b 3 1 0 f880 0a24  	movw acc,y;		am->fpregh;	cjp,neg xf3edgovflw;;			  | move low 16 bits to high 16 bits where
                                											  | scan conversion code expects to see it
                                											  | also handle case of too many edges
    a22  1a 27 8 0 0 7140 0005  	;			5->am;		rfct;		;			  | d <- 5; loop back until last edge
    a23  0a 00 3 7 0 7140 0a26  	;			;		cjp,go xf3lastedg;;
                                xf3edgovflw:
    a24  0a 00 e 0 0 db09 0000  	compw 0,r[9];		;		;		;			  | r[9] <- -1 and adjust r[8]
                                xf3horizedg:
    a25  18 27 8 0 8 d960 0005  	movw r[0],r[8];	5->am;		rfct;		;			  | ignore horizontal and overflow edges
                                											  | r[8] -= 9
                                											  | d<-5; loop back until last edge
                                xf3lastedg:
    a26  02 2c e 0 0 9104 077b  	xorw,s r[4],acc,y;	1915->fpap;	;		;			  | ignore horizontal last edge; fpap<-&x[0]
    a27  0a 0e 3 0 0 d848 09a3  	movw r[8],y;		am->fpdp;	cjp,zer xf3nxtbnd;;			  | fpdp <- address of nth edge
    a28  0a 0b e 0 6 f880 0000  	movw acc,y;		am->fpregh;	;		;		dp+	  | edg.ymin <- y[n-1]
    a29  0a 0b e 0 6 d844 0000  	movw r[4],y;		am->fpregh;	;		;		dp+	  | edg.ymax <- y[0]
    a2a  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- x[0]
    a2b  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a2c  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a2d  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.zmax <- z[0]
    a2e  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a2f  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a30  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.imax <- intensity[0]
    a31  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    a32  0a 0c e 0 0 9603 0000  	subw d,r[3],y;	 am->fpap;	;		;			  | fpap <- &x[n-1]
    a33  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmin <- x[n-1]
    a34  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a35  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a36  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.zmin <- z[n-1]
    a37  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    a38  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    a39  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.imin <- intensity[n-1]
    a3a  0b 3b e 0 6 c7c8 0000  	add2nw 3,r[8],r[8];	fpregl->fpregl;	;		;		dp+	  | r[8] += 8
    a3b  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | r[9] -= 1
    a3c  0b 0b 3 9 0 dd68 09a3  	incw r[8],r[8];	am->fpregl;	cjp,~neg xf3nxtbnd;;			  | edg.nxt <- r[8] <- addr of next edge
    a3d  0a 27 e 0 0 9e08 0009  	subw d,r[8],r[8];	9->am;		;		;			  | goto xf3nxtbnd; if (r[9] < 0),
    a3e  0a 00 3 7 0 db09 09a3  	compw 0,r[9];		;		cjp,go xf3nxtbnd;;			  | r[9] <- -1 and adjust r[8]
                                											  | completion code for r[19]==mkedges3
                                											  | code from jump vector to get here:
                                |	sub2nw 0,r[8],r[8];	am->fpdp;	cjp,go xf3doscan;;			  | fpdp <- &edg.nxt for last edge
                                xf3doscan: 
    a3f  02 00 e 0 0 f3f8 0000  	btstw,s 9, r[24]; ;		;		;			| 
    a40  02 00 3 8 0 f5f8 0a42  	btstw,s 10, r[24]; ;		cjp, ~zer .+2;	;			| 
    a41  0a 00 3 0 0 7140 0a83  	;			;		cjp, zer xf3polyscan; ;			| Go scan if no texturing.
    a42  0a 2f e 0 0 7140 01ff  	;			511->shmemp; ;	;			| What texture is in PP?
    a43  0a 17 e 0 0 d8c0 0000  	movw d, r[0];		shmem->am;	;		;			| 
    a44  0a 27 e 0 0 869d 000a  	addw d, r[29], acc;	10->am; ;		;			| Compare PP texture block ptr with our own.
    a45  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    a46  02 17 e 0 0 f8c0 0000  	movw,s d, y;		shmem->am;	;		;			| Check for invalid tex block (-1)
    a47  02 17 3 9 0 9600 0a4a  	subw,s d, r[0], y;	shmem->am;	cjp, ~neg xf3tex; ;			| Compare tex pointers.
    a48  0a 27 e 0 0 9ed8 f9ff  	andw d, r[24], r[24]; 0xf9ff->am; ;	;			| mask out bits 9 and 10. (comp 0x600)
    a49  0a 00 3 7 0 7140 0a83  	;			;		cjp, go xf3polyscan; ;			| 
    a4a  0a 00 3 0 0 7140 0a5b  xf3tex:	;			;		cjp, zer xf3texoff; ;			| 
    a4b  0a 27 e 0 0 869d 0007  	addw d, r[29], acc;	7->am; ;		;			| if (reload pp) shmemp = 7
    a4c  1a 0f 4 f 0 f880 0000  	movw acc, y;		am->shmemp;	push, ~go;	;			| 
    a4d  1a 26 d 4 0 7140 001b  	;			 27->fifo1;	loop, f1nf;	;			| 
    a4e  08 00 1 7 0 d96d 0320  	movw r[13], r[0];	;		cjs, go stprep;	;			| Save r[13].  stprep incr shmemp.
    a4f  0a 06 3 c 0 d84e 0a4f  	movw r[14], y;		am->fifo1;	cjp, f1f .;	;			| 
    a50  0a 17 e 0 0 d8c1 0000  	movw d, r[1];		shmem->am;	;		;			| TEX2FRAME (stprep incr shmemp)
    a51  0a 2f e 0 0 7140 01ff  	;			511->shmemp; ;	;			| 
    a52  0a 06 3 c 0 d84d 0a52  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    a53  0a 0a e 0 0 d841 0000  	movw r[1], y;		am->shmem;	;		;			| Remember what frame is on PP.
    a54  08 00 e 0 d d960 0000  	movw r[0], r[13];	;		;		;			| Restore r[13].
    a55  0a 06 3 c 0 d84f 0a55  	movw r[15], y;		am->fifo1;	cjp, f1f .;	;			| 
    a56  0a 0f e 0 0 d841 0000  	movw r[1], y;		am->shmemp;	;		;			| Address texture frame.
    a57  12 00 4 7 0 c1eb 0000  xf3ltex: sub2nw,s 0, r[11], r[11]; ;		push, go;	;			| Copy texture to PP.
    a58  0a 16 3 c 0 7140 0a58  	;			shmem->fifo1;	cjp, f1f .;	;			| 
    a59  1a 00 8 0 2 7140 0000  	;			;		rfct;		;		shp+	| 
    a5a  0a 08 3 8 0 d84c 0a57  	movw r[12], y;		am->brreg;	cjp, ~zer xf3ltex; ;			| Copy next row of texture.
    a5b  0a 27 e 0 0 869d 0018  xf3texoff: addw d, r[29], acc; 24->am; ;	;			| 
    a5c  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    a5d  02 17 e 0 0 f8c1 0000  	movw,s d, acc;		shmem->am;	;		;			| if (Kind == 0)
    a5e  0a 00 3 0 0 7140 0a7f  	;			;		cjp, zer xf3sxsy; ;			| else (Kind ==  2) Addr of xform subr.
    a5f  0a 2e e 0 0 7140 0003  	;			3->fpdp;	;		;			| 
    a60  0a 2b e 0 0 7140 3f80  	;			0x3f80->fpregh;	;		;			| 4th coord of pt is 1.0 (homog.)
    a61  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
    a62  0a 0e e 0 0 d90f 0000  	movw 0, r[15];		am->fpdp;	;		;			| 
    a63  0a 2c e 0 0 7140 0010  	;			16->fpap;	;		;			| Address of matrix for transform.
    a64  0a 27 e 0 0 869d 0012  	addw d, r[29], acc;	18->am; ;		;			| 
    a65  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| 
    a66  0a 1b e 0 2 c58e 0000  	mov2nw 2, r[14];	shmem->fpregh;	;		;		shp+	| store 3 coords at 0 (r[15]). r[14]= 4.
    a67  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+| 
    a68  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	| 
    a69  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+| 
    a6a  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	| 
    a6b  0b 1b 1 7 0 7140 0860  	;			shmem->fpregl;	cjs, go xf3;	;			| Transform point.
    a6c  0a 28 e 0 0 c584 0000  	mov2nw 2, r[4];	0->brreg;	;		;			| Pt. Addr->r[4], num vertices->brreg.
    a6d  0a 00 1 7 0 7140 0b69  	;			;		cjs, go vwpsclpts3; ;			| Do in-place viewport scale.
    a6e  2b 0c e 0 0 e596 0230  	mov2nw 2, y;		am->fpap;	;		lmode rn, ai, pipe, fast; | 
    a6f  2a 0e e 0 0 f900 00e0  	movw 0, y;		am->fpdp;	;		fixa, la, hi;		| Fix r[21] and r[22]. Ignore z coordinate.
    a70  2b 00 e 0 4 7140 00e0  	;			;		;		;		ap+	| 
    a71  2a 00 e 0 0 7140 00e0  	;			;		;		fixa, la, hi;		| 
    a72  2b 00 e 0 0 7140 00e0  	;			;		;		;			| 
    a73  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    a74  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    a75  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    a76  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    a77  2a 00 e 0 0 7140 0122  	;			;		;		adda,la, a, hi;		| 
    a78  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    a79  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 
    a7a  2b 00 e 0 6 f8e0 0123  	movw =xf3polyscan, y;	;		;		;		dp+	| 
    a7b  2a 08 e 0 0 0a83 0121  	;			am->brreg;	;		adda,la, st, hi;		| 
    a7c  2b 0c e 0 0 f900 0121  	movw 0, y;		am->fpap;	;		;			| 
    a7d  0b 37 e 0 4 d8d5 0000  	movw d, r[21];		fpregl->am;	;		;		ap+	| 
    a7e  1b 37 3 7 0 d8d6 0000  	movw d, r[22];		fpregl->am;	cjp, go;	;			| goto xf3polyscan.
    a7f  0a 27 e 0 0 869d 000c  xf3sxsy: addw d, r[29], acc;	 12->am; ;		;			| 
    a80  0a 0f e 0 0 f880 0000  	movw acc, y;		am->shmemp;	;		;			| retrieve r[21] and r[22].
    a81  0a 17 e 0 2 d8d5 0000  	movw d, r[21];		shmem->am;	;		;		shp+	| 
    a82  0a 17 e 0 0 d8d6 0000  	movw d, r[22];		shmem->am;	;		;			| 
    a83  0a 0e e 0 0 d848 0000  xf3polyscan: movw r[8], y;	am->fpdp;	;		;			| Reload dp.
    a84  03 2b e 0 0 d849 0000  	movw,s r[9],y;	0->fpregl;	;		;			  | load NULL r[8] for last edge
    a85  0a 00 3 1 0 9c09 0a8a  	subw,s r[9],180,r[9];;		cjp,neg xf3noscan;;			  | if # of edges > 180, goto xf3noscan
    a86  02 00 e 0 0 00b4 0000  	;			;		;		;			  | compute real # of edges
    a87  0a 27 e 0 0 d8ce 00e6  	movw d,r[14];		230->am;	;		;			  | if # of edges != 0, call polyscan3 with
    a88  08 00 e 0 f d96d 0000  	movw r[13],r[15];;		;		;			  | r[14], r[15], and r[16]
    a89  08 00 1 8 0 d978 0dcb  	movw r[24],r[16];;	cjs,~zer polyscan3;;
    a8a  0a 00 2 0 0 7140 0027  xf3noscan: ;			;		jmap getcmd;	;
    a8b  1a 08 4 7 0 d845 0000  xf32smlp: movw r[5],y;	am->brreg;	push,go;	;			  | brreg <- addr of transform routine
                                											  | now loop through r[10] pts & xform them
    a8c  0a 0e e 0 0 d90f 0000  	movw 0,r[15];		am->fpdp;	;		;			  | put untransformed pt at fpr[0]
    a8d  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[0] <- x[i]
    a8e  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+
    a8f  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpr[1] <- y[i]
    a90  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+  | 
    a91  0a 2b e 0 0 7140 0000  	;			0->fpregh;	;		;			  | fpr[2] <- z==0
    a92  1b 2b 1 7 0 7140 0000  	;			0->fpregl;	cjs,go;		;			  | transform pt and deposit in pt buffer
    a93  0a 0c e 0 0 e996 0000  	mov2nw 4,y;		am->fpap;	;		;			  | reload matrix ptr for constant shading
    a94  1a 27 8 0 0 9e8e 0005  	addw d,r[14],r[14];	5->am;		rfct;		;			  | increment r[14] and loop
    a95  02 00 3 7 0 d84c 09cf  	movw,s r[12],y;	;		cjp,go xf3smlclp;;			  | if constant shading, goto xf3smlclp
                                xf3nxtstep:
    a96  08 08 e 0 0 c1f3 0000  	sub2nw 0,r[19],r[16]; am->brreg;	;		;			  | next step after xform-clp-consumepts is
    a97  1a 00 3 7 0 7140 0000  	;			;		cjp,go;		;			  | determined from jump vector at
                                											  | r[19]-1
    a98  0a 0e e 0 0 d847 0000  nxtxfpt3: movw r[7],y;	am->fpdp;	;		;			  | fpdp <- address for next pt to clip
    a99  0a 0c e 0 0 d843 0000  	movw r[3],y;		am->fpap;	;		;			  | fpap <- address of next transformed pt
    a9a  02 3b e 0 0 c1ea 0000  	sub2nw,s 0,r[10],r[10];	fpregh->fpregh;	;		;			  | transfer x; r[10]-=1, set cc to
                                											  | reflect result (neg means no more pts)
    a9b  1b 3b a 1 8 7140 0000  	;			fpregl->fpregl;	crtn,neg;	;		adp+	  | return if no more pts
    a9c  0a 3b 4 7 0 7140 0002  	;			fpregh->fpregh;	push,go 2;	;			  | transfer y
    a9d  0b 3b e 0 8 f8e1 0000  	movw 5,acc;		fpregl->fpregl;	;		;		adp+
    a9e  1a 3b 8 0 0 0005 0000  	;			fpregh->fpregh;	rfct;		;			  | transfer z, r[20], and intensity
    a9f  1b 3b a 7 0 9883 0000  	addw r[3],acc,r[3]; fpregl->fpregl; crtn,go;	;			  | r[3] += 5; return (cc is ~neg)
                                xf3lrgpoly:
    aa0  02 00 e 0 0 fff8 0000  	btstw,s 15,r[24]; ;		;		;			  | test 2D or 3D input routine
    aa1  0a 00 3 8 0 d810 0aa6  	movw r[16],acc;		;		cjp,~zer xf32l;	;			  | if 2D assume constant shading
    aa2  02 2e e 0 0 e1f8 077e  	btstw,s 0,r[24]; 1918->fpdp; ;		;			  | test constant or Gouraud shading
    aa3  0a 00 3 0 0 7140 0aa8  	;			;		cjp,zer xf3lc;	;			  | 
                                											  | Gouraud shading
    aa4  0a 27 e 0 0 d8d2 0abc  xf3lg:	movw d,r[18];	=nxtcmdpt3g->am;;		;			  | r[18] points to subroutine nxtcmdpt3g
    aa5  0a 00 3 7 0 d883 0aa9  	movw acc,r[3];	;		cjp,go xf3l;	;			  | r[3] <- shmem addr of boundary pts
    aa6  0a 27 e 0 0 d8d2 0ab3  xf32l:	movw d,r[18];	=nxtcmdpt23->am; ;		;			  | 2D input routine
    aa7  0a 00 3 7 0 7140 0aa9  	;			;		cjp,go xf3l;	;			  | r[18] points to subroutine nxtcmdpt23
                                											  | constant shading
    aa8  0a 27 e 0 0 d8d2 0aac  xf3lc:	movw d,r[18];	=nxtcmdpt3c->am;;		;			  | r[18] points to subroutine nxtcmdpt3c
    aa9  0a 2b e 0 0 7140 3f80  xf3l:	;			0x3F80->fpregh;	;		;			  | fpreg[1915+3]<-1.0(used by nxtcmdpt3's)
    aaa  0b 0b 1 7 0 f900 0aca  	movw 0,y;		am->fpregl;	cjs,go clppoly3;;			  | call clppoly3
    aab  0a 00 3 7 0 7140 09a3  	;			;		cjp,go xf3nxtbnd;;			  | loop back to xf3nxtbnd
    aac  02 2c e 0 0 c1ea 0010  nxtcmdpt3c: sub2nw,s 0,r[10],r[10]; 16->fpap;	;		;			  | fpap pts to matrix; r[10] -= 1, cc
    aad  18 2e a 1 e d967 077b  	movw r[7],r[14];	1915->fpdp;	crtn,neg;	;			  | reflects result; return if no more pts
                                											  | else fpdp<-1915 (addr for new pt)
    aae  0a 08 e 0 0 d845 0000  	movw r[5],y;		am->brreg;	;		;			  | brreg pts to appropriate xform routine
    aaf  0a 1b 4 7 2 7140 0001  	;			shmem->fpregh;	push,go 1;	;		shp+	  | fpreg[1915] <- next x; r[14] <- addr
    ab0  0b 1b e 0 c d8ef 0000  	movw 1915,r[15];	shmem->fpregl;	;		;		shp+,dp+  | for xformed pt; transfer y and z
    ab1  1a 1b 8 0 2 077b 0000  	;			shmem->fpregh;	rfct;		;		shp+	  | transfer y and z; r[15] <- 1915
    ab2  1b 1b 3 7 2 7140 0000  	;			shmem->fpregl;	cjp,go;		;		shp+	  | jump to xform routine which returns to
                                											  | caller after xfrming pt & putting result
                                											  | at *r[7] (fpreg[1915+3] == 1.0)
                                											  | shmemp now pts to next pt
    ab3  02 2c e 0 0 c1ea 0010  nxtcmdpt23: sub2nw,s 0,r[10],r[10]; 16->fpap;	;		;			  | fpap pts to matrix; r[10] -= 1, cc
    ab4  18 2e a 1 e d967 077b  	movw r[7],r[14];	1915->fpdp;	crtn,neg;	;			  | reflects result; return if no more pts
                                											  | else fpdp<-1915 (addr for new pt)
    ab5  0a 08 e 0 0 d845 0000  	movw r[5],y;		am->brreg;	;		;			  | brreg pts to appropriate xform routine
    ab6  0a 1b e 0 2 7140 0000  	;			shmem->fpregh;	;		;		shp+	  | fpreg[1915] <- next x; r[14] <- addr
    ab7  0b 1b e 0 c d8ef 0000  	movw 1915,r[15];	shmem->fpregl;	;		;		shp+,dp+  | for xformed pt; transfer y
    ab8  0a 1b e 0 2 077b 0000  	;			shmem->fpregh;	;		;		shp+	  | transfer y; r[15] <- 1915
    ab9  0b 1b e 0 c 7140 0000  	;			shmem->fpregl;	;		;		shp+,dp+  |
    aba  0a 2b e 0 0 7140 0000  	;			0->fpregh;	;		;			  | z == 0
    abb  1b 2b 3 7 0 7140 0000  	;			0->fpregl;	cjp,go;		;			  | jump to xform routine which returns to
                                											  | caller after xfrming pt & putting result
                                											  | at *r[7] (fpreg[1915+3] == 1.0)
                                											  | shmemp now pts to next pt
    abc  02 2e e 0 0 c1ea 077b  nxtcmdpt3g: sub2nw,s 0,r[10],r[10]; 1915->fpdp;;		;			  | fpdp<-1915(addr for new pt);r[10] -= 1,
    abd  18 2c a 1 0 c5c3 077b  	add2nw 2,r[3],r[0];	1915->fpap;	crtn,neg;	;			  | cc reflects result;return if no more pts
    abe  0a 0f e 0 0 c3c0 0000  	add2nw 1,r[0],r[0];	am->shmemp;	;		;			  | fpap<-1915;shmemp <- r[0] <- shmem addr
    abf  0a 17 e 0 2 7140 0000  	;			shmem->am;	;		;		shp+	  | of vertex intensity; convert intensity
    ac0  2a 0b e 0 0 ef95 0230  	sub2nw 7,d,y;		am->fpregh;	;		lmode rn,ai,flow,fast;	  | fixed point representation from unsigned
    ac1  0b 1b c 0 0 7140 0002  	;			shmem->fpregl;	ldct 2;		;			  | (8-bit integer, 16-bit fraction) to
                                											  | signed (7-bit integer, 16-bit fraction)
                                											  | by subtracting 2^^7 from integer since
                                											  | Weitek float and fix ops only handle
                                											  | 24-bit twos-complement integers
                                											  | flow mode; 2910 R reg<-2
    ac2  2a 0f e 0 0 d843 00a0  	movw r[3],y;	am->shmemp;	;		floata,la,hi;		  | convert intensity to float; shmemp <- &x
    ac3  39 00 4 f 3 c3c0 00a0  	add2nw 1,r[0],r[3];	;		push,~go;	;			  | r[3] += 8 (addr of next pt in shmem)
    ac4  0a 1b e 0 2 d8ef 0000  	movw 1915,r[15];	shmem->fpregh;	;		;		shp+	  | transfer x, y, and z to fpreg[1915]
    ac5  1b 1b 8 0 c 077b 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+  | r[15]<-1915
    ac6  2a 08 e 0 0 d845 0102  	movw r[5],y;		am->brreg;	;		adda,a,hi;		  | enable unload of converted intensity
    ac7  29 0e e 0 0 c5c7 0102  	add2nw 2,r[7],r[0];	am->fpdp;	;		;			  | brreg<-r[5]; fpdp<-addr for intensity
    ac8  2a 0c e 0 0 e996 0101  	mov2nw 4,y;		am->fpap;	;		adda,st,hi;		  | *(r[7]+4) <-  converted intensity
    ac9  39 00 3 7 e d967 0101  	movw r[7],r[14];	;		cjp,go;		;			  | fpap pts to matrix
                                											  | r[14] <- addr for xformed pt
                                											  | jump to xform routine which returns to
                                											  | caller after xfrming pt & putting result
                                											  | at *r[7] (fpreg[1915+3] == 1.0)
                                clppoly3:
    aca  02 2e e 0 0 d914 0028  	movw,s 0,r[20];	40->fpdp;;		;			  | r[20] <- FALSE; cc == zer (tested
                                											  | below at nxtpt3)
    acb  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 40.firstvtx <- TRUE
    acc  0a 2e e 0 0 dd15 0037  	incw 0,r[21];	55->fpdp;;		;			  | r[21] <- TRUE
    acd  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 55.firstvtx <- TRUE
    ace  0a 2e e 0 0 7140 0046  	;			70->fpdp;;		;
    acf  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 70.firstvtx <- TRUE
    ad0  0a 2e e 0 0 7140 0055  	;			85->fpdp;;		;
    ad1  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 85.firstvtx <- TRUE
    ad2  0a 2e e 0 0 7140 0064  	;			100->fpdp;;		;
    ad3  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 100.firstvtx <- TRUE
    ad4  0a 2e e 0 0 7140 0073  	;			115->fpdp;;		;
    ad5  0a 2b e 0 0 7140 0001  	;			1->fpregh;	;		;			  | 115.firstvtx <- TRUE
    ad6  1a 08 a 8 0 d852 0000  nxtpt3: movw r[18],y;	am->brreg;	crtn,~zer;	;			  | when reach here, cc reflects state of
                                											  | r[20]; return when out of pts; else
                                											  | call routine to get next point with
    ad7  1a 27 1 7 0 d8c7 0082  	movw d,r[7];	130->am;	cjs,go;		;			  | r[7]==130; returns
    ad8  02 00 3 1 0 d84c 0afd  	movw,s r[12],y;	;		cjp,neg closepoly3;;			  | with cc neg when out of points
    ad9  0a 00 3 0 0 dd16 0afa  	incw 0,r[22];		;		cjp,zer putpts3;;			  | r[22]<-1; if clip disabled, goto putpts3
                                											  | else r[7] points to new pt; r[22]==1
    ada  0a 27 e 0 0 d8c6 00b4  nxtpt3a: movw d,r[6];	180->am;	;		;			  | r[6]<-180
    adb  02 27 e 0 0 ebec 0028  clpleft3: btstw,s 5,r[12]; 40->am;;		;			  | if left clipping enabled, call clppln3
    adc  0a 00 3 0 0 d8c4 0ae0  	movw d,r[4];		;		cjp,zer clptop3;;			  | with r[4]==40
    add  0a 28 e 0 0 7140 0b30  	;			=wec_left3->brreg;;		;			  | and brreg==wec_left3
    ade  0a 00 1 7 0 d917 0b02  	movw 0,r[23];		;		cjs,go clppln3;	;
    adf  08 00 1 7 6 d977 0aff  	movw r[23],r[22];		;		cjs,go switchbuf3;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    ae0  02 27 e 0 0 e5ec 0037  clptop3: btstw,s 2,r[12];	55->am;;		;			  | if top clipping enabled, call clppln3
    ae1  0a 00 3 0 0 d8c4 0ae5  	movw d,r[4];		;		cjp,zer clphither3;;			  | with r[4]==55
    ae2  0a 28 e 0 0 7140 0b35  	;			=wec_top3->brreg;;		;			  | and brreg==wec_top3
    ae3  0a 00 1 7 0 d917 0b02  	movw 0,r[23];		;		cjs,go clppln3;	;
    ae4  08 00 1 7 6 d977 0aff  	movw r[23],r[22];		;		cjs,go switchbuf3;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    ae5  02 27 e 0 0 e3ec 0046  clphither3: btstw,s 1,r[12]; 70->am;;		;			  | if hither clipping enabled, call clppln3
    ae6  0a 00 3 0 0 d8c4 0aea  	movw d,r[4];		;		cjp,zer clpright3;;			  | with r[4]==70
    ae7  0a 28 e 0 0 7140 0b40  	;			=wec_hither3->brreg;;		;			  | and brreg==wec_hither3
    ae8  0a 00 1 7 0 d917 0b02  	movw 0,r[23];		;		cjs,go clppln3;	;
    ae9  08 00 1 7 6 d977 0aff  	movw r[23],r[22];		;		cjs,go switchbuf3;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    aea  02 27 e 0 0 e9ec 0055  clpright3: btstw,s 4,r[12]; 85->am;;		;			  | if right clipping enabled, call clppln3
    aeb  0a 00 3 0 0 d8c4 0aef  	movw d,r[4];		;		cjp,zer clpbottom3;;			  | with r[4]==85
    aec  0a 28 e 0 0 7140 0b36  	;			=wec_right3->brreg;;		;			  | and brreg==wec_right3
    aed  0a 00 1 7 0 d917 0b02  	movw 0,r[23];		;		cjs,go clppln3;	;
    aee  08 00 1 7 6 d977 0aff  	movw r[23],r[22];		;		cjs,go switchbuf3;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    aef  02 27 e 0 0 e7ec 0064  clpbottom3: btstw,s 3,r[12]; 100->am;;		;			  | if bottom clipping enabled, call clppln3
    af0  0a 00 3 0 0 d8c4 0af4  	movw d,r[4];		;		cjp,zer clpyon3;;			  | with r[4]==100
    af1  0a 28 e 0 0 7140 0b2f  	;			=wec_bottom3->brreg;;		;			  | and brreg==wec_bottom3
    af2  0a 00 1 7 0 d917 0b02  	movw 0,r[23];		;		cjs,go clppln3;	;
    af3  08 00 1 7 6 d977 0aff  	movw r[23],r[22];		;		cjs,go switchbuf3;;			  | # of output pts is # of input pts for
                                											  | next stage; also switch buffers
    af4  02 27 e 0 0 e1ec 0073  clpyon3: btstw,s 0,r[12]; 115->am;;		;			  | if yon clipping enabled, call clppln3
    af5  0a 00 3 0 0 d8c4 0afa  	movw d,r[4];		;		cjp,zer putpts3;;			  | with r[4]==115
    af6  0a 28 e 0 0 7140 0b34  	;			=wec_yon3->brreg;;		;			  | and brreg==wec_yon3
    af7  0a 00 1 7 0 d917 0b02  	movw 0,r[23];		;		cjs,go clppln3;	;
    af8  08 00 e 0 6 d977 0000  	movw r[23],r[22];		;		;		;			  | # of output pts is # of pts which are
    af9  08 00 e 0 7 d966 0000  	movw r[6],r[7];;		;		;			  | passed to the pt consuming routine
    afa  0a 08 e 0 0 d853 0000  putpts3: movw r[19],y;	am->brreg;	;		;			  | r[7] points to the pts
    afb  18 00 1 7 f d967 0000  	movw r[7],r[15];	;		cjs,go;		;			  | call the consuming routine
    afc  02 00 3 7 0 d854 0ad6  	movw,s r[20],y;	;		cjp,go nxtpt3;	;			  | get next input pt; cc reflects state of
                                											  | variable r[20]
    afd  0a 00 c 0 0 dd14 0afa  closepoly3: incw 0,r[20];	;		ldct putpts3;	;			  | r[20] <- TRUE; r[22] <- 0
    afe  0a 00 7 8 0 d916 0ada  	movw 0,r[22];		;		jrp,~zer nxtpt3a;;			  | if clipping is disabled, goto putpts3;
                                											  | else do one more pass
                                											  | through clipping loop to flush out
                                											  | possible intersection points by passing
                                											  | each plane's saved 1st vertex to it as
                                											  | its last vertex
    aff  08 00 e 0 0 d966 0000  switchbuf3: movw r[6],r[0];	;		;		;			  | switch buffer ptrs
    b00  08 00 e 0 6 d967 0000  	movw r[7],r[6];;		;		;
    b01  18 00 a 7 7 d960 0000  	movw r[0],r[7];	;		crtn,go;	;
    b02  08 00 e 0 f d967 0000  clppln3: movw r[7],r[15];	;		;		;			  | use local copy of r[7]
    b03  08 00 e 0 e d966 0000  	movw r[6],r[14];	;		;		;			  | use local copy of r[6]
    b04  02 00 e 0 0 d856 0000  cpln3loop: movw,s r[22],y;	;		;		;			  | if r[22] == 0, goto chklastpt3
    b05  02 00 3 0 0 c1f6 0b12  	sub2nw,s 0,r[22];	;		cjp,zer chklastpt3;;			  | if ((r[22] -= 1) < 0), return
    b06  1a 0c a 1 0 d844 0000  	movw r[4],y;		am->fpap;	crtn,neg;	;			  | fpap <- r[4]
    b07  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;			  | if r[4]->firstvtxflg == FALSE, goto
    b08  0a 0c 3 0 0 d84f 0b16  	movw r[15],y;		am->fpap;	cjp,zer subseqvtx3;;			  | subseqvtx3; fpap <- r[15]
    b09  0a 0e e 0 0 d844 0000  firstvtx3: movw r[4],y;	am->fpdp;	;		;			  | fpdp <- r[4]
    b0a  0a 0b 4 7 6 f900 0004  	movw 0,y;		am->fpregh;	push,go 4;	;		dp+	  | r[4]->firstvtxflg <- FALSE
    b0b  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | r[4]->firstvtx <- input pt
    b0c  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    b0d  0a 0c 4 7 0 d84f 0004  	movw r[15],y;		am->fpap;	push,go 4;	;			  | fpap <- r[15]
    b0e  0a 3b e 0 0 f8e1 0000  	movw 5,acc;		fpregh->fpregh;	;		;			  | r[4]->savdvtx <- input pt
    b0f  1b 3b 8 0 8 0005 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | acc <- 5
    b10  1a 0c 1 7 0 d84f 0000  	movw r[15],y;		am->fpap;	cjs,go;		;			  | call routine to compute window edge
                                											  | coordinate for this plane and this pt
                                											  | fpap <- r[15]
                                											  | (brreg has address of routine)
                                											  | wec is stored in r[4]->savdwec
    b11  0a 00 3 7 0 988f 0b24  	addw r[15],acc,r[15];	;		cjp,go cpln3vischk;;			  | r[15] += 5;go check visibility using wec
    b12  02 00 e 0 0 d854 0000  chklastpt3: movw,s r[20],y;	;		;		;			  | if there are more pts, return; else
    b13  1a 0c a 0 0 d844 0000  	movw r[4],y;		am->fpap;	crtn,zer;	;			  | if r[4]->firstvtxflg == TRUE, return
    b14  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;
    b15  18 0c a 8 f dd64 0000  	incw r[4],r[15];	am->fpap;	crtn,~zer;	;			  | else fpap <- r[15] <- &r[4]->firstvtx
                                											  | and fall through to subseqvtx3
    b16  18 2e 1 7 0 c7c4 0008  subseqvtx3: add2nw 3,r[4],r[0];8->fpdp;	cjs,go;		;			  | fpreg[8] <-  wec for this plane and pt
    b17  0a 2c e 0 0 c3c0 0008  	add2nw 1,r[0],r[0];	8->fpap;	;		;			  | fpap <- address of input wec
    b18  0a 37 e 0 0 f8c1 0000  	movw d,acc;		fpregh->am;	;		;			  | acc <- high word of input wec
    b19  0a 0c e 0 0 dc40 0000  	incw r[0],y;		am->fpap;	;		;			  | fpap <- address of saved wec
    b1a  02 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregh->am;	;		;			  | test sign of (input wec) ^ (saved wec)
    b1b  0a 00 1 1 0 7140 0b43  	;			;		cjs,neg plnintsct3;;			  | if signs differ a polygon edge crosses
                                											  | this plane; call plnintsct3 to compute
                                											  | the intersection and add it to the
                                											  | output buffer
    b1c  0a 0c e 0 0 d84f 0000  	movw r[15],y;		am->fpap;	;		;			  | fpap <- address of input pt
    b1d  0a 27 e 0 0 8684 0006  	addw d,r[4],acc;	6->am;		;		;			  | acc <- &r[4]->savdvtx
    b1e  0a 0e 4 7 0 f880 0004  	movw acc,y;		am->fpdp;	push,go 4;	;			  | fpdp <- &r[4]->savdvtx
    b1f  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | r[4]->savdvtx <- input pt
    b20  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    b21  0a 2c e 0 0 7140 0008  	;			8->fpap;	;		;			  | fpap <- address of input wec
    b22  0a 3b e 0 0 9c8f 0000  	addw r[15],5,r[15];	fpregh->fpregh;	;		;			  | r[4]->savdwec <- input wec
    b23  0b 3b e 0 0 0005 0000  	;			fpregl->fpregl;	;		;			  | r[15] += 5
    b24  0a 00 e 0 0 9484 0000  cpln3vischk: addw r[4],11,y;	;		;		;
    b25  0a 0c e 0 0 000b 0000  	;			am->fpap;	;		;			  | fpap <- &r[4]->savdwec
    b26  02 37 e 0 0 f8c0 0000  	movw,s d,y;		fpregh->am;	;		;
    b27  02 00 3 1 0 d856 0b04  	movw,s r[22],y;		;		cjp,neg cpln3loop;;			  | wec < 0 => pt not visible
    b28  0a 0e 3 1 0 d84e 0b04  	movw r[14],y;		am->fpdp;	cjp,neg cpln3loop;;			  | (r[22] >= 0) => add pt to output
                                											  | (r[20] == TRUE) && (r[22] < 0) =>
                                											  | this last pt is the same as the first pt
                                											  | so ignore it (only reach here with
                                											  | r[22] < 0 when r[20] == TRUE)
                                cpln3vis:										  | fpdp <- r[14] (above)
    b29  0a 27 e 0 0 9484 0005  	addw r[4],6,y;	5->am;		;		;			  | d <- 5
    b2a  0a 0c e 0 0 0006 0000  	;			am->fpap;	;		;			  | fpap <- &r[4]->savdvtx
    b2b  0a 3b 4 7 0 dd77 0003  	incw r[23],r[23];		fpregh->fpregh;	push,go 3;	;			  | r[23] += 1
    b2c  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+	  | output buffer <- current point
    b2d  1a 3b 8 0 0 7140 0000  	;			fpregh->fpregh;	rfct;		;
    b2e  0b 3b 3 7 0 9e8e 0b04  	addw d,r[14],r[14];	fpregl->fpregl;	cjp,go cpln3loop;;			  | r[14] += 5; goto cpln3loop
    b2f  0a 00 e 0 4 7140 0000  wec_bottom3: ;			;		;		;		ap+	  | fpap pts to pt.y for wec_bottom3 OR
    b30  2a 00 e 0 0 948f 0230  wec_left3: addw r[15],3,y;	;		;		lmode rn,ai,flow,fast;	  | to pt.x for wec_left3
    b31  0a 0d c 0 0 0003 0b3a  	;			am->fpbp;	ldct wec_wait3;	;			  | fpbp <- &pt.r[20]
    b32  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | pt.r[20] + pt.x (left plane wec) OR
    b33  3b 00 7 f 0 7140 0110  	;			;		jrp,~go;	;			  | pt.r[20] + pt.y (bottom plane wec)
                                											  | jump to wec_wait3
    b34  0a 00 e 0 4 7140 0000  wec_yon3: ;			;		;		;		ap+	  | fpap pts to pt.z for wec_yon3 OR
    b35  0a 00 e 0 4 7140 0000  wec_top3: ;			;		;		;		ap+	  | to pt.y for wec_top3 OR
    b36  2a 00 e 0 0 948f 0230  wec_right3: addw r[15],3,y;	;		;		lmode rn,ai,flow,fast;	  | to pt.x for wec_right3
    b37  0a 0d e 0 0 0003 0000  	;			am->fpbp;	;		;			  | fpbp <- &pt.r[20]
    b38  2a 00 e 0 0 7140 0190  	;			;		;		rsuba,lab,hi;		  | pt.r[20] - pt.x (right plane wec) OR
    b39  2b 00 e 0 0 7140 0190  	;			;		;		;			  | pt.r[20] - pt.y (top plane wec) OR
                                											  | pt.r[20] - pt.z (yon plane wec)
    b3a  0a 00 4 7 0 7140 0002  wec_wait3: ;			;		push,go 2;	;
    b3b  1a 00 8 0 0 7140 0000  	;			;		rfct;		;
    b3c  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    b3d  2b 00 e 0 0 7140 0102  	;			;		;		;
    b3e  2a 00 e 0 0 7140 0101  	;			;		;		adda,st,hi;		  | store result and return; result < 0 =>
    b3f  3b 00 a 7 0 7140 0101  	;			;		crtn,go;	;			  | pt is on invisible side of pln
    b40  08 0c e 0 1 c3cf 0000  wec_hither3: add2nw 1,r[15],r[1]; am->fpap;	;		;			  | fpap <- &pt.z
    b41  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | store pt.z (hither plane wec); z < 0 =>
    b42  1b 3b a 7 0 7140 0000  	;			fpregl->fpregl;	crtn,go;	;			  | pt is on invisible side of pln; return
    b43  0a 2d e 0 0 9484 0008  plnintsct3: addw r[4],11,y;	8->fpbp;	;		;			  | fpbp pts to wec of new input pt
    b44  2a 0c e 0 0 000b 0230  	;			am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap pts to wec of saved pt
    b45  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | saved wec - input wec
    b46  2b 00 e 0 0 7140 0150  	;			;		;		;
    b47  0a 00 4 7 0 7140 0002  	;			;		push,go 2;	;			  | delay for flowthrough mode
    b48  1a 2e 8 0 0 7140 0009  	;			9->fpdp;	rfct;		;			  | fpdp <- 9
    b49  2a 00 e 0 0 f8e0 0102  	movw 9,y;		;		;		adda,a,hi;
    b4a  2b 0c e 0 0 0009 0102  	;			am->fpap;	;		;			  | fpap <- 9
    b4b  2a 00 e 0 0 d8e2 0101  	movw 10,r[2];	;		;		adda,st,hi;		  | store wec_diff in fpreg[9]
    b4c  2b 00 e 0 0 000a 0101  	;			;		;		;			  | r[2] <- 10
    b4d  0a 00 1 7 0 7140 034a  	;			;		cjs,go recip;	;			  | fpreg[10] <- reciprocal of difference
    b4e  2b 0d e 0 0 d842 0230  	movw r[2],y;		am->fpbp;	;		lmode rn,ai,pipe,fast;	  | fpbp <- 10; set pipeline mode
    b4f  0a 00 c 0 0 9484 0001  	addw r[4],11,y;	;		ldct 1;		;			  | 2910 R reg <- 1
    b50  0a 0c e 0 0 000b 0000  	;			am->fpap;	;		;			  | fpap pts to wec of saved pt
    b51  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | compute t = (wec of saved pt)/wec_diff
    b52  2b 0c e 0 0 d84f 0010  	movw r[15],y;		am->fpap;	;		;			  | fpap <- address of input pt
    b53  2a 00 e 0 0 9484 0120  	addw r[4],6,y;	;		;		adda,la,hi;
    b54  3b 0d 4 f 0 0006 0120  	;			am->fpbp;	push,~go;	;			  | fpbp <- address of saved pt
    b55  2a 00 e 0 0 7140 0150  	;			;		;		suba,lab,hi;		  | dx (input x - saved x) and
    b56  3b 00 8 0 7 7140 0150  	;			;		rfct;		;		abp+	  | dy (input y - saved y)
    b57  2a 00 e 0 0 f8e1 0154  	movw 9,acc;		;		;		suba,lab,m,hi;		  | dz (input z - saved z)
    b58  2b 0e e 0 7 0009 0154  	;			am->fpdp;	;		;		abp+	  | fpdp <- 9
    b59  2a 00 e 0 0 f8e0 0151  	movw 6,y;		;		;		suba,lab,st,hi;		  | fpreg[9] <- t; dw (input r[20] - saved r[20])
    b5a  2b 07 e 0 7 0006 0151  	;			am->am;		;		;		abp+	  | d <- 6
    b5b  2a 00 e 0 0 c580 0152  	mov2nw 2,r[0];		;		;		suba,lab,a,hi;		  | di (input i - saved i)
    b5c  3b 0d 4 f 0 f880 0152  	movw acc,y;		am->fpbp;	push,~go;	;			  | fpbp <- 9
    b5d  22 00 e 0 0 c1e0 001a  	sub2nw,s 0,r[0],r[0];	;		;		mabr,lab,a,hi;		  | dx * t; dy * t; dz * t; dw * t
    b5e  3b 00 d 0 0 7140 001a  	;			;		loop,zer;	;
    b5f  2a 00 e 0 0 c580 001c  	mov2nw 2,r[0];		;		;		mabr,lab,m,hi;		  | di * t
    b60  3b 0d 4 f 0 9684 001c  	addw d,r[4],y;	am->fpbp;	push,~go;	;			  | fpbp <- address of saved pt
    b61  22 00 e 0 0 c1e0 011c  	sub2nw,s 0,r[0],r[0];	;		;		addr,lab,m,hi;		  | saved x + dx*t; saved y + dy*t
    b62  3b 00 d 0 5 7140 011c  	;			;		loop,zer;	;		bp+	  | saved z + dz*t; saved r[20] + dw*t
    b63  2a 00 e 0 0 c580 011a  	mov2nw 2,r[0];		;		;		addr,lab,a,hi;		  | saved i + di*t
    b64  3b 0e 4 f 0 d84e 011a  	movw r[14],y;		am->fpdp;	push,~go;	;			  | fpdp <- r[14]
    b65  22 00 e 0 0 c1e0 0123  	sub2nw,s 0,r[0],r[0];	;		;		adda,la,a,st,hi;		  | store intersection x,y,z,r[20] at *r[14]
    b66  3b 00 d 0 6 dd6e 0123  	incw r[14],r[14];	;		loop,zer;	;		dp+	  | r[14] += 4
    b67  2a 00 e 0 0 dd6e 0101  	incw r[14],r[14];	;		;		adda,st,hi;		  | store intersection i at *(r[14]+4)
    b68  3b 00 a 7 0 dd77 0101  	incw r[23],r[23];		;		crtn,go;	;			  | r[14] += 1; r[23] += 1; return
                                vwpsclpts3:										  | in-place 3-D viewport scale
                                											  | assumes vwp params are at fpr[32],
                                											  | r[4] points to pts to be scaled,
                                											  | and brreg contains npts-1
                                											  | call with max of 1915-1890 (25) pts if
                                											  | there are pts in 1915, else max of
                                											  | 2048-1890 (158) pts, so 1890 doesn't
                                											  | overflow fpreg's
    b69  0a 27 e 0 0 d8c2 0762  	movw d,r[2];		1890->am;	;		;			  | r[2]<-1890, addr for r[20] reciprocals
    b6a  0a 00 e 0 0 d804 0000  	movw r[4],acc;	;		;		;			  | r[16] <- r[4]
    b6b  1a 27 4 7 0 d890 0003  	movw acc,r[16];		3->am;		push,go;	;			  | d <- 3; loop through npts
    b6c  0a 0c 1 7 0 9e90 034a  	addw d,r[16],r[16];	am->fpap;	cjs,go recip;	;			  | fpap <- &r[20][i];compute reciprocal of r[20][i]
    b6d  1a 27 8 0 0 dd62 0005  	incw r[2],r[2];	5->am;		rfct;		;			  | r[2] <- &1890[i+1] and loop back
    b6e  29 0c e 0 0 d964 0230  	movw r[4],r[0];	am->fpap;	;		lmode rn,ai,pipe,fast;	  | fpap <- r[0] <- &x[0]; pipeline mode
    b6f  0a 2d e 0 0 7140 0762  	;			1890->fpbp;	;		;			  | fpbp <- &wrecip[0]
    b70  2a 00 e 0 0 f8e1 0010  	movw 5,acc;		;		;		maba,lab,hi;		  | x0 * 1/w0
    b71  2b 00 e 0 4 0005 0010  	;			;		;		;		ap+	  | acc <- 5
    b72  2a 07 e 0 0 d840 0020  	movw r[0],y;		am->am;		;		maba,la,hi;		  | y0 * 1/w0
    b73  2b 0e e 0 4 d8d0 0020  	movw d,r[16];		am->fpdp;	;		;		ap+	  | fpdp <- r[16] <- &x[0]
    b74  2a 00 e 0 0 7140 0020  	;			;		;		maba,la,hi;		  | z0 * 1/w0
    b75  2b 0c e 0 5 9880 0020  	addw r[0],acc,r[0];	am->fpap;	;		;		bp+	  | fpap<-&x[1]; fpbp<-&wrecip[1]
    b76  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | x1 * 1/w1
    b77  2b 00 e 0 4 7140 0010  	;			;		;		;		ap+
    b78  2a 00 e 0 0 7140 0024  	;			;		;		maba,la,m,hi;		  | y1 * 1/w1
    b79  3b 00 4 7 4 7140 0024  	;			;		push,go;	;		ap+	  | loop through all pts (brreg == npts-1)
    b7a  2a 00 e 0 0 7140 0025  	;			;		;		maba,la,m,st,hi;	  | z[i] * 1/r[20][i]; store x[i-1]*1/r[20][i-1]
    b7b  2b 0c e 0 9 9880 0025  	addw r[0],acc,r[0];	am->fpap;	;		;		bdp+	  | fpap<-&x[i+1]; fpbp<-&wrecip[i+1]
    b7c  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | x[i+1] * 1/r[20][i+1]; store y[i-1]*1/r[20][i-1]
    b7d  2b 00 e 0 8 7140 0015  	;			;		;		;		adp+
    b7e  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | y[i+1] * 1/r[20][i+1]; store z[i-1]*1/r[20][i-1]
    b7f  3b 0e 8 0 4 9890 0015  	addw r[16],acc,r[16];	am->fpdp;	rfct;		;		ap+
    b80  0a 0d e 0 0 cb90 0000  	mov2nw 5,r[16];		am->fpbp;	;		;			  | fpbp <- r[16] <- &VWPXSCL
    b81  08 0c e 0 0 d964 0000  	movw r[4],r[0];	am->fpap;	;		;			  | fpap <- r[0] <- &x[0]
    b82  2a 0e e 0 0 d840 0010  	movw r[0],y;		am->fpdp;	;		maba,lab,hi;		  | x[0] * VWPXSCL; fpdp points to input pts
    b83  2b 0d e 0 4 c3d0 0010  	add2nw 1,r[16];		am->fpbp;	;		;		ap+
    b84  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | y[0] * VWPYSCL
    b85  2b 0d e 0 4 c3d0 0010  	add2nw 1,r[16];		am->fpbp;	;		;		ap+
    b86  2a 00 e 0 0 7140 0010  	;			;		;		maba,lab,hi;		  | z[0] * VWPZSCL
    b87  2b 0d e 0 0 c5f0 0010  	sub2nw 2,r[16];		am->fpbp;	;		;
    b88  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;			  | pipeline advance since can't change
    b89  2b 0c e 0 0 9880 0120  	addw r[0],acc,r[0];	am->fpap;	;		;			  | both fpap and fpbp fast enough
    b8a  2a 00 e 0 0 7140 0014  	;			;		;		maba,lab,m,hi;		  | x[1] * VWPXSCL
    b8b  3b 0d 4 7 4 c3d0 0014  	add2nw 1,r[16];		am->fpbp;	push,go;	;		ap+	  | loop through all pts
    b8c  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | y[i] * VWPYSCL; store x[i-1]*VWPXSCL
    b8d  2b 0d e 0 8 c3d0 0015  	add2nw 1,r[16];		am->fpbp;	;		;		adp+
    b8e  2a 00 e 0 0 7140 0015  	;			;		;		maba,lab,m,st,hi;	  | z[i] * VWPZSCL; store y[i-1]*VWPYSCL
    b8f  2b 0d e 0 6 c5f0 0015  	sub2nw 2,r[16];		am->fpbp;	;		;		dp+
    b90  2a 00 e 0 0 7140 0121  	;			;		;		adda,la,st,hi;		  | pipeline advance; store z[i-1]*VWPZSCL
    b91  2b 0c e 0 6 9880 0121  	addw r[0],acc,r[0];	am->fpap;	;		;		dp+
    b92  2a 00 e 0 6 7140 0014  	;			;		;		maba,lab,m,hi;	dp+	  | x[i+1] * VWPXSCL
    b93  3b 0d 8 0 8 c3d0 0014  	add2nw 1,r[16];		am->fpbp;	rfct;		;		adp+	  | fpdp <- &x[i]; loop back
    b94  0a 0d e 0 0 c1f0 0000  	sub2nw 0,r[16];		am->fpbp;	;		;			  | fpbp <- r[16] <- &VWPXOFF
    b95  08 0c e 0 0 d964 0000  	movw r[4],r[0];	am->fpap;	;		;			  | fpap <- r[0] <- &x[0]
    b96  2a 0e e 0 0 d840 0110  	movw r[0],y;		am->fpdp;	;		adda,lab,hi;		  | x[0] + VWPXOFF; fpdp points to input pts
    b97  2b 0d e 0 4 c3d0 0110  	add2nw 1,r[16];		am->fpbp;	;		;		ap+
    b98  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | y[0] + VWPYOFF
    b99  2b 0d e 0 4 c3d0 0110  	add2nw 1,r[16];		am->fpbp;	;		;		ap+
    b9a  2a 00 e 0 0 7140 0110  	;			;		;		adda,lab,hi;		  | z[0] + VWPZOFF
    b9b  2b 0d e 0 0 c5f0 0110  	sub2nw 2,r[16];		am->fpbp;	;		;
    b9c  2a 00 e 0 0 7140 0120  	;			;		;		adda,la,hi;			  | pipeline advance since can't change
    b9d  2b 0c e 0 0 9880 0120  	addw r[0],acc,r[0];	am->fpap;	;		;			  | both fpap and fpbp fast enough
    b9e  2a 00 e 0 0 7140 0112  	;			;		;		adda,lab,a,hi;		  | x[1] + VWPXOFF
    b9f  3b 0d 4 7 4 c3d0 0112  	add2nw 1,r[16];		am->fpbp;	push,go;	;		ap+	  | loop through all pts
    ba0  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | y[i] + VWPYOFF; store x[i-1]+VWPXOFF
    ba1  2b 0d e 0 8 c3d0 0113  	add2nw 1,r[16];		am->fpbp;	;		;		adp+
    ba2  2a 00 e 0 0 7140 0113  	;			;		;		adda,lab,a,st,hi;	  | z[i] + VWPZOFF; store y[i-1]+VWPYOFF
    ba3  2b 0d e 0 6 c5f0 0113  	sub2nw 2,r[16];		am->fpbp;	;		;		dp+
    ba4  2a 00 e 0 0 7140 0121  	;			;		;		adda,la,st,hi;		  | pipeline advance; store z[i-1]+VWPZOFF
    ba5  2b 0c e 0 6 9880 0121  	addw r[0],acc,r[0];	am->fpap;	;		;		dp+
    ba6  2a 00 e 0 6 7140 0112  	;			;		;		adda,lab,a,hi;	dp+	  | x[i+1] + VWPXOFF
    ba7  3b 0d 8 0 8 c3d0 0112  	add2nw 1,r[16];		am->fpbp;	rfct;		;		adp+	  | fpdp <- &x[i]; loop back
    ba8  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | return
                                											  | completion jump vector when r[19]
                                											  | points to mkedges3; after putting all
                                											  | pts through xform-clip-scale-mkedg,
                                											  | jump here to complete processing
    ba9  0a 0e 3 7 0 c1e8 0a3f  	sub2nw 0,r[8],r[8];	am->fpdp;	cjp,go xf3doscan;;			  | fpdp <- &edg.nxt for last edge and
                                											  | goto xf3doscan
    baa  02 00 e 0 0 d856 0000  mkedges3: movw,s r[22],y;	;		;		;
    bab  02 00 3 8 0 d854 0bae  	movw,s r[20],y;	;		cjp,~zer edgpts3;;			  | if (r[22] > 0) goto edgpts3
    bac  0a 00 3 8 0 7140 0be4  	;			;		cjp,~zer lastedg3;;			  | else if no more pts in this boundary
    bad  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | goto lastedg3; else return
    bae  08 08 e 0 0 c1f6 0000  edgpts3: sub2nw 0,r[22],r[16];	am->brreg;	;		;			  | brreg <- r[22]-1
    baf  08 00 1 7 4 d96f 0b69  	movw r[15],r[4];	;		cjs,go vwpsclpts3;;			  | r[4] points to input pts
                                											  | vwpsclpts3 assumes vwp params at fpr[32]
                                											  | vwpsclpts3 scales pts in place
    bb0  02 00 e 0 0 d855 0000  	movw,s r[21],y;	;		;		;
    bb1  0a 00 3 0 0 d915 0bc7  	movw 0,r[21];	;		cjp,zer mkedg3;	;			  | if not 1st pt of boundary, goto mkedg3
                                											  | r[21] <- FALSE
    bb2  2a 0c e 0 0 d84f 0230  firstpt3: movw r[15],y;		am->fpap;	;		lmode rn,ai,flow,fast;	  | fpap points to 1st pt y; flow mode
    bb3  0a 0e e 0 0 f900 0000  	movw 0,y;		am->fpdp;	;		;			  | fpdp <- 0
    bb4  0a 3b e 0 0 c1f6 0000  	sub2nw 0,r[22],r[22];	fpregh->fpregh;	;		;			  | fpreg[0] <- 1st pt x; r[22] -= 1
    bb5  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    bb6  2a 00 e 0 0 9c8f 00e0  	addw r[15],5,r[15];	;		;		fixa,la,hi;		  | convert y to int
    bb7  2b 00 e 0 4 0005 00e0  	;			;		;		;		ap+	  | r[15] += 5
    bb8  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | fpreg[1] <- 1st pt z
    bb9  0b 3b e 0 8 7140 0000  	;			fpregl->fpregl;	;		;		adp+
    bba  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    bbb  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | fpreg[2] <- 1st pt i
    bbc  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+
    bbd  2a 00 e 0 0 7140 0102  	;			;		;		adda,a,hi;
    bbe  2b 00 e 0 0 7140 0102  	;			;		;		;
    bbf  2a 00 e 0 0 f8e0 0101  	movw 3,y;		;		;		adda,st,hi;		  | fpreg[3] <- fixed 1st pt y
    bc0  2b 0c e 0 0 0003 0101  	;			am->fpap;	;		;			  | fpap <- 3
    bc1  0b 37 e 0 0 f8c1 0000  	movw d,acc;		fpregl->am;	;		;			  | acc <- low 16 bits of int y
    bc2  0a 0b e 0 6 f880 0000  	movw acc,y;		am->fpregh;	;		;		dp+	  | low 16 bits to high word of fpreg[3]
    bc3  0a 0c 4 7 0 f900 0002  	movw 0,y;		am->fpap;	push,go 2;	;			  | fpap <- 0 (addr of 1st pt storage)
    bc4  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | prev pt <- 1st pt x,z,i
    bc5  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    bc6  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | fpreg[7,high] <- int y (prev pt storage)
    bc7  22 00 e 0 0 c1f6 0230  mkedg3:	sub2nw,s 0,r[22],r[22];	;		;		lmode rn,ai,flow,fast;	  | select flow mode; if((r[22]-=1)<0),
    bc8  0a 0c 3 1 0 dc4f 0be3  	incw r[15],y;		am->fpap;	cjp,neg chklastedg3;;			  | goto chklastedg3; fpap <- &y[i]
    bc9  28 0e e 0 0 c3c8 00e0  	add2nw 1,r[8],r[0];	am->fpdp;	;		fixa,la,hi;		  | fix y[i]; fpdp <- &edg.xmax
    bca  2b 0c e 0 0 d84f 00e0  	movw r[15],y;		am->fpap;	;		;			  | fpap <- &x[i]
    bcb  08 3b e 0 0 d968 0000  	movw r[8],r[0];	fpregh->fpregh;	;		;			  | edg.xmax <- x[i]; r[0] <- r[8]
    bcc  0b 3b 4 7 8 7140 0001  	;			fpregl->fpregl;	push,go 1;	;		adp+
    bcd  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+
    bce  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.zmax <- z[i]; edg.imax <- i[i]
    bcf  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+
    bd0  0a 0c 4 7 0 e596 0002  	mov2nw 2,y;		am->fpap;	push,go 2;	;			  | fpap <- &x[i-1] (prev pt)
    bd1  0a 3b e 0 0 f8e1 0000  	movw 9,acc;		fpregh->fpregh;	;		;			  | edg.xmin <- x[i-1]; edg.zmin <- z[i-1]
    bd2  1b 3b 8 0 8 0009 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | edg.imin <- i[i-1]; acc <- 9
    bd3  0b 0b e 0 0 9888 0000  	addw r[8],acc,r[8];	am->fpregl;	;		;			  | edg.nxt <- r[8] <- addr of next edge
    bd4  0a 0e e 0 0 d840 0000  	movw r[0],y;		am->fpdp;	;		;			  | fpdp <- addr of this edge
    bd5  2a 3b e 0 6 9c8f 0102  	addw r[15],5,r[15];	fpregh->fpregh;	;		adda,a,hi;	dp+	  | edg.ymin <- y[i-1] (prev y,16-bit int)
    bd6  2b 00 e 0 0 0005 0102  	;			;		;		;			  | r[15] <- &x[i+1]
    bd7  2a 37 e 0 0 f8c1 0101  	movw d,acc;		fpregh->am;	;		adda,st,hi;		  | edg.ymax<-y[i](32-bit int);acc<-prev y
    bd8  2b 0c e 0 0 dc40 0101  	incw r[0],y;		am->fpap;	;		;			  | fpap <- &edg.ymax
    bd9  03 37 e 0 0 e300 0000  	xorw,s d,acc,y;		fpregl->am;	;		;			  | check for horizontal edges
    bda  0b 37 3 0 4 f8c1 0bde  	movw d,acc;		fpregl->am;	cjp,zer horizedg3;;		ap+	  | acc <- low order 16 bits of int y[i]
    bdb  02 00 e 0 0 c1e9 0000  	sub2nw,s 0,r[9],r[9];;		;		;			  | if (r[9] -= 1) >= 0, goto savpt3
    bdc  0a 0b 3 9 0 f880 0bdf  	movw acc,y;		am->fpregh;	cjp,~neg savpt3;;			  | move low 16 bits to high word where
                                											  | scan conversion code expects to see it
    bdd  0a 00 e 0 0 db09 0000  edgovflw3: compw 0,r[9];	;		;		;			  | on edge overflow, r[9] <- -1 and
                                											  | adjust r[8]
    bde  0a 27 e 0 0 9e08 0009  horizedg3: subw d,r[8],r[8]; 9->am;		;		;			  | ignore horizontal and overflow edges
    bdf  0a 0e 4 7 0 e596 0002  savpt3:	mov2nw 2,y;		am->fpdp;	push,go 2;	;			  | fpdp <- addr of prev pt (fpreg[4-7])
    be0  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | prev pt <- current pt
    be1  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | 32-bit float x,z,i
    be2  0a 0b 3 7 0 f880 0bc7  	movw acc,y;		am->fpregh;	cjp,go mkedg3;	;			  | 16-bit int y in high word; loop back
    be3  02 00 e 0 0 d854 0000  chklastedg3: movw,s r[20],y;;		;		;
    be4  12 00 a 0 0 d855 0000  lastedg3: movw,s r[21],y;	;		crtn,zer;	;			  | return if may be more pts in boundary
    be5  1a 2c a 8 0 7140 0003  	;			3->fpap;	crtn,~zer;	;			  | fpap <- addr of 1st y; return if no pts
    be6  0a 37 e 0 0 d8c0 0000  	movw d,r[0];		fpregh->am;	;		;			  | r[0] <- 1st y (16-bit int)
    be7  0a 2c e 0 0 7140 0007  	;			7->fpap;	;		;			  | fpap <- addr of prev pt y
    be8  02 37 e 0 0 9700 0000  	xorw,s d,r[0],y;		fpregh->am;	;		;			  | check for horizontal last edge
    be9  1a 0e a 0 0 d848 0000  	movw r[8],y;		am->fpdp;	crtn,zer;	;			  | rtn if horiz; fpdp<-addr for last edge
    bea  0a 3b e 0 6 c7c8 0000  	add2nw 3,r[8],r[8];	fpregh->fpregh;	;		;		dp+	  | edg.ymin <- prev y; r[8] += 8
    beb  0a 0b e 0 6 d840 0000  	movw r[0],y;		am->fpregh;	;		;		dp+	  | edg.ymax <- 1st y
    bec  0a 0c 4 7 0 f900 0002  	movw 0,y;		am->fpap;	push,go 2;	;			  | fpap <- addr of 1st pt x
    bed  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmax <- 1st x; edg.zmax <- 1st z
    bee  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | edg.imax <- 1st i
    bef  02 00 4 7 4 c1e9 0002  	sub2nw,s 0,r[9],r[9];;		push,go 2;	;		ap+	  | fpap <- addr of prev pt x; r[9] -= 1
    bf0  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			  | edg.xmin <- prev x; edg.zmin <- prev z
    bf1  1b 3b 8 0 8 7140 0000  	;			fpregl->fpregl;	rfct;		;		adp+	  | edg.imin <- prev i
    bf2  1b 0b a 9 0 dd68 0000  	incw r[8],r[8];	am->fpregl;	crtn,~neg;	;			  | edg.nxt <- r[8] <- addr of next edge
                                											  | if r[9] >= 0, return
    bf3  0a 00 e 0 0 db09 0000  	compw 0,r[9];		;		;		;			  | else r[9] <- -1
    bf4  1a 27 a 7 0 9e08 0009  	subw d,r[8],r[8];	9->am;		crtn,go;	;			  | adjust r[8] and return
                                procfastbnd3:
    bf5  0a 00 e 0 0 d914 0000  	movw 0,r[20];	;		;		;			  | r[20] <- FALSE
    bf6  0a 00 e 0 0 dd15 0000  	incw 0,r[21];	;		;		;			  | r[21] <- TRUE
    bf7  0a 00 e 0 0 d80a 0000  	movw r[10],acc;		;		;		;
    bf8  0a 00 e 0 0 d896 0000  	movw acc,r[22];		;		;		;			  | r[22] <- r[10], # of pts
    bf9  0a 08 e 0 0 d853 0000  	movw r[19],y;	am->brreg;	;		;			  | brreg <- addr of pt-consuming routine
    bfa  1a 27 1 7 0 d8cf 077b  	movw d,r[15];		1915->am;	cjs,go;		;			  | r[15]<-1915,addr of xfrmd,clptested pts
                                											  | and call r[19]
    bfb  0a 00 e 0 0 dd14 0000  	incw 0,r[20];	;		;		;			  | r[20] <- TRUE
    bfc  0a 08 e 0 0 d853 0000  	movw r[19],y;	am->brreg;	;		;			  | brreg <- addr of pt-consuming routine
    bfd  1a 00 1 7 0 d916 0000  	movw 0,r[22];		;		cjs,go;		;			  | r[22] <- 0, call pt-consuming routine
    bfe  0a 00 3 7 0 7140 09a3  	;			;		cjp,go xf3nxtbnd;;			  | loop back to xf3nxtbnd
                                |	movw d,r[11];		shmem->am;	jmap PROC_PGON_INT_3D;;			  | # of separate boundaries
                                PROC_PGON_INT_3D:
    bff  0a 27 e 0 0 d8c5 084f  	movw d,r[5];		=xfint3->am;	;		;			  | set ptr to do fixtofloat and fall 
                                											  | through to use regular xf3 routine
    c00  0a 00 3 7 0 d898 0c03  	movw acc,r[24]; ;		cjp,go cwpoly3;	;			  | after set ptr, use float routine
                                |	movw d,r[11];		shmem->am;	jmap COREWLDPOLYNDC_3D;;		  | # of separate boundaries
                                COREWLDPOLYNDC_3D:
    c01  0a 27 e 0 0 d8c5 0860  	movw d,r[5];		=xf3->am;	;		;			  | use the regular xf3 routine
    c02  0a 00 e 0 0 d898 0000  	movw acc,r[24];;		;		;
    c03  0a 27 e 0 0 869d 0004  cwpoly3: addw d,r[29],acc;	 4->am; ;		;			  | 
    c04  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
    c05  0a 17 e 0 2 d8cc 0000  	movw d,r[12];	shmem->am;	;		;		shp+	  | save clipplanes
    c06  0a 1f c 0 0 ffd8 000f  	bclrw 15,r[24]; shmem->shmemp;	ldct 15;	;			  | shmemp <- r[9], clear 2D flag
    c07  0a 0e 1 7 0 e996 0080  	mov2nw 4,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move matrix to fpr[16]
    c08  0a 27 e 0 0 869d 0034  	addw d,r[29],acc;	 52->am;;		;
    c09  0a 0f c 0 0 f880 0005  	movw acc,y;		am->shmemp;	ldct 5;		;			  |shmemp <- addr of vwp params
    c0a  0a 0e 1 7 0 eb96 0080  	mov2nw 5,y;		am->fpdp;	cjs,go shm_to_fpr;;			  | move viewport parameters to fpr[32]
                                	| Initialization for NDC output polygon variables when corendcproc3 is
                                	| the consuming routine for the points output by the polygon clipper
    c0b  0a 27 e 0 0 d8c8 00e6  cwp3:	movw d,r[8];		230->am;	;		;			  | address of beginning of output list
    c0c  0a 0e e 0 0 d848 0000  	movw r[8],y;		am->fpdp;	;		;			  | fpreg[230] is nbndsout
    c0d  0a 2b e 0 0 dd68 0000  	incw r[8],r[8];	0->fpregh;	;		;			  | nbndsout <- 0; r[8] keeps track of
                                											  | next available location in NDC list
    c0e  0a 27 e 0 0 d8d3 0c11  	movw d,r[19];	=corendcproc3->am;;		;			  | r[19] <- corendcproc3, ptr to
                                											  | point-consuming routine
    c0f  0a 00 3 7 0 7140 09a0  	;			;		cjp,go procpoly3;;			  | goto procpoly3 to put input polygon thru
                                											  | the xform-clip-consumepoint pipeline
                                											  | completion jump vector when r[19]
                                											  | points to corendcproc3; after putting
                                											  | all pts through xform-clip-ndcproc,
                                											  | jump here to complete processing
    c10  08 0f 3 7 1 d97e 0c39  	movw r[30],r[17];	am->shmemp;	cjp,go corendcfinish3;;			  | shmemp <- &MAXLOCS
                                											  |
                                corendcproc3:
    c11  02 00 e 0 0 d856 0000  	movw,s r[22],y;		;		;		;
    c12  02 00 3 8 0 d854 0c15  	movw,s r[20],y;	;		cjp,~zer ndcpts3;;			  | if (r[22] > 0) goto ndcpts3
    c13  0a 00 3 8 0 7140 0c24  	;			;		cjp,~zer lastndc3;;			  | else if no more pts in this boundary
    c14  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | goto lastndc3; else return
                                ndcpts3:
    c15  02 00 e 0 0 d855 0000  	movw,s r[21],y;	;		;		;
    c16  0a 00 3 0 0 d915 0c1a  	movw 0,r[21];	;		cjp,zer ndcp3;	;			  | if not 1st pt of boundary, goto ndcp3
                                											  | r[21] <- FALSE
    c17  0a 00 e 0 0 d909 0000  firstndc3: movw 0,r[9];	;		;		;			  | r[9] <- 0
    c18  08 00 e 0 c d968 0000  	movw r[8],r[12];	;		;		;			  | r[12] <- r[8]
    c19  0a 00 e 0 0 dd68 0000  	incw r[8],r[8];	;		;		;			  | r[8] += 1
    c1a  08 08 e 0 0 c1f6 0000  ndcp3:	sub2nw 0,r[22],r[16];	am->brreg;	;		;			  | brreg <- r[22]-1
    c1b  0a 0e e 0 0 d848 0000  	movw r[8],y;		am->fpdp;	;		;			  | fpdp <- addr for next output pt
    c1c  1a 0c 4 7 0 d84f 0000  	movw r[15],y;		am->fpap;	push,go;	;			  | fpap <- addr of xfrm-clp input pts
                                											  | for each input point
    c1d  0a 27 e 0 0 fec1 0005  	negw d,acc;		5->am;		;		;
    c1e  02 3b e 0 0 fc81 0000  	incw,s acc,acc;		fpregh->fpregh;	;		;			  | copy input to output
    c1f  0b 3b 3 8 8 7140 0c1e  	;			fpregl->fpregl;	cjp,~zer .-1;	;		adp+	  | x,y,z,r[20],i
    c20  02 27 e 0 0 9608 0758  	subw,s d,r[8],y;	1880->am;	;		;			  | if r[8] >= 1880, goto ndctoobig3
    c21  0a 00 b 9 0 dd69 0c37  	incw r[9],r[9];;		cjpp,~neg ndctoobig3;;			  | else r[9] += 1
    c22  12 27 8 0 0 9e88 0005  	addw,s d,r[8],r[8];	5->am;		rfct;		;			  | r[8] += 5, and loop back until done
    c23  02 00 e 0 0 d854 0000  	movw,s r[20],y;	;		;		;
    c24  12 2c a 0 0 d855 00e6  lastndc3: movw,s r[21],y;	230->fpap;	crtn,zer;	;			  | return if may be more pts in boundary
                                											  | fpap <- &nbndsout
    c25  12 37 a 8 0 f8c1 0000  	movw,s d,acc;		fpregh->am;	crtn,~zer;	;			  | return if r[21]
    c26  1a 2e a 1 0 7140 00e6  	;			230->fpdp;	crtn,neg;	;			  | return if nbndsout < 0 (overflow)
                                											  | fpdp <- &nbndsout
    c27  0a 0b e 0 0 fc81 0000  	incw acc,acc;		am->fpregh;	;		;			  | nbndsout += 1
    c28  0a 0e e 0 0 d84c 0000  	movw r[12],y;	am->fpdp;	;		;			  | fpdp <- &boundary data for this boundary
    c29  0a 0b e 0 0 d849 0000  	movw r[9],y;	am->fpregh;	;		;			  | store # of pts in this boundary
    c2a  08 08 e 0 0 c1e9 0000  	sub2nw 0,r[9],r[0]; am->brreg;	;		;			  | brreg <- r[9]-1
    c2b  08 00 1 7 4 dd6c 0b69  	incw r[12],r[4];;		cjs,go vwpsclpts3;;			  | r[4] points to output pts
                                											  | vwpsclpts3 assumes vwp params at fpr[32]
                                											  | vwpsclpts3 scales pts in place
    c2c  0a 00 e 0 0 8589 0000  	rolw 2,r[9],acc;	;		;		;
    c2d  0a 00 e 0 0 8089 0000  	addw r[9],acc,acc;	;		;		;
    c2e  2b 08 e 0 0 e185 0230  	sub2nw 0,acc;		am->brreg;	;		lmode rn,ai,pipe,fast;	  | brreg <- 5*r[9] - 1; pipeline mode
    c2f  0a 0c 4 7 0 dc4c 0003  	incw r[12],y;	am->fpap;	push,go 3;	;			  | fpap <- &x[0]; 2910 R reg <- 3
    c30  2a 00 e 0 0 7140 00e0  	;			;		;		fixa,la,hi;		  | convert x[0],y[0],z[0],r[20][0] to integer
    c31  3b 00 8 0 4 7140 00e0  	;			;		rfct;		;		ap+
    c32  2a 0e e 0 0 dc4c 00e2  	incw r[12],y;	am->fpdp;	;		fixa,la,a,hi;		  | i[0]; fpdp <- &x[0]
    c33  3b 00 4 7 4 7140 00e2  	;			;		push,go;	;		ap+
    c34  2a 00 e 0 0 7140 00e3  	;			;		;		fixa,la,a,st,hi;	  | loop through 5*r[9] values,
    c35  3b 00 8 0 8 7140 00e3  	;			;		rfct;		;		adp+	  | converting to integer and storing back
    c36  1a 00 a 7 0 7140 0000  	;			;		crtn,go;	;			  | return
                                ndctoobig3:
    c37  0a 2e e 0 0 dce8 00e6  	incw 230,r[8];	230->fpdp;	;		;			  | list has overflowed, so record this fact
    c38  1a 2b a 7 0 00e6 ffff  	;			0xFFFF->fpregh;	crtn,go;	;			  | nbndsout<- -1;r[8]<-230+1;return
                                |	movw r[30],r[17];	am->shmemp;	cjp,go corendcfinish3;;			  | shmemp <- r[17] <- &MAXLOCS
                                corendcfinish3:
    c39  0a 17 e 0 0 d8c0 0000  	movw d,r[0];		shmem->am;	;		;			  | tmp0 <- MAXLOCS
    c3a  0a 0f e 0 0 c3d1 0000  	add2nw 1,r[17],r[17];	am->shmemp;	;		;			  | shmemp <- r[17] <- &nbndsout
    c3b  0a 27 e 0 0 8608 00e6  	subw d,r[8],acc;	230->am;	;		;			  | acc <- (r[8] - 230)
    c3c  0a 00 e 0 0 ec01 0000  	sl0w acc,acc;		;		;		;			  | acc *= 2
    c3d  02 00 e 0 0 9040 0000  	rsubw,s r[0],acc,y;	;		;		;			  | if (2*(r[8] - 230) > MAXLOCS), set
    c3e  0a 00 3 1 0 db0b 0c41  	compw 0,r[11];		;		cjp,neg .+3;	;			  | r[11] <- 0xFFFF (more stringent test
    c3f  08 2c e 0 2 dd71 00e6  	incw r[17],r[18];	230->fpap;	;		;			  | could be done); else, fpap <- &nbndsclip
    c40  0a 37 e 0 4 d8cb 0000  	movw d,r[11];		fpregh->am;	;		;		ap+	  | r[11] <- nbndsclip
    c41  02 0a e 0 2 d84b 0000  	movw,s r[11],y;		am->shmem;	;		;		shp+	  | nbndsout <- r[11]; if neg or 0, goto
    c42  0a 00 3 1 0 9e92 0c59  	addw d,r[18],r[18];	;		cjp,neg corendcthru3;;			  | corendcthru3; r[18]<-r[17]+1+r[11](d)
                                corendcbndsloop3:
    c43  0a 0f 3 0 0 dd71 0c59  	incw r[17],r[17];	am->shmemp;	cjp,zer corendcthru3;;			  | shmemp <- (r[17]+=1), addr for r[10][i]
    c44  02 37 e 0 0 d8ca 0000  	movw,s d,r[10];		fpregh->am;	;		;			  | r[10] <- r[10][i]
    c45  0a 3a e 0 4 7140 0000  	;			fpregh->shmem;	;		;		ap+	  | *r[17] <- r[10][i]
    c46  0a 0f e 0 0 d852 0000  	movw r[18],y;		am->shmemp;	;		;			  | shmemp <- r[18], addr for vertices
                                corendcvertloop3:
    c47  0a 00 3 0 0 7140 0c58  	;			;		cjp,zer corendcnxtbnd3;;
    c48  02 00 e 0 0 fff8 0000  	btstw,s 15,r[24]; ;		;		;			  | test 2D or 3D output routine
    c49  0a 00 3 8 0 7140 0735  	;			;		cjp,~zer cwpout2; ;			  | go to 2D output routime
    c4a  02 00 4 7 0 e1f8 0002  	btstw,s 0,r[24];;		push,go 2;	;			  | cc reflects constant or Gouraud shading
    c4b  0a 3a e 0 2 dd72 0000  	incw r[18],r[18];	fpregh->shmem;	;		;		shp+	  | x,y,z to shmem
    c4c  1b 3a 8 0 b dd72 0000  	incw r[18],r[18];	fpregl->shmem;	rfct;		;		shp+,abp+ | r[18] += 6
    c4d  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+	  | skip r[20]
    c4e  0a 37 e 0 0 d8c0 0000  	movw d,r[0];		fpregh->am;	;		;			  | high intensity
    c4f  0b 37 3 0 4 d8c1 0c57  	movw d,r[1];		fpregl->am;	cjp,zer .+8;	;		ap+	  | if intensity not needed, don't send it
    c50  02 27 e 0 0 9700 007f  	xorw,s d,r[0],y;		0x7f->am;	;		;			  | otherwise, check for Weitek float to
    c51  02 00 3 8 0 dc41 0c54  	incw,s r[1],y;		;		cjp,~zer corendcnoadj;;			  | int conversion bug in which an intensity
    c52  0a 00 3 8 0 7140 0c54  	;			;		cjp,~zer corendcnoadj;;			  | between 127 + (65535/65536) and
    c53  0a 0a 3 7 2 d840 0c55  	movw r[0],y;		am->shmem;	cjp,go .+2;	;		shp+	  | 127 + (65535.5/65536), corresponding to
                                											  | an offset (by -2^23) float value between
                                											  | -1.0 and -0.5, is converted to the value
                                											  | 0x007FFFFF rather than 0xFFFFFFFF (after
                                											  | float->int and before adding 2^23);
                                											  | after adding back 0x00800000 (2^23),
                                											  | the value would be 0xFFFFFF (255 +
                                											  | (65535/65536)) rather than 0x007FFFFF
                                											  | (127 + (65535/65536));
                                											  | if this case has arisen, ensure that
                                											  | the intensity is changed to 0x007FFFFF
                                corendcnoadj:
    c54  0a 0a e 0 2 cfc0 0000  	add2nw 7,r[0],r[0];	am->shmem;	;		;		shp+	  | send intensity reconverted to
    c55  0a 0a e 0 2 d841 0000  	movw r[1],y;		am->shmem;	;		;		shp+	  | unsigned 8-bit integer, 16-bit fraction
    c56  0a 00 e 0 0 c3d2 0000  	add2nw 1,r[18],r[18];;		;		;			  | r[18] += 2
    c57  02 00 3 7 0 c1ea 0c47  	sub2nw,s 0,r[10],r[10]; ;		cjp,go corendcvertloop3; ;		  | r[10]-=1 and loop back
                                corendcnxtbnd3:
    c58  02 00 3 7 0 c1eb 0c43  	sub2nw,s 0,r[11],r[11];	;		cjp,go corendcbndsloop3;;		  | r[11]-=1 and loop back
                                corendcthru3:
    c59  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmem <- &data ready flag
    c5a  0a 2a e 0 0 dd7e 0000  	incw r[30],r[30];	0->shmem;	;		;			  | data ready flag <- 0; r[30]+=1
    c5b  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                | "@(#)polyscan.vp.u 1.2 86/09/12 SMI"
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |   Polygon scan conversion.  Polygon may have multiple holes.
                                |   Based on pr_polygon2.c which is derived from Foley and Van Dam pg. 459.
                                |   includes polyscan3.vp.u at end (which see).
                                |   Input:
                                |   	r[15]	colorop	PIX_OP | PIX_COLOR (color)
                                |   	r[14]	pet	pointer to edge table in FP register memory.  First edge is a dummy.
                                |   Edges are received in the form of EdgeIn and are converted internally to the Edge structure (structures are same size).
                                |   typedef struct EdgeIn {	(Edge for polygon fill)
                                |	int ymn, ymx;		(16 bit integers, value in the hi 16 bits)
                                |	float dx, xmn;		(dx is xmax initially.)
                                |	Edge *nxt;		(int in low 16 bits.)
                                |   } EdgeIn;
                                |   typedef struct Edge {	(Edge for polygon fill) (16 bit integers, values in the hi and lo 16 bits respectively)
                                |	short error, ymn;	(bresenham error accumulator, ymn.).
                                |	short errx, erry;	(incrementers).
                                |	short dx, xmn;
                                |	short ymx, dxerry;	(ymx, dx * erry).
                                |	Edge *nxt;		(int in low 16 bits.)
                                |   } Edge;
    c5c  0a 2e e 0 0 7140 0002  polyscan: ;			2->fpdp;	;		;			| save pointer to edge table.
    c5d  0b 0b e 0 0 d84e 0000  	movw r[14], y;		am->fpregl;	;		;			| 
    c5e  0a 27 e 0 0 7140 0004  	;			4->am;	;		;			| r[20]= et [0].r[18].  Skip dummy first edge
    c5f  0a 0c e 0 0 968e 0000  	addw d, r[14], y;		am->fpap;	;		;			| 
                                |   Initialize the edge values:  For all edges ymin must be lowest.
    c60  03 37 e 0 0 d8d4 0000  psinit:	movw,s d, r[20];		fpregl->am;	;		;			| while (r[20])
    c61  0b 3c 3 0 0 7140 0cdd  	;			fpregl->fpap;	cjp, zer pssort; ;			| for all edges, ymin must be < r[9].
    c62  0a 0e e 0 0 d854 0000  	movw r[20], y;		am->fpdp;	;		;			| adp 0 0 with respect to r[20].
    c63  0a 37 e 0 8 d8ca 0000  	movw d, r[10];		fpregh->am;	;		;		adp+	| adp 1 1
    c64  00 37 e 0 8 9e4a 0000  	rsubw,s d, r[10], r[8];	fpregh->am;	;		;			| 
    c65  0a 00 3 9 8 d8c9 0c70  	movw d, r[9];		;		cjp, ~neg psnoswap; ;		adp+	| adp 2 2.  if (r[9] < r[10]) ...
    c66  0a 00 e 0 0 df68 0000  	negw r[8], r[8];	;		;		;			| 
    c67  08 00 e 0 4 d96a 0000  	movw r[10], r[4];		;		;		;			| r[4] y's
    c68  08 00 e 0 a d969 0000  	movw r[9], r[10];		;		;		;			| 
    c69  08 00 e 0 9 d964 0000  	movw r[4], r[9];		;		;		;			| 
    c6a  0a 37 e 0 0 d8cb 0000  	movw d, r[11];		fpregh->am;	;		;			| r[4] x's
    c6b  0b 37 e 0 4 d8c4 0000  	movw d, r[4];		fpregl->am;	;		;		ap+	| adp 3 2
    c6c  0a 3b e 0 0 7140 0000  	;			fpregh->fpregh;	;		;			| 
    c6d  0b 3b e 0 6 7140 0000  	;			fpregl->fpregl;	;		;		dp+	| adp 3 3
    c6e  0a 0b e 0 0 d84b 0000  	movw r[11], y;		am->fpregh;	;		;			| 
    c6f  0b 0b e 0 0 d844 0000  	movw r[4], y;		am->fpregl;	;		;			| 
    c70  0a 0e e 0 0 f900 0000  psnoswap: movw 0, y;	am->fpdp;	;		;			| Stash r[8] in fpregs.
    c71  0b 0b e 0 0 d848 0000  	movw r[8], y;		am->fpregl;	;		;			| 
    c72  0a 2b e 0 0 7140 0000  	;			0->fpregh;	;		;			| 
    c73  29 0c e 0 7 c3d4 0230  	add2nw 1, r[20], r[23];	am->fpap;	;		lmode rn, ai, pipe, fast;| 
    c74  0a 0d e 0 0 dc57 0000  	incw r[23], y;		am->fpbp;	;		;			| 
    c75  2a 00 e 0 0 7140 0150  	;			;		;		suba, lab, hi;		| r[7]= r[11] - r[12], prepare to float r[8]
    c76  2b 00 e 0 4 7140 0150  	;			;		;		;		ap+	| 
    c77  2a 00 e 0 0 7140 00e2  	;			;		;		fixa, la, a, hi;	| fix r[12]
    c78  2b 0c e 0 0 f900 00e2  	movw 0, y;	am->fpap;	;		;			| 
    c79  2a 00 e 0 0 7140 00a2  	;			;		;		floata, la, a, hi;	| float r[8]
    c7a  2b 00 e 0 0 7140 00a2  	;			;		;		;			| 
    c7b  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    c7c  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    c7d  2a 00 e 0 0 7140 0122  	;			;		;		adda,la, a, hi;		| 
    c7e  2b 0e e 0 0 d857 0122  	movw r[23], y;		am->fpdp;	;		;			| 
    c7f  2a 00 e 0 0 7140 00eb  	;			;		;		fixr, la, a, st, hi;	| fix r[7].  store r[7] float in r[11].
    c80  2b 00 e 0 6 7140 00eb  	;			;		;		;		dp+	| 
    c81  2a 0c e 0 0 dc57 0123  	incw r[23], y;		am->fpap;	;		adda,la, a, st, hi;		| store r[12] fix in fpreg
    c82  2b 0e e 0 0 f900 0123  	movw 0, y;	am->fpdp;	;		;			| 
    c83  2a 00 e 0 0 7140 0121  	;			;		;		adda,la, st, hi;		| store r[8] float.  get r[12] from fpreg.
    c84  2b 37 e 0 0 d8cc 0121  	movw d, r[12];		fpregl->am;	;		;			| 
    c85  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    c86  2b 00 e 0 0 f8e0 0120  	movw =recip, y;		;		;		;			| 
    c87  2a 08 e 0 0 034a 0122  	;			am->brreg;	;		adda,la, a, hi;		| 
    c88  2b 0e e 0 0 dc54 0122  	incw r[20], y;		am->fpdp;	;		;			| 
    c89  2a 00 e 0 0 dd02 0121  	incw 0, r[2];	;		;		adda,la, st, hi;		| store fixed r[7] in what was r[9]
    c8a  3b 0c 1 7 0 f900 0121  	movw 0, y;		am->fpap;	cjs, go;	;			| Calculate reciprocal.
    c8b  2a 0c e 0 0 fd00 0270  	incw 0, y;	am->fpap;	;		lmode rz, ai, flow, fast;| recip may have changed mode.
    c8c  08 0d c 0 7 c3d4 0003  	add2nw 1, r[20], r[23];	am->fpbp;	ldct 3;		;			| 
                                |   r[7] / r[8] == -((-r[7]) / r[8]) for octants 2 and 3.
    c8d  2a 00 e 0 0 7140 0010  	;			;		;		maba, lab, hi;		| r[11]= r[7] / r[8]. (mul by recip.)
    c8e  3b 00 4 f 0 7140 0010  	;			;		push, ~go;	;			| 
    c8f  1a 28 8 0 0 7140 0003  	;			3->brreg;	rfct;		;			| 
    c90  2a 00 e 0 0 7140 0104  	;			;		;		adda, m, hi;		| 
    c91  2b 00 e 0 0 7140 0104  	;			;		;		;			| 
    c92  2a 00 e 0 0 7140 00e8  	;			;		;		fixr, la, hi;		| fix r[11].
    c93  3b 00 4 7 0 7140 00e8  	;			;		push, go;	;			| 
    c94  1a 00 8 0 0 7140 0000  	;			;		rfct;		;			| 
    c95  2a 00 e 0 0 7140 0102  	;			;		;		adda, a, hi;		| 
    c96  2b 0e e 0 0 dc57 0102  	incw r[23], y;		am->fpdp;	;		;			| store r[11] fix in old r[12] location.
    c97  2a 00 e 0 0 d808 0101  	movw r[8], acc;		;		;		adda, st, hi;		| set acc for mult.
    c98  2b 0c e 0 0 dc57 0101  	incw r[23], y;		am->fpap;	;		;			| 
    c99  0b 37 e 0 0 d8cb 0000  	movw d, r[11];		fpregl->am;	;		;			| 
    c9a  0a 00 1 7 0 d8c2 0fcc  	movw d, r[2];		;		cjs, go multiply; ;			| compute r[11]*r[8].  MAKE FLOAT (FIX) MUL
    c9b  08 00 e 0 5 d960 0000  	movw r[0], r[5];	;		;		;			| 
    c9c  0a 0c e 0 0 dc54 0000  	incw r[20], y;		am->fpap;	;		;			| 
    c9d  03 37 e 0 0 d8c7 0000  	movw,s d, r[7];		fpregl->am;	;		;			| if (r[7] >= 0)....
    c9e  02 00 3 1 0 9608 0cb0  	subw,s d, r[8], y;	;		cjp, neg psi23;	;			| if (r[8] < r[7])....
    c9f  08 00 3 9 3 cc8b 0cad  	sr0w r[11], r[3];	;		cjp, ~neg psi1;	;			| r[11]/2
    ca0  08 00 e 0 2 d963 0000  psi0:	movw r[3], r[2];	;		;		;			| OCTANT 0.  set r[2] for mult.
    ca1  0a 00 1 7 0 d808 0fcc  	movw r[8], acc;		;		cjs, go multiply; ;			| 
    ca2  0a 00 e 0 0 d807 0000  	movw r[7], acc;		;		;		;			| 
    ca3  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| r[7] >> 1
    ca4  00 00 e 0 6 9840 0000  	rsubw,s r[0], acc, r[6]; ;		;		;			| r[6]= -(r[7] >> 1) + (r[11]/2) * r[8].
    ca5  0a 00 3 1 0 d808 0ca7  	movw r[8], acc;		;		cjp, neg psi0jog; ;			| if (r[6] <= 0)....
    ca6  0a 00 3 8 0 7140 0ca9  	;			;		cjp, ~zer psi0njog; ;			| 
    ca7  0a 00 e 0 0 9886 0000  psi0jog: addw r[6], acc, r[6]; ;		;		;			| r[6] += r[8]
    ca8  0a 00 e 0 0 dd6c 0000  	incw r[12], r[12];		;		;		;			| r[12]++
    ca9  0a 00 e 0 0 d807 0000  psi0njog: movw r[7], acc;	;		;		;			| 
    caa  0a 00 e 0 0 9846 0000  	rsubw r[6], acc, r[6]; ;		;		;			| r[6] -= r[7]
    cab  08 07 e 0 3 cc8b 0000  	sr0w r[11], r[3];	am->am;		;		;			| 
    cac  0a 00 3 7 0 9e8c 0cd2  	addw d, r[12], r[12];	;		cjp, go psinxt;	;			| r[12] += r[11]/2
    cad  0a 00 e 0 0 d808 0000  psi1:	movw r[8], acc;		;		;		;			| OCTANT 1.
    cae  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| r[8] >> 1.
    caf  0a 00 3 7 0 de86 0cd2  	negw acc, r[6];	;		cjp, go psinxt;	;			| r[6] = - (r[8] >> 1)
                                |   OCTANTS 2 and 3.
    cb0  0a 00 e 0 0 fec1 0000  psi23:	negw d, acc;		;		;		;			| -r[7]
    cb1  02 00 e 0 0 9048 0000  	rsubw,s r[8], acc, y;	;		;		;			| 
    cb2  0a 00 3 9 0 de0b 0cca  	negw r[11], acc;		;		cjp, ~neg psi2;	;			| OCTANT 3.  (-r[11])
    cb3  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| (-r[11]) / 2.  set for multiplication.
    cb4  0a 00 e 0 0 d882 0000  	movw acc, r[2];		;		;		;			| 
    cb5  0a 00 1 7 0 d808 0fcc  	movw r[8], acc;		;		cjs, go multiply; ;			| ((-r[11]) / 2) * r[8]
    cb6  0a 00 e 0 0 de07 0000  	negw r[7], acc;		;		;		;			| -r[7]
    cb7  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| (-r[7]) >> 1
    cb8  00 00 e 0 6 9840 0000  	rsubw,s r[0], acc, r[6]; ;		;		;			| r[6]= -((-r[7]) >> 1) + ((-r[11])/2) * r[8]
    cb9  0a 00 3 1 0 d808 0cbb  	movw r[8], acc;		;		cjp, neg psi3jog; ;			| 
    cba  0a 00 3 8 0 7140 0cbd  	;			;		cjp, ~zer psi3njog; ;			| 
    cbb  0a 00 e 0 0 9886 0000  psi3jog: addw r[6], acc, r[6]; ;		;		;			| r[6] += r[8]
    cbc  0a 00 e 0 0 c1ec 0000  	sub2nw 0, r[12], r[12];	;		;		;			| r[12]--
    cbd  0a 00 e 0 0 d807 0000  psi3njog: movw r[7], acc;	;		;		;			| 
    cbe  0a 00 e 0 0 9886 0000  	addw r[6], acc, r[6];	;		;		;			| r[6] += r[7]
    cbf  0a 00 e 0 0 de0b 0000  	negw r[11], acc;		;		;		;			| 
    cc0  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| r[11] / 2
    cc1  0a 00 e 0 0 fe81 0000  	negw acc, acc;		;		;		;			| >> 2 is not symmetric about zero.
    cc2  0a 00 e 0 0 fc81 0000  	incw acc, acc;		;		;		;			| r[11] / 2 + 1
    cc3  0a 00 e 0 0 988c 0000  	addw r[12], acc, r[12];	;		;		;			| r[12] += r[11] / 2 + 1
    cc4  0a 00 e 0 0 d806 0000  	movw r[6], acc;	;		;		;			| 
    cc5  0a 00 e 0 0 8045 0000  	rsubw r[5], acc, acc;	;		;		;			| r[11] * r[8] - r[6]
    cc6  08 00 e 0 6 9887 0000  	addw r[7], acc, r[6];	;		;		;			| r[6]= r[7] + r[11] * r[8] - r[6]
    cc7  00 00 e 0 0 e1e8 0000  	btstw,s 0, r[8], r[0];	;		;		;			| if (r[8] & 1) ....
    cc8  0a 00 3 0 0 7140 0cd2  	;			;		cjp, zer psinxt; ;			| 
    cc9  0a 00 3 7 0 dd66 0cd2  	incw r[6], r[6];	;		cjp, go psinxt;	;			| 
    cca  0a 00 e 0 0 d808 0000  psi2:	movw r[8], acc;		;		;		;			| OCTANT 2.
    ccb  0a 00 e 0 0 ec81 0000  	sr0w acc, acc;		;		;		;			| r[8] >> 1
    ccc  0a 00 e 0 0 de86 0000  	negw acc, r[6];	;		;		;			| r[6]= -(r[8] >> 1)
    ccd  0a 00 e 0 0 de08 0000  	negw r[8], acc;		;		;		;			| -r[8]
    cce  02 00 e 0 0 9006 0000  	subw,s r[6], acc, y;	;		;		;			| if (r[6] <= -r[8])
    ccf  0a 00 3 1 0 d808 0cd2  	movw r[8], acc;		;		cjp, neg psinxt; ;			| 
    cd0  0a 00 e 0 0 c1ec 0000  	sub2nw 0, r[12], r[12];	;		;		;			| r[12]--
    cd1  0a 00 3 7 0 9886 0cd2  	addw r[6], acc, r[6];	;		cjp, go psinxt;	;			| r[6] += r[8]
    cd2  0a 0e e 0 0 d854 0000  psinxt:	movw r[20], y;		am->fpdp;	;		;			| 
    cd3  0a 0b e 0 0 d846 0000  	movw r[6], y;		am->fpregh;	;		;			| 
    cd4  0b 0b e 0 6 d84a 0000  	movw r[10], y;		am->fpregl;	;		;		dp+	| 
    cd5  0a 0b e 0 0 d847 0000  	movw r[7], y;		am->fpregh;	;		;			| 
    cd6  0b 0b e 0 6 d848 0000  	movw r[8], y;		am->fpregl;	;		;		dp+	| 
    cd7  0a 0b e 0 0 d84b 0000  	movw r[11], y;		am->fpregh;	;		;			| 
    cd8  0b 0b e 0 6 d84c 0000  	movw r[12], y;		am->fpregl;	;		;		dp+	| 
    cd9  0a 0b e 0 0 d849 0000  	movw r[9], y;		am->fpregh;	;		;			| 
    cda  0b 0b e 0 6 d845 0000  	movw r[5], y;		am->fpregl;	;		;		dp+	| 
    cdb  08 27 e 0 7 9e94 0004  	addw d, r[20], r[23];	4->am;	;		;			| 
    cdc  0a 0c 3 7 0 d857 0c60  	movw r[23], y;		am->fpap;	cjp, go psinit; ;			| 
                                |   Sort edge table on r[10] and on r[12] secondarily.
                                |   Bubble sort (?) for now.
                                |   From here on acc stores 4.
    cdd  0a 2c e 0 0 d904 0002  pssort:	movw 0, r[4];		2->fpap;	;		;			| Assume non-empty edge table.  do {
    cde  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    cdf  0a 27 e 0 0 f8c1 0004  	movw d, acc;		4->am;	;		;			| 
    ce0  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[20]= r[14]->r[18]
    ce1  0b 37 e 0 0 d8d4 0000  	movw d, r[20];		fpregl->am;	;		;			| 
    ce2  0a 0c e 0 0 9094 0000  pssort0: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    ce3  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    ce4  0a 0c 3 0 0 d854 0cfc  	movw r[20], y;		am->fpap;	cjp, zer psdowhile; ;			| 
    ce5  0b 37 e 0 0 d8ca 0000  	movw d, r[10];		fpregl->am;	;		;			| if (r[20]->r[10] > r[20]->r[18]->r[10]) {
    ce6  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| &r[20]->r[18]
    ce7  0b 37 e 0 0 d8d1 0000  	movw d, r[17];		fpregl->am;	;		;			| r[17]= r[20]->r[18]
    ce8  0b 3c e 0 0 7140 0000  	;			fpregl->fpap;	;		;			| &r[20]->next->r[10]
    ce9  03 37 e 0 0 964a 0000  	rsubw,s d, r[10], y;	fpregl->am;	;		;			| r[20]->r[10] > r[20]->r[18]->r[10]
    cea  08 0c 3 9 7 c3d4 0cf3  	add2nw 1, r[20], r[23];	am->fpap;	cjp, ~neg pssortx; ;			| r[20]->r[12]
    ceb  0a 0c e 0 0 9091 0000  psswaps: addw r[17], acc, y;	am->fpap;	;		;			| r[20]->r[18]= r[20]->r[18]->r[18]
    cec  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| 
    ced  0b 3b e 0 0 7140 0000  	;			fpregl->fpregl;	;		;			| 
    cee  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[17]->r[18]= r[14]->r[18]
    cef  0a 0e e 0 0 9091 0000  	addw r[17], acc, y;	am->fpdp;	;		;			| 
    cf0  0b 3b e 0 0 dd04 0000  	incw 0, r[4];		fpregl->fpregl;	;		;			| r[4]= 1
    cf1  0a 0e e 0 0 908e 0000  	addw r[14], acc, y;	am->fpdp;	;		;			| r[14]->r[18]= r[17]
    cf2  0b 0b 3 7 0 d851 0cf8  	movw r[17], y;		am->fpregl;	cjp, go pssort1; ;			| 
    cf3  0b 37 3 8 0 d8cc 0cf8  pssortx: movw d, r[12];		fpregl->am;	cjp, ~zer pssort1; ;			| r[20]->r[12]
    cf4  08 0c e 0 7 c3d1 0000  	add2nw 1, r[17], r[23];	am->fpap;	;		;			| r[20]->r[18]->r[12]
    cf5  03 37 e 0 0 960c 0000  	subw,s d, r[12], y;	fpregl->am;	;		;			| if (r[20]->r[12] > r[20]->r[18]->r[12]) {
    cf6  0a 00 3 0 0 7140 0cf8  	;			;		cjp, zer pssort1; ;			| 
    cf7  0a 00 3 9 0 7140 0ceb  	;			;		cjp, ~neg psswaps; ;			| r[4] }
    cf8  0a 0c e 0 0 908e 0000  pssort1: addw r[14], acc, y;	am->fpap;	;		;			| r[14]= r[14]->r[18]
    cf9  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    cfa  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[20]= r[14]->r[18]
    cfb  03 37 3 7 0 d8d4 0ce2  	movw,s d, r[20];		fpregl->am;	cjp, go pssort0; ;			| 
    cfc  02 00 e 0 0 d844 0000  psdowhile: movw,s r[4], y;	;		;		;			| } while (r[4])
    cfd  0a 00 3 8 0 7140 0cdd  	;			;		cjp, ~zer pssort; ;			| 
                                |   Ready to draw segments.
    cfe  02 00 e 0 0 d850 0000  psrdy:	movw,s r[16], y;	;		;		;			| 
                                |	;			;		cjp, go psrdy1;	;			| DEBUG.  Fits with pixrect.vp.u ppshinit.
    cff  0a 00 3 0 0 7140 0d16  	;			;		cjp, zer psrdy1; ;			| 
                                |   psinipp: ;			19->am;		;		;			| 
    d00  0a 27 e 0 0 7140 0015  psinipp: ;			21->am;	;		;			| DEBUG
    d01  0a 06 3 c 0 f8c0 0d01  	movw d, y;		am->fifo1;	cjp, f1f .;	;			| Send plhinit command (#19) to pp.
    d02  08 00 e 0 0 cc8f 0000  	sr0w r[15], r[0];	;		;		;			| 
    d03  0a 27 e 0 0 9ec0 000f  	andw d, r[0], r[0];	0xf->am;	;		;			| 
                                | PIXOP_NEEDS_DST (op << 1)= (op^(op << 1)) & 0xa
    d04  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| 
    d05  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
    d06  0a 00 e 0 0 8100 0000  	xorw r[0], acc, acc;	;		;		;			| 
    d07  02 27 e 0 0 e281 000a  	addw,s d, acc, acc;	0xa->am;	;		;			| 
    d08  0a 00 3 0 0 7140 0d0b  	;			;		cjp, zer psnodst; ;			| 
    d09  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| SWWPIX
    d0a  0a 00 3 7 0 7140 0d0c  	;			;		cjp, go psropreg; ;			| 
    d0b  0a 27 e 0 0 7140 0001  psnodst: ;			1->am;		;		;			| SRWPIX
    d0c  0a 06 3 c 0 f8c0 0d0c  psropreg: movw d, y;		am->fifo1;	cjp, f1f .;	;			| RopMode
    d0d  0a 06 3 c 0 d840 0d0d  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| Op
    d0e  0a 06 3 c 0 f900 0d0e  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Patt
    d0f  0a 06 3 c 0 f900 0d0f  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Mask2
    d10  0a 06 3 c 0 f900 0d10  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Mask1
    d11  0a 06 3 c 0 f900 0d11  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| r[14]
    d12  0a 06 3 c 0 f900 0d12  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| OpCnt
    d13  0a 06 3 c 0 f900 0d13  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Shift
    d14  0a 06 3 c 0 f900 0d14  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| PrimeSrc2
    d15  0a 27 e 0 0 f8c1 0004  	movw d, acc;		4->am;	;		;			| 
    d16  0a 2c e 0 0 7140 0002  psrdy1:	;			2->fpap;	;		;			| r[14]= et[0].r[18]
    d17  0b 37 e 0 0 7140 0000  	;			fpregl->am;	;		;			| 
    d18  0a 0c e 0 0 e280 0000  	addw d, acc, y;		am->fpap;	;		;			| 
    d19  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    d1a  0a 27 e 0 0 d8d1 07d0  	movw d, r[17];		2000->am;	;		;			| r[17]= aet
    d1b  0a 0c e 0 0 d84e 0000  	movw r[14], y;		am->fpap;	;		;			| r[13]= r[14]->r[10]
    d1c  0b 37 e 0 0 d8cd 0000  	movw d, r[13];		fpregl->am;	;		;			| 
    d1d  0a 0e e 0 0 9091 0000  	addw r[17], acc, y;	am->fpdp;	;		;			| r[17]->r[18]= 0
    d1e  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
                                |   Repeat until aet and et are empty.
                                |   Get current edges out of edge table (et) and put in active edge table.
    d1f  08 28 e 0 4 d971 0d34  psdo:	movw r[17], r[20];		=pspaint->brreg; ;		;			| r[20]= r[17]
    d20  02 0c e 0 0 d84e 0000  pswhily: movw,s r[14], y;		am->fpap;	;		;			| while (r[14] && (r[14]->r[10] <= r[13])) {
    d21  13 37 3 0 0 960d 0000  	subw,s d, r[13], y;	fpregl->am;	cjp, zer;	;			| (r[14]->r[10] <= r[13])
    d22  18 0c 3 1 0 c3ce 0000  	add2nw 1, r[14], r[0];	am->fpap;	cjp, neg;	;			| save r[14]->r[12]
    d23  0b 37 e 0 0 d8cc 0000  	movw d, r[12];		fpregl->am;	;		;			| 
    d24  0a 0c e 0 0 9094 0000  pswhilx: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18] && (
    d25  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| test r[20]->r[18] for 0
    d26  0a 00 3 0 0 7140 0d2b  	;			;		cjp, zer psetaet; ;			| 
    d27  08 0c e 0 7 c3d2 0000  	add2nw 1, r[18], r[23];	am->fpap;	;		;			| r[20]->r[18]->r[12]
    d28  03 37 e 0 0 964c 0000  	rsubw,s d, r[12], y;	fpregl->am;	;		;			| while( &&(r[20]->r[18]->r[12](a) < r[14]->r[12](b)))
    d29  0a 00 3 9 0 7140 0d2b  	;			;		cjp, ~neg psetaet; ;			| 
    d2a  08 00 3 7 4 d972 0d24  	movw r[18], r[20];		;		cjp, go pswhilx; ;			| { r[20]= r[20]->r[18] }
    d2b  08 00 e 0 3 d972 0000  psetaet: movw r[18], r[19];		;		;		;			| r[19]= r[20]->r[18]
    d2c  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| r[20]->r[18]= r[14]
    d2d  0b 0b e 0 0 d84e 0000  	movw r[14], y;		am->fpregl;	;		;			| 
    d2e  0a 07 e 0 0 d84e 0000  	movw r[14], y;		am->am;		;		;			| 
    d2f  0a 00 e 0 0 d8d2 0000  	movw d, r[18];		;		;		;			| 
    d30  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[14]= r[14]->r[18]
    d31  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    d32  0a 0e e 0 0 9092 0000  	addw r[18], acc, y;	am->fpdp;	;		;			| r[20]->r[18]->r[18]= r[19]
    d33  0b 0b 3 7 0 d853 0d20  	movw r[19], y;		am->fpregl;	cjp, go pswhily; ;			| }
                                |   Paint the current scanline segments.  We are guaranteed that the edges come in pairs.
    d34  0a 0c e 0 0 9091 0000  pspaint: addw r[17], acc, y;	am->fpap;	;		;			| r[20]= r[17]->r[18]
    d35  03 37 e 0 0 d8d4 0000  	movw,s d, r[20];		fpregl->am;	;		;			| 
    d36  0a 0c 3 0 0 9094 0d67  pswhp1:	addw r[20], acc, y;	am->fpap;	cjp, zer psremactive; ;			| while (r[20]) {  There are more edges
    d37  0b 37 c 0 0 d8d3 0003  	movw d, r[19];		fpregl->am;	ldct 3;		;			| 
                                |   First pixel x1= trunc (x + .4999 + r[11]/2)
    d38  02 28 e 0 0 d850 0d3c  	movw,s r[16], y;	=psppcmd->brreg; ;		;			| 
    d39  10 27 3 0 7 e1f0 0016  	btstw,s 0, r[16], r[23]; 22->am; cjp, zer;	;			| PPFill2DSeg (plgfill)
    d3a  1a 27 3 8 0 7140 001c  	;			28->am;	cjp, ~zer;	;			| 
    d3b  0a 27 e 0 0 7140 001d  	;			29->am;	;		;			| 
    d3c  0a 06 3 c 0 f8c0 0d3c  psppcmd:movw d, y;		am->fifo1;	cjp, f1f .;	;			| 
                                |   Args to plgfill:  r[13], x1, x2, color, op
                                |   Args to plgtex1:  r[13], x1, x2, color, color0, op, r[21], r[22]
                                |   Args to plgtex8:  r[13], x1, x2, op, r[21], r[22]
    d3d  0a 06 3 c 0 d84d 0d3d  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    d3e  08 0c e 0 7 c3d4 0000  	add2nw 1, r[20], r[23];	am->fpap;	;		;			| r[20]->r[12]
    d3f  0b 37 e 0 0 d8cc 0000  	movw d, r[12];		fpregl->am;	;		;			| 
    d40  0b 36 3 c 0 7140 0d40  	;			fpregl->fifo1;	cjp, f1f .;	;			| 
    d41  08 0c e 0 7 c3d3 0000  	add2nw 1, r[19], r[23];	am->fpap;	;		;			| r[19]->r[12]
    d42  0b 36 3 c 0 7140 0d42  	;			fpregl->fifo1;	cjp, f1f .;	;			| 
    d43  02 00 e 0 0 d850 0000  	movw,s r[16], y;	;		;		;			| 
    d44  00 00 3 0 7 e1f0 0d5e  	btstw,s 0, r[16], r[23]; ;		cjp, zer pstex0; ;			| 
    d45  0a 00 3 0 0 7140 0d55  	;			;		cjp, zer pstex8; ;			| 
                                |   pstex1:
    d46  08 00 e 0 0 97ef 0000  	rolw 11, r[15], r[0];	;		;		;			| Color in op
    d47  02 27 e 0 0 9ec0 07ff  	andw,s d, r[0], r[0];	0x7ff->am;	;		;			| if (color == 0) color= all ones.
    d48  0a 00 3 8 0 7140 0d4a  	;			;		cjp, ~zer .+2;	;			| 
    d49  0a 27 e 0 0 d8c0 ffff  	movw d, r[0];		0xffff->am;	;		;			| 
    d4a  0a 06 3 c 0 d840 0d4a  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    d4b  0a 06 3 c 0 f900 0d4b  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Color0
    d4c  08 27 e 0 0 9ecf 001f  	andw d, r[15], r[0];	0x1f->am;	;		;			| Op
    d4d  0a 06 3 c 0 d840 0d4d  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    d4e  02 07 e 0 0 d84c 0000  	movw,s r[12], y;		am->am;		;		;			| 
    d4f  08 00 e 0 7 9e95 0000  	addw d, r[21], r[23];	;		;		;			| 
    d50  0a 06 3 c 0 d857 0d50  	movw r[23], y;		am->fifo1;	cjp, f1f .;	;			| r[21]
    d51  0a 07 e 0 0 d84d 0000  	movw r[13], y;		am->am;		;		;			| 
    d52  08 00 e 0 7 9e96 0000  	addw d, r[22], r[23];	;		;		;			| 
    d53  0a 06 3 c 0 d857 0d53  	movw r[23], y;		am->fifo1;	cjp, f1f .;	;			| r[22]
    d54  0a 00 3 7 0 7140 0d63  	;			;		cjp, go psnxtseg; ;			| 
    d55  08 27 e 0 0 9ecf 001f  pstex8:	andw d, r[15], r[0];	0x1f->am;	;		;			| Op
    d56  0a 06 3 c 0 d840 0d56  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    d57  02 07 e 0 0 d84c 0000  	movw,s r[12], y;		am->am;		;		;			| 
    d58  08 00 e 0 7 9e95 0000  	addw d, r[21], r[23];	;		;		;			| 
    d59  0a 06 3 c 0 d857 0d59  	movw r[23], y;		am->fifo1;	cjp, f1f .;	;			| r[21]
    d5a  0a 07 e 0 0 d84d 0000  	movw r[13], y;		am->am;		;		;			| 
    d5b  08 00 e 0 7 9e96 0000  	addw d, r[22], r[23];	;		;		;			| 
    d5c  0a 06 3 c 0 d857 0d5c  	movw r[23], y;		am->fifo1;	cjp, f1f .;	;			| r[22]
    d5d  0a 00 3 7 0 7140 0d63  	;			;		cjp, go psnxtseg; ;			| 
    d5e  08 00 e 0 0 97ef 0000  pstex0:	rolw 11, r[15], r[0];	;		;		;			| Color in op
    d5f  0a 27 e 0 0 9ec0 07ff  	andw d, r[0], r[0];	0x7ff->am;	;		;			| 
    d60  0a 06 3 c 0 d840 0d60  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    d61  08 27 e 0 0 9ecf 001f  	andw d, r[15], r[0];	0x1f->am;	;		;			| Op
    d62  0a 06 3 c 0 d840 0d62  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    d63  0a 0c e 0 0 9093 0000  psnxtseg:addw r[19], acc, y;	am->fpap;	;		;			| r[20]= r[19]->r[18]
    d64  03 37 e 0 0 d8d4 0000  	movw,s d, r[20];		fpregl->am;	;		;			| 
    d65  0a 0c 3 0 0 9094 0d67  	addw r[20], acc, y;	am->fpap;	cjp, zer psremactive; ;			| if (r[20]) r[19]= r[20]->r[18].  NB while (r[20])
    d66  0b 37 3 7 0 d8d3 0d36  	movw d, r[19];		fpregl->am;	cjp, go pswhp1;	;			| 
                                |   Remove active edges whose ymax <= r[13]
    d67  0a 00 e 0 0 dd6d 0000  psremactive: incw r[13], r[13];	;		;		;			| r[13]++.  Step to next scanline
    d68  08 00 e 0 4 d971 0000  	movw r[17], r[20];		;		;		;			| r[20]= r[17]
    d69  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    d6a  03 37 e 0 0 d8d2 0000  psremwh: movw,s d, r[18];		fpregl->am;	;		;			| 
    d6b  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| 
    d6c  0a 0c 3 0 0 9692 0d73  	addw d, r[18], y;		am->fpap;	cjp, zer psupx;	;			| if (r[20]->r[18]->r[9] <= r[13])
    d6d  02 37 e 0 0 960d 0000  	subw,s d, r[13], y;	fpregh->am;	;		;			| 
    d6e  0a 0c 3 1 0 9092 0d71  	addw r[18], acc, y;	am->fpap;	cjp, neg psstep; ;			| r[20]->r[18]= r[20]->r[18]->r[18]
    d6f  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| 
    d70  0b 3b 3 7 0 7140 0d6a  	;			fpregl->fpregl;	cjp, go psremwh; ;			| 
    d71  08 00 e 0 4 d972 0000  psstep:	movw r[18], r[20];		;		;		;			| else r[20]= r[20]->r[18]
    d72  0a 0c 3 7 0 9094 0d6a  	addw r[20], acc, y;	am->fpap;	cjp, go psremwh; ;			| 
                                |   Update x values in aet
    d73  08 00 e 0 4 d971 0000  psupx:	movw r[17], r[20];		;		;		;			| r[20]= r[17]
    d74  0a 0c e 0 0 9094 0000  psupxwhile: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    d75  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    d76  08 00 3 0 4 d972 0da5  	movw r[18], r[20];		;		cjp, zer psresort; ;			| r[20]= r[20]->r[18]
    d77  0a 0c e 0 0 dc54 0000  	incw r[20], y;		am->fpap;	;		;			| 
    d78  02 37 e 0 0 d8c7 0000  	movw,s d, r[7];		fpregh->am;	;		;			| if (r[7] >= 0) ....
    d79  0b 37 3 1 0 d8c8 0d8e  	movw d, r[8];		fpregl->am;	cjp, neg psupx23; ;			| 
    d7a  02 00 e 0 4 9647 0000  psupx01: rsubw,s d, r[7], y;	;		;		;		ap+	| if (r[8] < r[7]) ....
    d7b  0b 37 3 9 0 d8cc 0d88  	movw d, r[12];		fpregl->am;	cjp, ~neg psupx1; ;			| 
    d7c  0a 37 e 0 0 9e8c 0000  psupx0:	addw d, r[12], r[12];	fpregh->am;	;		;			| OCTANT 0.  r[12] += r[11]
    d7d  0a 0c e 0 0 d854 0000  	movw r[20], y;		am->fpap;	;		;			| 
    d7e  0a 37 e 0 0 d8c6 0000  	movw d, r[6];		fpregh->am;	;		;			| 
    d7f  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| 
    d80  0a 0c e 0 0 9694 0000  	addw d, r[20], y;		am->fpap;	;		;			| 
    d81  03 37 e 0 0 9e86 0000  	addw,s d, r[6], r[6];	fpregl->am;	;		;			| r[6] += r[11] * r[8].  if (r[6] <= 0)....
    d82  0a 07 e 0 0 d847 0000  	movw r[7], y;		am->am;		;		;			| 
    d83  0a 00 3 1 0 9e06 0d85  	subw d, r[6], r[6];	;		cjp, neg psupx0if; ;			| r[6] -= r[7].
    d84  0a 00 3 8 0 7140 0da1  	;			;		cjp, ~zer psupxdo; ;			| Save r[12] & r[6], and loopback.
    d85  0a 07 e 0 0 d848 0000  psupx0if: movw r[8], y;		am->am;		;		;			| 
    d86  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| r[6] += r[8].
    d87  0a 00 3 7 0 dd6c 0da1  psupx0xmn: incw r[12], r[12];	;		cjp, go psupxdo; ;			| r[12]++.
    d88  0a 0c e 0 0 d854 0000  psupx1:	movw r[20], y;		am->fpap;	;		;			| OCTANT 1
    d89  00 37 e 0 6 9e87 0000  	addw,s d, r[7], r[6];	fpregh->am;	;		;			| r[6] += r[7]
    d8a  0a 00 3 1 0 7140 0da1  	;			;		cjp, neg psupxdo; ;			| 
    d8b  0a 07 3 0 0 d848 0da1  	movw r[8], y;		am->am;		cjp, zer psupxdo; ;			| 
    d8c  0a 00 e 0 0 9e06 0000  	subw d, r[6], r[6];	;		;		;			| r[6] -= r[8]
    d8d  0a 00 3 7 0 dd6c 0da1  	incw r[12], r[12];		;		cjp, go psupxdo; ;			| 
    d8e  08 00 e 0 0 df67 0000  psupx23: negw r[7], r[0];	;		;		;			| 
    d8f  02 00 e 0 4 9640 0000  	rsubw,s d, r[0], y;	;		;		;		ap+	| if (r[8] < -r[7])
    d90  0b 37 3 9 0 d8cc 0d9a  	movw d, r[12];		fpregl->am;	cjp, ~neg psupx2; ;			| 
    d91  0a 37 e 0 0 9e8c 0000  psupx3:	addw d, r[12], r[12];	fpregh->am;	;		;			| OCTANT 3.  r[12] += r[11]
    d92  0a 0c e 0 0 d854 0000  	movw r[20], y;		am->fpap;	;		;			| 
    d93  00 37 e 0 6 9e47 0000  	rsubw,s d, r[7], r[6];	fpregh->am;	;		;			| r[6] -= r[7]
    d94  08 0c 3 1 7 c3d4 0d98  	add2nw 1, r[20], r[23];	am->fpap;	cjp, neg psupx3a; ;			| prepare to access r[11] * r[8] (r[20] +3)
    d95  0a 07 3 0 0 d848 0d98  	movw r[8], y;		am->am;		cjp, zer psupx3a; ;			| if (r[6] > 0) ...
    d96  0a 00 e 0 0 9e06 0000  	subw d, r[6], r[6];	;		;		;			| 
    d97  0a 00 e 0 0 c1ec 0000  	sub2nw 0, r[12], r[12];	;		;		;			| 
    d98  0a 00 e 0 4 7140 0000  psupx3a: ;			;		;		;		ap+	| 
    d99  0b 37 3 7 0 9e86 0da1  	addw d, r[6], r[6];	fpregl->am;	cjp, go psupxdo; ;			| r[6] += r[11] * r[8]
    d9a  0a 0c e 0 0 d854 0000  psupx2:	movw r[20], y;		am->fpap;	;		;			| OCTANT 2.
    d9b  08 37 e 0 6 9e87 0000  	addw d, r[7], r[6];	fpregh->am;	;		;			| r[6] += r[7]
    d9c  0a 07 e 0 0 de48 0000  	negw r[8], y;		am->am;		;		;			| 
    d9d  02 00 e 0 0 9646 0000  	rsubw,s d, r[6], y;	;		;		;			| 
    d9e  0a 07 3 1 0 d848 0da1  	movw r[8], y;		am->am;		cjp, neg psupxdo; ;			| 
    d9f  0a 00 e 0 0 9e86 0000  	addw d, r[6], r[6];	;		;		;			| 
    da0  0a 00 3 7 0 c1ec 0da1  	sub2nw 0, r[12], r[12];	;		cjp, go psupxdo; ;			| 
    da1  0a 0e e 0 0 d854 0000  psupxdo: movw r[20], y;		am->fpdp;	;		;			| Save r[12] & r[6], and loopback.
    da2  0a 0b e 0 0 d846 0000  	movw r[6], y;		am->fpregh;	;		;			| 
    da3  08 0e e 0 7 c3d4 0000  	add2nw 1, r[20], r[23];	am->fpdp;	;		;			| 
    da4  0b 0b 3 7 0 d84c 0d74  	movw r[12], y;		am->fpregl;	cjp, go psupxwhile; ;			| 
                                |   Resort on > r[12] because previous step may have crossed edges.
    da5  08 00 e 0 4 d971 0000  psresort: movw r[17], r[20];	;		;		;			| r[20]= r[17]
    da6  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| if (r[20]->r[18])
    da7  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    da8  0a 00 3 0 0 7140 0dc6  	;			;		cjp, zer pswhend; ;			| 
    da9  08 00 e 0 4 d971 0000  psrsdo:	movw r[17], r[20];		;		;		;			| do { r[20]= r[17]
    daa  08 00 e 0 3 d972 0000  	movw r[18], r[19];		;		;		;			| r[19]= r[20]->r[18]
    dab  0a 00 e 0 0 d904 0000  	movw 0, r[4];		;		;		;			| r[4]= 0
    dac  0a 0c e 0 0 9093 0000  pswhp2nxt: addw r[19], acc, y;	am->fpap;	;		;			| while (r[19]->r[18])
    dad  03 37 e 0 0 d8c0 0000  	movw,s d, r[0];		fpregl->am;	;		;			| 
    dae  0a 00 3 0 0 7140 0dc4  	;			;		cjp, zer psdoswap; ;			| if (r[19]->r[12] > r[19]->r[18]->r[12])
    daf  08 0c e 0 1 c3c0 0000  	add2nw 1, r[0], r[1];	am->fpap;	;		;			| r[19]->r[18]->r[12]
    db0  0b 37 e 0 0 d8cc 0000  	movw d, r[12];		fpregl->am;	;		;			| 
    db1  08 0c e 0 7 c3d3 0000  	add2nw 1, r[19], r[23];	am->fpap;	;		;			| 
    db2  03 37 e 0 0 964c 0000  	rsubw,s d, r[12], y;	fpregl->am;	;		;			| 
    db3  0a 00 3 0 0 7140 0dc0  	;			;		cjp, zer psrselse; ;			| 
    db4  0a 00 3 1 0 7140 0dc0  	;			;		cjp, neg psrselse; ;			| 
    db5  0a 0e e 0 0 9094 0000  psrsthen: addw r[20], acc, y;	am->fpdp;	;		;			| r[20]->r[18]= r[19]->r[18]
    db6  0b 0b e 0 0 d840 0000  	movw r[0], y;		am->fpregl;	;		;			| 
    db7  0a 0e e 0 0 9093 0000  	addw r[19], acc, y;	am->fpdp;	;		;			| r[19]->r[18]= r[19]->r[18]->r[18]
    db8  0a 0c e 0 0 9080 0000  	addw r[0], acc, y;	am->fpap;	;		;			| 
    db9  0b 3b e 0 0 7140 0000  	;			fpregl->fpregl;	;		;			| 
    dba  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| r[20]->r[18]->r[18]= r[19]
    dbb  0b 37 e 0 0 d8d2 0000  	movw d, r[18];		fpregl->am;	;		;			| 
    dbc  0a 0e e 0 0 9092 0000  	addw r[18], acc, y;	am->fpdp;	;		;			| 
    dbd  0b 0b e 0 0 d853 0000  	movw r[19], y;		am->fpregl;	;		;			| 
    dbe  08 00 e 0 4 d972 0000  	movw r[18], r[20];		;		;		;			| r[20]= r[20]->r[18]
    dbf  0a 00 3 7 0 dd04 0dac  	incw 0, r[4];		;		cjp, go pswhp2nxt; ;			| r[4]= 1
    dc0  0a 0c e 0 0 9094 0000  psrselse: addw r[20], acc, y;	am->fpap;	;		;			| r[20]= r[20]->r[18]
    dc1  0b 37 e 0 0 d8d4 0000  	movw d, r[20];		fpregl->am;	;		;			| 
    dc2  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| r[19]= r[20]->r[18]
    dc3  0b 37 3 7 0 d8d3 0dac  	movw d, r[19];		fpregl->am;	cjp, go pswhp2nxt; ;			| 
    dc4  02 00 e 0 0 d844 0000  psdoswap: movw,s r[4], y;	;		;		;			| } while (r[4])
    dc5  0a 00 3 8 0 7140 0da9  	;			;		cjp, ~zer psrsdo; ;			| 
    dc6  0a 0c e 0 0 9091 0000  pswhend: addw r[17], acc, y;	am->fpap;	;		;			| } while (r[17]->r[18] || r[14])
    dc7  03 37 e 0 0 f8c0 0000  	movw,s d, y;		fpregl->am;	;		;			| r[17]->r[18]
    dc8  02 00 3 8 0 d84e 0d1f  	movw,s r[14], y;		;		cjp, ~zer psdo;	;			| 
    dc9  0a 00 3 8 0 7140 0d1f  	;			;		cjp, ~zer psdo;	;			| 
    dca  1a 00 a 7 0 7140 0000  	;			;		crtn, go;	;			| 
                                | "@(#)polyscan3.vp.u 1.2 86/09/12 SMI"
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |   3D Polygon scan conversion.  See also polyscan.vp.u
                                |   Polygon scan conversion.  Polygon may have multiple holes.
                                |   Based on pr_polygon2.c which is derived from Foley and Van Dam pg. 459.
                                |   Pixel vertices are offset by (-.5, 0)
                                |   Input:
                                |   	r[15]	colorop	PIX_OP | PIX_COLOR (color)
                                |   	r[14]	pet	pointer to edge table in FP register memory.  First edge is a dummy.  Will be around 0x80.
                                |   typedef struct EdgeZC {	(Edge for polyhedral shading)
                                |	int ymn, ymx;	(16 bit integers, value in the hi 16 bits)
                                |	float dx, dz, dc;	(These start off life as max values.  z is 0 to 2**16 - 1, c is -2**23 to 2**23 - 1.)
                                |   		(color was 24 bits (0 to 2**24 - 1) but xfpolygon3.vp.u subtracted 2**23 from it).
                                |	float xmn, zmn, cmn;	
                                |	Edge *nxt;	(int in low 16 bits.)
                                |   } EdgeZC;
    dcb  0a 2e e 0 0 7140 0010  polyscan3: ;			0x10->fpdp;	;		;			| 
    dcc  0a 2b e 0 0 7140 3f00  	;			0x3f00->fpregh;	;		;			| 0.5
    dcd  0b 2b e 0 6 7140 0000  	;			0->fpregl;	;		;		dp+	| 
    dce  0a 2b e 0 0 7140 c700  	;			0xc700->fpregh;	;		;			| ShiftZ value of -32768.0
    dcf  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
    dd0  0a 2b e 0 0 7140 4380  	;			0x4380->fpregh;	;		;			| Multiply z by 256 (shift up 8 bits).
    dd1  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
    dd2  0a 2e e 0 0 7140 0002  	;			2->fpdp;	;		;			| save pointer to edge table.
    dd3  0b 0b e 0 0 d84e 0000  	movw r[14], y;		am->fpregl;	;		;			| 
    dd4  0a 27 e 0 0 7140 0008  	;			8->am;	;		;			| r[20]= et [0].r[18].  Skip dummy first edge
    dd5  0a 0c e 0 0 968e 0000  	addw d, r[14], y;		am->fpap;	;		;			| 
    dd6  0a 27 e 0 0 d8c6 7f80  	movw d, r[6];		0x7f80->am;	;		;			| 
    dd7  0a 27 e 0 0 d8c5 807f  	movw d, r[5];	0x807f->am;	;		;			| 
                                |   Initialize the edge values:  For all edges ymin must be lowest.
    dd8  23 37 e 0 0 d8d4 0270  p3iedge: movw,s d, r[20];		fpregl->am;	;		lmode rz, ai, pipe, fast;| while (r[20])
    dd9  02 00 3 0 0 f1f0 0e6a  	btstw,s 8, r[16];	;		cjp, zer p3sort; ;			| for all edges, ymin must be < r[8].
    dda  0a 00 3 0 0 7140 0de6  	;			;		cjp, zer p3noz; ;			| 
    ddb  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| Shift first z up 7 bits (7 + 16 == 23).
    ddc  0a 0c e 0 0 9694 0000  	addw d, r[20], y;		am->fpap;	;		;			| 
    ddd  0a 0e e 0 0 9694 0000  	addw d, r[20], y;		am->fpdp;	;		;			| 
    dde  0a 37 e 0 0 d8c0 0000  	movw d, r[0];		fpregh->am;	;		;			| 
    ddf  0a 27 e 0 0 f8c1 0380  	movw d, acc;		0x380->am;	;		;			| 
    de0  0a 0b e 0 0 9080 0000  	addw r[0], acc, y;	am->fpregh;	;		;			| 
    de1  0a 27 e 0 0 7140 0006  	;			6->am;		;		;			| Shift second z up 7 bits (7 + 16 == 23).
    de2  0a 0c e 0 0 9694 0000  	addw d, r[20], y;		am->fpap;	;		;			| 
    de3  0a 0e e 0 0 9694 0000  	addw d, r[20], y;		am->fpdp;	;		;			| 
    de4  0a 37 e 0 0 d8c0 0000  	movw d, r[0];		fpregh->am;	;		;			| 
    de5  0a 0b e 0 0 9080 0000  	addw r[0], acc, y;	am->fpregh;	;		;			| Done shifting z.
    de6  0a 0c e 0 0 d854 0000  p3noz:	movw r[20], y;		am->fpap;	;		;			| 
    de7  0a 37 e 0 4 d8c9 0000  	movw d, r[9];		fpregh->am;	;		;		ap+	| r[20]->r[9]
    de8  0a 37 e 0 0 d8c8 0000  	movw d, r[8];		fpregh->am;	;		;			| 
    de9  20 37 e 0 7 9e09 0230  	subw,s d, r[9], r[7];	fpregh->am;	;		lmode rn, ai, flow, fast;| r[9] - r[8]
    dea  0a 2e e 0 0 7140 0000  	;			0->fpdp;	;		;			| 
    deb  0a 0b 3 9 0 f900 0e27  	movw 0, y;		am->fpregh;	cjp, ~neg p3swap; ;			| 
    dec  0b 0b c 0 0 de47 0003  	negw r[7], y;		am->fpregl;	ldct 3;		;			| 
    ded  0a 2c e 0 0 7140 0000  	;			0->fpap;	;		;			| 
    dee  2a 00 e 0 0 f8e0 00a0  	movw =recip, y;		;		;		floata, la, hi;		| 
    def  3b 08 4 f 0 034a 00a0  	;			am->brreg;	push, ~go;	;			| 
    df0  1a 00 8 0 0 7140 0000  	;			;		rfct;		;			| 
    df1  2a 00 e 0 0 7140 0102  	;			;		;		adda, a, hi;		| 
    df2  2b 00 e 0 0 7140 0102  	;			;		;		;			| 
    df3  2a 00 e 0 0 7140 0101  	;			;		;		adda, st, hi;		| 
    df4  2b 00 e 0 0 7140 0101  	;			;		;		;			| move from one register set to another.
    df5  1a 27 1 7 0 d8c2 0001  	movw d, r[2];		1->am;	cjs, go;	;			| load dp arg (r[2]) for recip of r[7].
    df6  29 0c e 0 b c3d4 0270  	add2nw 1, r[20], r[27];	am->fpap;	;		lmode rz, ai, pipe, fast;| Reset mode after return from recip
    df7  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| 
    df8  08 0d e 0 b 9e94 0000  	addw d, r[20], r[27];	am->fpbp;	;		;			| 
    df9  2a 00 e 0 0 7140 0150  	;			;		;		suba, lab, hi;		| r[20]->xmx - r[20]->r[12]
    dfa  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+	| 
    dfb  2a 00 e 0 0 7140 0150  	;			;		;		suba, lab, hi;		| r[20]->zmx - r[20]->zmn
    dfc  2b 00 e 0 7 7140 0150  	;			;		;		;		abp+	| 
    dfd  2a 00 e 0 0 7140 0150  	;			;		;		suba, lab, hi;		| r[20]->cmx - r[20]->cmn
    dfe  2b 00 e 0 0 7140 0150  	;			;		;		;			| 
    dff  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    e00  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    e01  2a 0d e 0 0 fd00 0122  	incw 0, y;		am->fpbp;	;		adda,la, a, hi;		| 1->fpbp
    e02  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    e03  2a 00 e 0 0 7140 001a  	;			;		;		mabr, lab, a, hi;	| * 1 / r[7].
    e04  2b 00 e 0 0 7140 001a  	;			;		;		;			| 
    e05  2a 00 e 0 0 7140 001a  	;			;		;		mabr, lab, a, hi;	| * 1 / r[7].
    e06  2b 00 e 0 0 7140 001a  	;			;		;		;			| 
    e07  2a 00 e 0 0 7140 0018  	;			;		;		mabr, lab, hi;		| * 1 / r[7].
    e08  2b 00 e 0 0 7140 0018  	;			;		;		;			| 
    e09  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    e0a  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    e0b  28 0e e 0 b c3d4 0124  	add2nw 1, r[20], r[27];	am->fpdp;	;		adda,la, m, hi;		| 
    e0c  2b 00 e 0 0 7140 0124  	;			;		;		;			| 
    e0d  2a 00 e 0 0 7140 0125  	;			;		;		adda,la, m, st, hi;		| Store r[11].
    e0e  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+	| 
    e0f  2a 00 e 0 0 7140 0125  	;			;		;		adda,la, m, st, hi;		| Store r[23].
    e10  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+	| 
    e11  28 0c e 0 b c3d4 0121  	add2nw 1, r[20], r[27];	am->fpap;	;		adda,la, st, hi;		| Store r[25].
    e12  29 0d e 0 b c5d4 0121  	add2nw 2, r[20], r[27];	am->fpbp;	;		;			| 
    e13  02 37 e 0 0 d8c0 0000  	movw,s d, r[0];		fpregh->am;	;		;			| if (r[11] < 0)
                                |	add2nw 1, r[20], r[27];	am->fpdp;	cjp, ~neg p3dxok; ;			| 
    e14  08 0e 3 7 b c3d4 0e16  	add2nw 1, r[20], r[27];	am->fpdp;	cjp, go p3dxok; ;			| 
    e15  0a 0b e 0 0 ffc0 0000  	bclrw 15, r[0], r[0];	am->fpregh;	;		;			| 
    e16  2a 00 e 0 0 cf80 0270  p3dxok:	mov2nw 7, r[0];		;		;		lmode rz, ai, flow, fast;| Wait to use fpregh.
    e17  02 37 e 0 0 86c6 0000  	andw,s d, r[6], acc;	fpregh->am;	;		;			| 
    e18  0a 00 3 0 5 8000 0e1a  	subw r[0], acc, acc;	;		cjp, zer p3xmn;	;		bp+	| r[11] / 2
    e19  0a 0b e 0 0 a105 0000  	romw 0, d, acc, r[5]; am->fpregh;	;		;			| 
    e1a  0a 28 e 0 6 7140 0003  p3xmn:	;			3->brreg;	;		;		dp+	| Wait for fpreg memory cycle.
    e1b  2a 00 e 0 6 7140 0110  	;			;		;		adda, lab, hi;	dp+	| pxmn += r[11] / 2
    e1c  3b 00 4 7 6 7140 0110  	;			;		push, go;	;		dp+	| 
    e1d  1a 00 8 0 0 7140 0000  	;			;		rfct;		;			| 
    e1e  2a 00 e 0 0 7140 0102  	;			;		;		adda, a, hi;		| 
    e1f  2b 00 e 0 0 f8e0 0102  	movw =p3xmn1, y;	;		;		;			| 
    e20  2a 08 e 0 0 0e25 0101  	;			am->brreg;	;		adda, st, hi;		| Store pxmn.
    e21  39 0e 3 0 b c3d4 0101  	add2nw 1, r[20], r[27];	am->fpdp;	cjp, zer;	;			| 
    e22  0a 37 e 0 0 86c6 0000  	andw d, r[6], acc;	fpregh->am;	;		;			| 
    e23  0a 00 e 0 0 8080 0000  	addw r[0], acc, acc;	;		;		;			| Restore r[11] * 2
    e24  0a 0b e 0 0 a105 0000  	romw 0, d, acc, r[5]; am->fpregh;	;		;			| 
    e25  08 27 e 0 b 9e94 0008  p3xmn1:	addw d, r[20], r[27];	8->am;	;		;			| 
    e26  0a 0c 3 7 0 d85b 0dd8  	movw r[27], y;		am->fpap;	cjp, go p3iedge; ;			| 
                                |   if (r[20]->r[9] > r[20]->r[8]) i.e. neg:  r[7] = r[20]->r[8] - r[20]->r[9]
    e27  0b 0b c 0 0 d847 0003  p3swap:	movw r[7], y;		am->fpregl;	ldct 3;		;			| 
    e28  0a 2c e 0 0 7140 0000  	;			0->fpap;	;		;			| 
    e29  0a 0e e 0 0 d854 0000  	movw r[20], y;		am->fpdp;	;		;			| 
    e2a  2a 0b e 0 0 d848 00a0  	movw r[8], y;		am->fpregh;	;		floata, la, hi;		| Swap r[9] and r[8].
    e2b  3b 00 4 f 6 7140 00a0  	;			;		push, ~go;	;		dp+	| 
    e2c  1a 28 8 0 0 7140 034a  	;			=recip->brreg;	rfct;		;			| 
    e2d  2a 0b e 0 0 d849 0102  	movw r[9], y;		am->fpregh;	;		adda, a, hi;		| 
    e2e  2b 0e e 0 0 f900 0102  	movw 0, y;		am->fpdp;	;		;			| 
    e2f  2a 0c e 0 0 f900 0101  	movw 0, y;		am->fpap;	;		adda, st, hi;		| 
    e30  2b 00 e 0 0 7140 0101  	;			;		;		;			| 
    e31  1a 27 1 7 0 d8c2 0001  	movw d, r[2];		1->am;	cjs, go;	;			| load dp arg (r[2]) for recip of r[7].
    e32  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| 
    e33  2b 0d e 0 0 9694 0270  	addw d, r[20], y;		am->fpbp;	;		lmode rz, ai, pipe, fast;| 
    e34  08 0c e 0 b c3d4 0000  	add2nw 1, r[20], r[27];	am->fpap;	;		;			| 
    e35  2a 37 e 0 0 d8cb 0190  	movw d, r[11];		fpregh->am;	;		rsuba, lab, hi;		| r[20]->r[12] - r[20]->r[11]
    e36  2b 37 e 0 7 d8ca 0190  	movw d, r[10];		fpregl->am;	;		;		abp+	| Save r[20]->r[11] for implicit r[3]
    e37  2a 37 e 0 0 d8d7 0190  	movw d, r[23];		fpregh->am;	;		rsuba, lab, hi;		| r[20]->zmn - r[20]->r[23]
    e38  2b 37 e 0 7 d8d8 0190  	movw d, r[24];		fpregl->am;	;		;		abp+	| Save r[20]->r[23] for implicit r[3]
    e39  2a 37 e 0 0 d8d9 0190  	movw d, r[25];		fpregh->am;	;		rsuba, lab, hi;		| r[20]->cmn - r[20]->r[25]
    e3a  2b 37 e 0 0 d8da 0190  	movw d, r[26];		fpregl->am;	;		;			| Save r[20]->r[25] for implicit r[3]
    e3b  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    e3c  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    e3d  2a 0d e 0 0 fd00 0122  	incw 0, y;		am->fpbp;	;		adda,la, a, hi;		| 1->fpbp
    e3e  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    e3f  2a 00 e 0 0 7140 001a  	;			;		;		mabr, lab, a, hi;	| * 1 / r[7].
    e40  2b 00 e 0 0 7140 001a  	;			;		;		;			| 
    e41  2a 00 e 0 0 7140 001a  	;			;		;		mabr, lab, a, hi;	| * 1 / r[7].
    e42  2b 00 e 0 0 7140 001a  	;			;		;		;			| 
    e43  2a 00 e 0 0 7140 0018  	;			;		;		mabr, lab, hi;		| * 1 / r[7].
    e44  2b 00 e 0 0 7140 0018  	;			;		;		;			| 
    e45  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    e46  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    e47  2a 00 e 0 0 7140 0124  	;			;		;		adda,la, m, hi;		| 
    e48  29 0e e 0 b c3d4 0124  	add2nw 1, r[20], r[27];	am->fpdp;	;		;			| 
    e49  2a 00 e 0 0 7140 0125  	;			;		;		adda,la, m, st, hi;		| store r[11].
    e4a  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+	| 
    e4b  2a 00 e 0 0 7140 0125  	;			;		;		adda,la, m, st, hi;		| store r[23].
    e4c  2b 00 e 0 6 7140 0125  	;			;		;		;		dp+	| 
    e4d  28 0c e 0 b c3d4 0121  	add2nw 1, r[20], r[27];	am->fpap;	;		adda,la, st, hi;		| store r[25].
    e4e  29 0d e 0 b c5d4 0121  	add2nw 2, r[20], r[27];	am->fpbp;	;		;			| 
    e4f  02 37 e 0 0 d8c0 0000  	movw,s d, r[0];		fpregh->am;	;		;			| 
                                |	add2nw 1, r[20], r[27];	am->fpdp;	cjp, ~neg p3dxok1; ;			| 
    e50  08 0e 3 7 b c3d4 0e52  	add2nw 1, r[20], r[27];	am->fpdp;	cjp, go p3dxok1; ;			| 
    e51  0a 0b e 0 0 ffc0 0000  	bclrw 15, r[0], r[0];	am->fpregh;	;		;			| 
    e52  2a 00 e 0 0 cf80 0270  p3dxok1: mov2nw 7, r[0];	;		;		lmode rz, ai, flow, fast;| 
    e53  02 37 e 0 0 86c6 0000  	andw,s d, r[6], acc;	fpregh->am;	;		;			| 
    e54  0a 00 3 0 5 8000 0e56  	subw r[0], acc, acc;	;		cjp, zer p3xmn2; ;		bp+	| r[11] / 2
    e55  0a 0b e 0 0 a105 0000  	romw 0, d, acc, r[5]; am->fpregh;	;		;			| 
    e56  0a 28 e 0 0 9494 0003  p3xmn2:	addw r[20], 5, y;		3->brreg;	;		;			| 
    e57  0a 0e e 0 0 0005 0000  	;			am->fpdp;	;		;			| 
    e58  0a 0b e 0 0 d84b 0000  	movw r[11], y;		am->fpregh;	;		;			| saveddx + (r[11] / 2)
    e59  0b 0b e 0 6 d84a 0000  	movw r[10], y;		am->fpregl;	;		;		dp+	| 
    e5a  0a 0b e 0 0 d857 0000  	movw r[23], y;		am->fpregh;	;		;			| saveddx + (r[11] / 2)
    e5b  0b 0b e 0 6 d858 0000  	movw r[24], y;		am->fpregl;	;		;		dp+	| 
    e5c  0a 0b e 0 0 d859 0000  	movw r[25], y;		am->fpregh;	;		;			| saveddx + (r[11] / 2)
    e5d  0b 0b e 0 0 d85a 0000  	movw r[26], y;		am->fpregl;	;		;			| 
    e5e  28 0e e 0 b c5d4 0110  	add2nw 2, r[20], r[27];	am->fpdp;	;		adda, lab, hi;		| pxmn += r[11] / 2
    e5f  3b 00 4 7 6 7140 0110  	;			;		push, go;	;		dp+	| 
    e60  1a 27 8 0 0 7140 0003  	;			3->am;		rfct;		;			| 
    e61  2a 00 e 0 0 7140 0102  	;			;		;		adda, a, hi;		| 
    e62  2b 00 e 0 0 f8e0 0102  	movw =p3xmn3, y;	;		;		;			| 
    e63  2a 08 e 0 0 0e68 0101  	;			am->brreg;	;		adda, st, hi;		| Store pxmn.
    e64  39 0e 3 0 b c3d4 0101  	add2nw 1, r[20], r[27];	am->fpdp;	cjp, zer;	;			| 
    e65  0a 37 e 0 0 86c6 0000  	andw d, r[6], acc;	fpregh->am;	;		;			| 
    e66  0a 00 e 0 0 8080 0000  	addw r[0], acc, acc;	;		;		;			| Restore r[11] * 2
    e67  0a 0b e 0 0 a105 0000  	romw 0, d, acc, r[5]; am->fpregh;	;		;			| 
    e68  08 27 e 0 b 9e94 0008  p3xmn3:	addw d, r[20], r[27];	8->am;	;		;			| 
    e69  0a 0c 3 7 0 d85b 0dd8  	movw r[27], y;		am->fpap;	cjp, go p3iedge; ;			| 
                                |   Sort edge table on r[9] and on r[12] secondarily.
                                |   Bubble sort (?) for now.
                                |   From here on acc stores 8.
    e6a  0a 2c e 0 0 d903 0002  p3sort:	movw 0, r[3];		2->fpap;	;		;			| Assume non-empty edge table.  do {
    e6b  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    e6c  0a 27 e 0 0 f8c1 0008  	movw d, acc;		8->am;	;		;			| 
    e6d  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[20]= r[14]->r[18]
    e6e  0b 37 e 0 0 d8d4 0000  	movw d, r[20];		fpregl->am;	;		;			| 
    e6f  0a 0c e 0 0 9094 0000  p3sort0: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    e70  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    e71  0a 0c 3 0 0 d854 0e95  	movw r[20], y;		am->fpap;	cjp, zer p3dowhile; ;			| 
    e72  0a 37 e 0 0 d8c9 0000  	movw d, r[9];		fpregh->am;	;		;			| if (r[20]->r[9] > r[20]->r[18]->r[9]) {
    e73  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| &r[20]->r[18]
    e74  0b 37 e 0 0 d8d1 0000  	movw d, r[17];		fpregl->am;	;		;			| r[17]= r[20]->r[18]
    e75  0b 3c e 0 0 7140 0000  	;			fpregl->fpap;	;		;			| &r[20]->next->r[9]
    e76  02 37 e 0 0 9649 0000  	rsubw,s d, r[9], y;	fpregh->am;	;		;			| r[20]->r[9] > r[20]->r[18]->r[9]
    e77  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| 
    e78  0a 0c 3 9 0 9694 0e81  	addw d, r[20], y;		am->fpap;	cjp, ~neg p3sortx; ;			| r[20]->r[12]
    e79  0a 0c e 0 0 9091 0000  p3swaps: addw r[17], acc, y;	am->fpap;	;		;			| r[20]->r[18]= r[20]->r[18]->r[18]
    e7a  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| 
    e7b  0b 3b e 0 0 7140 0000  	;			fpregl->fpregl;	;		;			| 
    e7c  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[17]->r[18]= r[14]->r[18]
    e7d  0a 0e e 0 0 9091 0000  	addw r[17], acc, y;	am->fpdp;	;		;			| 
    e7e  0b 3b e 0 0 dd03 0000  	incw 0, r[3];		fpregl->fpregl;	;		;			| r[3]= 1
    e7f  0a 0e e 0 0 908e 0000  	addw r[14], acc, y;	am->fpdp;	;		;			| r[14]->r[18]= r[17]
    e80  0b 0b 3 7 0 d851 0e91  	movw r[17], y;		am->fpregl;	cjp, go p3sort1; ;			| 
    e81  0a 37 3 8 0 d8cc 0e91  p3sortx: movw d, r[12];		fpregh->am;	cjp, ~zer p3sort1; ;			| r[20]->r[12]
    e82  0b 37 e 0 0 d8ca 0000  	movw d, r[10];		fpregl->am;	;		;			| 
    e83  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| 
    e84  0a 0c e 0 0 9691 0000  	addw d, r[17], y;	am->fpap;	;		;			| r[20]->r[18]->r[12]
    e85  02 37 e 0 0 970c 0000  	xorw,s d, r[12], y;	fpregh->am;	;		;			| if (r[20]->r[12] > r[20]->r[18]->r[12]) {
    e86  02 37 3 9 0 f8c0 0e89  	movw,s d, y;		fpregh->am;	cjp, ~neg p3same2; ;			| Start by comparing signs.
    e87  0a 00 3 1 0 7140 0e79  	;			;		cjp, neg p3swaps; ;			| If different then sign of b is (a>b)
    e88  0a 00 3 9 0 7140 0e91  	;			;		cjp, ~neg p3sort1; ;			| 
    e89  0b 37 3 9 0 960a 0e8e  p3same2: subw d, r[10], y;	fpregl->am;	cjp, ~neg p3samepos2; ;			| 
    e8a  02 37 e 0 0 962c 0000  	subcw,s d, r[12], y;	fpregh->am;	;		;			| 
    e8b  0a 00 3 0 0 7140 0e91  	;			;		cjp, zer p3sort1; ;			| 
    e8c  0a 00 3 a 0 7140 0e79  	;			;		cjp, ~cry p3swaps; ;			| 
    e8d  0a 00 3 2 0 7140 0e91  	;			;		cjp, cry p3sort1; ;			| 
    e8e  02 37 e 0 0 962c 0000  p3samepos2: subcw,s d, r[12], y; fpregh->am;	;		;			| 
    e8f  0a 00 3 0 0 7140 0e91  	;			;		cjp, zer p3sort1; ;			| 
    e90  0a 00 3 2 0 7140 0e79  	;			;		cjp, cry p3swaps; ;			| 
    e91  0a 0c e 0 0 908e 0000  p3sort1: addw r[14], acc, y;	am->fpap;	;		;			| r[14]= r[14]->r[18]
    e92  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    e93  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[20]= r[14]->r[18]
    e94  03 37 3 7 0 d8d4 0e6f  	movw,s d, r[20];		fpregl->am;	cjp, go p3sort0; ;			| 
    e95  02 00 e 0 0 d843 0000  p3dowhile: movw,s r[3], y;	;		;		;			| } while (r[3])
    e96  0a 00 3 8 0 7140 0e6a  	;			;		cjp, ~zer p3sort; ;			| 
                                |   Ready to draw segments.
    e97  02 00 e 0 0 d850 0000  	movw,s r[16], y;	;		;		;			| 
    e98  0a 00 3 0 0 7140 0eaf  	;			;		cjp, zer p3rdydraw; ;			| 
    e99  0a 27 e 0 0 7140 0013  p3inipp: ;			19->am;		;		;			| 
    e9a  0a 06 3 c 0 f8c0 0e9a  	movw d, y;		am->fifo1;	cjp, f1f .;	;			| Send plhinit command (#19) to pp.
    e9b  08 00 e 0 0 cc8f 0000  	sr0w r[15], r[0];	;		;		;			| 
    e9c  0a 27 e 0 0 9ec0 000f  	andw d, r[0], r[0];	0xf->am;	;		;			| 
                                | PIXOP_NEEDS_DST (op << 1)= (op^(op << 1)) & 0xa
    e9d  0a 00 e 0 0 d800 0000  	movw r[0], acc;		;		;		;			| 
    e9e  0a 00 e 0 0 ec01 0000  	sl0w acc, acc;		;		;		;			| 
    e9f  0a 00 e 0 0 8100 0000  	xorw r[0], acc, acc;	;		;		;			| 
    ea0  02 27 e 0 0 e281 000a  	addw,s d, acc, acc;	0xa->am;	;		;			| 
    ea1  0a 00 3 0 0 7140 0ea4  	;			;		cjp, zer p3nodst; ;			| 
    ea2  0a 27 e 0 0 7140 0003  	;			3->am;		;		;			| SWWPIX
    ea3  0a 00 3 7 0 7140 0ea5  	;			;		cjp, go p3ropreg; ;			| 
    ea4  0a 27 e 0 0 7140 0001  p3nodst: ;			1->am;		;		;			| SRWPIX
    ea5  0a 06 3 c 0 f8c0 0ea5  p3ropreg: movw d, y;		am->fifo1;	cjp, f1f .;	;			| RopMode
    ea6  0a 06 3 c 0 d840 0ea6  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| Op
    ea7  0a 06 3 c 0 f900 0ea7  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Patt
    ea8  0a 06 3 c 0 f900 0ea8  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Mask2
    ea9  0a 06 3 c 0 f900 0ea9  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Mask1
    eaa  0a 06 3 c 0 f900 0eaa  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| r[14]
    eab  0a 06 3 c 0 f900 0eab  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| OpCnt
    eac  0a 06 3 c 0 f900 0eac  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Shift
    ead  0a 06 3 c 0 f900 0ead  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| PrimeSrc2
    eae  0a 27 e 0 0 f8c1 0008  	movw d, acc;		8->am;	;		;			| 
    eaf  0a 2c e 0 0 7140 0002  p3rdydraw: ;			2->fpap;	;		;			| r[14]= et[0].r[18]
    eb0  0b 37 e 0 0 7140 0000  	;			fpregl->am;	;		;			| 
    eb1  0a 0c e 0 0 e280 0000  	addw d, acc, y;		am->fpap;	;		;			| 
    eb2  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    eb3  0a 27 e 0 0 d8d1 07d0  	movw d, r[17];		2000->am;	;		;			| r[17]= aet
    eb4  0a 0c e 0 0 d84e 0000  	movw r[14], y;		am->fpap;	;		;			| r[13]= r[14]->r[9] + 0x8000
    eb5  0a 37 e 0 0 d8cd 0000  	movw d, r[13];		fpregh->am;	;		;			| 
    eb6  0a 0e e 0 0 9091 0000  	addw r[17], acc, y;	am->fpdp;	;		;			| r[17]->r[18]= 0
    eb7  0b 2b e 0 0 7140 0000  	;			0->fpregl;	;		;			| 
                                |   Repeat until aet and et are empty.
                                |   Get current edges out of edge table (et) and put in active edge table.
    eb8  08 28 e 0 4 d971 0eda  p3do:	movw r[17], r[20];		=p3paint->brreg; ;		;			| r[20]= r[17]
    eb9  02 0c e 0 0 d84e 0000  p3whily: movw,s r[14], y;		am->fpap;	;		;			| while (r[14] && (r[14]->r[9] <= r[13])) {
    eba  12 37 3 0 0 960d 0000  	subw,s d, r[13], y;	fpregh->am;	cjp, zer;	;			| (r[14]->r[9] <= r[13])
    ebb  1a 27 3 1 0 7140 0005  	;			5->am;		cjp, neg;	;			| save r[14]->r[12]
    ebc  0a 0c e 0 0 968e 0000  	addw d, r[14], y;		am->fpap;	;		;			| 
    ebd  0a 37 e 0 0 d8cc 0000  	movw d, r[12];		fpregh->am;	;		;			| 
    ebe  0b 37 e 0 0 d8ca 0000  	movw d, r[10];		fpregl->am;	;		;			| 
    ebf  0a 0c e 0 0 9094 0000  p3whilx: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18] && (
    ec0  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| test r[20]->r[18] for 0
    ec1  0a 00 3 0 0 7140 0ed1  	;			;		cjp, zer p3etaet; ;			| 
    ec2  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| 
    ec3  0a 0c e 0 0 9692 0000  	addw d, r[18], y;		am->fpap;	;		;			| r[20]->r[18]->r[12]
    ec4  02 37 e 0 0 970c 0000  	xorw,s d, r[12], y;	fpregh->am;	;		;			| while( && (r[20]->r[18]->r[12](a) < r[14]->r[12](b)))
    ec5  02 37 3 9 0 f8c0 0ec8  	movw,s d, y;		fpregh->am;	cjp, ~neg p3same; ;			| Start by comparing signs.
    ec6  0a 00 3 9 0 7140 0ed1  	;			;		cjp, ~neg p3etaet; ;			| If different then sign of a is (a<b)
    ec7  0a 00 3 1 0 7140 0ed0  	;			;		cjp, neg p3whilx0; ;			| 
    ec8  0b 37 3 9 0 964a 0ecd  p3same:	rsubw d, r[10], y;	fpregl->am;	cjp, ~neg p3samepos; ;			| Do a-b
    ec9  02 37 e 0 0 966c 0000  	rsubcw,s d, r[12], y;	fpregh->am;	;		;			| a and b same sign, but negative.
    eca  0a 00 3 0 0 7140 0ed1  	;			;		cjp, zer p3etaet; ;			| 
    ecb  0a 00 3 a 0 7140 0ed1  	;			;		cjp, ~cry p3etaet; ;			| 
    ecc  0a 00 3 2 0 7140 0ed0  	;			;		cjp, cry p3whilx0; ;			| 
    ecd  02 37 e 0 0 966c 0000  p3samepos: rsubcw,s d, r[12], y; fpregh->am;	;		;			| 
    ece  0a 00 3 0 0 7140 0ed1  	;			;		cjp, zer p3etaet; ;			| 
    ecf  0a 00 3 2 0 7140 0ed1  	;			;		cjp, cry p3etaet; ;			| 
    ed0  08 00 3 7 4 d972 0ebf  p3whilx0: movw r[18], r[20];		;		cjp, go p3whilx; ;			| { r[20]= r[20]->r[18] }
    ed1  08 00 e 0 3 d972 0000  p3etaet: movw r[18], r[19];		;		;		;			| r[19]= r[20]->r[18]
    ed2  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| r[20]->r[18]= r[14]
    ed3  0b 0b e 0 0 d84e 0000  	movw r[14], y;		am->fpregl;	;		;			| 
    ed4  0a 07 e 0 0 d84e 0000  	movw r[14], y;		am->am;		;		;			| 
    ed5  0a 00 e 0 0 d8d2 0000  	movw d, r[18];		;		;		;			| 
    ed6  0a 0c e 0 0 908e 0000  	addw r[14], acc, y;	am->fpap;	;		;			| r[14]= r[14]->r[18]
    ed7  0b 37 e 0 0 d8ce 0000  	movw d, r[14];		fpregl->am;	;		;			| 
    ed8  0a 0e e 0 0 9092 0000  	addw r[18], acc, y;	am->fpdp;	;		;			| r[20]->r[18]->r[18]= r[19]
    ed9  0b 0b 3 7 0 d853 0eb9  	movw r[19], y;		am->fpregl;	cjp, go p3whily; ;			| }
                                |   Paint the current scanline segments.  We are guaranteed that the edges come in pairs.
                                |   p3paint: addw r[17], acc, y;	am->fpap;	;		;			| r[20]= r[17]->r[18]
    eda  0a 0c e 0 0 9091 0000  p3paint: addw r[17], acc, y;	am->fpap;	;		;			| r[20]= r[17]->r[18]
    edb  03 37 e 0 0 d8d4 0000  	movw,s d, r[20];		fpregl->am;	;		;			| 
    edc  0a 0c 3 0 0 9094 0f77  p3whp1:	addw r[20], acc, y;	am->fpap;	cjp, zer p3remactive; ;			| while (r[20]) {  There are more edges
    edd  0b 37 e 0 0 d8d3 0000  	movw d, r[19];		fpregl->am;	;		;			| 
    ede  02 28 e 0 0 f1f0 0ee4  	btstw,s 8, r[16];	=p3ppnohse->brreg; ;		;			| 
    edf  12 28 3 0 0 e1f0 0ee8  	btstw,s 0, r[16];	=p3ppcmd->brreg; cjp, zer;	;			| 
    ee0  12 27 3 8 0 f3f0 0019  	btstw,s 9, r[16];	 25->am;	cjp, ~zer;	;			| 3D shaded.
    ee1  12 27 3 8 0 f5f0 001c  	btstw,s 10, r[16];	28->am;	cjp, ~zer;	;			| 3D 1-bit texture
    ee2  1a 27 3 8 0 7140 001d  	;			29->am;	cjp, ~zer;	;			| 3D 8-bit texture
    ee3  1a 27 3 7 0 7140 0019  	;			 25->am;	cjp, go;	;			| 3D solid.
    ee4  12 27 3 8 0 f3f0 0018  p3ppnohse: btstw,s 9, r[16];  24->am;	cjp, ~zer;	;			| 2D shaded
    ee5  12 27 3 8 0 f5f0 001c  	btstw,s 10, r[16];	28->am;	cjp, ~zer;	;			| 2D 1-bit texture
    ee6  1a 27 3 8 0 7140 001d  	;			29->am;	cjp, ~zer;	;			| 2D 8-bit texture
    ee7  0a 27 e 0 0 7140 0016  	;			22->am;	;		;			| 2D solid
                                |   Args to plhsh:    r[13], x1, x2, op, zhi, dzhi, r[24], chi, dchi, r[26] (Solid: dchi = r[26] = 0)
                                |   Args to plgsh:    r[13], x1, x2, op, chi, dchi, r[26]
                                |   Args to plgtex1:  r[13], x1, x2, color, color0, op, r[21], r[22]
                                |   Args to plgtex8:  r[13], x1, x2, op, r[21], r[22]
                                |   Args to plgfill:  r[13], x1, x2, color, op
    ee8  0a 06 3 c 0 f8c0 0ee8  p3ppcmd: movw d, y;		am->fifo1;	cjp, f1f .;	;			| Send command to fifo
    ee9  0a 06 3 c 0 d84d 0ee9  	movw r[13], y;		am->fifo1;	cjp, f1f .;	;			| 
    eea  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| Offset from r[20].
    eeb  0a 2d e 0 0 7140 0010  	;			0x10->fpbp;	;		;			| 
                                |   First pixel x1= trunc (x + .4999 + r[11]/2)
    eec  2b 0c e 0 0 9694 0270  	addw d, r[20], y;		am->fpap;	;		lmode rz, ai, pipe, fast;| x1= r[20]->r[12]
    eed  0a 00 e 0 0 7140 0000  	;			;		;		;			| 
    eee  2a 00 e 0 0 7140 0110  	;			;		;		adda, lab, hi;		| x1 + 0.5
    eef  2b 0c e 0 0 9693 0110  	addw d, r[19], y;		am->fpap;	;		;			| 
    ef0  2a 00 e 0 0 7140 0110  	;			;		;		adda, lab, hi;		| x2 + 0.5
    ef1  2b 00 e 0 0 7140 0110  	;			;		;		;			| 
    ef2  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    ef3  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    ef4  2a 0c e 0 0 9694 0120  	addw d, r[20], y;		am->fpap;	;		adda,la, hi;			| 
    ef5  2b 0d e 0 0 9693 0120  	addw d, r[19], y;		am->fpbp;	;		;			| 
    ef6  2a 00 e 0 0 7140 0192  	;			;		;		rsuba, lab, a, hi;	| x2 - x1
    ef7  2b 00 e 0 0 7140 0192  	;			;		;		;			| 
    ef8  2a 00 e 0 0 7140 00ea  	;			;		;		fixr, la, a, hi;	| x1
    ef9  2b 00 e 0 0 7140 00ea  	;			;		;		;			| 
    efa  2a 00 e 0 0 7140 00e8  	;			;		;		fixr, la, hi;		| x2
    efb  2b 00 e 0 7 7140 00e8  	;			;		;		;		abp+	| 
    efc  2a 00 e 0 0 7140 0190  	;			;		;		rsuba, lab, hi;		| z2 - z1
    efd  2b 00 e 0 0 7140 0190  	;			;		;		;			| 
    efe  2a 00 e 0 0 7140 00e2  	;			;		;		fixa, la, a, hi;	| z1
    eff  2b 0e e 0 7 f900 00e2  	movw 0, y;		am->fpdp;	;		;		abp+	| 
    f00  2a 00 e 0 0 7140 0193  	;			;		;		rsuba, lab, a, st, hi;	| 0:  Store x2 - x1.  c2 - c1
    f01  2b 00 e 0 6 7140 0193  	;			;		;		;		dp+	| 
    f02  2a 00 e 0 0 7140 00e3  	;			;		;		fixa, la, a, st, hi;	| 1:  (int) x1.  Fix c1
    f03  2b 00 e 0 6 7140 00e3  	;			;		;		;		dp+	| 
    f04  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 2:  (int) x2
    f05  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f06  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 3:  z2 - z1
    f07  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f08  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 4:  (int) z1
    f09  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f0a  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| 5:  c2 - c1
    f0b  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f0c  2a 0c e 0 0 fd00 0123  	incw 0, y;		am->fpap;	;		adda,la, a, st, hi;		| 6:  (int) c1
    f0d  2b 00 e 0 0 7140 0123  	;			;		;		;			| 
    f0e  0b 37 e 0 0 dccc 0000  	incw d, r[12];		fpregl->am;	;		;			| Save r[12] for use by r[21] at p3texoff
    f0f  0a 06 3 c 0 d84c 0f0f  	movw r[12], y;		am->fifo1;	cjp, f1f .;	;			| x1
    f10  0a 00 e 0 4 7140 0000  	;			;		;		;		ap+	| 
    f11  0b 37 e 0 0 dcc0 0000  	incw d, r[0];		fpregl->am;	;		;			| 
    f12  0a 06 3 c 0 d840 0f12  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| x2
    f13  02 00 e 0 0 d850 0000  	movw,s r[16], y;	;		;		;			| 
    f14  02 00 3 0 0 e1f0 0f19  	btstw,s 0, r[16];	;		cjp, zer p3colorop; ;			| 
    f15  02 00 3 8 0 f5f0 0f1f  	btstw,s 10, r[16];	;		cjp, ~zer p3notsld2d; ;			| 
    f16  02 00 3 8 0 f3f0 0f1f  	btstw,s 9, r[16];	;		cjp, ~zer p3notsld2d; ;			| 
    f17  0a 00 3 8 0 7140 0f19  	;			;		cjp, ~zer p3colorop; ;			| 
    f18  0a 00 3 7 0 7140 0f1f  	;			;		cjp, go p3notsld2d; ;			| 
    f19  08 00 e 0 0 97ef 0000  p3colorop: rolw 11, r[15], r[0]; ;		;		;			| Color from op for Solid 2D and tex 1.
    f1a  0a 27 e 0 0 9ec0 07ff  	andw d, r[0], r[0];	0x7ff->am;	;		;			| 
    f1b  0a 06 3 c 0 d840 0f1b  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| 
    f1c  02 00 e 0 0 f3f0 0000  	btstw,s 9, r[16];	;		;		;			| 
    f1d  0a 00 3 0 0 7140 0f1f  	;			;		cjp, zer p3notsld2d; ;			| 
    f1e  0a 06 3 c 0 f900 0f1e  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| color0.
    f1f  08 27 e 0 0 9ecf 001f  p3notsld2d: andw d, r[15], r[0]; 0x1f->am;	;		;			| 
    f20  0a 06 3 c 0 d840 0f20  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| Op
    f21  02 00 e 0 0 d850 0000  	movw,s r[16], y;	;		;		;			| 
    f22  02 00 3 0 0 f3f0 0f2c  	btstw,s 9, r[16];	;		cjp, zer p3nexte; ;			| Finished Solid 2D segment. Go set fpap.
    f23  02 00 3 8 0 f5f0 0f26  	btstw,s 10, r[16];	;		cjp, ~zer p3texoff; ;			| 
    f24  0a 00 3 8 0 7140 0f26  	;			;		cjp, ~zer p3texoff; ;			| 
    f25  0a 00 3 7 0 7140 0f2d  	;			;		cjp, go p3notex; ;			| 
    f26  0a 07 e 0 0 d84c 0000  p3texoff: movw r[12], y;		am->am;		;		;			| 
    f27  08 00 e 0 b 9e95 0000  	addw d, r[21], r[27];	;		;		;			| 
    f28  0a 06 3 c 0 d85b 0f28  	movw r[27], y;		am->fifo1;	cjp, f1f .;	;			| 
    f29  0a 07 e 0 0 d84d 0000  	movw r[13], y;		am->am;		;		;			| 
    f2a  08 00 e 0 b 9e96 0000  	addw d, r[22], r[27];	;		;		;			| 
    f2b  0a 06 3 c 0 d85b 0f2b  	movw r[27], y;		am->fifo1;	cjp, f1f .;	;			| 
    f2c  0a 0c 3 7 0 9093 0f74  p3nexte: addw r[19], acc, y;	am->fpap;	cjp, go p3nxtedge; ;			| Finished textured 2D segment. Set fpap.
    f2d  0a 2c e 0 0 7140 0004  p3notex: ;			4->fpap;	;		;			| 2D Shaded, 3D HSE or shaded.
    f2e  02 00 e 0 0 f1f0 0000  	btstw,s 8, r[16];	;		;		;			| 
    f2f  0a 00 3 0 0 7140 0f38  	;			;		cjp, zer p3recip; ;			| 
    f30  0a 37 e 0 0 b020 0000  	rolw 8, d, r[0];	fpregh->am;	;		;			| Shift z up from 23 bits to 32 bits.
    f31  0b 37 e 0 0 b120 0000  	romw 8, d, r[0], 0xff;	fpregl->am;	;		;			| 
    f32  0a 00 e 0 0 00ff 0000  	;			;		;		;			| 
    f33  0b 37 e 0 0 b021 0000  	rolw 8, d, r[1];	fpregl->am;	;		;			| 
    f34  0a 27 e 0 0 9ec1 ff00  	andw d, r[1], r[1];	0xff00->am;	;		;			| 
    f35  0a 27 e 0 0 9e81 7fff  	addw d, r[1], r[1];	0x7fff->am;	;		;			| add 0.5
    f36  0a 27 e 0 0 9ea0 0000  	addcw d, r[0], r[0];	0->am;		;		;			| 
    f37  0a 06 3 c 0 d840 0f37  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| zhi
                                |	movw r[1], y;		am->fifo1;	cjp, f1f .;	;			| zlo
    f38  0a 2c e 0 0 7140 0000  p3recip: ;			0->fpap;	;		;			| 
    f39  0a 2e e 0 0 dd02 0000  	incw 0, r[2];		0->fpdp;	;		;			| Store recip in fpreg [1]
    f3a  0a 00 1 7 0 7140 034a  	;			;		cjs, go recip;	;			| 
    f3b  0a 27 e 0 0 f8c1 0008  	movw d, acc;		8->am;	;		;			| Restore accumulator value.
    f3c  0a 2d e 0 0 7140 0003  	;			3->fpbp;	;		;			| 
    f3d  2b 0c e 0 0 fd00 0270  	incw 0, y;		am->fpap;	;		lmode rz, ai, pipe, fast;| 
    f3e  0a 0e e 0 0 fd00 0000  	incw 0, y;		am->fpdp;	;		;			| 
    f3f  2a 00 e 0 0 f8e0 0010  	movw 5, y;		;		;		maba, lab, hi;		| (z2 - z1) * 1 / (x2 - x1)
    f40  2b 0d e 0 0 0005 0010  	;			am->fpbp;	;		;			| 
    f41  2a 00 e 0 0 7140 0010  	;			;		;		maba, lab, hi;		| (c2 - c1) * 1 / (x2 - x1)
    f42  2b 00 e 0 0 7140 0010  	;			;		;		;			| 
    f43  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    f44  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    f45  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    f46  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    f47  2a 0e e 0 0 f900 0124  	movw 0, y;		am->fpdp;	;		adda,la, m, hi;		| 
    f48  2b 00 e 0 0 7140 0124  	;			;		;		;			| 
    f49  2a 00 e 0 0 7140 00ec  	;			;		;		fixr, la, m, hi;	| 
    f4a  2b 00 e 0 0 7140 00ec  	;			;		;		;			| 
    f4b  2a 00 e 0 0 7140 00e8  	;			;		;		fixr, la, hi;		| 
    f4c  2b 00 e 0 0 7140 00e8  	;			;		;		;			| 
    f4d  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    f4e  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    f4f  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    f50  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    f51  2a 00 e 0 0 7140 0122  	;			;		;		adda,la, a, hi;		| 
    f52  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    f53  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| r[23]
    f54  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f55  2a 00 e 0 0 7140 0121  	;			;		;		adda,la, st, hi;		| r[25]
    f56  2b 0c e 0 0 f900 0121  	movw 0, y;		am->fpap;	;		;			| 
    f57  02 00 e 0 0 f1f0 0000  	btstw,s 8, r[16];	;		;		;			| 
    f58  0a 37 3 0 0 b020 0f5f  	rolw 8, d, r[0];	fpregh->am;	cjp, zer p3color; ;			| Shift r[23] up from 23 bits to 32 bits.
    f59  0b 37 e 0 0 b120 0000  	romw 8, d, r[0], 0xff;	fpregl->am;	;		;			| 
    f5a  0a 00 e 0 0 00ff 0000  	;			;		;		;			| 
    f5b  0a 06 3 c 0 d840 0f5b  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| dzhi
    f5c  0b 37 e 0 0 b021 0000  	rolw 8, d, r[1];	fpregl->am;	;		;			| 
    f5d  0a 27 e 0 0 9ec1 ff00  	andw d, r[1], r[1];	0xff00->am;	;		;			| 
    f5e  0a 06 3 c 0 d841 0f5e  	movw r[1], y;		am->fifo1;	cjp, f1f .;	;			| r[24]
    f5f  02 2c e 0 0 e1f0 0006  p3color: btstw,s 0, r[16];	6->fpap;	;		;			| c= fpreg [5].
    f60  0a 00 3 8 0 7140 0f67  	;			;		cjp, ~zer p3shade; ;			| 
                                |   Reached only if r[16] == 0x100.
    f61  08 27 e 0 0 97ef 07ff  	rolw 11, r[15], r[0]; 0x7ff->am;	;		;			| 
    f62  0a 06 3 c 0 96c0 0f62  	andw d, r[0], y;	am->fifo1;	cjp, f1f .;	;			| Color hi is taken from op. (shift rt. 5).
    f63  0a 06 3 c 0 f900 0f63  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| Color low.
    f64  0a 06 3 c 0 f900 0f64  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| dchi
    f65  0a 06 3 c 0 f900 0f65  	movw 0, y;		am->fifo1;	cjp, f1f .;	;			| r[26]
    f66  0a 0c 3 7 0 9093 0f74  	addw r[19], acc, y;	am->fpap;	cjp, go p3nxtedge; ;			| r[20]= r[19]->r[18]
                                |   Shadestyles 0x101 and 1.
    f67  0b 37 e 0 0 d8c1 0000  p3shade: movw d, r[1];	fpregl->am;	;		;			| 
    f68  0a 37 e 0 0 d8c0 0000  	movw d, r[0];		fpregh->am;	;		;			| 
    f69  0a 00 e 0 0 cfc0 0000  	add2nw 7, r[0];	;		;		;			| add 2**23 to color. (undoes xfpolygon3.vp)
    f6a  0a 27 e 0 0 9e81 7fff  	addw d, r[1], r[1];	0x7fff->am;	;		;			| add 0.5
    f6b  0a 27 e 0 0 9ea0 0000  	addcw d, r[0], r[0]; 0->am;		;		;			| 
    f6c  0a 06 3 c 0 d840 0f6c  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| c1.  color hi.
    f6d  0a 06 3 c 0 d841 0f6d  	movw r[1], y;		am->fifo1;	cjp, f1f .;	;			| color lo.
    f6e  0a 2c e 0 0 7140 0001  	;			1->fpap;	;		;			| 
    f6f  0b 37 e 0 0 d8c1 0000  	movw d, r[1];		fpregl->am;	;		;			| 
    f70  0a 37 e 0 0 d8c0 0000  	movw d, r[0];		fpregh->am;	;		;			| 
    f71  0a 06 3 c 0 d840 0f71  	movw r[0], y;		am->fifo1;	cjp, f1f .;	;			| dchi
    f72  0a 06 3 c 0 d841 0f72  	movw r[1], y;		am->fifo1;	cjp, f1f .;	;			| r[26].
    f73  0a 0c e 0 0 9093 0000  	addw r[19], acc, y;	am->fpap;	;		;			| r[20]= r[19]->r[18]
    f74  03 37 e 0 0 d8d4 0000  p3nxtedge: movw,s d, r[20];	fpregl->am;	;		;			| Must have fpap= r[19] + acc = r[19]->r[18]
    f75  0a 0c 3 0 0 9094 0f77  	addw r[20], acc, y;	am->fpap;	cjp, zer p3remactive; ;			| if (r[20]) r[19]= r[20]->r[18].  NB while (r[20])
    f76  0b 37 3 7 0 d8d3 0edc  	movw d, r[19];		fpregl->am;	cjp, go p3whp1;	;			| 
                                |   Remove active edges whose ymax <= r[13]
    f77  0a 00 e 0 0 dd6d 0000  p3remactive: incw r[13], r[13];	;		;		;			| r[13]++.  Step to next scanline
    f78  08 00 e 0 4 d971 0000  	movw r[17], r[20];		;		;		;			| r[20]= r[17]
    f79  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    f7a  03 37 e 0 0 d8d2 0000  p3remwh: movw,s d, r[18];		fpregl->am;	;		;			| 
    f7b  0a 0c 3 0 0 dc52 0f82  	incw r[18], y;		am->fpap;	cjp, zer p3upx;	;			| if (r[20]->r[18] <= r[13])
    f7c  02 37 e 0 0 960d 0000  	subw,s d, r[13], y;	fpregh->am;	;		;			| 
    f7d  0a 0c 3 1 0 9092 0f80  	addw r[18], acc, y;	am->fpap;	cjp, neg p3step; ;			| r[20]->r[18]= r[20]->r[18]->r[18]
    f7e  0a 0e e 0 0 9094 0000  	addw r[20], acc, y;	am->fpdp;	;		;			| 
    f7f  0b 3b 3 7 0 7140 0f7a  	;			fpregl->fpregl;	cjp, go p3remwh; ;			| 
    f80  08 00 e 0 4 d972 0000  p3step:	movw r[18], r[20];		;		;		;			| else r[20]= r[20]->r[18]
    f81  0a 0c 3 7 0 9094 0f7a  	addw r[20], acc, y;	am->fpap;	cjp, go p3remwh; ;			| 
                                |   Update x values in aet
    f82  08 28 e 0 4 d971 0f9a  p3upx:	movw r[17], r[20];		=p3resort->brreg; ;		;			| r[20]= r[17]
    f83  0a 0c e 0 0 9094 0000  p3whupx: addw r[20], acc, y;	am->fpap;	;		;			| while (r[20]->r[18]) {
    f84  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    f85  18 27 3 0 4 d972 0005  	movw r[18], r[20];		5->am;		cjp, zer;	;			| r[20]= r[20]->r[18]
    f86  08 0c e 0 b c3d4 0000  	add2nw 1, r[20], r[27];	am->fpap;	;		;			| r[20]->r[12] += r[20]->r[11]
    f87  08 0d e 0 b 9e94 0000  	addw d, r[20], r[27];	am->fpbp;	;		;			| r[12].
    f88  2a 0e e 0 0 d85b 0110  	movw r[27], y;		am->fpdp;	;		adda, lab, hi;		| r[20]->r[12] += r[20]->r[11]
    f89  2b 00 e 0 7 7140 0110  	;			;		;		;		abp+	| 
    f8a  2a 00 e 0 0 7140 0110  	;			;		;		adda, lab, hi;		| r[20]->zmn += r[20]->r[23]
    f8b  2b 00 e 0 7 7140 0110  	;			;		;		;		abp+	| 
    f8c  2a 00 e 0 0 7140 0110  	;			;		;		adda, lab, hi;		| r[20]->cmn += r[20]->r[25]
    f8d  2b 00 e 0 7 7140 0110  	;			;		;		;		abp+	|
    f8e  2a 00 e 0 0 7140 0120  	;			;		;		adda,la, hi;			| 
    f8f  2b 00 e 0 0 7140 0120  	;			;		;		;			| 
    f90  2a 00 e 0 0 7140 0122  	;			;		;		adda,la, a, hi;		| 
    f91  2b 00 e 0 0 7140 0122  	;			;		;		;			| 
    f92  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| r[20]->r[12]
    f93  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f94  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| r[20]->zmn
    f95  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f96  2a 00 e 0 0 7140 0123  	;			;		;		adda,la, a, st, hi;		| r[20]->cmn
    f97  2b 00 e 0 6 7140 0123  	;			;		;		;		dp+	| 
    f98  0a 28 e 0 0 7140 0f83  	;			=p3whupx->brreg; ;		;			| 
    f99  1a 28 3 7 0 7140 0f9a  	;			=p3resort->brreg; cjp, go;	;			| 
                                |   Resort on > r[12] because previous step may have crossed edges.
    f9a  08 00 e 0 4 d971 0000  p3resort: movw r[17], r[20];	;		;		;			| r[20]= r[17]
    f9b  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| if (r[20]->r[18])
    f9c  03 37 e 0 0 d8d2 0000  	movw,s d, r[18];		fpregl->am;	;		;			| 
    f9d  0a 00 3 0 0 7140 0fc7  	;			;		cjp, zer p3whend; ;			| 
    f9e  08 00 e 0 4 d971 0000  p3rsdo:	movw r[17], r[20];		;		;		;			| do { r[20]= r[17]
    f9f  08 00 e 0 3 d972 0000  	movw r[18], r[19];		;		;		;			| r[19]= r[20]->r[18]
    fa0  0a 00 e 0 0 d903 0000  	movw 0, r[3];		;		;		;			| r[3]= 0
    fa1  0a 0c e 0 0 9093 0000  p3whp2nxt: addw r[19], acc, y;	am->fpap;	;		;			| while (r[19]->r[18])
    fa2  03 37 e 0 0 d8c0 0000  	movw,s d, r[0];		fpregl->am;	;		;			| 
    fa3  0a 00 3 0 0 7140 0fc5  	;			;		cjp, zer p3doswap; ;			| 
    fa4  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| if (r[19]->r[12] > r[19]->r[18]->r[12])
    fa5  0a 0c e 0 0 9680 0000  	addw d, r[0], y;	am->fpap;	;		;			| r[19]->r[18]->r[12]
    fa6  0a 37 e 0 0 d8cc 0000  	movw d, r[12];		fpregh->am;	;		;			| 
    fa7  0b 37 e 0 0 d8ca 0000  	movw d, r[10];		fpregl->am;	;		;			| 
    fa8  0a 27 e 0 0 7140 0005  	;			5->am;		;		;			| r[19]->r[12]
    fa9  0a 0c e 0 0 9693 0000  	addw d, r[19], y;		am->fpap;	;		;			| 
    faa  02 37 e 0 0 970c 0000  	xorw,s d, r[12], y;	fpregh->am;	;		;			| if: start by comparing signs.
    fab  02 00 3 9 0 d84c 0fae  	movw,s r[12], y;	;		cjp, ~neg p3same1; ;			| 
    fac  0a 00 3 1 0 7140 0fb6  	;			;		cjp, neg p3rsthen; ;			| If different then sign of b is (a>b)
    fad  0a 00 3 9 0 7140 0fc1  	;			;		cjp, ~neg p3rselse; ;			| 
    fae  0b 37 3 9 0 964a 0fb3  p3same1: rsubw d, r[10], y;	fpregl->am;	cjp, ~neg p3samepos1; ;			| Do a-b
    faf  02 37 e 0 0 966c 0000  	rsubcw,s d, r[12], y;	fpregh->am;	;		;			| a and b same sign, but negative.
    fb0  0a 00 3 0 0 7140 0fc1  	;			;		cjp, zer p3rselse; ;			| 
    fb1  0a 00 3 a 0 7140 0fb6  	;			;		cjp, ~cry p3rsthen; ;			| 
    fb2  0a 00 3 2 0 7140 0fc1  	;			;		cjp, cry p3rselse; ;			| 
    fb3  02 37 e 0 0 966c 0000  p3samepos1: rsubcw,s d, r[12], y; fpregh->am;	;		;			| 
    fb4  0a 00 3 0 0 7140 0fc1  	;			;		cjp, zer p3rselse; ;			| 
    fb5  0a 00 3 a 0 7140 0fc1  	;			;		cjp, ~cry p3rselse; ;			| 
    fb6  0a 0e e 0 0 9094 0000  p3rsthen: addw r[20], acc, y;	am->fpdp;	;		;			| r[20]->r[18]= r[19]->r[18]
    fb7  0b 0b e 0 0 d840 0000  	movw r[0], y;		am->fpregl;	;		;			| 
    fb8  0a 0e e 0 0 9093 0000  	addw r[19], acc, y;	am->fpdp;	;		;			| r[19]->r[18]= r[19]->r[18]->r[18]
    fb9  0a 0c e 0 0 9080 0000  	addw r[0], acc, y;	am->fpap;	;		;			| 
    fba  0b 3b e 0 0 7140 0000  	;			fpregl->fpregl;	;		;			| 
    fbb  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| r[20]->r[18]->r[18]= r[19]
    fbc  0b 37 e 0 0 d8d2 0000  	movw d, r[18];		fpregl->am;	;		;			| 
    fbd  0a 0e e 0 0 9092 0000  	addw r[18], acc, y;	am->fpdp;	;		;			| 
    fbe  0b 0b e 0 0 d853 0000  	movw r[19], y;		am->fpregl;	;		;			| 
    fbf  08 00 e 0 4 d972 0000  	movw r[18], r[20];		;		;		;			| r[20]= r[20]->r[18]
    fc0  0a 00 3 7 0 dd03 0fa1  	incw 0, r[3];		;		cjp, go p3whp2nxt; ;			| r[3]= 1
    fc1  0a 0c e 0 0 9094 0000  p3rselse: addw r[20], acc, y;	am->fpap;	;		;			| r[20]= r[20]->r[18]
    fc2  0b 37 e 0 0 d8d4 0000  	movw d, r[20];		fpregl->am;	;		;			| 
    fc3  0a 0c e 0 0 9094 0000  	addw r[20], acc, y;	am->fpap;	;		;			| r[19]= r[20]->r[18]
    fc4  0b 37 3 7 0 d8d3 0fa1  	movw d, r[19];		fpregl->am;	cjp, go p3whp2nxt; ;			| 
    fc5  02 00 e 0 0 d843 0000  p3doswap: movw,s r[3], y;	;		;		;			| } while (r[3])
    fc6  0a 00 3 8 0 7140 0f9e  	;			;		cjp, ~zer p3rsdo; ;			| 
    fc7  0a 0c e 0 0 9091 0000  p3whend: addw r[17], acc, y;	am->fpap;	;		;			| } while (r[17]->r[18] || r[14])
    fc8  03 37 e 0 0 f8c0 0000  	movw,s d, y;		fpregl->am;	;		;			| r[17]->r[18]
    fc9  02 00 3 8 0 d84e 0eb8  	movw,s r[14], y;		;		cjp, ~zer p3do;	;			| 
    fca  0a 00 3 8 0 7140 0eb8  	;			;		cjp, ~zer p3do;	;			| 
    fcb  1a 00 a 7 0 7140 0000  	;			;		crtn, go;	;			| 
                                | "@(#)multiply.vp.u 1.2 86/09/12 SMI"
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |   Multiplier routine.
                                |   Multiplier arrives in r[2].  It should have fewer one bits than
                                |   multiplicand which arrives in acc.  The result is computed and
                                |   in r[0,1] with the low order bits in r[0].  The algorithm is a
                                |   simple shift-add.  It was chosen because the majority of
                                |   multipliers will not have many bits.
    fcc  02 00 e 0 0 9102 0000  multiply: xorw,s r[2], acc, y; ;	;		;			| 
    fcd  0a 00 3 9 0 d904 0fcf  	movw 0, r[4];		;		cjp, ~neg mul;	;			| 
    fce  0a 00 e 0 0 dd04 0000  	incw 0, r[4];		;		;		;			| 
    fcf  0a 00 e 0 0 d900 0000  mul:	movw 0, r[0];		;		;		;			| Clear.
    fd0  02 28 e 0 0 d842 0fd7  	movw,s r[2], y;	=mul2->brreg;	;		;			| 
    fd1  0a 00 3 9 0 d901 0fd3  	movw 0, r[1];		;		cjp, ~neg mul1;	;			| 
    fd2  0a 00 e 0 0 df62 0000  	negw r[2], r[2]; ;		;		;			| 
    fd3  12 00 a 0 0 f880 0000  mul1:	movw,s acc, y;	;		crtn, zer;	;			| 
    fd4  18 27 3 9 3 d462 0010  	priw r[2], 0, r[3]; 16->am;	cjp, ~neg;	;			| Find highest bit and test r[2].
    fd5  0a 00 e 0 0 7140 0000  	;			;		;		;			| NOP ASSEMBLER BUG WORKAROUND
    fd6  0a 00 e 0 0 fe81 0000  	negw acc, acc;	;		;		;			| 
    fd7  1a 08 a 0 0 9e43 0000  mul2:	rsubw d, r[3], r[3];	am->brreg;	crtn, zer;	;			| Generate number of times for loop.
    fd8  12 00 4 7 0 9fe2 0000  	rolw,s 15, r[2], r[2]; ;	push, go;	;			| Shift r[2]. Set carry 0.
                                | Ld cntr.  Push mulloop on stack.
    fd9  0a 00 3 9 0 7140 0fdb  	;			;		cjp, ~neg mulshift; ;			| If bit 15 zero skip addition.
    fda  02 00 e 0 0 9881 0000  	addw,s r[1], acc, r[1]; ;	;		;			| Add Multiplicand to result.
    fdb  0a 00 e 0 0 cce1 0000  mulshift: srcw r[1], r[1];	;		;		;			| Shift result.
    fdc  0a 00 e 0 0 ccc0 0000  	srqw r[0], r[0];	;		;		;			| 
    fdd  12 00 8 0 0 9fe2 0000  	rolw,s 15, r[2], r[2]; ;	rfct;		;			| Shift r[2]. Set carry 0.
    fde  0a 03 e 0 0 dc43 0000  	incw r[3], y;		am->nreg;	;		;			| 
    fdf  0a 00 e 0 0 d903 0000  	movw 0, r[3];		;		;		;			| 
    fe0  0e 00 e 0 0 e1a3 0000  	bsetw n, r[3];		;		;		;			| 
    fe1  0a 07 e 0 0 c1e3 0000  	sub2nw 0, r[3], r[3];	am->am;		;		;			| 
    fe2  0e 00 e 0 0 81e1 0000  	rolw n, r[1], r[1];	;		;		;			| Rotate right 1 bit.
    fe3  0a 00 e 0 0 d801 0000  	movw r[1], acc;	;		;		;			| 
    fe4  0a 00 e 0 0 9ec1 0000  	andw d, r[1], r[1];	;		;		;			| r[3] is in d.
    fe5  0a 07 e 0 0 d840 0000  	movw r[0], y;		am->am;		;		;			| Save r[0] in d.
    fe6  0e 00 e 0 0 a103 0000  	romw n, d, acc, r[3];	;		;		;			| 
    fe7  02 00 e 0 0 d844 0000  	movw,s r[4], y;		;		;		;			| 
    fe8  1a 00 a 0 0 d880 0000  	movw acc, r[0];	;		crtn, zer;	;			| 
    fe9  02 00 e 0 0 df60 0000  	negw,s r[0], r[0];	;		;		;			| 
    fea  1a 00 a a 0 db61 0000  	compw r[1], r[1];	;		crtn, ~cry;	;			| 
    feb  1a 00 a 7 0 dd61 0000  	incw r[1], r[1];	;		crtn, go;	;			| 
                                | "@(#)gbuffer.vp.u 1.2 86/09/12"
                                | Copyright 1986 by Sun Microsystems, Inc.
                                |	movw r[29],y;	am->shmemp;	jmap SETZBUF;	;
    fec  0a 17 1 7 0 d8d0 0009  SETZBUF: movw d,r[16];		shmem->am;	cjs,go gb_board_inq;;			  | r[16] <- r[28] for this frame
                                											  | check whether gbuffer is present
    fed  02 00 3 1 0 9110 0fef  	xorw,s r[16],acc,y;	;		cjp,neg nozbuf;	;			  | if not, goto nozbuf; else if gbuffer is
    fee  08 0f 3 0 0 d1dd 0ff1  	add2nw 8,r[29],r[16];am->shmemp;	cjp,zer zbuf;	;			  | associated with this frame buffer, goto
                                											  | zbuf; shmemp <- addr of clipping list
    fef  0a 27 e 0 0 9e9e 0006  nozbuf:	addw d,r[30],r[30];	6->am;		;		;			  | SETZBUF r[0] is invalid; r[30] += 6
    ff0  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;			  | jump to r[0] loop
    ff1  0a 28 e 0 0 f8e1 007d  zbuf:	movw 10,acc;	=wrfifo->brreg;	;		;			  | send 10 command to PP
    ff2  1a 06 1 c 0 000a 0000  	;			am->fifo1;	cjs,f1f;	;
    ff3  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | acc <- # of rectangles & send to PP
    ff4  02 00 4 7 0 e185 0003  setzb1:sub2nw,s 0,acc;		;		push,go 3;	;			  | 4 values in one rectangle.
    ff5  0a 16 3 c 0 7140 0ff5  	;			shmem->fifo1;	cjp,f1f .;	;
    ff6  1a 00 8 0 2 7140 0000  	;			;		rfct;		;		shp+
    ff7  0a 00 3 8 0 7140 0ff4  	;			;		cjp, ~zer setzb1;;
    ff8  1a 27 1 7 0 f8c1 0010  	movw d,acc;		16->am;	cjs,go;		;			  | send 16 command to PP
    ff9  0a 0f 4 7 0 dc5e 0004  	incw r[30],y;		am->shmemp;	push,go 4;	;			  | shmemp <- addr of command args
    ffa  0a 16 3 c 0 7140 0ffa  	;			shmem->fifo1;	cjp,f1f .;	;			  | send 5 args to PP: 16-bit value, screen
    ffb  1a 27 8 0 2 7140 0006  	;			6->am;		rfct;		;		shp+	  | X, screen Y, width, height
    ffc  0a 00 2 0 0 9e9e 0027  	addw d,r[30],r[30];	;		jmap getcmd;	;			  | r[30] += 6; jump to r[0] loop
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)statpixrect.vp.u 1.1 86/09/12 SMI
                                | These routines were moved over to the painting processor's memory bank, due to space considerations on the viewing
                                | processor.  
                                org 0x1000
                                debug off
                                |   Pixinit does alot of the initialization that is common between pr_line, polyline and vec.
   1000  0a 28 e 0 0 f8e1 109c  pixinit: movw  8,acc;	=wrfifo_pp->brreg; ;		;			| 
   1001  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs,f1f;	;
   1002  1a 27 1 7 0 86c0 00ff  	andw d,r[0],acc;		0xFF->am;	cjs,go;		;
   1003  1a 27 1 7 0 f8c1 000a  	movw d,acc;		10->am;	cjs,go;		;
   1004  08 0f e 0 0 c5de 0000  	add2nw 2,r[30],r[16];	am->shmemp;	;		;			| want shmemp to point to rect
   1005  0a 06 3 c 0 fd00 1005  	incw 0, y;		am->fifo1;	cjp,f1f .;	;			| 1 clipping rectangle.
   1006  0a 16 3 c 0 7140 1006  	;			shmem->fifo1;	cjp,f1f .;	;
   1007  0a 17 e 0 2 d8c1 0000  	movw d,r[1];		shmem->am;	;		;		shp+
   1008  0a 16 3 c 0 7140 1008  	;			shmem->fifo1;	cjp,f1f .;	;			| 
   1009  0a 17 c 0 2 d8c2 0001  	movw d,r[2];		shmem->am;	ldct 1;		;		shp+	| 
   100a  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+
   100b  1a 17 3 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjp,go;		;		shp+	| will return from here (cjp)
                                |	;			;		jmap prvec_pp; ;			| 
   100c  0a 00 1 7 0 7140 1000  prvec_pp: ;			;		cjs,go pixinit;	;			| 
   100d  1a 27 1 7 0 f8c1 0009  	movw d,acc;		9->am;		cjs,go;		;
   100e  1a 17 1 7 2 8681 0000  prvec1:	addw d,r[1],acc;	shmem->am;	cjs,go;		;		shp+
   100f  1a 17 1 7 2 8682 0000  	addw d,r[2],acc;	shmem->am;	cjs,go;		;		shp+
   1010  0a 00 9 0 0 7140 100e  	;			;		rpct prvec1;	;
   1011  0a 27 e 0 0 869e 0002  	addw d,r[30],acc;	2->am;		;		;
   1012  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
   1013  0a 16 3 c 0 7140 1013  	;			shmem->fifo1;	cjp,f1f .;	;
   1014  0a 27 e 0 2 9e9e 000c  	addw d,r[30],r[30];	12->am;		;		;		shp+
   1015  0a 16 3 c 0 7140 1015  	;			shmem->fifo1;	cjp,f1f .;	;
   1016  0a 00 2 0 0 7140 0027  	;			;		jmap getcmd;	;
                                |	;			;		jmap pr_line_pp; ;			| 
                                pr_line_pp: 
   1017  0a 00 1 7 0 7140 1000  	;			;		cjs,go pixinit;	;			| 
   1018  1a 27 1 7 0 f8c1 001a  	movw d,acc;		26->am;	cjs,go;		;			| pr_line pp command
   1019  1a 17 1 7 2 8681 0000  prtvec1:addw d,r[1],acc;	shmem->am;	cjs,go;		;		shp+
   101a  1a 17 1 7 2 8682 0000  	addw d,r[2],acc;	shmem->am;	cjs,go;		;		shp+
   101b  0a 00 9 0 0 7140 1019  	;			;		rpct prtvec1;	;			| 
   101c  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	| width->fifo1
   101d  0a 17 e 0 2 db00 0000  	compw 0,r[0];	shmem->am;	;		;		shp+	| first pattern segment from shmem
   101e  02 06 3 c 0 f8c0 101e  prtpat:	movw,s d,y;		am->fifo1;	cjp,f1f .;	;			| first segment->fifo1
   101f  0a 17 3 0 2 dd60 1029  	incw r[0],r[0];	shmem->am;	cjp,zer prtsol;	;		shp+	| jump if 5 vector (1st seg 0).
   1020  02 06 3 c 0 f8c0 1020  prtpatlp: movw,s d,y;		am->fifo1;	cjp,f1f .;	;			| continue writing segments
   1021  0a 17 3 8 2 dd60 1020  	incw r[0],r[0];	shmem->am;	cjp,~zer prtpatlp; ;		shp+	| loop until pattern ends.
   1022  1a 00 1 7 0 f8c1 0000  	movw d,acc;		;		cjs,go;		;			| starting offset->fifo1
   1023  1a 17 1 7 0 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;			| options->fifo1
   1024  08 0f e 0 0 c3de 0000  prtbyt:	add2nw 1,r[30],r[16];	am->shmemp;	;		;			| shmemp points to op (r[30]+2)
   1025  0a 16 3 c 0 7140 1025  	;			shmem->fifo1;	cjp,f1f .;	;			| op->fifo1
   1026  0a 07 e 0 2 c9c0 0000  	add2nw 4,r[0];	am->am;		;		;		shp+	| r[3]+r[0]+1->r[30]
   1027  0a 16 3 c 0 7140 1027  	;			shmem->fifo1;	cjp,f1f .;	;			| color->fifo1
   1028  0a 00 2 0 0 9e9e 0027  	addw d,r[30],r[30];	;		jmap getcmd;	;			| 
   1029  0a 06 3 c 0 eb96 1029  prtsol:	mov2nw 5,y;		am->fifo1;	cjp, f1f .;	;			| options(solidvec)->fifo1
   102a  0a 00 3 7 0 c3e0 1024  	sub2nw 1,r[0];	;		cjp, go prtbyt;	;			| 5,r[30]+=14(nb = -2)
                                |	;			;		jmap pr_polyline_pp; ;			| 
                                pr_polyline_pp:
   102b  0a 00 1 7 0 7140 1000  	;			;		cjs,go pixinit;	;			| 
   102c  1a 27 1 7 0 f8c1 001e  	movw d,acc;		30->am; cjs,go;	;			| polyline pp command->fifo1
   102d  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	| r[7]->fifo1
   102e  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	| r[8]->fifo1
   102f  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	| width->fifo1
   1030  0a 17 e 0 2 dd03 0000  	incw 0,r[3];		shmem->am;	;		;		shp+	| first pattern segment from shmem
   1031  02 06 3 c 0 f8c0 1031  	movw,s d,y;		am->fifo1;	cjp,f1f .;	;			| first segment->fifo1
   1032  0a 17 3 0 2 d8c4 1052  	movw d,r[4];		shmem->am;	cjp,zer prpsol;	;		shp+	| jump if 5 (just pulled options)
   1033  02 06 3 c 0 f8c0 1033  prppatlp: movw,s d,y;		am->fifo1;	cjp,f1f .;	;			| first segment->fifo1
   1034  0a 17 3 8 2 dd63 1033  	incw r[3],r[3];	shmem->am;	cjp,~zer prppatlp; ;		shp+	| increment count, pull next seg
   1035  0a 06 3 c 0 f8c0 1035  prpoff:	movw d,y;		am->fifo1;	cjp,f1f .;	;			| starting offset->fifo1
   1036  02 17 e 0 2 d8c4 0000  	movw,s d,r[4];		shmem->am;	;		;		shp+	| options->r[4]
   1037  0a 06 3 c 0 eb91 1037  	bclrw 5,d,y;	am->fifo1;	cjp,f1f .;	;			| options->fifo1 (clear 5 bit)
   1038  08 0f e 0 0 c3de 0000  	add2nw 1,r[30],r[16];	am->shmemp;	;		;			| load shmemp with op address
   1039  0a 16 3 c 0 7140 1039  prpbyt:	;			shmem->fifo1;	cjp,f1f .;	;			| op->fifo1
   103a  0a 27 e 0 2 8683 000d  	addw d,r[3],acc;	13->am;		;		;		shp+	| add pattern length + # bytes sent.
   103b  0a 16 3 c 0 7140 103b  	;			shmem->fifo1;	cjp,f1f .;	;			| color->fifo1
   103c  0a 0f e 0 0 989e 0000  	addw r[30],acc,r[30];	am->shmemp;	;		;			| sum->r[30] & shmemp to fetch nbytes
   103d  0a 17 e 0 2 d8c3 0000  	movw d,r[3];		shmem->am;	;		;		shp+	| npts->r[3] & d-latch
   103e  0a 06 3 c 0 f8c0 103e  	movw d,y;		am->fifo1;	cjp,f1f .;	;			| npts->fifo1 
   103f  02 00 e 0 0 f3e4 0000  	btstw,s 9,r[4];	;		;		;			| test if 9 exists
   1040  0a 08 3 8 0 c1e3 1048  	sub2nw 0,r[3],r[3];	am->brreg;	cjp,~zer prpmv;	;			| npts-1->brreg, npts->r[3], cjp 9
   1041  1a 00 c 0 0 dd63 0000  	incw r[3],r[3];		;		ldct;		;			| npts->r[3]
   1042  0a 17 e 0 2 8681 0000  prpptlp: addw d,r[1],acc;	shmem->am;	;		;		shp+	| x+offset->acc
   1043  0a 06 3 c 0 f880 1043  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			| x->fifo1
   1044  0a 17 e 0 2 8682 0000  	addw d,r[2],acc;	shmem->am;	;		;		shp+	| y+offset->acc
   1045  0a 06 3 c 0 f880 1045  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			| y->fifo1
   1046  0a 00 9 0 0 7140 1042  	;			;		rpct prpptlp;	;			| loop until zero
   1047  0a 07 3 7 0 cc23 1051  	sl1w r[3],r[3];		am->am;		cjp,go prpend;	;			| npts*2+1->d-latch (1->fetching npts)
   1048  1a 00 c 0 0 dd63 0000  prpmv:	incw r[3],r[3];		;		ldct;		;			| npts-1->brreg, npts->r[3]
   1049  0a 17 e 0 2 8681 0000  prpmvlp: addw d,r[1],acc;	shmem->am;	;		;		shp+	| x+offset->acc
   104a  0a 06 3 c 0 f880 104a  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			| x->fifo1
   104b  0a 17 e 0 2 8682 0000  	addw d,r[2],acc;	shmem->am;	;		;		shp+	| y+offset->acc
   104c  0a 06 3 c 0 f880 104c  	movw acc,y;		am->fifo1;	cjp,f1f .;	;			| y->fifo1
   104d  0a 16 3 c 0 7140 104d  	;			shmem->fifo1;	cjp,f1f .;	;			| 9->fifo1
   104e  0a 00 9 0 2 d803 1049  	movw r[3],acc;		;		rpct prpmvlp;	;		shp+	| loop until zero
   104f  0a 00 e 0 0 cc23 0000  	sl1w r[3],r[3];		;		;		;			| npts*2+1->r[3] (1->fetching npts)
   1050  0a 07 e 0 0 8083 0000  	addw r[3],acc,acc;	am->am;		;		;			| npts*3+1->d-latch
   1051  0a 00 2 0 0 9e9e 0027  prpend:	addw d,r[30],r[30];	;		jmap getcmd;	;			| update r[30] for next fetch
   1052  0a 06 3 c 0 d903 1052  prpsol:	movw 0,r[3];		am->fifo1;	cjp,f1f .;	;			| dummy stoff->fifo1
   1053  0a 06 3 c 0 eba4 1053  	bsetw 5,r[4];	am->fifo1;	cjp,f1f .;	;			| options->fifo1 (5 bit set)
   1054  08 0f 3 7 0 c3de 1039  	add2nw 1,r[30],r[16];	am->shmemp;	cjp,go prpbyt;	;			| 
                                |	movw 0, r[16];	;		jmap PRPOLYSOL1_PP; ;			| Solid => no texture.
                                PRPOLYSOL1_PP:
   1055  0a 28 e 0 0 f8e1 109c  	movw  8,acc;	=wrfifo_pp->brreg; ;		;			| put wrfifo_pp address in brreg and
   1056  1a 06 1 c 0 0008 0000  	;			am->fifo1;	cjs,f1f;	;			  | send  8 r[0] to PP
   1057  1a 27 1 7 0 86c0 00ff  	andw d,r[0],acc;		0xFF->am;	cjs,go;		;			  | send bit plane mask to PP
   1058  0a 17 e 0 2 d8cf 0000  	movw d,r[15];		shmem->am;	;		;		shp+	  | save color and op for later
   1059  1a 27 1 7 0 f8c1 000a  	movw d,acc;		10->am;	cjs,go;		;			  | now send clipping list
   105a  0a 06 3 c 0 fd00 105a  	incw 0, y;		am->fifo1;	cjp,f1f .;	;			  | 1 clipping rectangle.
   105b  0a 17 e 0 2 d8c7 0000  	movw d,r[7];		shmem->am;	;		;		shp+	  | save dst pixrect x offset and send to PP
   105c  0a 06 3 c 0 d847 105c  	movw r[7],y;		am->fifo1;	cjp,f1f .;	;
   105d  0a 17 c 0 2 d8c8 0001  	movw d,r[8];		shmem->am;	ldct 1;		;		shp+	| save dst pixrect y offset and send to PP
   105e  0a 06 3 c 0 d848 105e  	movw r[8],y;		am->fifo1;	cjp,f1f .;	;
   105f  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | send dst pixrect x size
   1060  1a 17 1 7 2 f8c1 0000  	movw d,acc;		shmem->am;	cjs,go;		;		shp+	  | send dst pixrect y size
   1061  02 00 e 0 0 d850 0000  	movw,s r[16], y;	;		;		;			| 
   1062  0a 17 3 0 2 9e87 1064  	addw d,r[7],r[7];	shmem->am;	cjp, zer .+2;	;		shp+	| add dx to dst pixrect x offset
   1063  0a 00 e 0 0 9e15 0000  	subw d, r[21], r[21];		;		;		;			| sub dx since vertices will include it.
   1064  0a 17 3 0 2 9e88 1066  	addw d,r[8],r[8];	shmem->am;	cjp, zer .+2;	;		shp+	| add dy to dst pixrect y offset
   1065  0a 00 e 0 0 9e16 0000  	subw d, r[22], r[22];		;		;		;			| 
                                											  | now have physical device coord offsets
                                											  | for polygon vertices
   1066  08 27 e 0 1 9e9e 000a  	addw d,r[30],r[17];	10->am;		;		;			  | r[17] pts to vector of npts per boundary
   1067  08 17 e 0 e 9e91 0000  	addw d,r[17],r[30];	shmem->am;	;		;			  | r[30] now points to first vertex
   1068  0a 00 e 0 2 d8cd 0000  	movw d,r[13];		;		;		;		shp+	  | # of separate boundaries
   1069  0a 00 e 0 0 c1f1 0000  	sub2nw 0,r[17];		;		;		;			  | decrement r[17] because increment below
                                										|
                                										| edge structure is:
                                										| fpreg[edgptr+0]: ymin    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[edgptr+1]: ymax    16-bit int in high word
                                										|		   X       don't care in low word
                                										| fpreg[edgptr+2]: xmax    32-bit float
                                										| fpreg[edgptr+3]: xmin    32-bit float
                                										| fpreg[edgptr+4]: X       don't care in high word
                                										|		   nxt     11-bit ptr in low word
                                										|
   106a  0a 27 e 0 0 d8cb 0190  	movw d,r[11];		400->am;	;		;			  | r[11]<-400
   106b  0a 00 e 0 0 c98e 0000  	mov2nw 4,r[14];	;		;		;			  | r[14]<-16
   106c  08 0e e 0 a c5ce 0000  	add2nw 2,r[14],r[10]; am->fpdp;	;		;			  | fpdp<-&et[0].nxt
   106d  0b 0b e 0 6 dd6a 0000  	incw r[10],r[10];	am->fpregl;	;		;		dp+	  | r[10]<-21; et[0].nxt<-r[10]; r[10] of
                                											  | dummy first edge
   106e  02 00 e 0 0 c1ed 0000  nxtbnd:	sub2nw,s 0,r[13],r[13];	;		;		;			  | if ((r[13] -= 1)<0), goto doscan
   106f  0a 0f 3 1 0 dd71 109b  	incw r[17],r[17];	am->shmemp;	cjp,neg doscan_pp; ;			| else get # of vertices for next
   1070  0a 17 e 0 0 d8cc 0000  	movw d,r[12];		shmem->am;	;		;			  | boundary
   1071  0a 00 e 0 0 ee01 0000  	sl0w d,acc;		;		;		;			  | acc <- r[12]*2
   1072  02 27 e 0 0 960c 0003  	subw,s d,r[12],y;	3->am;		;		;			  | if 0 <= r[12] < 3, not a good boundary
   1073  0a 0f e 0 0 d85e 0000  	movw r[30],y;		am->shmemp;	;		;			  | shmemp pts to vertices;update r[30] to
   1074  0a 00 3 a 0 989e 106e  	addw r[30],acc,r[30];	;		cjp,~cry nxtbnd;;			  | point to 1st loc after bndry's vertices
   1075  0a 17 e 0 2 8687 0000  	addw d,r[7],acc;	shmem->am;	;		;		shp+
   1076  0a 17 e 0 2 d886 0000  	movw acc,r[6];		shmem->am;	;		;		shp+	  | r[6] <- pt.x + r[7]
   1077  08 00 e 0 4 d966 0000  	movw r[6],r[4];		;		;		;			  | remember x coord of 1st bndry pt
   1078  08 00 e 0 5 9e88 0000  	addw d,r[8],r[5];	;		;		;			  | r[5] <- pt.y + r[8]
   1079  08 00 e 0 3 d965 0000  	movw r[5],r[3];		;		;		;			  | remember y coord of 1st bndry pt
   107a  02 00 e 0 0 c1ec 0000  nxtvrt:	sub2nw,s 0,r[12],r[12];	;		;		;			  | if ((r[12] -= 1)==0), goto endbnd
   107b  0a 17 3 0 2 d8c9 108d  	movw d,r[9];		shmem->am;	cjp,zer endbnd;	;		shp+	  | r[9] <- pt.x
   107c  0a 17 e 0 2 8688 0000  	addw d,r[8],acc;	shmem->am;	;		;		shp+	  | acc <- pt.y + r[8]
   107d  02 00 e 0 0 9105 0000  	xorw,s r[5],acc,y;	;		;		;			  | check for horizontal edge (r[5]==acc)
   107e  0a 07 3 8 0 d847 1080  	movw r[7],y;		am->am;		cjp,~zer .+2;	;			  | d <- r[7]
   107f  08 00 3 7 6 9e89 107a  	addw d,r[9],r[6];	;		cjp,go nxtvrt;	;			  | if horiz, r[6]<-r[9]+r[7] & goto nxtvrt
   1080  0a 0b e 0 6 d845 0000  	movw r[5],y;		am->fpregh;	;		;		dp+	  | fpreg[edgptr+0,high] <- r[5]
   1081  0a 0b e 0 6 d885 0000  	movw acc,r[5];		am->fpregh;	;		;		dp+	  | fpreg[edgptr+1,high] <- r[5] <- new y
   1082  03 0b e 0 0 8689 0000  	addw,s d,r[9],acc;	am->fpregl;	;		;			  | fpreg[edgptr+2,low]<-acc<-(r[9]+r[7])
   1083  02 00 3 1 0 d846 1085  	movw,s r[6],y;		;		cjp,neg .+2;	;			  | arrange sign extension bits in high word
   1084  0a 0b 3 7 6 f900 1086  	movw 0,y;		am->fpregh;	cjp,go .+2;	;		dp+	  | positive sign for (r[9]+r[7])
   1085  0a 2b e 0 6 7140 ffff  	;			0xFFFF->fpregh;	;		;		dp+	  | negative sign for (r[9]+r[7])
   1086  0b 0b 3 1 0 d846 1088  	movw r[6],y;		am->fpregl;	cjp,neg .+2;	;			  | fpreg[edgptr+3,low] <- r[6]
   1087  0a 0b 3 7 6 f900 1089  	movw 0,y;		am->fpregh;	cjp,go .+2;	;		dp+	  | positive sign for r[6]
   1088  0a 2b e 0 6 7140 ffff  	;			0xFFFF->fpregh;	;		;		dp+	  | negative sign for r[6]
   1089  02 00 e 0 0 c1eb 0000  	sub2nw,s 0,r[11],r[11];;		;		;			  | r[11]-=1
   108a  0a 27 e 0 0 d886 0005  	movw acc,r[6];		5->am;		;		;			  | r[6] <- (r[9]+r[7])
   108b  0b 0b 3 9 6 9e8a 107a  	addw d,r[10],r[10];	am->fpregl;	cjp,~neg nxtvrt;;		dp+	  | fpreg[edgptr+4,low]<-r[10]<-address of
                                											  | next edge;if edgtbl not full,goto nxtvrt
   108c  0a 00 3 7 0 db0b 107a  	compw 0,r[11];		;		cjp,go nxtvrt;	;			  | else r[11] <- -1 and goto nxtvrt
                                											  | last point in boundary
   108d  0a 0b e 0 6 d805 0000  endbnd:	movw r[5],acc;		am->fpregh;	;		;		dp+	  | fpreg[edgptr+0,high] <- r[5]
   108e  02 00 e 0 0 9103 0000  	xorw,s r[3],acc,y;	;		;		;			  | check for horizontal edge (r[5]==r[3])
   108f  0a 0b 3 8 6 d843 1091  	movw r[3],y;		am->fpregh;	cjp,~zer .+2;	;		dp+	  | fpreg[edgptr+1,high] <- r[3]
   1090  0a 0e 3 7 0 d84a 106e  	movw r[10],y;		am->fpdp;	cjp,go nxtbnd;	;			  | if horiz, reload fpdp and goto nxtbnd
   1091  03 0b e 0 0 d844 0000  	movw,s r[4],y;		am->fpregl;	;		;			  | fpreg[edgptr+2,low]<-r[4]
   1092  02 00 3 1 0 d846 1094  	movw,s r[6],y;	;			cjp,neg .+2;	;			  | arrange sign extension bits in high word
   1093  0a 0b 3 7 6 f900 1095  	movw 0,y;		am->fpregh;	cjp,go .+2;	;		dp+	  | positive sign for r[4]
   1094  0a 2b e 0 6 7140 ffff  	;			0xFFFF->fpregh;	;		;		dp+	  | negative sign for r[4]
   1095  0b 0b 3 1 0 d846 1097  	movw r[6],y;		am->fpregl;	cjp,neg .+2;	;			  | fpreg[edgptr+3,low] <- r[6]
   1096  0a 0b 3 7 6 f900 1098  	movw 0,y;		am->fpregh;	cjp,go .+2;	;		dp+	  | positive sign for r[6]
   1097  0a 2b e 0 6 7140 ffff  	;			0xFFFF->fpregh;	;		;		dp+	  | negative sign for r[6]
   1098  02 27 e 0 0 c1eb 0005  	sub2nw,s 0,r[11],r[11]; 5->am;	;		;			  | r[11]-=1
   1099  0b 0b 3 9 6 9e8a 106e  	addw d,r[10],r[10];	am->fpregl;	cjp,~neg nxtbnd;;		dp+	  | fpreg[edgptr+4,low]<-r[10]<-address of
                                											  | next edge;if edgtbl not full,goto nxtbnd
   109a  0a 00 3 7 0 db0b 106e  	compw 0,r[11];		;		cjp,go nxtbnd;	;			  | else r[11] <- -1 and goto nxtbnd
   109b  0a 00 2 0 0 7140 00af  doscan_pp: ;			;		jmap doscan;	;			| scan convert on vp bank
   109c  1a 06 a 4 0 f880 0000  wrfifo_pp: movw acc,y;		am->fifo1;	crtn,f1nf;	;			| 
   109d  0a 00 3 7 0 7140 109c  	;			;		cjp,go wrfifo_pp; ;			| 
                                | Copyright (c) 1985 by Sun Microsystems, Inc.
                                |	@(#)statatts.vp.u 1.2 86/09/13 SMI
                                | texture and width registers
                                |	incw r[30],r[30];	;		jmap SETCOLOR;	;
                                SETCOLOR:
   109e  0a 00 e 0 0 949d 0000  	addw r[29], 3,y;;		;		;
   109f  0a 0f e 0 0 0003 0000  	;			am->shmemp;	;		;
   10a0  0a 0a 2 0 0 f880 0027  	movw acc,y;		am->shmem;	jmap getcmd;	;
                                |	add2nw 1,r[30],r[30];	shmem->am;	jmap SETROP;	;
   10a1  0a 00 e 0 0 949d 0000  SETROP:	addw r[29], 2,y;;		;		;
   10a2  0a 0f e 0 0 0002 0000  	;			am->shmemp;	;		;
   10a3  0a 0a 2 0 0 f8c0 0027  	movw d,y;		am->shmem;	jmap getcmd;	;
                                |	incw r[30],r[30];	;		jmap SETFBINDX;	;
                                SETFBINDX:
   10a4  0a 00 e 0 0 949d 0000  	addw r[29], 0,y;;		;		;
   10a5  0a 0f e 0 0 0000 0000  	;			am->shmemp;	;		;
   10a6  0a 0a 2 0 0 f880 0027  	movw acc,y;		am->shmem;	jmap getcmd;	;
                                |	incw r[30],r[30];	;		jmap SETPIXPLANES;;
                                SETPIXPLANES:
   10a7  0a 00 e 0 0 949d 0000  	addw r[29], 1,y;;	;		;
   10a8  0a 0f e 0 0 0001 0000  	;			am->shmemp;	;		;
   10a9  0a 0a 2 0 0 f880 0027  	movw acc,y;		am->shmem;	jmap getcmd;	;
                                |	movw 0,y;		am->fpdp;	jmap SETMATRIX_3D; ;			  | zero fpr dst ptr
   10aa  0a 07 4 7 0 eb9c 000f  SETMATRIX_3D: rolw 5,acc,y;	am->am;		push,go 15;	;			  | d <- index*32 (index is passed in acc)
   10ab  0a 1b e 0 2 ea81 0000  	addw d, 64,acc;	shmem->fpregh;	;		;		shp+	  | copy from r[0] list in shmem to fpr[0]
   10ac  1b 1b 8 0 c 0040 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+  | acc <-  64 + index*32
   10ad  0a 0f e 0 0 909d 0000  	addw r[29],acc,y;	am->shmemp;	;		;			  | shmemp <- addr to store matrix
   10ae  0a 0c 4 7 0 f900 000f  	movw 0,y;		am->fpap;	push,go 15;	;			  | zero fpr src ptr
   10af  0a 3a e 0 2 f8e1 0000  	movw 33,acc;		fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to frame in shmem
   10b0  1b 3a 8 0 b 0021 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
   10b1  0a 00 2 0 0 989e 0027  	addw r[30],acc,r[30];	;		jmap getcmd;	;
                                |	movw 0,y;		am->fpdp;	jmap GETMATRIX_3D; ;			  | zero fpr dst ptr
   10b2  0a 2c e 0 0 eb9d 0000  GETMATRIX_3D: rolw 5,acc,acc;	0->fpap;	;		;			  | acc <- index*32 (index is passed in acc)
   10b3  0a 27 e 0 0 e281 0040  	addw d,acc,acc;		 64->am;;		;			  | fpap <- 0
   10b4  0a 0f 4 7 0 909d 000f  	addw r[29],acc,y;	am->shmemp;	push,go 15;	;			  | shmemp <- addr to retrieve matrix
   10b5  0a 1b e 0 2 dc1e 0000  	incw r[30],acc;	shmem->fpregh;	;		;		shp+	  | copy from frame in shmem to fpr[0]
   10b6  1b 1b 8 0 c 7140 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+  | acc has shmem addr of flag
   10b7  0a 0f 4 7 0 fc80 000f  	incw acc,y;		am->shmemp;	push,go 15;	;			  | shmemp <- addr to store matrix
   10b8  0a 3a e 0 2 c49e 0000  	addw acc,33,r[30];	fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to shmem r[0] area
   10b9  1b 3a 8 0 b 0021 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+ | r[30] += 34
   10ba  0a 0f e 0 0 f880 0000  	movw acc,y;		am->shmemp;	;		;
   10bb  0a 0a 2 0 0 f900 0027  	movw 0,y;		am->shmem;	jmap getcmd;	;			  | flag <- 0; jump to r[0] loop
                                |	incw r[30],r[30];	;		jmap SETHIDDENSURF;;
                                SETHIDDENSURF:
   10bc  0a 00 e 0 0 949d 0000  	addw r[29],6,y;;	;		;
   10bd  0a 0f e 0 0 0006 0000  	;			am->shmemp;	;		;
   10be  0a 0a 2 0 0 f880 0027  	movw acc,y;		am->shmem;	jmap getcmd;	;
                                |	incw r[30],r[30];	;		jmap SELECTMATRIX;;			  | r[30] += 1
                                SELECTMATRIX:
   10bf  0a 27 e 0 0 eb9d 0005  	rolw 5,acc,acc;		5->am;;		;			  | acc <- index*32 (index is passed in acc)
   10c0  0a 0f e 0 0 969d 0000  	addw d,r[29],y;	am->shmemp;	;		;			  | shmemp <- addr to store matrixptr
   10c1  0a 27 e 0 0 809d 0040  	addw r[29],acc,acc;	 64->am;;		;			  | acc <- r[29] + index*32
   10c2  0a 0a 2 0 0 e280 0027  	addw d,acc,y;		am->shmem;	jmap getcmd;	;			  | matrixptr <- r[29] +  64 +
                                											  | index*32; jump back to r[0] loop
                                |	movw 0,y;		am->fpdp;	jmap SETVWP_3D; ;			  | zero fpr dst ptr
   10c3  0a 0c 4 7 0 f900 0005  SETVWP_3D: movw 0,y;		am->fpap;	push,go 5;	;			  | zero fpr src ptr
   10c4  0a 1b e 0 2 f8e1 0000  	movw  52,acc;shmem->fpregh;	;		;		shp+	  | copy from r[0] list in shmem to fpr[0]
   10c5  1b 1b 8 0 c 0034 0000  	;			shmem->fpregl;	rfct;		;		shp+,dp+
   10c6  0a 0f 4 7 0 909d 0005  	addw r[29],acc,y;	am->shmemp;	push,go 5;	;			  | add r[29] and viewport frame offset
   10c7  0a 3a e 0 2 f8e1 0000  	movw 13,acc;		fpregh->shmem;	;		;		shp+	  | copy from fpr[0] to frame in shmem
   10c8  1b 3a 8 0 b 000d 0000  	;			fpregl->shmem;	rfct;		;		shp+,abp+
   10c9  0a 00 2 0 0 989e 0027  	addw r[30],acc,r[30];	;		jmap getcmd;	;
                                |	movw d,r[0];		shmem->am;	jmap SETCLPLST;	;		shp+	  | r[0] <- NRECTS
   10ca  02 27 e 0 0 9600 003d  SETCLPLST: subw,s d,r[0],y;	61->am;		;		;
   10cb  02 07 3 a 0 85c0 10cf  	rolw,s 2,r[0],y;	am->am;		cjp,~cry getlst;;			  | d<-NRECTS*4; if 0 <= NRECTS < 60, getlst
   10cc  0a 00 3 0 0 ca9e 10d7  	addw d,-240,r[30];	;		cjp,zer nullst;	;			  | else use 1st 60 rects; fix r[30] to
   10cd  0a 28 c 0 0 ff10 00ef  	;			239->brreg;	ldct 239;	;			  | skip other rects; brreg<-60*4-1
   10ce  0a 0e 3 7 0 f901 10d1  	movw 0,acc;		am->fpdp;	cjp,go getlst1;	;			  | zero acc and fpdp
   10cf  0a 08 3 0 0 e195 10d7  getlst:	sub2nw 0,d,y;		am->brreg;	cjp,zer nullst;	;			  | brreg<-NRECTS*4-1; if NRECTS==0, nullst
   10d0  1a 0e c 0 0 f901 0000  	movw 0,acc;		am->fpdp;	ldct;		;			  | zero acc and fpdp
   10d1  0a 1b 9 0 c fc81 10d1  getlst1: incw acc,acc;		shmem->fpregh;	rpct .;		;		shp+,dp+  | move from r[0] blk to fpregs; cnt in acc
   10d2  0a 2c e 0 0 949d 0000  	addw r[29], 256,y; 0->fpap;	;		;			  | zero fpap
   10d3  0a 0f e 0 0 0100 0000  	;			am->shmemp;	;		;			  | shmemp <- clipping list address
   10d4  1a 0a 4 7 2 fd9d 0000  	rolw 14,acc,acc;	am->shmem;	push,go;	;		shp+	  | # of rects actually used is acc/4
   10d5  1a 3a 8 0 b dd7e 0000  	incw r[30],r[30];	fpregh->shmem;	rfct;		;		shp+,abp+ | move from fpregs to static blk
   10d6  0a 00 2 0 0 c3de 0027  	add2nw 1,r[30],r[30];	;		jmap getcmd;	;			  | r[30] is now adjusted for next r[0]
   10d7  0a 00 e 0 0 949d 0000  nullst:	addw r[29], 256,y; ;		;		;
   10d8  0a 0f e 0 0 0100 0000  	;			am->shmemp;	;		;			  | shmemp <- clipping list address
   10d9  0a 0a 4 7 2 fd00 0003  	incw 0,y;		am->shmem;	push,go 3;	;		shp+	  | set NRECT to 1
   10da  1a 0a 8 0 2 f900 0000  	movw 0,y;		am->shmem;	rfct;		;		shp+	  | rect coords are 0,0,0,0
   10db  0a 00 2 0 0 c3de 0027  	add2nw 1,r[30],r[30];	;		jmap getcmd;	;			  | r[30] is now adjusted for next r[0]
                                |	incw,s 0,y;		;		jmap SET_LINE_TEX; ;			  
                                SET_LINE_TEX:
   10dc  0a 0e c 0 0 f900 000f  	movw 0,y;		am->fpdp;	ldct 15;	;			  | Load counter & fp d-reg addr.
   10dd  02 17 3 0 2 f8c0 10e1  stexlp:	movw,s d,y;		shmem->am;	cjp, zer setstoff;;		shp+	  | Cc for 1st set in main.vp.u.
   10de  0a 0b 9 0 6 f8c0 10dd  	movw d,y;		am->fpregh;	rpct stexlp;	;		dp+	  | Pull segs till 16 or zero segment.
   10df  0a 17 e 0 2 f8c0 0000  	movw d,y;		shmem->am;	;		;		shp+	  | If had 16 segs, should be null term.
   10e0  0a 17 3 7 2 d8c0 10e2  	movw d,r[0];		shmem->am;	cjp, go setopt;	;		shp+	  | Fetch r[0].
   10e1  0a 00 e 0 0 d8c0 0000  setstoff: movw d,r[0];		;		;		;			  | Move d-latch into r[0].
   10e2  0a 17 e 0 0 d8c1 0000  setopt:	movw d,r[1];		shmem->am;	;		;			  | Fetch r[1].
   10e3  0a 00 e 0 0 949d 0000  setstore: addw r[29], 26,y; ;	;		;			  | Store r[0],r[1], then texture.
   10e4  0a 0f e 0 0 001a 0000  	;			am->shmemp;	;		;			  | Address where texture is stored.
   10e5  0a 0a e 0 2 d840 0000  	movw r[0],y;		am->shmem;	;		;		shp+	  | r[0]->att. block.
   10e6  0a 0a e 0 2 e1c1 0000  	bclrw 0,r[1];	am->shmem;	;		;		shp+	  | r[1]->att. block. (clear 5080 bit).	
   10e7  02 27 e 0 0 d8d0 0001  	movw,s d,r[16];	1->am;		;		;			  | Set status for first seg,r[16]=1.
   10e8  0a 0c c 0 0 f900 000f  	movw 0,y;		am->fpap;	ldct 15;	;			  | Load counter & fp a-reg addr.
   10e9  02 37 3 0 0 f8c0 10ec  storlp:	movw,s d,y;		fpregh->am;	cjp, zer setckfr; ;			  | Pull segment & set status.
   10ea  0a 3a 9 0 b dd70 10e9  	incw r[16],r[16];	fpregh->shmem;	rpct storlp;	;		shp+,abp+ | r[16]++, store & loop till 0 or 16.
   10eb  0a 00 e 0 0 dd70 0000  	incw r[16],r[16];	;		;		;			  | If was 16, must count null term also.
   10ec  0a 2f e 0 0 7140 01fe  setckfr: ;			510->shmemp; ;		;			  | Check which frames texture on PP.
   10ed  02 17 e 0 0 971d 0000  	xorw,s d,r[29],y;	shmem->am;	;		;			  | 
   10ee  0a 07 e 0 0 c3de 0000  	add2nw 1,r[30];	am->am;		;		;			  | r[30]+2 -> d-latch.
   10ef  08 00 3 8 e 9e90 10f1  	addw d,r[16],r[30];	;		cjp, ~zer stend; ;			| r[30] += r[16](r[16]+=1).
   10f0  0a 0a 1 7 0 d85d 1116  	movw r[29],y;	am->shmem;	cjs, go sendtex; ;			  |  Update PP r[20]/new texture.
   10f1  0a 00 2 0 0 7140 0027  stend:	;			;		jmap getcmd;	;			| 
                                |	movw 0,y;		am->fpdp;	jmap SET_LINE_WIDTH; ;
                                SET_LINE_WIDTH:
   10f2  0a 1b e 0 c 7140 0000  	;			shmem->fpregh;	;		;		shp+,dp+  | Pull width.
   10f3  0a 1b e 0 0 7140 0000  	;			shmem->fpregh;	;		;		          | Pull width.r[1].
   10f4  0a 00 e 0 0 949d 0000  	addw r[29], 44,y; ;		;		;			  | 
   10f5  0a 0f e 0 0 002c 0000  	;			am->shmemp;	;		;			  | 
   10f6  0a 0c e 0 0 f900 0000  	movw 0,y;		am->fpap;	;		;			  | 
   10f7  0a 3a e 0 b 7140 0000  	;			fpregh->shmem;	;		;		shp+,abp+ | width->static block.
   10f8  0a 3a e 0 2 7140 0000  	;			fpregh->shmem;	;		;		shp+	  | width.r[1]->static block.
   10f9  0a 2f e 0 0 c1de 01fe  	add2nw 0,r[30];	510->shmemp; ;		;			  | Check which frames texture on PP.
   10fa  02 17 e 0 0 971d 0000  	xorw,s d,r[29],y;	shmem->am;	;		;			  | If this frame, need to update 
   10fb  0a 00 3 8 0 c3de 1103  	add2nw 1,r[30];	;		cjp, ~zer swidend; ;			| r[30]+=3 (total cmds + 1).
   10fc  0a 0a e 0 0 d85d 0000  	movw r[29],y;	am->shmem;	;		;			|  PP r[20]/new texture.
   10fd  0a 00 e 0 0 949d 0000  	addw r[29], 44,y; ;		;		;			| 
   10fe  1a 0f 4 f 0 002c 0000  	;			am->shmemp;	push, ~go;	;			| 
   10ff  1a 26 d 4 0 7140 0022  	;			34->fifo1; loop, f1nf; ;			| setwidth command->fifo1 (PP).
   1100  0a 16 3 c 0 7140 1100  	;			shmem->fifo1;	cjp, f1f .;	;			| width->fifo1.
   1101  0a 00 e 0 2 7140 0000  	;			;		;		;		shp+	| 
   1102  0a 16 3 c 0 7140 1102  	;			shmem->fifo1;	cjp, f1f .;	;			| width.r[1]->fifo1, jump to getcmd.
   1103  0a 00 2 0 0 7140 0027  swidend: ;			;		jmap getcmd;	;			| 
                                |	tvec_attr_pp -- jmap'ed to from vp bank
                                |
                                |	Input Parameters:	shmemp -- points at frame's texture
                                tvec_attr_pp:
   1104  0a 00 e 0 0 949d 0000  	addw r[29], 44,y; ;		;		;			| 
   1105  0a 0f 3 8 0 002c 1109  	;			am->shmemp;	cjp, ~zer tveca2; ;			| Jump if textured.
   1106  02 17 e 0 0 e395 0000  	sub2nw,s 1,d,y;		shmem->am;	;		;			| Compute (width-2).
   1107  0a 0f 3 9 0 d85d 1109  	movw r[29],y;	am->shmemp;	cjp, ~neg tveca2; ;			| 
   1108  0a 00 2 0 0 7140 02ba  	;			;		jmap vec_attr;	;			| Jmp if solid, width 1.
   1109  0a 2f e 0 0 7140 01fe  tveca2:	;			510->shmemp; ;		;			| Check which frames texture on PP.
   110a  02 17 e 0 0 971d 0000  	xorw,s d,r[29],y;	shmem->am;	;		;			| Check if this frames texture on PP.
   110b  0a 00 3 0 0 7140 1112  	;			;		cjp, zer tveca3; ;			| If not, send tex,width, & update ptr.
   110c  0a 0a 1 7 0 d85d 1116  	movw r[29],y;	am->shmem;	cjs, go sendtex; ;			| Send texture to PP.
   110d  1a 00 4 f 0 7140 0000  	;			;		push, ~go;	;			| Send width by hand, since shmemp corr.
   110e  1a 26 d 4 0 7140 0022  	;			34->fifo1; loop, f1nf; ;			| setwidth command->fifo1 (PP).
   110f  0a 16 3 c 0 7140 110f  	;			shmem->fifo1;	cjp, f1f .;	;			| width->fifo1.
   1110  0a 00 e 0 2 7140 0000  	;			;		;		;		shp+	| 
   1111  0a 16 3 c 0 7140 1111  	;			shmem->fifo1;	cjp, f1f .;	;			| width.r[1]->fifo1.
   1112  1a 0f 4 f 0 d85d 0000  tveca3:	movw r[29],y;	am->shmemp;	push, ~go;	;			| Restore shmemp & fall through.
   1113  1a 26 d 4 0 7140 001f  	;			31->fifo1; loop, f1nf; ;			| Send line initialization command to pp.
   1114  0a 27 e 0 0 d8d1 0020  	movw d,r[17];		32->am;	;		;			| Textured vector command->r[17].
   1115  02 17 2 0 0 961c 02bd  	subw,s d,r[28],y;	shmem->am;	jmap vecatt2;	;			| tst oldfbindx - newfbindx & jump.
                                |   Sendtex sends the offset, r[1], and then the pattern, which is null terminated, except in the case
                                |   where it is exactly 16 segments long, and it is not null terminated.
   1116  0a 00 e 0 0 949d 0000  sendtex: addw r[29], 26,y; ;	;		;			| 
   1117  1a 0f 4 f 0 001a 0000  	;			am->shmemp;	push, ~go;	;			| 
   1118  1a 26 d 4 0 7140 0021  	;			33->fifo1; loop, f1nf; ;			| settex command->fifo1 (PP).
   1119  0a 16 3 c 0 7140 1119  	;			shmem->fifo1;	cjp, f1f .;	;			| r[0]->fifo1.
   111a  0a 00 e 0 2 7140 0000  	;			;		;		;		shp+	| 
   111b  0a 16 3 c 0 7140 111b  	;			shmem->fifo1;	cjp, f1f .;	;			| r[1]->fifo1.
   111c  0a 27 e 0 2 f8c1 002c  	movw d,acc;		 44->am;	;		;		shp+	| r[14] offset in acc.
   111d  0a 17 c 0 2 7140 000f  	;			shmem->am;	ldct 15;	;		shp+	| Fetch first pattern segment.
   111e  02 06 3 c 0 f8c0 111e  tveclp:	movw,s d,y;		am->fifo1;	cjp, f1f .;	;			| segment->fifo1.
   111f  0a 17 3 0 2 7140 1121  	;			shmem->am;	cjp, zer tvwid;	;		shp+	| Jump if just sent zero segment.
   1120  0a 00 9 0 0 7140 111e  	;			;		rpct tveclp;	;			| Loop until counter hits zero.
   1121  1a 0f a 7 0 909d 0000  tvwid:	addw r[29],acc,y;	am->shmemp;	crtn, go;	;			| Return & set pointer to width.


